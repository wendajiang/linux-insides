<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Queued spinlocks - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html" class="active">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="synchronization-primitives-in-the-linux-kernel-part-2"><a class="header" href="#synchronization-primitives-in-the-linux-kernel-part-2">Synchronization primitives in the Linux kernel. Part 2.</a></h1>
<h2 id="queued-spinlocks"><a class="header" href="#queued-spinlocks">Queued Spinlocks</a></h2>
<p>This is the second part of the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim">chapter</a> which describes synchronization primitives in the Linux kernel.  In the first <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">part</a> of this chapter we meet the first <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a>. We will continue to learn about this synchronization primitive here. If you have read the previous part, you may remember that besides normal spinlocks, the Linux kernel provides a special type of <code>spinlocks</code> - <code>queued spinlocks</code>. Here we will try to understand what this concept represents.</p>
<p>We saw the <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> of <code>spinlock</code> in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">part</a>:</p>
<ul>
<li><code>spin_lock_init</code> - produces initialization of the given <code>spinlock</code>;</li>
<li><code>spin_lock</code> - acquires given <code>spinlock</code>;</li>
<li><code>spin_lock_bh</code> - disables software <a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a> and acquire given <code>spinlock</code>;</li>
<li><code>spin_lock_irqsave</code> and <code>spin_lock_irq</code> - disable interrupts on local processor and preserve/not preserve previous interrupt state in the <code>flags</code>;</li>
<li><code>spin_unlock</code> - releases given <code>spinlock</code> and acquire given <code>spinlock</code>;</li>
<li><code>spin_unlock_bh</code> - releases given <code>spinlock</code> and enables software interrupts;</li>
<li><code>spin_is_locked</code> - returns the state of the given <code>spinlock</code>;</li>
<li>and etc.</li>
</ul>
<p>And we know that all of these macros with the <code>arch_*</code> prefix which are defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/spinlock.h">include/linux/spinlock.h</a> header file will be expanded to the call of the functions  from the <a href="https://github.com/torvalds/linux/blob/master/include/asm-generic/qspinlock.h">include/asm-generic/qspinlock.h</a>:</p>
<pre><code class="language-C">#define arch_spin_is_locked(l)          queued_spin_is_locked(l)
#define arch_spin_is_contended(l)       queued_spin_is_contended(l)
#define arch_spin_value_unlocked(l)     queued_spin_value_unlocked(l)
#define arch_spin_lock(l)               queued_spin_lock(l)
#define arch_spin_trylock(l)            queued_spin_trylock(l)
#define arch_spin_unlock(l)             queued_spin_unlock(l)
</code></pre>
<p>Before we consider how queued spinlocks and their <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> are implemented, let's first take a look at the theory.</p>
<h2 id="introduction-to-queued-spinlocks"><a class="header" href="#introduction-to-queued-spinlocks">Introduction to queued spinlocks</a></h2>
<p>Queued spinlocks is a <a href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29">locking mechanism</a> in the Linux kernel which is replacement for the standard <code>spinlocks</code>. At least this is true for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture. If we will look at the following kernel configuration file - <a href="https://github.com/torvalds/linux/blob/master/kernel/Kconfig.locks">kernel/Kconfig.locks</a>, we will see following configuration entries:</p>
<pre><code>config ARCH_USE_QUEUED_SPINLOCKS
	bool

config QUEUED_SPINLOCKS
	def_bool y if ARCH_USE_QUEUED_SPINLOCKS
	depends on SMP
</code></pre>
<p>This means that the <code>CONFIG_QUEUED_SPINLOCKS</code> kernel configuration option will be enabled by default if the <code>ARCH_USE_QUEUED_SPINLOCKS</code> is enabled. We may see that the <code>ARCH_USE_QUEUED_SPINLOCKS</code> is enabled by default in the <code>x86_64</code> specific kernel configuration file - <a href="https://github.com/torvalds/linux/blob/master/arch/x86/Kconfig">arch/x86/Kconfig</a>:</p>
<pre><code>config X86
    ...
    ...
    ...
    select ARCH_USE_QUEUED_SPINLOCKS
    ...
    ...
    ...
</code></pre>
<p>Before we start to consider what queued spinlock concept is, let's look on other types of <code>spinlocks</code>. For the start let's consider how a <code>normal</code> spinlock is implemented. Usually, the implementation of a <code>normal</code> spinlock is based on the <a href="https://en.wikipedia.org/wiki/Test-and-set">test and set</a> instruction. The principle of how this instruction works is pretty simple. It writes a value to the memory location and returns the old value from it. Together these instructions are atomic i.e. non-interruptible instructions. So if the first thread starts to execute this instruction, second thread will wait until the first processor has finished its instruction. A basic lock can be built on top of this mechanism. Schematically it may look like this:</p>
<pre><code class="language-C">int lock(lock)
{
    while (test_and_set(lock) == 1)
        ;
    return 0;
}

int unlock(lock)
{
    lock=0;

    return lock;
}
</code></pre>
<p>The first thread will execute the <code>test_and_set</code> which will set the <code>lock</code> to <code>1</code>. When the second thread calls the <code>lock</code> function, it will spin in the <code>while</code> loop, until the first thread calls the <code>unlock</code> function and the <code>lock</code> will be equal to <code>0</code>. This implementation is not very good for performance reasons, due to (at least) two problems. The first problem is that this implementation may be unfair since other threads which arrived later at the lock may acquire it first. The second problem is that all threads which want to acquire a lock must execute many <code>atomic</code> operations like <code>test_and_set</code> on a variable which is in shared memory. This leads to the cache invalidation as the cache of the processor will store <code>lock=1</code>, but the value of the <code>lock</code> in memory may not be <code>1</code> after a thread will release this lock.</p>
<p>The topic of this part is <code>queued spinlocks</code>. This approach may help to solve both of these problems. The <code>queued spinlocks</code> allows each processor to spin while checking its own memory location. The basic principle of a queue-based spinlock can best be understood by studying a classic queue-based spinlock implementation called the <a href="http://www.cs.rochester.edu/%7Escott/papers/1991_TOCS_synch.pdf">MCS</a> lock. Before we look at implementation of the <code>queued spinlocks</code> in the Linux kernel, we will try to understand how <code>MCS</code> lock works.</p>
<p>The basic idea of the <code>MCS</code> lock is that a thread spins on a local variable and each processor in the system has its own copy of this variable (see the previous paragraph). In other words this concept is built on top of the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> variables concept in the Linux kernel.</p>
<p>When the first thread wants to acquire a lock, it registers itself in the <code>queue</code>. In other words it will be added to the special <code>queue</code> and will acquire lock, because it is free for now. When the second thread wants to acquire the same lock before the first thread releases it, this thread adds its own copy of the lock variable into this <code>queue</code>. In this case the first thread will contain a <code>next</code> field which will point to the second thread. From this moment, the second thread will wait until the first thread releases its lock and notifies <code>next</code> thread about this event. The first thread will be deleted from the <code>queue</code> and the second thread will be owner of a lock.</p>
<p>Schematically we can represent it like:</p>
<p>Empty queue:</p>
<pre><code>+---------+
|         |
|  Queue  |
|         |
+---------+
</code></pre>
<p>First thread tries to acquire a lock:</p>
<pre><code>+---------+     +----------------------------+
|         |     |                            |
|  Queue  |----&gt;| First thread acquired lock |
|         |     |                            |
+---------+     +----------------------------+
</code></pre>
<p>Second thread tries to acquire a lock:</p>
<pre><code>+---------+     +----------------------------------------+     +-------------------------+
|         |     |                                        |     |                         |
|  Queue  |----&gt;|  Second thread waits for first thread  |&lt;----| First thread holds lock |
|         |     |                                        |     |                         |
+---------+     +----------------------------------------+     +-------------------------+
</code></pre>
<p>Or the pseudocode:</p>
<pre><code class="language-C">void lock(...)
{
    lock.next = NULL;
    ancestor = put_lock_to_queue_and_return_ancestor(queue, lock);

    // if we have ancestor, the lock is already acquired and we
    // need to wait until it is released
    if (ancestor)
    {
        lock.is_locked = 1;
        ancestor.next = lock;

        while (lock.is_locked == true)
            ;
    }

    // otherwise we are owner of the lock and may exit
}

void unlock(...)
{
    // do we need to notify somebody or we are alone in the
    // queue?
    if (lock.next != NULL) {
        // the while loop from the lock() function will be
        // finished
        lock.next.is_locked = false;
    }

    // So, we have no next threads in the queue to notify about
    // lock releasing event. Let's just put `0` to the lock, will
    // delete ourself from the queue and exit.
}
</code></pre>
<p>That's all we'll say about the theory of the <code>queued spinlocks</code>.  Now let's consider how this mechanism is implemented in the Linux kernel. Unlike above pseudocode, the implementation of the <code>queued spinlocks</code> looks complex and tangled. But the study with attention will lead to success.</p>
<h2 id="api-of-queued-spinlocks"><a class="header" href="#api-of-queued-spinlocks">API of queued spinlocks</a></h2>
<p>Now that we know a little about <code>queued spinlocks</code> from the theoretical side, it's time to see the implementation of this mechanism in the Linux kernel. As we saw above, the <a href="https://github.com/torvalds/linux/blob/master/include/asm-generic/qspinlock.h">include/asm-generic/qspinlock.h</a> header file provides a set of macros which represents the API for a spinlock acquiring, releasing, etc:</p>
<pre><code class="language-C">#define arch_spin_is_locked(l)          queued_spin_is_locked(l)
#define arch_spin_is_contended(l)       queued_spin_is_contended(l)
#define arch_spin_value_unlocked(l)     queued_spin_value_unlocked(l)
#define arch_spin_lock(l)               queued_spin_lock(l)
#define arch_spin_trylock(l)            queued_spin_trylock(l)
#define arch_spin_unlock(l)             queued_spin_unlock(l)
</code></pre>
<p>All of these macros expand to the call of functions from the same header file. Additionally, we saw the <code>qspinlock</code> structure from the <a href="https://github.com/torvalds/linux/blob/master/include/asm-generic/qspinlock_types.h">include/asm-generic/qspinlock_types.h</a> header file which represents a queued spinlock in the Linux kernel:</p>
<pre><code class="language-C">typedef struct qspinlock {
	union {
		atomic_t val;

		struct {
			u8	locked;
			u8	pending;
		};
		struct {
			u16	locked_pending;
			u16	tail;
		};
	};
} arch_spinlock_t;
</code></pre>
<p>The <code>val</code> field represents the state of a given <code>spinlock</code>. This <code>4</code> bytes field consists from following parts:</p>
<ul>
<li><code>0-7</code> - locked byte;</li>
<li><code>8</code> - pending bit;</li>
<li><code>9-15</code> - not used;</li>
<li><code>16-17</code> - two bit index which represents entry of the <code>per-cpu</code> array of the <code>MCS</code> lock (will see it soon);</li>
<li><code>18-31</code> - contains number of processor which indicates tail of the queue.</li>
</ul>
<p>Before we move on to consider the <code>API</code> of <code>queued spinlocks</code>, notice the <code>val</code> field of the <code>qspinlock</code> structure has type - <code>atomic_t</code> which represents atomic variable aka a &quot;one operation at a time&quot; variable. So, all operations with this field will be <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a>. For example let's look at the reading value of the <code>val</code> API:</p>
<pre><code class="language-C">static __always_inline int queued_spin_is_locked(struct qspinlock *lock)
{
	return atomic_read(&amp;lock-&gt;val);
}
</code></pre>
<p>Ok, now we know data structures which represents queued spinlock in the Linux kernel and now is the time to look at the implementation of the main function from the <code>queued spinlocks</code> <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a>:</p>
<pre><code class="language-C">#define arch_spin_lock(l)               queued_spin_lock(l)
</code></pre>
<p>Yes, this function is - <code>queued_spin_lock</code>. As we may understand from the function's name, it allows a thread to acquire a lock. This function is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/asm-generic/qspinlock_types.h">include/asm-generic/qspinlock_types.h</a> header file and its implementation is:</p>
<pre><code class="language-C">static __always_inline void queued_spin_lock(struct qspinlock *lock)
{
        u32 val;

        val = atomic_cmpxchg_acquire(&amp;lock-&gt;val, 0, _Q_LOCKED_VAL);
        if (likely(val == 0))
                 return;
        queued_spin_lock_slowpath(lock, val);
}
</code></pre>
<p>Looks pretty easy, except for the <code>queued_spin_lock_slowpath</code> function. We see that it takes only one parameter. In our case this parameter represents <code>queued spinlock</code>, which will be locked. Let's consider the situation where <code>queue</code> with locks is empty for now and the first thread wanted to acquire lock. As we may see the <code>queued_spin_lock</code> function starts from the call of the <code>atomic_cmpxchg_acquire</code> macro. As you may guess from its name, it executes atomic <a href="http://x86.renejeschke.de/html/file_module_x86_id_41.html">CMPXCHG</a> instruction. Ultimately, the <code>atomic_cmpxchg_acquire</code> macro expands to the call of the <code>__raw_cmpxchg</code> macro almost like the following:</p>
<pre><code class="language-C">#define __raw_cmpxchg(ptr, old, new, size, lock)		\
({								\
	__typeof__(*(ptr)) __ret;				\
	__typeof__(*(ptr)) __old = (old);			\
	__typeof__(*(ptr)) __new = (new);			\
								\
	volatile u32 *__ptr = (volatile u32 *)(ptr);		\
	asm volatile(lock &quot;cmpxchgl %2,%1&quot;			\
		     : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr)		\
		     : &quot;r&quot; (__new), &quot;0&quot; (__old)			\
		     : &quot;memory&quot;);				\
								\
	__ret;							\
})
</code></pre>
<p>which compares the <code>old</code> with the value pointed to by <code>ptr</code>.  If they are equal, it stores the <code>new</code> in the memory location which is pointed by the <code>ptr</code> and returns the initial value in this memory location.</p>
<p>Let's back to the <code>queued_spin_lock</code> function. Assuming that we are the first one who tried to acquire the lock, the <code>val</code> will be zero and we will return from the <code>queued_spin_lock</code> function:</p>
<pre><code class="language-C">	val = atomic_cmpxchg_acquire(&amp;lock-&gt;val, 0, _Q_LOCKED_VAL);
	if (likely(val == 0))
		return;
</code></pre>
<p>So far, we've only considered uncontended case (i.e. fast-path). Now let's consider contended case (i.e. slow-path). Suppose that one thread tried to acquire a lock, but the lock is already held, then <code>queued_spin_lock_slowpath</code> will be called. The <code>queued_spin_lock_slowpath</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/locking/qspinlock.c">kernel/locking/qspinlock.c</a> source code file:</p>
<pre><code class="language-C">void queued_spin_lock_slowpath(struct qspinlock *lock, u32 val)
{
	...
	...
	...
	if (val == _Q_PENDING_VAL) {
		int cnt = _Q_PENDING_LOOPS;
		val = atomic_cond_read_relaxed(&amp;lock-&gt;val,
					       (VAL != _Q_PENDING_VAL) || !cnt--);
	}
	...
	...
	...
}
</code></pre>
<p>which waits for in-progress lock acquisition to be done with a bounded number of spins so that we guarantee forward progress. Above, we saw that the lock contains - pending bit. This bit represents thread which wanted to acquire lock, but it is already acquired by the other thread and <code>queue</code> is empty at the same time. In this case, the pending bit will be set and the <code>queue</code> will not be touched. This is done for optimization, because there are no need in unnecessary latency which will be caused by the cache invalidation in a touching of own <code>mcs_spinlock</code> array.</p>
<p>If we observe contention, then we have no choice other than queueing, so jump to <code>queue</code> label that we'll see later:</p>
<pre><code class="language-C">	if (val &amp; ~_Q_LOCKED_MASK)
		goto queue;
</code></pre>
<p>So, the lock is already held. That is, we set the pending bit of the lock:</p>
<pre><code class="language-C">	val = queued_fetch_set_pending_acquire(lock);
</code></pre>
<p>Again if we observe contention, undo the pending and queue.</p>
<pre><code class="language-C">	if (unlikely(val &amp; ~_Q_LOCKED_MASK)) {
		if (!(val &amp; _Q_PENDING_MASK))
			clear_pending(lock);
		goto queue;
	}
</code></pre>
<p>Now, we're pending, wait for the lock owner to release it.</p>
<pre><code class="language-C">	if (val &amp; _Q_LOCKED_MASK)
		atomic_cond_read_acquire(&amp;)
</code></pre>
<p>We are allowed to take the lock. So, we clear the pending bit and set the locked bit. Now we have nothing to do with the <code>queued_spin_lock_slowpath</code> function, return from it.</p>
<pre><code class="language-C">	clear_pending_set_locked(lock);
	return;
</code></pre>
<p>Before diving into queueing, we'll see about <code>MCS</code> lock mechanism first. As we already know, each processor in the system has own copy of the lock. The lock is represented by the following structure:</p>
<pre><code class="language-C">struct mcs_spinlock {
       struct mcs_spinlock *next;
       int locked;
       int count;
};
</code></pre>
<p>from the <a href="https://github.com/torvalds/linux/blob/master/kernel/locking/mcs_spinlock.h">kernel/locking/mcs_spinlock.h</a> header file. The first field represents a pointer to the next thread in the <code>queue</code>. The second field represents the state of the current thread in the <code>queue</code>, where <code>1</code> is <code>lock</code> already acquired and <code>0</code> in other way. And the last field of the <code>mcs_spinlock</code> structure represents nested locks. To understand what nested lock is, imagine situation when a thread acquired lock, but was interrupted by the hardware <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a> and an <a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt handler</a> tries to take a lock too. For this case, each processor has not just copy of the <code>mcs_spinlock</code> structure but array of these structures:</p>
<pre><code class="language-C">static DEFINE_PER_CPU_ALIGNED(struct qnode, qnodes[MAX_NODES]);
</code></pre>
<p>This array allows to make four attempts of a lock acquisition for the four events in following contexts:</p>
<ul>
<li>normal task context;</li>
<li>hardware interrupt context;</li>
<li>software interrupt context;</li>
<li>non-maskable interrupt context.</li>
</ul>
<p>Notice that we did not touch <code>queue</code> yet. We do not need it, because for two threads it just leads to unnecessary latency for memory access. In other case, the first thread may release it lock before this moment. In this case the <code>lock-&gt;val</code> will contain <code>_Q_LOCKED_VAL | _Q_PENDING_VAL</code> and we will start to build <code>queue</code>. We start to build <code>queue</code> by the getting the local copy of the <code>qnodes</code> array of the processor which executes thread and calculate <code>tail</code> which will indicate the tail of the <code>queue</code> and <code>idx</code> which represents an index of the <code>qnodes</code> array:</p>
<pre><code class="language-C">queue:
	node = this_cpu_ptr(&amp;qnodes[0].mcs);
	idx = node-&gt;count++;
	tail = encode_tail(smp_processer_id(), idx);

	node = grab_mcs_node(node, idx);
</code></pre>
<p>After this, we set <code>locked</code> to zero because this thread didn't acquire lock yet and <code>next</code> to <code>NULL</code> because we don't know anything about other <code>queue</code> entries:</p>
<pre><code class="language-C">	node-&gt;locked = 0;
	node-&gt;next = NULL;
</code></pre>
<p>We already touched <code>per-cpu</code> copy of the queue for the processor which executes current thread which wants to acquire lock, this means that owner of the lock may released it before this moment. So we may try to acquire lock again by the call of the <code>queued_spin_trylock</code> function:</p>
<pre><code class="language-C">	if (queued_spin_trylock(lock))
		goto release;
</code></pre>
<p>It does the almost same thing <code>queued_spin_lock</code> function does.</p>
<p>If the lock was successfully acquired we jump to the <code>release</code> label to release a node of the <code>queue</code>:</p>
<pre><code class="language-C">release:
	__this_cpu_dec(qnodes[0].mcs.count);
</code></pre>
<p>because we no need in it anymore as lock is acquired. If the <code>queued_spin_trylock</code> was unsuccessful, we update tail of the queue:</p>
<pre><code class="language-C">	old = xchg_tail(lock, tail);
	next = NULL;
</code></pre>
<p>and retrieve previous tail. The next step is to check that <code>queue</code> is not empty. In this case we need to link previous entry with the new. While waiting for the MCS lock, the next pointer may have been set by another lock waiter. We optimistically load the next pointer &amp; prefetch the cacheline for writing to reduce latency in the upcoming MCS unlock operation:</p>
<pre><code class="language-C">	if (old &amp; _Q_TAIL_MASK) {
		prev = decode_tail(old);
		WRITE_ONCE(prev-&gt;next, node);

		arch_mcs_spin_lock_contended(&amp;node-&gt;locked);

		next = READ_ONCE(node-&gt;next);
		if (next)
			prefetchw(next);
	}
</code></pre>
<p>If the new node was added, we prefetch cache line from memory pointed by the next queue entry with the <a href="http://www.felixcloutier.com/x86/PREFETCHW.html">PREFETCHW</a> instruction. We preload this pointer now for optimization purpose. We just became a head of queue and this means that there is upcoming <code>MCS</code> unlock operation and the next entry will be touched.</p>
<p>Yes, from this moment we are in the head of the <code>queue</code>. But before we are able to acquire a lock, we need to wait at least two events: current owner of a lock will release it and the second thread with <code>pending</code> bit will acquire a lock too:</p>
<pre><code class="language-C">	val = atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_PENDING_MASK));
</code></pre>
<p>After both threads will release a lock, the head of the <code>queue</code> will hold a lock. In the end we just need to update the tail of the <code>queue</code> and remove current head from it.</p>
<p>That's all.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This is the end of the second part of the <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitives</a> chapter in the Linux kernel. In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">part</a> we already met the first synchronization primitive <code>spinlock</code> provided by the Linux kernel which is implemented as <code>ticket spinlock</code>. In this part we saw another implementation of the <code>spinlock</code> mechanism - <code>queued spinlock</code>. In the next part we will continue to dive into synchronization primitives in the Linux kernel.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt handler</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a></li>
<li><a href="https://en.wikipedia.org/wiki/Test-and-set">Test and Set</a></li>
<li><a href="http://www.cs.rochester.edu/%7Escott/papers/1991_TOCS_synch.pdf">MCS</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu variables</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linearizability">atomic instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_41.html">CMPXCHG instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">LOCK instruction</a></li>
<li><a href="https://en.wikipedia.org/wiki/NOP">NOP instruction</a></li>
<li><a href="http://www.felixcloutier.com/x86/PREFETCHW.html">PREFETCHW instruction</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">Previous part</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../SyncPrim/linux-sync-1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../SyncPrim/linux-sync-3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../SyncPrim/linux-sync-1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../SyncPrim/linux-sync-3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
