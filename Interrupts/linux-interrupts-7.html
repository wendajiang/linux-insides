<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dive into external hardware interrupts - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html" class="active">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="interrupts-and-interrupt-handling-part-7"><a class="header" href="#interrupts-and-interrupt-handling-part-7">Interrupts and Interrupt Handling. Part 7.</a></h1>
<h2 id="introduction-to-external-interrupts"><a class="header" href="#introduction-to-external-interrupts">Introduction to external interrupts</a></h2>
<p>This is the seventh part of the Interrupts and Interrupt Handling in the Linux kernel <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">chapter</a> and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-6">part</a> we have finished with the exceptions which are generated by the processor. In this part we will continue to dive to the interrupt handling and will start with the external hardware interrupt handling. As you can remember, in the previous part we have finished with the <code>trap_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/trap.c</a> and the next step is the call of the <code>early_irq_init</code> function from <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>.</p>
<p>Interrupts are signal that are sent across <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> or <code>Interrupt Request Line</code> by a hardware or software. External hardware interrupts allow devices like keyboard, mouse and etc, to indicate that it needs attention of the processor. Once the processor receives the <code>Interrupt Request</code>, it will temporary stop execution of the running program and invoke special routine which depends on an interrupt. We already know that this routine is called interrupt handler (or how we will call it <code>ISR</code> or <code>Interrupt Service Routine</code> from this part). The <code>ISR</code> or <code>Interrupt Handler Routine</code> can be found in Interrupt Vector table that is located at fixed address in the memory. After the interrupt is handled processor resumes the interrupted process. At the boot/initialization time, the Linux kernel identifies all devices in the machine, and appropriate interrupt handlers are loaded into the interrupt table. As we saw in the previous parts, most exceptions are handled simply by the sending a <a href="https://en.wikipedia.org/wiki/Unix_signal">Unix signal</a> to the interrupted process. That's how the kernel can handle an exception quickly. Unfortunately we can not use this approach for the external hardware interrupts, because often they arrive after (and sometimes long after) the process to which they are related has been suspended. So it would make no sense to send a Unix signal to the current process. External interrupt handling depends on the type of an interrupt:</p>
<ul>
<li><code>I/O</code> interrupts;</li>
<li>Timer interrupts;</li>
<li>Interprocessor interrupts.</li>
</ul>
<p>I will try to describe all types of interrupts in this book.</p>
<p>Generally, a handler of an <code>I/O</code> interrupt must be flexible enough to service several devices at the same time. For example in the <a href="https://en.wikipedia.org/wiki/Conventional_PCI">PCI</a> bus architecture several devices may share the same <code>IRQ</code> line. In the simplest way the Linux kernel must do following thing when an <code>I/O</code> interrupt occurred:</p>
<ul>
<li>Save the value of an <code>IRQ</code> and the register's contents on the kernel stack;</li>
<li>Send an acknowledgment to the hardware controller which is servicing the <code>IRQ</code> line;</li>
<li>Execute the interrupt service routine (next we will call it <code>ISR</code>) which is associated with the device;</li>
<li>Restore registers and return from an interrupt;</li>
</ul>
<p>Ok, we know a little theory and now let's start with the <code>early_irq_init</code> function. The implementation of the <code>early_irq_init</code> function is in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c">kernel/irq/irqdesc.c</a>. This function make early initialization of the <code>irq_desc</code> structure. The <code>irq_desc</code> structure is the foundation of interrupt management code in the Linux kernel. An array of this structure, which has the same name - <code>irq_desc</code>, keeps track of every interrupt request source in the Linux kernel. This structure defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irqdesc.h">include/linux/irqdesc.h</a> and as you can note it depends on the <code>CONFIG_SPARSE_IRQ</code> kernel configuration option. This kernel configuration option enables support for sparse IRQs. The <code>irq_desc</code> structure contains many different fields:</p>
<ul>
<li><code>irq_common_data</code> - per irq and chip data passed down to chip functions;</li>
<li><code>status_use_accessors</code> - contains status of the interrupt source which is combination of the values from the <code>enum</code> from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irq.h">include/linux/irq.h</a> and different macros which are defined in the same source code file;</li>
<li><code>kstat_irqs</code> - irq stats per-cpu;</li>
<li><code>handle_irq</code> - highlevel irq-events handler;</li>
<li><code>action</code> - identifies the interrupt service routines to be invoked when the <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> occurs;</li>
<li><code>irq_count</code> - counter of interrupt occurrences on the IRQ line;</li>
<li><code>depth</code> - <code>0</code> if the IRQ line is enabled and a positive value if it has been disabled at least once;</li>
<li><code>last_unhandled</code> - aging timer for unhandled count;</li>
<li><code>irqs_unhandled</code> - count of the unhandled interrupts;</li>
<li><code>lock</code>  - a spin lock used to serialize the accesses to the <code>IRQ</code> descriptor;</li>
<li><code>pending_mask</code> - pending rebalanced interrupts;</li>
<li><code>owner</code> - an owner of interrupt descriptor. Interrupt descriptors can be allocated from modules. This field is need to proved refcount on the module which provides the interrupts;</li>
<li>and etc.</li>
</ul>
<p>Of course it is not all fields of the <code>irq_desc</code> structure, because it is too long to describe each field of this structure, but we will see it all soon. Now let's start to dive into the implementation of the <code>early_irq_init</code> function.</p>
<h2 id="early-external-interrupts-initialization"><a class="header" href="#early-external-interrupts-initialization">Early external interrupts initialization</a></h2>
<p>Now, let's look on the implementation of the <code>early_irq_init</code> function. Note that implementation of the <code>early_irq_init</code> function depends on the <code>CONFIG_SPARSE_IRQ</code> kernel configuration option. Now we consider implementation of the <code>early_irq_init</code> function when the <code>CONFIG_SPARSE_IRQ</code> kernel configuration option is not set. This function starts from the declaration of the following variables: <code>irq</code> descriptors counter, loop counter, memory node and the <code>irq_desc</code> descriptor:</p>
<pre><code class="language-C">int __init early_irq_init(void)
{
        int count, i, node = first_online_node;
        struct irq_desc *desc;
		...
		...
		...
}
</code></pre>
<p>The <code>node</code> is an online <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a> node which depends on the <code>MAX_NUMNODES</code> value which depends on the <code>CONFIG_NODES_SHIFT</code> kernel configuration parameter:</p>
<pre><code class="language-C">#define MAX_NUMNODES    (1 &lt;&lt; NODES_SHIFT)
...
...
...
#ifdef CONFIG_NODES_SHIFT
    #define NODES_SHIFT     CONFIG_NODES_SHIFT
#else
    #define NODES_SHIFT     0
#endif
</code></pre>
<p>As I already wrote, implementation of the <code>first_online_node</code> macro depends on the <code>MAX_NUMNODES</code> value:</p>
<pre><code class="language-C">#if MAX_NUMNODES &gt; 1
  #define first_online_node       first_node(node_states[N_ONLINE])
#else
  #define first_online_node       0
</code></pre>
<p>The <code>node_states</code> is the <a href="https://en.wikipedia.org/wiki/Enumerated_type">enum</a> which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/nodemask.h">include/linux/nodemask.h</a> and represent the set of the states of a node. In our case we are searching an online node and it will be <code>0</code> if <code>MAX_NUMNODES</code> is one or zero. If the <code>MAX_NUMNODES</code> is greater than one, the <code>node_states[N_ONLINE]</code> will return <code>1</code> and the <code>first_node</code> macro will be expanded to the call of the <code>__first_node</code> function which will return <code>minimal</code> or the first online node:</p>
<pre><code class="language-C">#define first_node(src) __first_node(&amp;(src))

static inline int __first_node(const nodemask_t *srcp)
{
        return min_t(int, MAX_NUMNODES, find_first_bit(srcp-&gt;bits, MAX_NUMNODES));
}
</code></pre>
<p>More about this will be in the another chapter about the <code>NUMA</code>. The next step after the declaration of these local variables is the call of the:</p>
<pre><code class="language-C">init_irq_default_affinity();
</code></pre>
<p>function. The <code>init_irq_default_affinity</code> function defined in the same source code file and depends on the <code>CONFIG_SMP</code> kernel configuration option allocates a given <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumask</a> structure (in our case it is the <code>irq_default_affinity</code>):</p>
<pre><code class="language-C">#if defined(CONFIG_SMP)
cpumask_var_t irq_default_affinity;

static void __init init_irq_default_affinity(void)
{
        alloc_cpumask_var(&amp;irq_default_affinity, GFP_NOWAIT);
        cpumask_setall(irq_default_affinity);
}
#else
static void __init init_irq_default_affinity(void)
{
}
#endif
</code></pre>
<p>We know that when a hardware, such as disk controller or keyboard, needs attention from the processor, it throws an interrupt. The interrupt tells to the processor that something has happened and that the processor should interrupt current process and handle an incoming event. In order to prevent multiple devices from sending the same interrupts, the <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> system was established where each device in a computer system is assigned its own special IRQ so that its interrupts are unique. Linux kernel can assign certain <code>IRQs</code> to specific processors. This is known as <code>SMP IRQ affinity</code>, and it allows you to control how your system will respond to various hardware events (that's why it has certain implementation only if the <code>CONFIG_SMP</code> kernel configuration option is set). After we allocated <code>irq_default_affinity</code> cpumask, we can see <code>printk</code> output:</p>
<pre><code class="language-C">printk(KERN_INFO &quot;NR_IRQS:%d\n&quot;, NR_IRQS);
</code></pre>
<p>which prints <code>NR_IRQS</code>:</p>
<pre><code class="language-C">~$ dmesg | grep NR_IRQS
[    0.000000] NR_IRQS:4352
</code></pre>
<p>The <code>NR_IRQS</code> is the maximum number of the <code>irq</code> descriptors or in another words maximum number of interrupts. Its value depends on the state of the <code>CONFIG_X86_IO_APIC</code> kernel configuration option. If the <code>CONFIG_X86_IO_APIC</code> is not set and the Linux kernel uses an old <a href="https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller">PIC</a> chip, the <code>NR_IRQS</code> is:</p>
<pre><code class="language-C">#define NR_IRQS_LEGACY                    16

#ifdef CONFIG_X86_IO_APIC
...
...
...
#else
# define NR_IRQS                        NR_IRQS_LEGACY
#endif
</code></pre>
<p>In other way, when the <code>CONFIG_X86_IO_APIC</code> kernel configuration option is set, the <code>NR_IRQS</code> depends on the amount of the processors and amount of the interrupt vectors:</p>
<pre><code class="language-C">#define CPU_VECTOR_LIMIT               (64 * NR_CPUS)
#define NR_VECTORS                     256
#define IO_APIC_VECTOR_LIMIT           ( 32 * MAX_IO_APICS )
#define MAX_IO_APICS                   128

# define NR_IRQS                                       \
        (CPU_VECTOR_LIMIT &gt; IO_APIC_VECTOR_LIMIT ?     \
                (NR_VECTORS + CPU_VECTOR_LIMIT)  :     \
                (NR_VECTORS + IO_APIC_VECTOR_LIMIT))
...
...
...
</code></pre>
<p>We remember from the previous parts, that the amount of processors we can set during Linux kernel configuration process with the <code>CONFIG_NR_CPUS</code> configuration option:</p>
<p><img src="images/kernel.png" alt="kernel" /></p>
<p>In the first case (<code>CPU_VECTOR_LIMIT &gt; IO_APIC_VECTOR_LIMIT</code>), the <code>NR_IRQS</code> will be <code>4352</code>, in the second case (<code>CPU_VECTOR_LIMIT &lt; IO_APIC_VECTOR_LIMIT</code>), the <code>NR_IRQS</code> will be <code>768</code>. In my case the <code>NR_CPUS</code> is <code>8</code> as you can see in the my configuration, the <code>CPU_VECTOR_LIMIT</code> is <code>512</code> and the <code>IO_APIC_VECTOR_LIMIT</code> is <code>4096</code>. So <code>NR_IRQS</code> for my configuration is <code>4352</code>:</p>
<pre><code>~$ dmesg | grep NR_IRQS
[    0.000000] NR_IRQS:4352
</code></pre>
<p>In the next step we assign array of the IRQ descriptors to the <code>irq_desc</code> variable which we defined in the start of the <code>early_irq_init</code> function and calculate count of the <code>irq_desc</code> array with the <code>ARRAY_SIZE</code> macro:</p>
<pre><code class="language-C">desc = irq_desc;
count = ARRAY_SIZE(irq_desc);
</code></pre>
<p>The <code>irq_desc</code> array defined in the same source code file and looks like:</p>
<pre><code class="language-C">struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
        [0 ... NR_IRQS-1] = {
                .handle_irq     = handle_bad_irq,
                .depth          = 1,
                .lock           = __RAW_SPIN_LOCK_UNLOCKED(irq_desc-&gt;lock),
        }
};
</code></pre>
<p>The <code>irq_desc</code> is array of the <code>irq</code> descriptors. It has three already initialized fields:</p>
<ul>
<li><code>handle_irq</code> - as I already wrote above, this field is the highlevel irq-event handler. In our case it initialized with the <code>handle_bad_irq</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/handle.c">kernel/irq/handle.c</a> source code file and handles spurious and unhandled IRQs;</li>
<li><code>depth</code> - <code>0</code> if the IRQ line is enabled and a positive value if it has been disabled at least once;</li>
<li><code>lock</code> - A spin lock used to serialize the accesses to the <code>IRQ</code> descriptor.</li>
</ul>
<p>As we calculated count of the interrupts and initialized our <code>irq_desc</code> array, we start to fill descriptors in the loop:</p>
<pre><code class="language-C">for (i = 0; i &lt; count; i++) {
    desc[i].kstat_irqs = alloc_percpu(unsigned int);
    alloc_masks(&amp;desc[i], GFP_KERNEL, node);
    raw_spin_lock_init(&amp;desc[i].lock);
    lockdep_set_class(&amp;desc[i].lock, &amp;irq_desc_lock_class);
	desc_set_defaults(i, &amp;desc[i], node, NULL);
}
</code></pre>
<p>We are going through the all interrupt descriptors and do the following things:</p>
<p>First of all we allocate <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a> variable for the <code>irq</code> kernel statistic with the <code>alloc_percpu</code> macro. This macro allocates one instance of an object of the given type for every processor on the system. You can access kernel statistic from the userspace via <code>/proc/stat</code>:</p>
<pre><code>~$ cat /proc/stat
cpu  207907 68 53904 5427850 14394 0 394 0 0 0
cpu0 25881 11 6684 679131 1351 0 18 0 0 0
cpu1 24791 16 5894 679994 2285 0 24 0 0 0
cpu2 26321 4 7154 678924 664 0 71 0 0 0
cpu3 26648 8 6931 678891 414 0 244 0 0 0
...
...
...
</code></pre>
<p>Where the sixth column is the servicing interrupts. After this we allocate <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumask</a> for the given irq descriptor affinity and initialize the <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a> for the given interrupt descriptor. After this before the <a href="https://en.wikipedia.org/wiki/Critical_section">critical section</a>, the lock will be acquired with a call of the <code>raw_spin_lock</code> and unlocked with the call of the <code>raw_spin_unlock</code>. In the next step we call the <code>lockdep_set_class</code> macro which set the <a href="https://lwn.net/Articles/185666/">Lock validator</a> <code>irq_desc_lock_class</code> class for the lock of the given interrupt descriptor. More about <code>lockdep</code>, <code>spinlock</code> and other synchronization primitives will be described in the separate chapter.</p>
<p>In the end of the loop we call the <code>desc_set_defaults</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c">kernel/irq/irqdesc.c</a>. This function takes four parameters:</p>
<ul>
<li>number of a irq;</li>
<li>interrupt descriptor;</li>
<li>online <code>NUMA</code> node;</li>
<li>owner of interrupt descriptor. Interrupt descriptors can be allocated from modules. This field is need to proved refcount on the module which provides the interrupts;</li>
</ul>
<p>and fills the rest of the <code>irq_desc</code> fields. The <code>desc_set_defaults</code> function fills interrupt number, <code>irq</code> chip, platform-specific per-chip private data for the chip methods, per-IRQ data for the <code>irq_chip</code> methods and <a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">MSI</a> descriptor for the per <code>irq</code> and <code>irq</code> chip data:</p>
<pre><code class="language-C">desc-&gt;irq_data.irq = irq;
desc-&gt;irq_data.chip = &amp;no_irq_chip;
desc-&gt;irq_data.chip_data = NULL;
desc-&gt;irq_data.handler_data = NULL;
desc-&gt;irq_data.msi_desc = NULL;
...
...
...
</code></pre>
<p>The <code>irq_data.chip</code> structure provides general <code>API</code> like the <code>irq_set_chip</code>, <code>irq_set_irq_type</code> and etc, for the irq controller <a href="https://github.com/torvalds/linux/tree/master/drivers/irqchip">drivers</a>. You can find it in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/chip.c">kernel/irq/chip.c</a> source code file.</p>
<p>After this we set the status of the accessor for the given descriptor and set disabled state of the interrupts:</p>
<pre><code class="language-C">...
...
...
irq_settings_clr_and_set(desc, ~0, _IRQ_DEFAULT_INIT_FLAGS);
irqd_set(&amp;desc-&gt;irq_data, IRQD_IRQ_DISABLED);
...
...
...
</code></pre>
<p>In the next step we set the high level interrupt handlers to the <code>handle_bad_irq</code> which handles spurious and unhandled IRQs (as the hardware stuff is not initialized yet, we set this handler), set <code>irq_desc.desc</code> to <code>1</code> which means that an <code>IRQ</code> is disabled, reset count of the unhandled interrupts and interrupts in general:</p>
<pre><code class="language-C">...
...
...
desc-&gt;handle_irq = handle_bad_irq;
desc-&gt;depth = 1;
desc-&gt;irq_count = 0;
desc-&gt;irqs_unhandled = 0;
desc-&gt;name = NULL;
desc-&gt;owner = owner;
...
...
...
</code></pre>
<p>After this we go through the all <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">possible</a> processor with the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/cpumask.h#L714">for_each_possible_cpu</a> helper and set the <code>kstat_irqs</code> to zero for the given interrupt descriptor:</p>
<pre><code class="language-C">	for_each_possible_cpu(cpu)
		*per_cpu_ptr(desc-&gt;kstat_irqs, cpu) = 0;
</code></pre>
<p>and call the <code>desc_smp_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c">kernel/irq/irqdesc.c</a> that initializes <code>NUMA</code> node of the given interrupt descriptor, sets default <code>SMP</code> affinity and clears the <code>pending_mask</code> of the given interrupt descriptor depends on the value of the <code>CONFIG_GENERIC_PENDING_IRQ</code> kernel configuration option:</p>
<pre><code class="language-C">static void desc_smp_init(struct irq_desc *desc, int node)
{
        desc-&gt;irq_data.node = node;
        cpumask_copy(desc-&gt;irq_data.affinity, irq_default_affinity);
#ifdef CONFIG_GENERIC_PENDING_IRQ
        cpumask_clear(desc-&gt;pending_mask);
#endif
}
</code></pre>
<p>In the end of the <code>early_irq_init</code> function we return the return value of the <code>arch_early_irq_init</code> function:</p>
<pre><code class="language-C">return arch_early_irq_init();
</code></pre>
<p>This function defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/apic/vector.c">kernel/apic/vector.c</a> and contains only one call of the <code>arch_early_ioapic_init</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/apic/io_apic.c">kernel/apic/io_apic.c</a>. As we can understand from the <code>arch_early_ioapic_init</code> function's name, this function makes early initialization of the <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">I/O APIC</a>. First of all it make a check of the number of the legacy interrupts with the call of the <code>nr_legacy_irqs</code> function. If we have no legacy interrupts with the <a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a> programmable interrupt controller we set <code>io_apic_irqs</code> to the <code>0xffffffffffffffff</code>:</p>
<pre><code class="language-C">if (!nr_legacy_irqs())
	io_apic_irqs = ~0UL;
</code></pre>
<p>After this we are going through the all <code>I/O APICs</code> and allocate space for the registers with the call of the <code>alloc_ioapic_saved_registers</code>:</p>
<pre><code class="language-C">for_each_ioapic(i)
	alloc_ioapic_saved_registers(i);
</code></pre>
<p>And in the end of the <code>arch_early_ioapic_init</code> function we are going through the all legacy IRQs (from <code>IRQ0</code> to <code>IRQ15</code>) in the loop and allocate space for the <code>irq_cfg</code> which represents configuration of an irq on the given <code>NUMA</code> node:</p>
<pre><code class="language-C">for (i = 0; i &lt; nr_legacy_irqs(); i++) {
    cfg = alloc_irq_and_cfg_at(i, node);
    cfg-&gt;vector = IRQ0_VECTOR + i;
    cpumask_setall(cfg-&gt;domain);
}
</code></pre>
<p>That's all.</p>
<h2 id="sparse-irqs"><a class="header" href="#sparse-irqs">Sparse IRQs</a></h2>
<p>We already saw in the beginning of this part that implementation of the <code>early_irq_init</code> function depends on the <code>CONFIG_SPARSE_IRQ</code> kernel configuration option. Previously we saw implementation of the <code>early_irq_init</code> function when the <code>CONFIG_SPARSE_IRQ</code> configuration option is not set, now let's look at its implementation when this option is set. Implementation of this function very similar, but little differ. We can see the same definition of variables and call of the <code>init_irq_default_affinity</code> in the beginning of the <code>early_irq_init</code> function:</p>
<pre><code class="language-C">#ifdef CONFIG_SPARSE_IRQ
int __init early_irq_init(void)
{
    int i, initcnt, node = first_online_node;
	struct irq_desc *desc;

	init_irq_default_affinity();
	...
	...
	...
}
#else
...
...
...
</code></pre>
<p>But after this we can see the following call:</p>
<pre><code class="language-C">initcnt = arch_probe_nr_irqs();
</code></pre>
<p>The <code>arch_probe_nr_irqs</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/apic/vector.c">arch/x86/kernel/apic/vector.c</a> and calculates count of the pre-allocated IRQs and update <code>nr_irqs</code> with this number. But stop. Why are there pre-allocated IRQs? There is alternative form of interrupts called - <a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">Message Signaled Interrupts</a> available in the <a href="https://en.wikipedia.org/wiki/Conventional_PCI">PCI</a>. Instead of assigning a fixed number of the interrupt request, the device is allowed to record a message at a particular address of RAM, in fact, the display on the <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#Integrated_local_APICs">Local APIC</a>. <code>MSI</code> permits a device to allocate <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code> or <code>32</code> interrupts and <code>MSI-X</code> permits a device to allocate up to <code>2048</code> interrupts. Now we know that IRQs can be pre-allocated. More about <code>MSI</code> will be in a next part, but now let's look on the <code>arch_probe_nr_irqs</code> function. We can see the check which assign amount of the interrupt vectors for the each processor in the system to the <code>nr_irqs</code> if it is greater and calculate the <code>nr</code> which represents number of <code>MSI</code> interrupts:</p>
<pre><code class="language-C">int nr_irqs = NR_IRQS;

if (nr_irqs &gt; (NR_VECTORS * nr_cpu_ids))
	nr_irqs = NR_VECTORS * nr_cpu_ids;

nr = (gsi_top + nr_legacy_irqs()) + 8 * nr_cpu_ids;
</code></pre>
<p>Take a look on the <code>gsi_top</code> variable. Each <code>APIC</code> is identified with its own <code>ID</code> and with the offset where its <code>IRQ</code> starts. It is called <code>GSI</code> base or <code>Global System Interrupt</code> base. So the <code>gsi_top</code> represents it. We get the <code>Global System Interrupt</code> base from the <a href="https://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Configuration Table</a> table (you can remember that we have parsed this table in the sixth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-6">part</a> of the Linux kernel initialization process chapter).</p>
<p>After this we update the <code>nr</code> depends on the value of the <code>gsi_top</code>:</p>
<pre><code class="language-C">#if defined(CONFIG_PCI_MSI) || defined(CONFIG_HT_IRQ)
        if (gsi_top &lt;= NR_IRQS_LEGACY)
                nr +=  8 * nr_cpu_ids;
        else
                nr += gsi_top * 16;
#endif
</code></pre>
<p>Update the <code>nr_irqs</code> if it less than <code>nr</code> and return the number of the legacy IRQs:</p>
<pre><code class="language-C">if (nr &lt; nr_irqs)
    nr_irqs = nr;

return nr_legacy_irqs();
}
</code></pre>
<p>The next after the <code>arch_probe_nr_irqs</code> is printing information about number of <code>IRQs</code>:</p>
<pre><code class="language-C">printk(KERN_INFO &quot;NR_IRQS:%d nr_irqs:%d %d\n&quot;, NR_IRQS, nr_irqs, initcnt);
</code></pre>
<p>We can find it in the <a href="https://en.wikipedia.org/wiki/Dmesg">dmesg</a> output:</p>
<pre><code>$ dmesg | grep NR_IRQS
[    0.000000] NR_IRQS:4352 nr_irqs:488 16
</code></pre>
<p>After this we do some checks that <code>nr_irqs</code> and <code>initcnt</code> values is not greater than maximum allowable number of <code>irqs</code>:</p>
<pre><code class="language-C">if (WARN_ON(nr_irqs &gt; IRQ_BITMAP_BITS))
    nr_irqs = IRQ_BITMAP_BITS;

if (WARN_ON(initcnt &gt; IRQ_BITMAP_BITS))
    initcnt = IRQ_BITMAP_BITS;
</code></pre>
<p>where <code>IRQ_BITMAP_BITS</code> is equal to the <code>NR_IRQS</code> if the <code>CONFIG_SPARSE_IRQ</code> is not set and <code>NR_IRQS + 8196</code> in other way. In the next step we are going over all interrupt descriptors which need to be allocated in the loop and allocate space for the descriptor and insert to the <code>irq_desc_tree</code> <a href="https://0xax.gitbook.io/linux-insides/summary/datastructures/linux-datastructures-2">radix tree</a>:</p>
<pre><code class="language-C">for (i = 0; i &lt; initcnt; i++) {
    desc = alloc_desc(i, node, NULL);
    set_bit(i, allocated_irqs);
	irq_insert_desc(i, desc);
}
</code></pre>
<p>In the end of the <code>early_irq_init</code> function we return the value of the call of the <code>arch_early_irq_init</code> function as we did it already in the previous variant when the <code>CONFIG_SPARSE_IRQ</code> option was not set:</p>
<pre><code class="language-C">return arch_early_irq_init();
</code></pre>
<p>That's all.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>It is the end of the seventh part of the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">Interrupts and Interrupt Handling</a> chapter and we started to dive into external hardware interrupts in this part. We saw early initialization of the <code>irq_desc</code> structure which represents description of an external interrupt and contains information about it like list of irq actions, information about interrupt handler, interrupt's owner, count of the unhandled interrupt and etc. In the next part we will continue to research external interrupts.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a></li>
<li><a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">numa</a></li>
<li><a href="https://en.wikipedia.org/wiki/Enumerated_type">Enum type</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumask</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a></li>
<li><a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Critical_section">critical section</a></li>
<li><a href="https://lwn.net/Articles/185666/">Lock validator</a></li>
<li><a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">MSI</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">I/O APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#Integrated_local_APICs">Local APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a></li>
<li><a href="https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller">PIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Configuration Table</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/datastructures/linux-datastructures-2">radix tree</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dmesg">dmesg</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Interrupts/linux-interrupts-6.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Interrupts/linux-interrupts-8.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Interrupts/linux-interrupts-6.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Interrupts/linux-interrupts-8.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
