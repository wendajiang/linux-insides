<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Initialization of external hardware interrupts structures - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html" class="active">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="interrupts-and-interrupt-handling-part-8"><a class="header" href="#interrupts-and-interrupt-handling-part-8">Interrupts and Interrupt Handling. Part 8.</a></h1>
<h2 id="non-early-initialization-of-the-irqs"><a class="header" href="#non-early-initialization-of-the-irqs">Non-early initialization of the IRQs</a></h2>
<p>This is the eighth part of the Interrupts and Interrupt Handling in the Linux kernel <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">chapter</a> and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-7">part</a> we started to dive into the external hardware <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">interrupts</a>. We looked on the implementation of the <code>early_irq_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c">kernel/irq/irqdesc.c</a> source code file and saw the initialization of the <code>irq_desc</code> structure in this function. Remind that <code>irq_desc</code> structure (defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irqdesc.h#L46">include/linux/irqdesc.h</a> is the foundation of interrupt management code in the Linux kernel and represents an interrupt descriptor. In this part we will continue to dive into the initialization stuff which is related to the external hardware interrupts.</p>
<p>Right after the call of the <code>early_irq_init</code> function in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> we can see the call of the <code>init_IRQ</code> function. This function is architecture-specific and defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/irqinit.c">arch/x86/kernel/irqinit.c</a>. The <code>init_IRQ</code> function makes initialization of the <code>vector_irq</code> <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a> variable that defined in the same <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/irqinit.c">arch/x86/kernel/irqinit.c</a> source code file:</p>
<pre><code class="language-C">...
DEFINE_PER_CPU(vector_irq_t, vector_irq) = {
         [0 ... NR_VECTORS - 1] = -1,
};
...
</code></pre>
<p>and represents <code>percpu</code> array of the interrupt vector numbers. The <code>vector_irq_t</code> defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/hw_irq.h">arch/x86/include/asm/hw_irq.h</a> and expands to the:</p>
<pre><code class="language-C">typedef int vector_irq_t[NR_VECTORS];
</code></pre>
<p>where <code>NR_VECTORS</code> is count of the vector number and as you can remember from the first <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-1">part</a> of this chapter it is <code>256</code> for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a>:</p>
<pre><code class="language-C">#define NR_VECTORS                       256
</code></pre>
<p>So, in the start of the <code>init_IRQ</code> function we fill the <code>vector_irq</code> <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a> array with the vector number of the <code>legacy</code> interrupts:</p>
<pre><code class="language-C">void __init init_IRQ(void)
{
	int i;

	for (i = 0; i &lt; nr_legacy_irqs(); i++)
		per_cpu(vector_irq, 0)[IRQ0_VECTOR + i] = i;
...
...
...
}
</code></pre>
<p>This <code>vector_irq</code> will be used during the first steps of an external hardware interrupt handling in the <code>do_IRQ</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/irq.c">arch/x86/kernel/irq.c</a>:</p>
<pre><code class="language-C">__visible unsigned int __irq_entry do_IRQ(struct pt_regs *regs)
{
	...
	...
	...
	irq = __this_cpu_read(vector_irq[vector]);

	if (!handle_irq(irq, regs)) {
		...
		...
		...
	}

	exiting_irq();
	...
	...
	return 1;
}
</code></pre>
<p>Why is <code>legacy</code> here? Actually all interrupts are handled by the modern <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#I.2FO_APICs">IO-APIC</a> controller. But these interrupts (from <code>0x30</code> to <code>0x3f</code>) by legacy interrupt-controllers like <a href="https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller">Programmable Interrupt Controller</a>. If these interrupts are handled by the <code>I/O APIC</code> then this vector space will be freed and re-used. Let's look on this code closer. First of all the <code>nr_legacy_irqs</code> defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/i8259.h">arch/x86/include/asm/i8259.h</a> and just returns the <code>nr_legacy_irqs</code> field from the <code>legacy_pic</code> structure:</p>
<pre><code class="language-C">static inline int nr_legacy_irqs(void)
{
        return legacy_pic-&gt;nr_legacy_irqs;
}
</code></pre>
<p>This structure defined in the same header file and represents non-modern programmable interrupts controller:</p>
<pre><code class="language-C">struct legacy_pic {
        int nr_legacy_irqs;
        struct irq_chip *chip;
        void (*mask)(unsigned int irq);
        void (*unmask)(unsigned int irq);
        void (*mask_all)(void);
        void (*restore_mask)(void);
        void (*init)(int auto_eoi);
        int (*irq_pending)(unsigned int irq);
        void (*make_irq)(unsigned int irq);
};
</code></pre>
<p>Actual default maximum number of the legacy interrupts represented by the <code>NR_IRQ_LEGACY</code> macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/irq_vectors.h">arch/x86/include/asm/irq_vectors.h</a>:</p>
<pre><code class="language-C">#define NR_IRQS_LEGACY                    16
</code></pre>
<p>In the loop we are accessing the <code>vecto_irq</code> per-cpu array with the <code>per_cpu</code> macro by the <code>IRQ0_VECTOR + i</code> index and write the legacy vector number there. The <code>IRQ0_VECTOR</code> macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/irq_vectors.h">arch/x86/include/asm/irq_vectors.h</a> header file and expands to the <code>0x30</code>:</p>
<pre><code class="language-C">#define FIRST_EXTERNAL_VECTOR           0x20

#define IRQ0_VECTOR                     ((FIRST_EXTERNAL_VECTOR + 16) &amp; ~15)
</code></pre>
<p>Why is <code>0x30</code> here? You can remember from the first <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-1">part</a> of this chapter that first 32 vector numbers from <code>0</code> to <code>31</code> are reserved by the processor and used for the processing of architecture-defined exceptions and interrupts. Vector numbers from <code>0x30</code> to <code>0x3f</code> are reserved for the <a href="https://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA</a>. So, it means that we fill the <code>vector_irq</code> from the <code>IRQ0_VECTOR</code> which is equal to the <code>32</code> to the <code>IRQ0_VECTOR + 16</code> (before the <code>0x30</code>).</p>
<p>In the end of the <code>init_IRQ</code> function we can see the call of the following function:</p>
<pre><code class="language-C">x86_init.irqs.intr_init();
</code></pre>
<p>from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/x86_init.c">arch/x86/kernel/x86_init.c</a> source code file. If you have read <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">chapter</a> about the Linux kernel initialization process, you can remember the <code>x86_init</code> structure. This structure contains a couple of files which point to the function related to the platform setup (<code>x86_64</code> in our case), for example <code>resources</code> - related with the memory resources, <code>mpparse</code> - related with the parsing of the <a href="https://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Configuration Table</a> table, etc.). As we can see the <code>x86_init</code> also contains the <code>irqs</code> field which contains the three following fields:</p>
<pre><code class="language-C">struct x86_init_ops x86_init __initdata
{
	...
	...
	...
    .irqs = {
                .pre_vector_init        = init_ISA_irqs,
                .intr_init              = native_init_IRQ,
                .trap_init              = x86_init_noop,
	},
	...
	...
	...
}
</code></pre>
<p>Now, we are interesting in the <code>native_init_IRQ</code>. As we can note, the name of the <code>native_init_IRQ</code> function contains the <code>native_</code> prefix which means that this function is architecture-specific. It defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/irqinit.c">arch/x86/kernel/irqinit.c</a> and executes general initialization of the <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#Integrated_local_APICs">Local APIC</a> and initialization of the <a href="https://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA</a> irqs. Let's look at the implementation of the <code>native_init_IRQ</code> function and try to understand what occurs there. The <code>native_init_IRQ</code> function starts from the execution of the following function:</p>
<pre><code class="language-C">x86_init.irqs.pre_vector_init();
</code></pre>
<p>As we can see above, the <code>pre_vector_init</code> points to the <code>init_ISA_irqs</code> function that defined in the same <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/irqinit.c">source code</a> file and as we can understand from the function's name, it makes initialization of the <code>ISA</code> related interrupts. The <code>init_ISA_irqs</code> function starts from the definition of the <code>chip</code> variable which has a <code>irq_chip</code> type:</p>
<pre><code class="language-C">void __init init_ISA_irqs(void)
{
	struct irq_chip *chip = legacy_pic-&gt;chip;
	...
	...
	...
</code></pre>
<p>The <code>irq_chip</code> structure defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irq.h">include/linux/irq.h</a> header file and represents hardware interrupt chip descriptor. It contains:</p>
<ul>
<li><code>name</code> - name of a device. Used in the <code>/proc/interrupts</code>:</li>
</ul>
<pre><code class="language-C">$ cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7
  0:         16          0          0          0          0          0          0          0   IO-APIC   2-edge      timer
  1:          2          0          0          0          0          0          0          0   IO-APIC   1-edge      i8042
  8:          1          0          0          0          0          0          0          0   IO-APIC   8-edge      rtc0
</code></pre>
<p>look at the last column;</p>
<ul>
<li><code>(*irq_mask)(struct irq_data *data)</code>  - mask an interrupt source;</li>
<li><code>(*irq_ack)(struct irq_data *data)</code> - start of a new interrupt;</li>
<li><code>(*irq_startup)(struct irq_data *data)</code> - start up the interrupt;</li>
<li><code>(*irq_shutdown)(struct irq_data *data)</code> - shutdown the interrupt</li>
<li>etc.</li>
</ul>
<p>fields. Note that the <code>irq_data</code> structure represents set of the per irq chip data passed down to chip functions. It contains <code>mask</code> - precomputed bitmask for accessing the chip registers, <code>irq</code> - interrupt number, <code>hwirq</code> - hardware interrupt number, local to the interrupt domain chip low level interrupt hardware access, etc.</p>
<p>After this depends on the <code>CONFIG_X86_64</code> and <code>CONFIG_X86_LOCAL_APIC</code> kernel configuration option call the <code>init_bsp_APIC</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/apic/apic.c">arch/x86/kernel/apic/apic.c</a>:</p>
<pre><code class="language-C">#if defined(CONFIG_X86_64) || defined(CONFIG_X86_LOCAL_APIC)
	init_bsp_APIC();
#endif
</code></pre>
<p>This function makes initialization of the <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a> of <code>bootstrap processor</code> (or processor which starts first). It starts from the check that we found <a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a> config (read more about it in the sixth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-6">part</a> of the Linux kernel initialization process chapter) and the processor has <code>APIC</code>:</p>
<pre><code class="language-C">if (smp_found_config || !cpu_has_apic)
	return;
</code></pre>
<p>Otherwise, we return from this function. In the next step we call the <code>clear_local_APIC</code> function from the same source code file that shuts down the local <code>APIC</code> (more on it in the <code>Advanced Programmable Interrupt Controller</code> chapter) and enable <code>APIC</code> of the first processor by the setting <code>unsigned int value</code> to the <code>APIC_SPIV_APIC_ENABLED</code>:</p>
<pre><code class="language-C">value = apic_read(APIC_SPIV);
value &amp;= ~APIC_VECTOR_MASK;
value |= APIC_SPIV_APIC_ENABLED;
</code></pre>
<p>and writing it with the help of the <code>apic_write</code> function:</p>
<pre><code class="language-C">apic_write(APIC_SPIV, value);
</code></pre>
<p>After we have enabled <code>APIC</code> for the bootstrap processor, we return to the <code>init_ISA_irqs</code> function and in the next step we initialize legacy <code>Programmable Interrupt Controller</code> and set the legacy chip and handler for each legacy irq:</p>
<pre><code class="language-C">legacy_pic-&gt;init(0);

for (i = 0; i &lt; nr_legacy_irqs(); i++)
    irq_set_chip_and_handler(i, chip, handle_level_irq);
</code></pre>
<p>Where can we find <code>init</code> function? The <code>legacy_pic</code> defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/i8259.c">arch/x86/kernel/i8259.c</a> and it is:</p>
<pre><code class="language-C">struct legacy_pic *legacy_pic = &amp;default_legacy_pic;
</code></pre>
<p>Where the <code>default_legacy_pic</code> is:</p>
<pre><code class="language-C">struct legacy_pic default_legacy_pic = {
	...
	...
	...
	.init = init_8259A,
	...
	...
	...
}
</code></pre>
<p>The <code>init_8259A</code> function defined in the same source code file and executes initialization of the <a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a> <code>Programmable Interrupt Controller</code> (more about it will be in the separate chapter about <code>Programmable Interrupt Controllers</code> and <code>APIC</code>).</p>
<p>Now we can return to the <code>native_init_IRQ</code> function, after the <code>init_ISA_irqs</code> function finished its work. The next step is the call of the <code>apic_intr_init</code> function that allocates special interrupt gates which are used by the <a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a> architecture for the <a href="https://en.wikipedia.org/wiki/Inter-processor_interrupt">Inter-processor interrupt</a>. The <code>alloc_intr_gate</code> macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/desc.h">arch/x86/include/asm/desc.h</a> used for the interrupt descriptor allocation:</p>
<pre><code class="language-C">#define alloc_intr_gate(n, addr)                        \
do {                                                    \
        alloc_system_vector(n);                         \
        set_intr_gate(n, addr);                         \
} while (0)
</code></pre>
<p>As we can see, first of all it expands to the call of the <code>alloc_system_vector</code> function that checks the given vector number in the <code>used_vectors</code> bitmap (read previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-7">part</a> about it) and if it is not set in the <code>used_vectors</code> bitmap we set it. After this we test that the <code>first_system_vector</code> is greater than given interrupt vector number and if it is greater we assign it:</p>
<pre><code class="language-C">if (!test_bit(vector, used_vectors)) {
	set_bit(vector, used_vectors);
    if (first_system_vector &gt; vector)
		first_system_vector = vector;
} else {
	BUG();
}
</code></pre>
<p>We already saw the <code>set_bit</code> macro, now let's look at the <code>test_bit</code> and the <code>first_system_vector</code>. The first <code>test_bit</code> macro defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> and looks like this:</p>
<pre><code class="language-C">#define test_bit(nr, addr)                      \
        (__builtin_constant_p((nr))             \
         ? constant_test_bit((nr), (addr))      \
         : variable_test_bit((nr), (addr)))
</code></pre>
<p>We can see the <a href="https://en.wikipedia.org/wiki/Ternary_operation">ternary operator</a> here makes a test with the <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a> built-in function <code>__builtin_constant_p</code> tests that given vector number (<code>nr</code>) is known at compile time. If you're feeling misunderstanding of the <code>__builtin_constant_p</code>, we can make simple test:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

#define PREDEFINED_VAL 1

int main() {
	int i = 5;
	printf(&quot;__builtin_constant_p(i) is %d\n&quot;, __builtin_constant_p(i));
	printf(&quot;__builtin_constant_p(PREDEFINED_VAL) is %d\n&quot;, __builtin_constant_p(PREDEFINED_VAL));
	printf(&quot;__builtin_constant_p(100) is %d\n&quot;, __builtin_constant_p(100));

	return 0;
}
</code></pre>
<p>and look at the result:</p>
<pre><code>$ gcc test.c -o test
$ ./test
__builtin_constant_p(i) is 0
__builtin_constant_p(PREDEFINED_VAL) is 1
__builtin_constant_p(100) is 1
</code></pre>
<p>Now I think it must be clear for you. Let's get back to the <code>test_bit</code> macro. If the <code>__builtin_constant_p</code> returns non-zero, we call <code>constant_test_bit</code> function:</p>
<pre><code class="language-C">static inline int constant_test_bit(int nr, const void *addr)
{
	const u32 *p = (const u32 *)addr;

	return ((1UL &lt;&lt; (nr &amp; 31)) &amp; (p[nr &gt;&gt; 5])) != 0;
}
</code></pre>
<p>and the <code>variable_test_bit</code> in other way:</p>
<pre><code class="language-C">static inline int variable_test_bit(int nr, const void *addr)
{
        u8 v;
        const u32 *p = (const u32 *)addr;

        asm(&quot;btl %2,%1; setc %0&quot; : &quot;=qm&quot; (v) : &quot;m&quot; (*p), &quot;Ir&quot; (nr));
        return v;
}
</code></pre>
<p>What's the difference between two these functions and why do we need in two different functions for the same purpose? As you already can guess main purpose is optimization. If we write simple example with these functions:</p>
<pre><code class="language-C">#define CONST 25

int main() {
	int nr = 24;
	variable_test_bit(nr, (int*)0x10000000);
	constant_test_bit(CONST, (int*)0x10000000)
	return 0;
}
</code></pre>
<p>and will look at the assembly output of our example we will see following assembly code:</p>
<pre><code class="language-assembly">pushq	%rbp
movq	%rsp, %rbp

movl	$268435456, %esi
movl	$25, %edi
call	constant_test_bit
</code></pre>
<p>for the <code>constant_test_bit</code>, and:</p>
<pre><code class="language-assembly">pushq	%rbp
movq	%rsp, %rbp

subq	$16, %rsp
movl	$24, -4(%rbp)
movl	-4(%rbp), %eax
movl	$268435456, %esi
movl	%eax, %edi
call	variable_test_bit
</code></pre>
<p>for the <code>variable_test_bit</code>. These two code listings starts with the same part, first of all we save base of the current stack frame in the <code>%rbp</code> register. But after this code for both examples is different. In the first example we put <code>$268435456</code> (here the <code>$268435456</code> is our second parameter - <code>0x10000000</code>) to the <code>esi</code> and <code>$25</code> (our first parameter) to the <code>edi</code> register and call <code>constant_test_bit</code>. We put function parameters to the <code>esi</code> and <code>edi</code> registers because as we are learning Linux kernel for the <code>x86_64</code> architecture we use <code>System V AMD64 ABI</code> <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">calling convention</a>. All is pretty simple. When we are using predefined constant, the compiler can just substitute its value. Now let's look at the second part. As you can see here, the compiler can not substitute value from the <code>nr</code> variable. In this case compiler must calculate its offset on the program's <a href="https://en.wikipedia.org/wiki/Call_stack">stack frame</a>. We subtract <code>16</code> from the <code>rsp</code> register to allocate stack for the local variables data and put the <code>$24</code> (value of the <code>nr</code> variable) to the <code>rbp</code> with offset <code>-4</code>. Our stack frame will be like this:</p>
<pre><code>         &lt;- stack grows

	          %[rbp]
                 |
+----------+ +---------+ +---------+ +--------+
|          | |         | | return  | |        |
|    nr    |-|         |-|         |-|  argc  |
|          | |         | | address | |        |
+----------+ +---------+ +---------+ +--------+
                 |
              %[rsp]
</code></pre>
<p>After this we put this value to the <code>eax</code>, so <code>eax</code> register now contains value of the <code>nr</code>. In the end we do the same that in the first example, we put the <code>$268435456</code> (the first parameter of the <code>variable_test_bit</code> function) and the value of the <code>eax</code> (value of <code>nr</code>) to the <code>edi</code> register (the second parameter of the <code>variable_test_bit function</code>).</p>
<p>The next step after the <code>apic_intr_init</code> function will finish its work is the setting interrupt gates from the <code>FIRST_EXTERNAL_VECTOR</code> or <code>0x20</code> up to <code>0x100</code>:</p>
<pre><code class="language-C">i = FIRST_EXTERNAL_VECTOR;

#ifndef CONFIG_X86_LOCAL_APIC
#define first_system_vector NR_VECTORS
#endif

for_each_clear_bit_from(i, used_vectors, first_system_vector) {
	set_intr_gate(i, irq_entries_start + 8 * (i - FIRST_EXTERNAL_VECTOR));
}
</code></pre>
<p>But as we are using the <code>for_each_clear_bit_from</code> helper, we set only non-initialized interrupt gates. After this we use the same <code>for_each_clear_bit_from</code> helper to fill the non-filled interrupt gates in the interrupt table with the <code>spurious_interrupt</code>:</p>
<pre><code class="language-C">#ifdef CONFIG_X86_LOCAL_APIC
for_each_clear_bit_from(i, used_vectors, NR_VECTORS)
    set_intr_gate(i, spurious_interrupt);
#endif
</code></pre>
<p>Where the <code>spurious_interrupt</code> function represent interrupt handler for the <code>spurious</code> interrupt. Here the <code>used_vectors</code> is the <code>unsigned long</code> that contains already initialized interrupt gates. We already filled first <code>32</code> interrupt vectors in the <code>trap_init</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> source code file:</p>
<pre><code class="language-C">for (i = 0; i &lt; FIRST_EXTERNAL_VECTOR; i++)
    set_bit(i, used_vectors);
</code></pre>
<p>You can remember how we did it in the sixth <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-6">part</a> of this chapter.</p>
<p>In the end of the <code>native_init_IRQ</code> function we can see the following check:</p>
<pre><code class="language-C">if (!acpi_ioapic &amp;&amp; !of_ioapic &amp;&amp; nr_legacy_irqs())
	setup_irq(2, &amp;irq2);
</code></pre>
<p>First of all let's deal with the condition. The <code>acpi_ioapic</code> variable represents existence of <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#I.2FO_APICs">I/O APIC</a>. It defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/acpi/boot.c">arch/x86/kernel/acpi/boot.c</a>. This variable set in the <code>acpi_set_irq_model_ioapic</code> function that called during the processing <code>Multiple APIC Description Table</code>. This occurs during initialization of the architecture-specific stuff in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> (more about it we will know in the other chapter about <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a>). Note that the value of the <code>acpi_ioapic</code> variable depends on the <code>CONFIG_ACPI</code> and <code>CONFIG_X86_LOCAL_APIC</code> Linux kernel configuration options. If these options were not set, this variable will be just zero:</p>
<pre><code class="language-C">#define acpi_ioapic 0
</code></pre>
<p>The second condition - <code>!of_ioapic &amp;&amp; nr_legacy_irqs()</code> checks that we do not use <a href="https://en.wikipedia.org/wiki/Open_Firmware">Open Firmware</a> <code>I/O APIC</code> and legacy interrupt controller. We already know about the <code>nr_legacy_irqs</code>. The second is <code>of_ioapic</code> variable defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/devicetree.c">arch/x86/kernel/devicetree.c</a> and initialized in the <code>dtb_ioapic_setup</code> function that build information about <code>APICs</code> in the <a href="https://en.wikipedia.org/wiki/Device_tree">devicetree</a>. Note that <code>of_ioapic</code> variable depends on the <code>CONFIG_OF</code> Linux kernel configuration option. If this option is not set, the value of the <code>of_ioapic</code> will be zero too:</p>
<pre><code class="language-C">#ifdef CONFIG_OF
extern int of_ioapic;
...
...
...
#else
#define of_ioapic 0
...
...
...
#endif
</code></pre>
<p>If the condition returns non-zero value we call the:</p>
<pre><code class="language-C">setup_irq(2, &amp;irq2);
</code></pre>
<p>function. First of all about the <code>irq2</code>. The <code>irq2</code> is the <code>irqaction</code> structure that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/irqinit.c">arch/x86/kernel/irqinit.c</a> source code file and represents <code>IRQ 2</code> line that is used to query devices connected cascade:</p>
<pre><code class="language-C">static struct irqaction irq2 = {
	.handler = no_action,
    .name = &quot;cascade&quot;,
    .flags = IRQF_NO_THREAD,
};
</code></pre>
<p>Some time ago interrupt controller consisted of two chips and one was connected to second. The second chip that was connected to the first chip via this <code>IRQ 2</code> line. This chip serviced lines from <code>8</code> to <code>15</code> and after this lines of the first chip. So, for example <a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259A</a> has following lines:</p>
<ul>
<li><code>IRQ 0</code>  - system time;</li>
<li><code>IRQ 1</code>  - keyboard;</li>
<li><code>IRQ 2</code>  - used for devices which are cascade connected;</li>
<li><code>IRQ 8</code>  - <a href="https://en.wikipedia.org/wiki/Real-time_clock">RTC</a>;</li>
<li><code>IRQ 9</code>  - reserved;</li>
<li><code>IRQ 10</code> - reserved;</li>
<li><code>IRQ 11</code> - reserved;</li>
<li><code>IRQ 12</code> - <code>ps/2</code> mouse;</li>
<li><code>IRQ 13</code> - coprocessor;</li>
<li><code>IRQ 14</code> - hard drive controller;</li>
<li><code>IRQ 1</code>  - reserved;</li>
<li><code>IRQ 3</code>  - <code>COM2</code> and <code>COM4</code>;</li>
<li><code>IRQ 4</code>  - <code>COM1</code> and <code>COM3</code>;</li>
<li><code>IRQ 5</code>  - <code>LPT2</code>;</li>
<li><code>IRQ 6</code>  - drive controller;</li>
<li><code>IRQ 7</code>  - <code>LPT1</code>.</li>
</ul>
<p>The <code>setup_irq</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/manage.c">kernel/irq/manage.c</a> and takes two parameters:</p>
<ul>
<li>vector number of an interrupt;</li>
<li><code>irqaction</code> structure related with an interrupt.</li>
</ul>
<p>This function initializes interrupt descriptor from the given vector number at the beginning:</p>
<pre><code class="language-C">struct irq_desc *desc = irq_to_desc(irq);
</code></pre>
<p>And call the <code>__setup_irq</code> function that sets up given interrupt:</p>
<pre><code class="language-C">chip_bus_lock(desc);
retval = __setup_irq(irq, desc, act);
chip_bus_sync_unlock(desc);
return retval;
</code></pre>
<p>Note that the interrupt descriptor is locked during <code>__setup_irq</code> function will work. The <code>__setup_irq</code> function does many different things: it creates a handler thread when a thread function is supplied and the interrupt does not nest into another interrupt thread, sets the flags of the chip, fills the <code>irqaction</code> structure and many many more.</p>
<p>All of the above it creates <code>/prov/vector_number</code> directory and fills it, but if you are using modern computer all values will be zero there:</p>
<pre><code>$ cat /proc/irq/2/node
0

$cat /proc/irq/2/affinity_hint
00

cat /proc/irq/2/spurious
count 0
unhandled 0
last_unhandled 0 ms
</code></pre>
<p>because probably <code>APIC</code> handles interrupts on the machine.</p>
<p>That's all.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>It is the end of the eighth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">Interrupts and Interrupt Handling</a> chapter and we continued to dive into external hardware interrupts in this part. In the previous part we started to do it and saw early initialization of the <code>IRQs</code>. In this part we already saw non-early interrupts initialization in the <code>init_IRQ</code> function. We saw initialization of the <code>vector_irq</code> per-cpu array which is store vector numbers of the interrupts and will be used during interrupt handling and initialization of other stuff which is related to the external hardware interrupts.</p>
<p>In the next part we will continue to learn interrupts handling related stuff and will see initialization of the <code>softirqs</code>.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a></li>
<li><a href="https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller">Programmable Interrupt Controller</a></li>
<li><a href="https://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA</a></li>
<li><a href="https://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Configuration Table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#Integrated_local_APICs">Local APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#I.2FO_APICs">I/O APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a></li>
<li><a href="https://en.wikipedia.org/wiki/Inter-processor_interrupt">Inter-processor interrupt</a></li>
<li><a href="https://en.wikipedia.org/wiki/Ternary_operation">ternary operator</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions">calling convention</a></li>
<li><a href="http://x86-64.org/documentation/abi.pdf">PDF. System V Application Binary Interface AMD64</a></li>
<li><a href="https://en.wikipedia.org/wiki/Call_stack">Call stack</a></li>
<li><a href="https://en.wikipedia.org/wiki/Open_Firmware">Open Firmware</a></li>
<li><a href="https://en.wikipedia.org/wiki/Device_tree">devicetree</a></li>
<li><a href="https://en.wikipedia.org/wiki/Real-time_clock">RTC</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-7">Previous part</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Interrupts/linux-interrupts-7.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Interrupts/linux-interrupts-9.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Interrupts/linux-interrupts-7.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Interrupts/linux-interrupts-9.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
