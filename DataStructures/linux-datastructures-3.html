<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bit arrays - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html" class="active">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="data-structures-in-the-linux-kernel"><a class="header" href="#data-structures-in-the-linux-kernel">Data Structures in the Linux Kernel</a></h1>
<h2 id="bit-arrays-and-bit-operations-in-the-linux-kernel"><a class="header" href="#bit-arrays-and-bit-operations-in-the-linux-kernel">Bit arrays and bit operations in the Linux kernel</a></h2>
<p>Besides different <a href="https://en.wikipedia.org/wiki/Linked_data_structure">linked</a> and <a href="https://en.wikipedia.org/wiki/Tree_%28data_structure%29">tree</a> based data structures, the Linux kernel provides <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> for <a href="https://en.wikipedia.org/wiki/Bit_array">bit arrays</a> or <code>bitmap</code>. Bit arrays are heavily used in the Linux kernel and following source code files contain common <code>API</code> for work with such structures:</p>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/lib/bitmap.c">lib/bitmap.c</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitmap.h">include/linux/bitmap.h</a></li>
</ul>
<p>Besides these two files, there is also architecture-specific header file which provides optimized bit operations for certain architecture. We consider <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture, so in our case it will be:</p>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a></li>
</ul>
<p>header file. As I just wrote above, the <code>bitmap</code> is heavily used in the Linux kernel. For example a <code>bit array</code> is used to store set of online/offline processors for systems which support <a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">hot-plug</a> CPU (more about this you can read in the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumasks</a> part), a <code>bit array</code> stores set of allocated <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQs</a> during initialization of the Linux kernel and etc.</p>
<p>So, the main goal of this part is to see how <code>bit arrays</code> are implemented in the Linux kernel. Let's start.</p>
<h1 id="declaration-of-bit-array"><a class="header" href="#declaration-of-bit-array">Declaration of bit array</a></h1>
<p>Before we will look on <code>API</code> for bitmaps manipulation, we must know how to declare it in the Linux kernel. There are two common method to declare own bit array. The first simple way to declare a bit array is to array of <code>unsigned long</code>. For example:</p>
<pre><code class="language-C">unsigned long my_bitmap[8]
</code></pre>
<p>The second way is to use the <code>DECLARE_BITMAP</code> macro which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/types.h">include/linux/types.h</a> header file:</p>
<pre><code class="language-C">#define DECLARE_BITMAP(name,bits) \
    unsigned long name[BITS_TO_LONGS(bits)]
</code></pre>
<p>We can see that <code>DECLARE_BITMAP</code> macro takes two parameters:</p>
<ul>
<li><code>name</code> - name of bitmap;</li>
<li><code>bits</code> - amount of bits in bitmap;</li>
</ul>
<p>and just expands to the definition of <code>unsigned long</code> array with <code>BITS_TO_LONGS(bits)</code> elements, where the <code>BITS_TO_LONGS</code> macro converts a given number of bits to number of <code>longs</code> or in other words it calculates how many <code>8</code> byte elements in <code>bits</code>:</p>
<pre><code class="language-C">#define BITS_PER_BYTE           8
#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
#define BITS_TO_LONGS(nr)       DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
</code></pre>
<p>So, for example <code>DECLARE_BITMAP(my_bitmap, 64)</code> will produce:</p>
<pre><code class="language-python">&gt;&gt;&gt; (((64) + (64) - 1) / (64))
1
</code></pre>
<p>and:</p>
<pre><code class="language-C">unsigned long my_bitmap[1];
</code></pre>
<p>After we are able to declare a bit array, we can start to use it.</p>
<h1 id="architecture-specific-bit-operations"><a class="header" href="#architecture-specific-bit-operations">Architecture-specific bit operations</a></h1>
<p>We already saw above a couple of source code and header files which provide <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> for manipulation of bit arrays. The most important and widely used API of bit arrays is architecture-specific and located as we already know in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> header file.</p>
<p>First of all let's look at the two most important functions:</p>
<ul>
<li><code>set_bit</code>;</li>
<li><code>clear_bit</code>.</li>
</ul>
<p>I think that there is no need to explain what these function do. This is already must be clear from their name. Let's look on their implementation. If you will look into the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> header file, you will note that each of these functions represented by two variants: <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a> and not. Before we will start to dive into implementations of these functions, first of all we must to know a little about <code>atomic</code> operations.</p>
<p>In simple words atomic operations guarantees that two or more operations will not be performed on the same data concurrently. The <code>x86</code> architecture provides a set of atomic instructions, for example <a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">xchg</a> instruction, <a href="http://x86.renejeschke.de/html/file_module_x86_id_41.html">cmpxchg</a> instruction and etc. Besides atomic instructions, some of non-atomic instructions can be made atomic with the help of the <a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">lock</a> instruction. It is enough to know about atomic operations for now, so we can begin to consider implementation of <code>set_bit</code> and <code>clear_bit</code> functions.</p>
<p>First of all, let's start to consider <code>non-atomic</code> variants of this function. Names of non-atomic <code>set_bit</code> and <code>clear_bit</code> starts with double underscore. As we already know, all of these functions are defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> header file and the first function is <code>__set_bit</code>:</p>
<pre><code class="language-C">static inline void __set_bit(long nr, volatile unsigned long *addr)
{
	asm volatile(&quot;bts %1,%0&quot; : ADDR : &quot;Ir&quot; (nr) : &quot;memory&quot;);
}
</code></pre>
<p>As we can see it takes two arguments:</p>
<ul>
<li><code>nr</code> - number of bit in a bit array.</li>
<li><code>addr</code> - address of a bit array where we need to set bit.</li>
</ul>
<p>Note that the <code>addr</code> parameter is defined with <code>volatile</code> keyword which tells to compiler that value maybe changed by the given address. The implementation of the <code>__set_bit</code> is pretty easy. As we can see, it just contains one line of <a href="https://en.wikipedia.org/wiki/Inline_assembler">inline assembler</a> code. In our case we are using the <a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">bts</a> instruction which selects a bit which is specified with the first operand (<code>nr</code> in our case) from the bit array, stores the value of the selected bit in the <a href="https://en.wikipedia.org/wiki/FLAGS_register">CF</a> flags register and set this bit.</p>
<p>Note that we can see usage of the <code>nr</code>, but there is <code>addr</code> here. You already might guess that the secret is in <code>ADDR</code>. The <code>ADDR</code> is the macro which is defined in the same header code file and expands to the string which contains value of the given address and <code>+m</code> constraint:</p>
<pre><code class="language-C">#define ADDR				BITOP_ADDR(addr)
#define BITOP_ADDR(x) &quot;+m&quot; (*(volatile long *) (x))
</code></pre>
<p>Besides the <code>+m</code>, we can see other constraints in the <code>__set_bit</code> function. Let's look on they and try to understand what do they mean:</p>
<ul>
<li><code>+m</code> - represents memory operand where <code>+</code> tells that the given operand will be input and output operand;</li>
<li><code>I</code> - represents integer constant;</li>
<li><code>r</code> - represents register operand</li>
</ul>
<p>Besides these constraint, we also can see - the <code>memory</code> keyword which tells compiler that this code will change value in memory. That's all. Now let's look at the same function but at <code>atomic</code> variant. It looks more complex that its <code>non-atomic</code> variant:</p>
<pre><code class="language-C">static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX &quot;orb %1,%0&quot;
			: CONST_MASK_ADDR(nr, addr)
			: &quot;iq&quot; ((u8)CONST_MASK(nr))
			: &quot;memory&quot;);
	} else {
		asm volatile(LOCK_PREFIX &quot;bts %1,%0&quot;
			: BITOP_ADDR(addr) : &quot;Ir&quot; (nr) : &quot;memory&quot;);
	}
}
</code></pre>
<p>First of all note that this function takes the same set of parameters that <code>__set_bit</code>, but additionally marked with the <code>__always_inline</code> attribute. The <code>__always_inline</code> is macro which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/compiler-gcc.h">include/linux/compiler-gcc.h</a> and just expands to the <code>always_inline</code> attribute:</p>
<pre><code class="language-C">#define __always_inline inline __attribute__((always_inline))
</code></pre>
<p>which means that this function will be always inlined to reduce size of the Linux kernel image. Now let's try to understand implementation of the <code>set_bit</code> function. First of all we check a given number of bit at the beginning of the <code>set_bit</code> function. The <code>IS_IMMEDIATE</code> macro defined in the same <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">header</a> file and expands to the call of the builtin <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a> function:</p>
<pre><code class="language-C">#define IS_IMMEDIATE(nr)		(__builtin_constant_p(nr))
</code></pre>
<p>The <code>__builtin_constant_p</code> builtin function returns <code>1</code> if the given parameter is known to be constant at compile-time and returns <code>0</code> in other case. We do not need to use slow <code>bts</code> instruction to set bit if the given number of bit is known in compile time constant. We can just apply <a href="https://en.wikipedia.org/wiki/Bitwise_operation#OR">bitwise or</a> for byte from the give address which contains given bit and masked number of bits where high bit is <code>1</code> and other is zero. In other case if the given number of bit is not known constant at compile-time, we do the same as we did in the <code>__set_bit</code> function. The <code>CONST_MASK_ADDR</code> macro:</p>
<pre><code class="language-C">#define CONST_MASK_ADDR(nr, addr)	BITOP_ADDR((void *)(addr) + ((nr)&gt;&gt;3))
</code></pre>
<p>expands to the given address with offset to the byte which contains a given bit. For example we have address <code>0x1000</code> and the number of bit is <code>0x9</code>. So, as <code>0x9</code> is <code>one byte + one bit</code> our address with be <code>addr + 1</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; hex(0x1000 + (0x9 &gt;&gt; 3))
'0x1001'
</code></pre>
<p>The <code>CONST_MASK</code> macro represents our given number of bit as byte where high bit is <code>1</code> and other bits are <code>0</code>:</p>
<pre><code class="language-C">#define CONST_MASK(nr)			(1 &lt;&lt; ((nr) &amp; 7))
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; bin(1 &lt;&lt; (0x9 &amp; 7))
'0b10'
</code></pre>
<p>In the end we just apply bitwise <code>or</code> for these values. So, for example if our address will be <code>0x4097</code> and we need to set <code>0x9</code> bit:</p>
<pre><code class="language-python">&gt;&gt;&gt; bin(0x4097)
'0b100000010010111'
&gt;&gt;&gt; bin((0x4097 &gt;&gt; 0x9) | (1 &lt;&lt; (0x9 &amp; 7)))
'0b100010'
</code></pre>
<p>the <code>ninth</code> bit will be set.</p>
<p>Note that all of these operations are marked with <code>LOCK_PREFIX</code> which is expands to the <a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">lock</a> instruction which guarantees atomicity of this operation.</p>
<p>As we already know, besides the <code>set_bit</code> and <code>__set_bit</code> operations, the Linux kernel provides two inverse functions to clear bit in atomic and non-atomic context. They are <code>clear_bit</code> and <code>__clear_bit</code>. Both of these functions are defined in the same <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">header file</a> and takes the same set of arguments. But not only arguments are similar. Generally these functions are very similar on the <code>set_bit</code> and <code>__set_bit</code>. Let's look on the implementation of the non-atomic <code>__clear_bit</code> function:</p>
<pre><code class="language-C">static inline void __clear_bit(long nr, volatile unsigned long *addr)
{
	asm volatile(&quot;btr %1,%0&quot; : ADDR : &quot;Ir&quot; (nr));
}
</code></pre>
<p>Yes. As we see, it takes the same set of arguments and contains very similar block of inline assembler. It just uses the <a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">btr</a> instruction instead of <code>bts</code>. As we can understand form the function's name, it clears a given bit by the given address. The <code>btr</code> instruction acts like <code>bts</code>. This instruction also selects a given bit which is specified in the first operand, stores its value in the <code>CF</code> flag register and clears this bit in the given bit array which is specified with second operand.</p>
<p>The atomic variant of the <code>__clear_bit</code> is <code>clear_bit</code>:</p>
<pre><code class="language-C">static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX &quot;andb %1,%0&quot;
			: CONST_MASK_ADDR(nr, addr)
			: &quot;iq&quot; ((u8)~CONST_MASK(nr)));
	} else {
		asm volatile(LOCK_PREFIX &quot;btr %1,%0&quot;
			: BITOP_ADDR(addr)
			: &quot;Ir&quot; (nr));
	}
}
</code></pre>
<p>and as we can see it is very similar on <code>set_bit</code> and just contains two differences. The first difference it uses <code>btr</code> instruction to clear bit when the <code>set_bit</code> uses <code>bts</code> instruction to set bit. The second difference it uses negated mask and <code>and</code> instruction to clear bit in the given byte when the <code>set_bit</code> uses <code>or</code> instruction.</p>
<p>That's all. Now we can set and clear bit in any bit array and and we can go to other operations on bitmasks.</p>
<p>Most widely used operations on a bit arrays are set and clear bit in a bit array in the Linux kernel. But besides this operations it is useful to do additional operations on a bit array. Yet another widely used operation in the Linux kernel - is to know if a given bit is set or not in a bit array. We can achieve this with the help of the <code>test_bit</code> macro. This macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> header file and expands to the call of the <code>constant_test_bit</code> or <code>variable_test_bit</code> depending on bit number:</p>
<pre><code class="language-C">#define test_bit(nr, addr)			\
	(__builtin_constant_p((nr))                 \
	 ? constant_test_bit((nr), (addr))	        \
	 : variable_test_bit((nr), (addr)))
</code></pre>
<p>So, if the <code>nr</code> is known in compile time constant, the <code>test_bit</code> will be expanded to the call of the <code>constant_test_bit</code> function or <code>variable_test_bit</code> in other case. Now let's look at implementations of these functions. Let's start from the <code>variable_test_bit</code>:</p>
<pre><code class="language-C">static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile(&quot;bt %2,%1\n\t&quot;
		     &quot;sbb %0,%0&quot;
		     : &quot;=r&quot; (oldbit)
		     : &quot;m&quot; (*(unsigned long *)addr), &quot;Ir&quot; (nr));

	return oldbit;
}
</code></pre>
<p>The <code>variable_test_bit</code> function takes similar set of arguments as <code>set_bit</code> and other function take. We also may see inline assembly code here which executes <a href="http://x86.renejeschke.de/html/file_module_x86_id_22.html">bt</a> and <a href="http://x86.renejeschke.de/html/file_module_x86_id_286.html">sbb</a> instruction. The <code>bt</code> or <code>bit test</code> instruction selects a given bit which is specified with first operand from the bit array which is specified with the second operand and stores its value in the <a href="https://en.wikipedia.org/wiki/FLAGS_register">CF</a> bit of flags register. The second <code>sbb</code> instruction subtracts first operand from second and subtracts value of the <code>CF</code>. So, here write a value of a given bit number from a given bit array to the <code>CF</code> bit of flags register and execute <code>sbb</code> instruction which calculates: <code>00000000 - CF</code> and writes the result to the <code>oldbit</code>.</p>
<p>The <code>constant_test_bit</code> function does the same as we saw in the <code>set_bit</code>:</p>
<pre><code class="language-C">static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL &lt;&lt; (nr &amp; (BITS_PER_LONG-1))) &amp;
		(addr[nr &gt;&gt; _BITOPS_LONG_SHIFT])) != 0;
}
</code></pre>
<p>It generates a byte where high bit is <code>1</code> and other bits are <code>0</code> (as we saw in <code>CONST_MASK</code>) and applies bitwise <a href="https://en.wikipedia.org/wiki/Bitwise_operation#AND">and</a> to the byte which contains a given bit number.</p>
<p>The next widely used bit array related operation is to change bit in a bit array. The Linux kernel provides two helper for this:</p>
<ul>
<li><code>__change_bit</code>;</li>
<li><code>change_bit</code>.</li>
</ul>
<p>As you already can guess, these two variants are atomic and non-atomic as for example <code>set_bit</code> and <code>__set_bit</code>. For the start, let's look at the implementation of the <code>__change_bit</code> function:</p>
<pre><code class="language-C">static inline void __change_bit(long nr, volatile unsigned long *addr)
{
    asm volatile(&quot;btc %1,%0&quot; : ADDR : &quot;Ir&quot; (nr));
}
</code></pre>
<p>Pretty easy, is it not? The implementation of the <code>__change_bit</code> is the same as <code>__set_bit</code>, but instead of <code>bts</code> instruction, we are using <a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">btc</a>. This instruction selects a given bit from a given bit array, stores its value in the <code>CF</code> and changes its value by the applying of complement operation. So, a bit with value <code>1</code> will be <code>0</code> and vice versa:</p>
<pre><code class="language-python">&gt;&gt;&gt; int(not 1)
0
&gt;&gt;&gt; int(not 0)
1
</code></pre>
<p>The atomic version of the <code>__change_bit</code> is the <code>change_bit</code> function:</p>
<pre><code class="language-C">static inline void change_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX &quot;xorb %1,%0&quot;
			: CONST_MASK_ADDR(nr, addr)
			: &quot;iq&quot; ((u8)CONST_MASK(nr)));
	} else {
		asm volatile(LOCK_PREFIX &quot;btc %1,%0&quot;
			: BITOP_ADDR(addr)
			: &quot;Ir&quot; (nr));
	}
}
</code></pre>
<p>It is similar on <code>set_bit</code> function, but also has two differences. The first difference is <code>xor</code> operation instead of <code>or</code> and the second is <code>btc</code> instead of <code>bts</code>.</p>
<p>For this moment we know the most important architecture-specific operations with bit arrays. Time to look at generic bitmap API.</p>
<h1 id="common-bit-operations"><a class="header" href="#common-bit-operations">Common bit operations</a></h1>
<p>Besides the architecture-specific API from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> header file, the Linux kernel provides common API for manipulation of bit arrays. As we know from the beginning of this part, we can find it in the  <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitmap.h">include/linux/bitmap.h</a> header file and additionally in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/lib/bitmap.c">lib/bitmap.c</a>  source code file. But before these source code files let's look into the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitops.h">include/linux/bitops.h</a> header file which provides a set of useful macro. Let's look on some of them.</p>
<p>First of all let's look at following four macros:</p>
<ul>
<li><code>for_each_set_bit</code></li>
<li><code>for_each_set_bit_from</code></li>
<li><code>for_each_clear_bit</code></li>
<li><code>for_each_clear_bit_from</code></li>
</ul>
<p>All of these macros provide iterator over certain set of bits in a bit array. The first macro iterates over bits which are set, the second does the same, but starts from a certain bits. The last two macros do the same, but iterates over clear bits. Let's look on implementation of the <code>for_each_set_bit</code> macro:</p>
<pre><code class="language-C">#define for_each_set_bit(bit, addr, size) \
	for ((bit) = find_first_bit((addr), (size));		\
	     (bit) &lt; (size);					\
	     (bit) = find_next_bit((addr), (size), (bit) + 1))
</code></pre>
<p>As we may see it takes three arguments and expands to the loop from first set bit which is returned as result of the <code>find_first_bit</code> function and to the last bit number while it is less than given size.</p>
<p>Besides these four macros, the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> provides API for rotation of <code>64-bit</code> or <code>32-bit</code> values and etc.</p>
<p>The next <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitmap.h">header</a> file which provides API for manipulation with a bit arrays. For example it provides two functions:</p>
<ul>
<li><code>bitmap_zero</code>;</li>
<li><code>bitmap_fill</code>.</li>
</ul>
<p>To clear a bit array or fill it with <code>1</code>. Let's look at the implementation of the <code>bitmap_zero</code> function:</p>
<pre><code class="language-C">static inline void bitmap_zero(unsigned long *dst, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		*dst = 0UL;
	else {
		unsigned int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
		memset(dst, 0, len);
	}
}
</code></pre>
<p>First of all we can see the check for <code>nbits</code>. The <code>small_const_nbits</code> is macro which defined in the same header <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitmap.h">file</a> and looks:</p>
<pre><code class="language-C">#define small_const_nbits(nbits) \
	(__builtin_constant_p(nbits) &amp;&amp; (nbits) &lt;= BITS_PER_LONG)
</code></pre>
<p>As we may see it checks that <code>nbits</code> is known constant in compile time and <code>nbits</code> value does not overflow <code>BITS_PER_LONG</code> or <code>64</code>. If bits number does not overflow amount of bits in a <code>long</code> value we can just set to zero. In other case we need to calculate how many <code>long</code> values do we need to fill our bit array and fill it with <a href="http://man7.org/linux/man-pages/man3/memset.3.html">memset</a>.</p>
<p>The implementation of the <code>bitmap_fill</code> function is similar on implementation of the <code>bitmap_zero</code> function, except we fill a given bit array with <code>0xff</code> values or <code>0b11111111</code>:</p>
<pre><code class="language-C">static inline void bitmap_fill(unsigned long *dst, unsigned int nbits)
{
	unsigned int nlongs = BITS_TO_LONGS(nbits);
	if (!small_const_nbits(nbits)) {
		unsigned int len = (nlongs - 1) * sizeof(unsigned long);
		memset(dst, 0xff,  len);
	}
	dst[nlongs - 1] = BITMAP_LAST_WORD_MASK(nbits);
}
</code></pre>
<p>Besides the <code>bitmap_fill</code> and <code>bitmap_zero</code> functions, the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitmap.h">include/linux/bitmap.h</a> header file provides <code>bitmap_copy</code> which is similar on the <code>bitmap_zero</code>, but just uses <a href="http://man7.org/linux/man-pages/man3/memcpy.3.html">memcpy</a> instead of <a href="http://man7.org/linux/man-pages/man3/memset.3.html">memset</a>. Also it provides bitwise operations for bit array like <code>bitmap_and</code>, <code>bitmap_or</code>, <code>bitamp_xor</code> and etc. We will not consider implementation of these functions because it is easy to understand implementations of these functions if you understood all from this part. Anyway if you are interested in how these function are implemented, you may open <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitmap.h">include/linux/bitmap.h</a> header file and start to research.</p>
<p>That's all.</p>
<h1 id="links"><a class="header" href="#links">Links</a></h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Bit_array">bitmap</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linked_data_structure">linked data structures</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tree_%28data_structure%29">tree data structures</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">hot-plug</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumasks</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQs</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linearizability">atomic operations</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">xchg instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_41.html">cmpxchg instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">lock instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">bts instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">btr instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_22.html">bt instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_286.html">sbb instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">btc instruction</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/memcpy.3.html">man memcpy</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/memset.3.html">man memset</a></li>
<li><a href="https://en.wikipedia.org/wiki/FLAGS_register">CF</a></li>
<li><a href="https://en.wikipedia.org/wiki/Inline_assembler">inline assembler</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../DataStructures/linux-datastructures-2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Theory/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../DataStructures/linux-datastructures-2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Theory/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
