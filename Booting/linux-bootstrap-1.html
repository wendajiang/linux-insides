<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>From bootloader to kernel - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html" class="active">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="kernel-booting-process-part-1"><a class="header" href="#kernel-booting-process-part-1">Kernel booting process. Part 1.</a></h1>
<h2 id="from-the-bootloader-to-the-kernel"><a class="header" href="#from-the-bootloader-to-the-kernel">From the bootloader to the kernel</a></h2>
<p>If you read my previous <a href="https://0xax.github.io/categories/assembler/">blog posts</a>, you might have noticed that I  have been involved with low-level programming for some time. I wrote some posts about assembly programming for <code>x86_64</code> Linux and, at the same time, started to dive into the Linux kernel source code.</p>
<p>I have a great interest in understanding how low-level things work, how programs run on my computer, how they are located in memory, how the kernel manages processes and memory, how the network stack works at a low level, and many many other things. So, I decided to write yet another series of posts about the Linux kernel for the <strong>x86_64</strong> architecture.</p>
<p>Note that I'm not a professional kernel hacker and I don't write code for the kernel at work. It's just a hobby. I just like low-level stuff, and it is interesting for me to see how these things work. So if you notice anything confusing, or if you have any questions/remarks, ping me on Twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>. I appreciate it.</p>
<p>All posts will also be accessible at <a href="https://github.com/0xAX/linux-insides">github repo</a> and, if you find something wrong with my English or the post content, feel free to send a pull request.</p>
<p><em>Note that this isn't official documentation, just learning and sharing knowledge.</em></p>
<p><strong>Required knowledge</strong></p>
<ul>
<li>Understanding C code</li>
<li>Understanding assembly code (AT&amp;T syntax)</li>
</ul>
<p>Anyway, if you're just starting to learn such tools, I will try to explain some parts during this and the following posts. Alright, this is the end of the simple introduction. Let's start to dive into the Linux kernel and low-level stuff!</p>
<p>I started writing these posts at the time of the <code>3.18</code> Linux kernel, and many things have changed since that time. If there are changes, I will update the posts accordingly.</p>
<h2 id="the-magical-power-button-what-happens-next"><a class="header" href="#the-magical-power-button-what-happens-next">The Magical Power Button, What happens next?</a></h2>
<p>Although this is a series of posts about the Linux kernel, we won't start directly from the kernel code. As soon as you press the magical power button on your laptop or desktop computer, it starts working. The motherboard sends a signal to the <a href="https://en.wikipedia.org/wiki/Power_supply">power supply</a> device. After receiving the signal, the power supply provides the proper amount of electricity to the computer. Once the motherboard receives the <a href="https://en.wikipedia.org/wiki/Power_good_signal">power good signal</a>, it tries to start the CPU. The CPU resets all leftover data in its registers and sets predefined values for each of them.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Intel_80386">80386</a> and later CPUs define the following predefined data in CPU registers after the computer resets:</p>
<pre><code>IP          0xfff0
CS selector 0xf000
CS base     0xffff0000
</code></pre>
<p>The processor starts working in <a href="https://en.wikipedia.org/wiki/Real_mode">real mode</a>. Let's back up a little and try to understand <a href="https://en.wikipedia.org/wiki/Memory_segmentation">memory segmentation</a> in this mode. Real mode is supported on all x86-compatible processors, from the <a href="https://en.wikipedia.org/wiki/Intel_8086">8086</a> CPU all the way to the modern Intel 64-bit CPUs. The <code>8086</code> processor has a 20-bit address bus, which means that it could work with a <code>0-0xFFFFF</code> or <code>1 megabyte</code> address space. But it only has <code>16-bit</code> registers, which have a maximum address of <code>2^16 - 1</code> or <code>0xffff</code> (64 kilobytes).</p>
<p><a href="https://en.wikipedia.org/wiki/Memory_segmentation">Memory segmentation</a> is used to make use of all the address space available. All memory is divided into small, fixed-size segments of <code>65536</code> bytes (64 KB). Since we cannot address memory above <code>64 KB</code> with 16-bit registers, an alternate method was devised.</p>
<p>An address consists of two parts: a segment selector, which has a base address; and an offset from this base address. In real mode, the associated base address of a segment selector is <code>Segment Selector * 16</code>. Thus, to get a physical address in memory, we need to multiply the segment selector part by <code>16</code> and add the offset to it:</p>
<pre><code>PhysicalAddress = Segment Selector * 16 + Offset
</code></pre>
<p>For example, if <code>CS:IP</code> is <code>0x2000:0x0010</code>, then the corresponding physical address will be:</p>
<pre><code class="language-python">&gt;&gt;&gt; hex((0x2000 &lt;&lt; 4) + 0x0010)
'0x20010'
</code></pre>
<p>But, if we take the largest segment selector and offset, <code>0xffff:0xffff</code>, then the resulting address will be:</p>
<pre><code class="language-python">&gt;&gt;&gt; hex((0xffff &lt;&lt; 4) + 0xffff)
'0x10ffef'
</code></pre>
<p>which is <code>65520</code> bytes past the first megabyte. Since only one megabyte is accessible in real mode, <code>0x10ffef</code> becomes <code>0x00ffef</code> with the <a href="https://en.wikipedia.org/wiki/A20_line">A20 line</a> disabled.</p>
<p>Ok, now we know a little bit about real mode and its memory addressing. Let's get back to discussing register values after reset.</p>
<p>The <code>CS</code> register consists of two parts: the visible segment selector and the hidden base address.  In real-address mode, the base address is normally formed by shifting the 16-bit segment selector value 4 bits to the left to produce a 20-bit base address. However, during a hardware reset the segment selector in the CS register is loaded with <code>0xf000</code> and the base address is loaded with <code>0xffff0000</code>. The processor uses this special base address until <code>CS</code> changes.</p>
<p>The starting address is formed by adding the base address to the value in the EIP register:</p>
<pre><code class="language-python">&gt;&gt;&gt; 0xffff0000 + 0xfff0
'0xfffffff0'
</code></pre>
<p>We get <code>0xfffffff0</code>, which is 16 bytes below 4GB. This point is called the <a href="https://en.wikipedia.org/wiki/Reset_vector">reset vector</a>. It's the memory location at which the CPU expects to find the first instruction to execute after reset. It contains a <a href="https://en.wikipedia.org/wiki/JMP_%28x86_instruction%29">jump</a> (<code>jmp</code>) instruction that usually points to the <a href="https://en.wikipedia.org/wiki/BIOS">BIOS</a> (Basic Input/Output System) entry point. For example, if we look in the <a href="https://www.coreboot.org/">coreboot</a> source code (<a href="https://review.coreboot.org/plugins/gitiles/coreboot/+/refs/heads/4.11_branch/src/cpu/x86/16bit/reset16.inc">src/cpu/x86/16bit/reset16.inc</a>), we see:</p>
<pre><code class="language-assembly">    .section &quot;.reset&quot;, &quot;ax&quot;, %progbits
    .code16
.globl	_start
_start:
    .byte  0xe9
    .int   _start16bit - ( . + 2 )
    ...
</code></pre>
<p>Here we can see the <code>jmp</code> instruction <a href="http://ref.x86asm.net/coder32.html#xE9">opcode</a>, which is <code>0xe9</code>, and its destination address at <code>_start16bit - ( . + 2)</code>.</p>
<p>We also see that the <code>reset</code> section is <code>16</code> bytes and is compiled to start from the address <code>0xfffffff0</code> (<a href="https://review.coreboot.org/plugins/gitiles/coreboot/+/refs/heads/4.11_branch/src/cpu/x86/16bit/reset16.ld">src/cpu/x86/16bit/reset16.ld</a>):</p>
<pre><code>SECTIONS {
    /* Trigger an error if I have an unusable start address */
    _bogus = ASSERT(_start16bit &gt;= 0xffff0000, &quot;_start16bit too low. Please report.&quot;);
    _ROMTOP = 0xfffffff0;
    . = _ROMTOP;
    .reset . : {
        *(.reset);
        . = 15;
        BYTE(0x00);
    }
}
</code></pre>
<p>Now the BIOS starts. After initializing and checking the hardware, the BIOS needs to find a bootable device. A boot order is stored in the BIOS configuration, controlling which devices the BIOS attempts to boot from. When attempting to boot from a hard drive, the BIOS tries to find a boot sector. On hard drives partitioned with an <a href="https://en.wikipedia.org/wiki/Master_boot_record">MBR partition layout</a>, the boot sector is stored in the first <code>446</code> bytes of the first sector, where each sector is <code>512</code> bytes. The final two bytes of the first sector are <code>0x55</code> and <code>0xaa</code>, which designates to the BIOS that this device is bootable. Once the BIOS finds the boot sector, it copies it into a fixed memory location at 0x7c00, jumps to there and start executing it.</p>
<p>For example:</p>
<pre><code class="language-assembly">;
; Note: this example is written in Intel Assembly syntax
;
[BITS 16]

boot:
    mov al, '!'
    mov ah, 0x0e
    mov bh, 0x00
    mov bl, 0x07

    int 0x10
    jmp $

times 510-($-$$) db 0

db 0x55
db 0xaa
</code></pre>
<p>Build and run this with:</p>
<pre><code>nasm -f bin boot.nasm &amp;&amp; qemu-system-x86_64 boot
</code></pre>
<p>This will instruct <a href="https://www.qemu.org/">QEMU</a> to use the <code>boot</code> binary that we just built as a disk image. Since the binary generated by the assembly code above fulfills the requirements of the boot sector (we end it with the magic sequence), QEMU will treat the binary as the master boot record (MBR) of a disk image. Note that when providing a boot binary image to QEMU, setting the origin to 0x7c00 (using <code>[ORG  0x7c00]</code>)
is unneeded.</p>
<p>You will see:</p>
<p><img src="images/simple_bootloader.png" alt="Simple bootloader which prints only !" /></p>
<p>In this example, we can see that the code will be executed in <code>16-bit</code> real mode. After starting, it calls the <a href="http://www.ctyme.com/intr/rb-0106.htm">0x10</a> interrupt, which just prints the <code>!</code> symbol. The times directive will pad that number of bytes up to 510th byte with zeros and finishes with the two magic bytes <code>0xaa</code> and <code>0x55</code>.</p>
<p>You can see a binary dump of this using the <code>objdump</code> utility:</p>
<pre><code>nasm -f bin boot.nasm
objdump -D -b binary -mi386 -Maddr16,data16,intel boot
</code></pre>
<p>A real-world boot sector has code for continuing the boot process and a partition table instead of a bunch of 0's and an exclamation mark. :) From this point onwards, the BIOS hands control over to the bootloader.</p>
<p><strong>NOTE</strong>: As explained above, the CPU is in real mode. In real mode, calculating the physical address in memory is done as follows:</p>
<pre><code>PhysicalAddress = Segment Selector * 16 + Offset
</code></pre>
<p>just as explained above. We have only 16-bit general purpose registers, which has a maximum value of <code>0xffff</code>, so if we take the largest values the result will be:</p>
<pre><code class="language-python">&gt;&gt;&gt; hex((0xffff * 16) + 0xffff)
'0x10ffef'
</code></pre>
<p>where <code>0x10ffef</code> is equal to <code>(1MB + 64KB - 16B) - 1</code>. An <a href="https://en.wikipedia.org/wiki/Intel_8086">8086</a> processor (which was the first processor with real mode), in contrast, has a 20-bit address line. Since <code>2^20 = 1048576</code> is 1MB and <code>2^20 - 1</code> is the maximum address that could be used, this means that the actual available memory is 1MB.</p>
<p>In general, real mode's memory map is as follows:</p>
<pre><code>0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table
0x00000400 - 0x000004FF - BIOS Data Area
0x00000500 - 0x00007BFF - Unused
0x00007C00 - 0x00007DFF - Our Bootloader
0x00007E00 - 0x0009FFFF - Unused
0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory
0x000B0000 - 0x000B7777 - Monochrome Video Memory
0x000B8000 - 0x000BFFFF - Color Video Memory
0x000C0000 - 0x000C7FFF - Video ROM BIOS
0x000C8000 - 0x000EFFFF - BIOS Shadow Area
0x000F0000 - 0x000FFFFF - System BIOS
</code></pre>
<p>At the beginning of this post, I wrote that the first instruction executed by the CPU is located at address <code>0xFFFFFFF0</code>, which is much larger than <code>0xFFFFF</code> (1MB). How can the CPU access this address in real mode? The answer is in the <a href="https://www.coreboot.org/Developer_Manual/Memory_map">coreboot</a> documentation:</p>
<pre><code>0xFFFE_0000 - 0xFFFF_FFFF: 128 kilobyte ROM mapped into address space
</code></pre>
<p>At the start of execution, the BIOS is not in RAM, but in ROM.</p>
<h2 id="bootloader"><a class="header" href="#bootloader">Bootloader</a></h2>
<p>There are a number of bootloaders that can boot Linux, such as <a href="https://www.gnu.org/software/grub/">GRUB 2</a> and <a href="http://www.syslinux.org/wiki/index.php/The_Syslinux_Project">syslinux</a>. The Linux kernel has a <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/boot.txt">Boot protocol</a> which specifies the requirements for a bootloader to implement Linux support. This example will describe GRUB 2.</p>
<p>Continuing from before, now that the BIOS has chosen a boot device and transferred control to the boot sector code, execution starts from <a href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/boot.S;hb=HEAD">boot.img</a>. Its code is very simple, due to the limited amount of space available. It contains a pointer which is used to jump to the location of GRUB 2's core image. The core image begins with <a href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/diskboot.S;hb=HEAD">diskboot.img</a>, which is usually stored immediately after the first sector in the unused space before the first partition. The above code loads the rest of the core image, which contains GRUB 2's kernel and drivers for handling filesystems, into memory. After loading the rest of the core image, it executes the <a href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/kern/main.c">grub_main</a> function.</p>
<p>The <code>grub_main</code> function initializes the console, gets the base address for modules, sets the root device, loads/parses the grub configuration file, loads modules, etc. At the end of execution, the <code>grub_main</code> function moves grub to normal mode. The <code>grub_normal_execute</code> function (from the <code>grub-core/normal/main.c</code> source code file) completes the final preparations and shows a menu to select an operating system. When we select one of the grub menu entries, the <code>grub_menu_execute_entry</code> function runs, executing the grub <code>boot</code> command and booting the selected operating system.</p>
<p>As we can read in the kernel boot protocol, the bootloader must read and fill some fields of the kernel setup header, which starts at offset <code>0x01f1</code> from the kernel setup code. You may look at the boot <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/setup.ld">linker script</a> to confirm the value of this offset. The kernel header <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S">arch/x86/boot/header.S</a> starts from:</p>
<pre><code class="language-assembly">    .globl hdr
hdr:
    setup_sects: .byte 0
    root_flags:  .word ROOT_RDONLY
    syssize:     .long 0
    ram_size:    .word 0
    vid_mode:    .word SVGA_MODE
    root_dev:    .word 0
    boot_flag:   .word 0xAA55
</code></pre>
<p>The bootloader must fill this and the rest of the headers (which are only marked as being type <code>write</code> in the Linux boot protocol, such as in <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/boot.txt#L354">this example</a>) with values either received from the command line or calculated during booting. (We will not go over full descriptions and explanations for all fields of the kernel setup header for now, but we shall do so when discussing how the kernel uses them. You can find a description of all fields in the <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/boot.txt#L156">boot protocol</a>.)</p>
<p>As we can see in the kernel boot protocol, memory will be mapped as follows after loading the kernel:</p>
<pre><code class="language-shell">         | Protected-mode kernel  |
100000   +------------------------+
         | I/O memory hole        |
0A0000   +------------------------+
         | Reserved for BIOS      | Leave as much as possible unused
         ~                        ~
         | Command line           | (Can also be below the X+10000 mark)
X+10000  +------------------------+
         | Stack/heap             | For use by the kernel real-mode code.
X+08000  +------------------------+
         | Kernel setup           | The kernel real-mode code.
         | Kernel boot sector     | The kernel legacy boot sector.
       X +------------------------+
         | Boot loader            | &lt;- Boot sector entry point 0x7C00
001000   +------------------------+
         | Reserved for MBR/BIOS  |
000800   +------------------------+
         | Typically used by MBR  |
000600   +------------------------+
         | BIOS use only          |
000000   +------------------------+

</code></pre>
<p>When the bootloader transfers control to the kernel, it starts at:</p>
<pre><code>X + sizeof(KernelBootSector) + 1
</code></pre>
<p>where <code>X</code> is the address of the kernel boot sector being loaded. In my case, <code>X</code> is <code>0x10000</code>, as we can see in a memory dump:</p>
<p><img src="images/kernel_first_address.png" alt="kernel first address" /></p>
<h2 id="how-to-get-this-memory-dump-in-real-mode"><a class="header" href="#how-to-get-this-memory-dump-in-real-mode">How to get this memory dump in real mode?</a></h2>
<pre><code>root@parallels-vm:/usr/src/linux# more arch/x86/kernel/vmlinux.lds
...
SECTIONS
{
 . = (0xffffffff80000000 + ALIGN(0x1000000, 0x200000));
 phys_startup_64 = ABSOLUTE(startup_64 - 0xffffffff80000000);
 .text : AT(ADDR(.text) - 0xffffffff80000000) {
  _text = .;
  _stext = .;
....
</code></pre>
<pre><code>root@parallels-vm:/usr/src/linux# nm vmlinux|grep startup_64
0000000001000000 A phys_startup_64
ffffffff81000030 T secondary_startup_64
ffffffff810001f0 T __startup_64
ffffffff81000000 T startup_64
</code></pre>
<p>Here we can see the memory address of the entry point, which is <code>0x0000000001000000</code>. Let's go ahead.</p>
<p>Before trying to debug the kernel, please see <a href="http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/">Booting a Custom Linux Kernel in QEMU and Debugging It With GDB</a></p>
<h4 id="step-1"><a class="header" href="#step-1">Step 1</a></h4>
<p>Booting in QEMU</p>
<pre><code>qemu-system-x86_64 -kernel /usr/src/linux-4.14.207/arch/x86_64/boot/bzImage -nographic -append &quot;console=ttyS0 nokaslr&quot; -initrd /data/busybox/busybox-1.28.0/initramfs.cpio.gz -S -s
</code></pre>
<h4 id="step-2"><a class="header" href="#step-2">Step 2</a></h4>
<p>Attaching GDB to QEMU</p>
<pre><code>gdb vmlinux
(gdb) target remote :1234
(gdb) hbreak *0x0000000001000000
(gdb) c
(gdb) dump binary memory /tmp/dump 0x0000 0x20000
</code></pre>
<h4 id="step-3"><a class="header" href="#step-3">Step 3</a></h4>
<pre><code>root@parallels-vm:/# hd /tmp/dump |grep -A 31 MZ
00010000  4d 5a ea 07 00 c0 07 8c  c8 8e d8 8e c0 8e d0 31  |MZ.............1|
00010010  e4 fb fc be 40 00 ac 20  c0 74 09 b4 0e bb 07 00  |....@.. .t......|
00010020  cd 10 eb f2 31 c0 cd 16  cd 19 ea f0 ff 00 f0 00  |....1...........|
00010030  00 00 00 00 00 00 00 00  00 00 00 00 82 00 00 00  |................|
00010040  55 73 65 20 61 20 62 6f  6f 74 20 6c 6f 61 64 65  |Use a boot loade|
00010050  72 2e 0d 0a 0a 52 65 6d  6f 76 65 20 64 69 73 6b  |r....Remove disk|
00010060  20 61 6e 64 20 70 72 65  73 73 20 61 6e 79 20 6b  | and press any k|
00010070  65 79 20 74 6f 20 72 65  62 6f 6f 74 2e 2e 2e 0d  |ey to reboot....|
00010080  0a 00 50 45 00 00 64 86  04 00 00 00 00 00 00 00  |..PE..d.........|
00010090  00 00 01 00 00 00 a0 00  06 02 0b 02 02 14 20 d5  |.............. .|
000100a0  80 00 00 00 00 00 e0 b8  79 01 80 46 00 00 00 02  |........y..F....|
000100b0  00 00 00 00 00 00 00 00  00 00 20 00 00 00 20 00  |.......... ... .|
000100c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000100d0  00 00 00 90 fa 01 00 02  00 00 00 00 00 00 0a 00  |................|
000100e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00010100  00 00 00 00 00 00 06 00  00 00 00 00 00 00 00 00  |................|
00010110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00010130  00 00 00 00 00 00 00 00  00 00 2e 73 65 74 75 70  |...........setup|
00010140  00 00 e0 41 00 00 00 02  00 00 e0 41 00 00 00 02  |...A.......A....|
00010150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 20 00  |.............. .|
00010160  50 60 2e 72 65 6c 6f 63  00 00 20 00 00 00 e0 43  |P`.reloc.. ....C|
00010170  00 00 20 00 00 00 e0 43  00 00 00 00 00 00 00 00  |.. ....C........|
00010180  00 00 00 00 00 00 40 00  10 42 2e 74 65 78 74 00  |......@..B.text.|
00010190  00 00 20 93 80 00 00 44  00 00 20 93 80 00 00 44  |.. ....D.. ....D|
000101a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 20 00  |.............. .|
000101b0  50 60 2e 62 73 73 00 00  00 00 e0 b8 79 01 20 d7  |P`.bss......y. .|
000101c0  80 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000101d0  00 00 00 00 00 00 80 00  00 c8 00 00 00 00 00 00  |................|
000101e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 ff  |................|
000101f0  ff 21 01 00 32 09 08 00  00 00 ff ff 00 00 55 aa  |.!..2.........U.|
</code></pre>
<p>The bootloader has now loaded the Linux kernel into memory, filled the header fields, and then jumped to the corresponding memory address. We now move directly to the kernel setup code.</p>
<h2 id="the-beginning-of-the-kernel-setup-stage"><a class="header" href="#the-beginning-of-the-kernel-setup-stage">The Beginning of the Kernel Setup Stage</a></h2>
<p>Finally, we are in the kernel! Technically, the kernel hasn't run yet. First, the kernel setup part must configure stuff such as the decompressor and some memory management related things, to name a few. After all these things are done, the kernel setup part will decompress the actual kernel and jump to it. Execution of the setup part starts from <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S">arch/x86/boot/header.S</a> at the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L292">_start</a> symbol.</p>
<p>It may look a bit strange at first sight, as there are several instructions before it. A long time ago, the Linux kernel had its own bootloader. Now, however, if you run, for example,</p>
<pre><code>qemu-system-x86_64 vmlinuz-3.18-generic
</code></pre>
<p>then you will see:</p>
<p><img src="images/try_vmlinuz_in_qemu.png" alt="Try vmlinuz in qemu" /></p>
<p>Actually, the file <code>header.S</code> starts with the magic number <a href="https://en.wikipedia.org/wiki/DOS_MZ_executable">MZ</a> (see image above), the error message that displays and, following that, the <a href="https://en.wikipedia.org/wiki/Portable_Executable">PE</a> header:</p>
<pre><code class="language-assembly">#ifdef CONFIG_EFI_STUB
# &quot;MZ&quot;, MS-DOS header
.byte 0x4d
.byte 0x5a
#endif
...
...
...
pe_header:
    .ascii &quot;PE&quot;
    .word 0
</code></pre>
<p>It needs this to load an operating system with <a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a> support. We won't be looking into its inner workings right now but will cover it in upcoming chapters.</p>
<p>The actual kernel setup entry point is:</p>
<pre><code class="language-assembly">// header.S line 292
.globl _start
_start:
</code></pre>
<p>The bootloader (GRUB 2 and others) knows about this point (at an offset of <code>0x200</code> from <code>MZ</code>) and jumps directly to it, despite the fact that <code>header.S</code> starts from the <code>.bstext</code> section, which prints an error message:</p>
<pre><code>//
// arch/x86/boot/setup.ld
//
. = 0;                    // current position
.bstext : { *(.bstext) }  // put .bstext section to position 0
.bsdata : { *(.bsdata) }
</code></pre>
<p>The kernel setup entry point is:</p>
<pre><code class="language-assembly">    .globl _start
_start:
    .byte  0xeb
    .byte  start_of_setup-1f
1:
    //
    // rest of the header
    //
</code></pre>
<p>Here we can see a <code>jmp</code> instruction opcode (<code>0xeb</code>) that jumps to the <code>start_of_setup-1f</code> point. In <code>Nf</code> notation, <code>2f</code>, for example, refers to the local label <code>2:</code>. In our case, it's label <code>1:</code> that is present right after the jump, and contains the rest of the setup <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/boot.txt#L156">header</a>. Right after the setup header, we see the <code>.entrytext</code> section, which starts at the <code>start_of_setup</code> label.</p>
<p>This is the first code that actually runs (aside from the previous jump instructions, of course). After the kernel setup part receives control from the bootloader, the first <code>jmp</code> instruction is located at the <code>0x200</code> offset from the start of the kernel real mode, i.e., after the first 512 bytes. This can be seen in both the Linux kernel boot protocol and the GRUB 2 source code:</p>
<pre><code class="language-C">segment = grub_linux_real_target &gt;&gt; 4;
state.gs = state.fs = state.es = state.ds = state.ss = segment;
state.cs = segment + 0x20;
</code></pre>
<p>In my case, the kernel is loaded at the physical address <code>0x10000</code>. This means that segment registers have the following values after kernel setup starts:</p>
<pre><code>gs = fs = es = ds = ss = 0x1000
cs = 0x1020
</code></pre>
<p>After the jump to <code>start_of_setup</code>, the kernel needs to do the following:</p>
<ul>
<li>Make sure that all segment register values are equal</li>
<li>Set up a correct stack, if needed</li>
<li>Set up <a href="https://en.wikipedia.org/wiki/.bss">bss</a></li>
<li>Jump to the C code in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c">arch/x86/boot/main.c</a></li>
</ul>
<p>Let's look at the implementation.</p>
<h2 id="aligning-the-segment-registers"><a class="header" href="#aligning-the-segment-registers">Aligning the Segment Registers</a></h2>
<p>First of all, the kernel ensures that the <code>ds</code> and <code>es</code> segment registers point to the same address. Next, it clears the direction flag using the <code>cld</code> instruction:</p>
<pre><code class="language-assembly">    movw    %ds, %ax
    movw    %ax, %es
    cld
</code></pre>
<p>As I wrote earlier, <code>grub2</code> loads kernel setup code at address <code>0x10000</code> by default and <code>cs</code> at <code>0x1020</code> because execution doesn't start from the start of the file, but from the jump here:</p>
<pre><code class="language-assembly">_start:
    .byte 0xeb
    .byte start_of_setup-1f
</code></pre>
<p>which is at a <code>512</code> byte offset from <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L46">4d 5a</a>. We also need to align <code>cs</code> from <code>0x1020</code> to <code>0x1000</code>, as well as all other segment registers. After that, we set up the stack:</p>
<pre><code class="language-assembly">    pushw   %ds
    pushw   $6f
    lretw
</code></pre>
<p>which pushes the value of <code>ds</code> to the stack, followed by the address of the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L602">6</a> label and executes the <code>lretw</code> instruction. When the <code>lretw</code> instruction is called, it loads the address of label <code>6</code> into the <a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a> register and loads <code>cs</code> with the value of <code>ds</code>. Afterward, <code>ds</code> and <code>cs</code> will have the same values.</p>
<h2 id="stack-setup"><a class="header" href="#stack-setup">Stack Setup</a></h2>
<p>Almost all of the setup code is for preparing the C language environment in real mode. The next <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L575">step</a> is checking the <code>ss</code> register's value and setting up a correct stack if <code>ss</code> is wrong:</p>
<pre><code class="language-assembly">    movw    %ss, %dx
    cmpw    %ax, %dx
    movw    %sp, %dx
    je      2f
</code></pre>
<p>This can lead to 3 different scenarios:</p>
<ul>
<li><code>ss</code> has a valid value <code>0x1000</code> (as do all the other segment registers besides <code>cs</code>)</li>
<li><code>ss</code> is invalid and the <code>CAN_USE_HEAP</code> flag is set     (see below)</li>
<li><code>ss</code> is invalid and the <code>CAN_USE_HEAP</code> flag is not set (see below)</li>
</ul>
<p>Let's look at all three of these scenarios in turn:</p>
<ul>
<li><code>ss</code> has a correct address (<code>0x1000</code>). In this case, we go to label <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L589">2</a>:</li>
</ul>
<pre><code class="language-assembly">2:  andw    $~3, %dx
    jnz     3f
    movw    $0xfffc, %dx
3:  movw    %ax, %ss
    movzwl  %dx, %esp
    sti
</code></pre>
<p>Here we set the alignment of <code>dx</code> (which contains the value of <code>sp</code> as given by the bootloader) to <code>4</code> bytes and check if it is zero. If it is, we set <code>dx</code> to <code>0xfffc</code> (The last 4-byte aligned address in a 64KB segment). If it is not zero, we continue to use the value of <code>sp</code> given by the bootloader (<code>0xf7f4</code> in my case). Afterwards, we put the value of <code>ax</code> (<code>0x1000</code>) into <code>ss</code>. We now have a correct stack:</p>
<p><img src="images/stack1.png" alt="stack" /></p>
<ul>
<li>The second scenario, (<code>ss</code> != <code>ds</code>). First, we put the value of <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/setup.ld">_end</a> (the address of the end of the setup code) into <code>dx</code> and check the <code>loadflags</code> header field using the <code>testb</code> instruction to see whether we can use the heap. <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L320">loadflags</a> is a bitmask header defined as:</li>
</ul>
<pre><code class="language-C">#define LOADED_HIGH     (1&lt;&lt;0)
#define QUIET_FLAG      (1&lt;&lt;5)
#define KEEP_SEGMENTS   (1&lt;&lt;6)
#define CAN_USE_HEAP    (1&lt;&lt;7)
</code></pre>
<p>and as we can read in the boot protocol:</p>
<pre><code>Field name: loadflags

  This field is a bitmask.

  Bit 7 (write): CAN_USE_HEAP
    Set this bit to 1 to indicate that the value entered in the
    heap_end_ptr is valid.  If this field is clear, some setup code
    functionality will be disabled.
</code></pre>
<p>If the <code>CAN_USE_HEAP</code> bit is set, we put <code>heap_end_ptr</code> into <code>dx</code> (which points to <code>_end</code>) and add <code>STACK_SIZE</code> (the minimum stack size, <code>1024</code> bytes) to it. After this, if <code>dx</code> is not carried (it will not be carried, <code>dx = _end + 1024</code>), jump to label <code>2</code> (as in the previous case) and make a correct stack.</p>
<p><img src="images/stack2.png" alt="stack" /></p>
<ul>
<li>When <code>CAN_USE_HEAP</code> is not set, we just use a minimal stack from <code>_end</code> to <code>_end + STACK_SIZE</code>:</li>
</ul>
<p><img src="images/minimal_stack.png" alt="minimal stack" /></p>
<h2 id="bss-setup"><a class="header" href="#bss-setup">BSS Setup</a></h2>
<p>The last two steps that need to happen before we can jump to the main C code are setting up the <a href="https://en.wikipedia.org/wiki/.bss">BSS</a> area and checking the &quot;magic&quot; signature. First, signature checking:</p>
<pre><code class="language-assembly">    cmpl    $0x5a5aaa55, setup_sig
    jne     setup_bad
</code></pre>
<p>This simply compares the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/setup.ld">setup_sig</a> with the magic number <code>0x5a5aaa55</code>. If they are not equal, a fatal error is reported.</p>
<p>If the magic number matches, knowing we have a set of correct segment registers and a stack, we only need to set up the BSS section before jumping into the C code.</p>
<p>The BSS section is used to store statically allocated, uninitialized data. Linux carefully ensures this area of memory is first zeroed using the following code:</p>
<pre><code class="language-assembly">    movw    $__bss_start, %di
    movw    $_end+3, %cx
    xorl    %eax, %eax
    subw    %di, %cx
    shrw    $2, %cx
    rep; stosl
</code></pre>
<p>First, the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/setup.ld">__bss_start</a> address is moved into <code>di</code>. Next, the <code>_end + 3</code> address (+3 - aligns to 4 bytes) is moved into <code>cx</code>. The <code>eax</code> register is cleared (using the <code>xor</code> instruction), and the bss section size (<code>cx - di</code>) is calculated and put into <code>cx</code>. Then, <code>cx</code> is divided by four (the size of a 'word'), and the <code>stosl</code> instruction is used repeatedly, storing the value of <code>eax</code> (zero) into the address pointed to by <code>di</code>, automatically increasing <code>di</code> by four, repeating until <code>cx</code> reaches zero. The net effect of this code is that zeros are written through all words in memory from <code>__bss_start</code> to <code>_end</code>:</p>
<p><img src="images/bss.png" alt="bss" /></p>
<h2 id="jump-to-main"><a class="header" href="#jump-to-main">Jump to main</a></h2>
<p>That's all! We have the stack and BSS, so we can jump to the <code>main()</code> C function:</p>
<pre><code class="language-assembly">    call main
</code></pre>
<p>The <code>main()</code> function is located in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c">arch/x86/boot/main.c</a>. You can read about what this does in the next part.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This is the end of the first part about Linux kernel insides. If you have questions or suggestions, ping me on Twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a>, or just create an <a href="https://github.com/0xAX/linux-internals/issues/new">issue</a>. In the next part, we will see the first C code that executes in the Linux kernel setup, the implementation of memory routines such as <code>memset</code>, <code>memcpy</code>, <code>earlyprintk</code>, early console implementation and initialization, and much more.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-internals">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="http://css.csail.mit.edu/6.858/2014/readings/i386.pdf">Intel 80386 programmer's reference manual 1986</a></li>
<li><a href="https://www.cs.cmu.edu/%7E410/doc/minimal_boot.pdf">Minimal Boot Loader for Intel® Architecture</a></li>
<li><a href="https://github.com/Stefan20162016/linux-insides-code/blob/master/bootloader.asm">Minimal Boot Loader in Assembler with comments</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8086">8086</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_80386">80386</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reset_vector">Reset vector</a></li>
<li><a href="https://en.wikipedia.org/wiki/Real_mode">Real mode</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">Linux kernel boot protocol</a></li>
<li><a href="https://www.coreboot.org/Developer_Manual">coreboot developer manual</a></li>
<li><a href="http://www.ctyme.com/intr/int.htm">Ralf Brown's Interrupt List</a></li>
<li><a href="https://en.wikipedia.org/wiki/Power_supply">Power supply</a></li>
<li><a href="https://en.wikipedia.org/wiki/Power_good_signal">Power good signal</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Booting/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Booting/linux-bootstrap-2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Booting/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Booting/linux-bootstrap-2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
