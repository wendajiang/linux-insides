<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Transition to 64-bit mode - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html" class="active">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="kernel-booting-process-part-4"><a class="header" href="#kernel-booting-process-part-4">Kernel booting process. Part 4.</a></h1>
<h2 id="the-transition-to-64-bit-mode"><a class="header" href="#the-transition-to-64-bit-mode">The Transition to 64-bit mode</a></h2>
<p>This is the fourth part of the <code>Kernel booting process</code>. Here, we will learn about the first steps taken in <a href="http://en.wikipedia.org/wiki/Protected_mode">protected mode</a>, like checking if the CPU supports <a href="http://en.wikipedia.org/wiki/Long_mode">long mode</a> and <a href="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a>. We will initialize the page tables with <a href="http://en.wikipedia.org/wiki/Paging">paging</a> and, at the end, transition the CPU to <a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a>.</p>
<p><strong>NOTE: there will be lots of assembly code in this part, so if you are not familiar with that, you might want to consult a book about it</strong></p>
<p>In the previous <a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-3.md">part</a> we stopped at the jump to the <code>32-bit</code> entry point in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/pmjump.S">arch/x86/boot/pmjump.S</a>:</p>
<pre><code class="language-assembly">jmpl	*%eax
</code></pre>
<p>You will recall that the <code>eax</code> register contains the address of the 32-bit entry point. We can read about this in the <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">linux kernel x86 boot protocol</a>:</p>
<pre><code>When using bzImage, the protected-mode kernel was relocated to 0x100000
</code></pre>
<p>Let's make sure that this is so by looking at the register values at the 32-bit entry point:</p>
<pre><code>eax            0x100000	1048576
ecx            0x0	    0
edx            0x0	    0
ebx            0x0	    0
esp            0x1ff5c	0x1ff5c
ebp            0x0	    0x0
esi            0x14470	83056
edi            0x0	    0
eip            0x100000	0x100000
eflags         0x46	    [ PF ZF ]
cs             0x10	16
ss             0x18	24
ds             0x18	24
es             0x18	24
fs             0x18	24
gs             0x18	24
</code></pre>
<p>We can see here that the <code>cs</code> register contains a value of <code>0x10</code> (as you might recall from the <a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-3.md">previous part</a>, this is the second index in the <code>Global Descriptor Table</code>), the <code>eip</code> register contains the value <code>0x100000</code> and the base address of all segments including the code segment are zero.</p>
<p>So, the physical address where the kernel is loaded would be <code>0:0x100000</code> or just <code>0x100000</code>, as specified by the boot protocol. Now let's start with the <code>32-bit</code> entry point.</p>
<h2 id="the-32-bit-entry-point"><a class="header" href="#the-32-bit-entry-point">The 32-bit entry point</a></h2>
<p>The <code>32-bit</code> entry point is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly source code file:</p>
<pre><code class="language-assembly">	__HEAD
	.code32
ENTRY(startup_32)
....
....
....
ENDPROC(startup_32)
</code></pre>
<p>First, why is the directory named <code>compressed</code>? The answer to that is that <code>bzimage</code> is a gzipped package consisting of <code>vmlinux</code>,   <code>header</code> and <code> kernel setup code</code>. We looked at kernel setup code in all of the previous parts. The main goal of the code in <code>head_64.S</code> is to prepare to enter long mode, enter it and then decompress the kernel. We will look at all of the steps leading to kernel decompression in this part.</p>
<p>You will find two files in the <code>arch/x86/boot/compressed</code> directory:</p>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_32.S">head_32.S</a></li>
<li><a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">head_64.S</a></li>
</ul>
<p>but we will consider only the <code>head_64.S</code> source code file because, as you may remember, this book is only <code>x86_64</code> related; Let's look at <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/Makefile">arch/x86/boot/compressed/Makefile</a>. We can find the following <code>make</code> target here:</p>
<pre><code class="language-Makefile">vmlinux-objs-y := $(obj)/vmlinux.lds $(obj)/head_$(BITS).o $(obj)/misc.o \
	$(obj)/string.o $(obj)/cmdline.o \
	$(obj)/piggy.o $(obj)/cpuflags.o
</code></pre>
<p>The first line contains this- <code>$(obj)/head_$(BITS).o</code>.</p>
<p>This means that we will select which file to link based on what <code>$(BITS)</code> is set to, either <code>head_32.o</code> or <code>head_64.o</code>. The <code>$(BITS)</code> variable is defined elsewhere in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/Makefile">arch/x86/Makefile</a> based on the kernel configuration:</p>
<pre><code class="language-Makefile">ifeq ($(CONFIG_X86_32),y)
        BITS := 32
        ...
        ...
else
        BITS := 64
        ...
        ...
endif
</code></pre>
<p>Now that we know where to start, let's get to it.</p>
<h2 id="reload-the-segments-if-needed"><a class="header" href="#reload-the-segments-if-needed">Reload the segments if needed</a></h2>
<p>As indicated above, we start in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly source code file. We first see the definition of a special section attribute before the definition of the <code>startup_32</code> function:</p>
<pre><code class="language-assembly">    __HEAD
    .code32
ENTRY(startup_32)
</code></pre>
<p><code>__HEAD</code> is a macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init.h">include/linux/init.h</a> header file and expands to the definition of the following section:</p>
<pre><code class="language-C">#define __HEAD		.section	&quot;.head.text&quot;,&quot;ax&quot;
</code></pre>
<p>Here, <code>.head.text</code> is the name of the section and <code>ax</code> is a set of flags. In our case, these flags show us that this section is <a href="https://en.wikipedia.org/wiki/Executable">executable</a> or in other words contains code. We can find the definition of this section in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/vmlinux.lds.S">arch/x86/boot/compressed/vmlinux.lds.S</a> linker script:</p>
<pre><code>SECTIONS
{
	. = 0;
	.head.text : {
		_head = . ;
		HEAD_TEXT
		_ehead = . ;
     }
     ...
     ...
     ...
}
</code></pre>
<p>If you are not familiar with the syntax of the <code>GNU LD</code> linker scripting language, you can find more information in its <a href="https://sourceware.org/binutils/docs/ld/Scripts.html#Scripts">documentation</a>. In short, the <code>.</code> symbol is a special linker variable, the location counter. The value assigned to it is an offset relative to the segment. In our case, we set the location counter to zero. This means that our code is linked to run from an offset of <code>0</code> in memory. This is also stated in the comments:</p>
<pre><code>Be careful parts of head_64.S assume startup_32 is at address 0.
</code></pre>
<p>Now that we have our bearings, let's look at the contents of the <code>startup_32</code> function.</p>
<p>In the beginning of the <code>startup_32</code> function, we can see the <code>cld</code> instruction which clears the <code>DF</code> bit in the <a href="https://en.wikipedia.org/wiki/FLAGS_register">flags</a> register. When the direction flag is clear, all string operations like <a href="http://x86.renejeschke.de/html/file_module_x86_id_306.html">stos</a>, <a href="http://x86.renejeschke.de/html/file_module_x86_id_287.html">scas</a> and others will increment the index registers <code>esi</code> or <code>edi</code>. We need to clear the direction flag because later we will use strings operations to perform various operations such as clearing space for page tables.</p>
<p>After we have cleared the <code>DF</code> bit, the next step is to check the <code>KEEP_SEGMENTS</code> flag in the <code>loadflags</code> kernel setup header field. If you remember, we already talked about <code>loadflags</code> in the very first <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-1">part</a> of this book. There we checked the <code>CAN_USE_HEAP</code> flag to query the ability to use the heap. Now we need to check the <code>KEEP_SEGMENTS</code> flag. This flag is described in the Linux <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">boot protocol</a> documentation:</p>
<pre><code>Bit 6 (write): KEEP_SEGMENTS
  Protocol: 2.07+
  - If 0, reload the segment registers in the 32bit entry point.
  - If 1, do not reload the segment registers in the 32bit entry point.
    Assume that %cs %ds %ss %es are all set to flat segments with
		a base of 0 (or the equivalent for their environment).
</code></pre>
<p>So, if the <code>KEEP_SEGMENTS</code> bit is not set in <code>loadflags</code>, we need to set the <code>ds</code>, <code>ss</code> and <code>es</code> segment registers to the index of the data segment with a base of <code>0</code>. That we do:</p>
<pre><code class="language-C">	testb $KEEP_SEGMENTS, BP_loadflags(%esi)
	jnz 1f

	cli
	movl	$(__BOOT_DS), %eax
	movl	%eax, %ds
	movl	%eax, %es
	movl	%eax, %ss
</code></pre>
<p>Remember that <code>__BOOT_DS</code> is <code>0x18</code> (the index of the data segment in the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a>). If <code>KEEP_SEGMENTS</code> is set, we jump to the nearest <code>1f</code> label or update segment registers with <code>__BOOT_DS</code> if they are not set. This is all pretty easy, but here's something to consider. If you've read the previous <a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-3.md">part</a>, you may remember that we already updated these segment registers right after we switched to <a href="https://en.wikipedia.org/wiki/Protected_mode">protected mode</a> in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/pmjump.S">arch/x86/boot/pmjump.S</a>. So why do we need to care about the values in the segment registers again? The answer is easy. The Linux kernel also has a 32-bit boot protocol and if a bootloader uses <em>that</em> to load the Linux kernel, all the code before the <code>startup_32</code> function will be missed. In this case, the <code>startup_32</code> function would be the first entry point to the Linux kernel right after the bootloader and there are no guarantees that the segment registers will be in a known state.</p>
<p>After we have checked the <code>KEEP_SEGMENTS</code> flag and set the segment registers to a correct value, the next step is to calculate the difference between where the kernel is compiled to run, and where we loaded it. Remember that <code>setup.ld.S</code> contains the following definition: <code>. = 0</code> at the start of the <code>.head.text</code> section. This means that the code in this section is compiled to run at the address <code>0</code>. We can see this in the output of <code>objdump</code>:</p>
<pre><code>arch/x86/boot/compressed/vmlinux:     file format elf64-x86-64


Disassembly of section .head.text:

0000000000000000 &lt;startup_32&gt;:
   0:   fc                      cld
   1:   f6 86 11 02 00 00 40    testb  $0x40,0x211(%rsi)
</code></pre>
<p>The <code>objdump</code> util tells us that the address of the <code>startup_32</code> function is <code>0</code> but that isn't so. We now need to know where we actually are. This is pretty simple to do in <a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a> because it supports <code>rip</code> relative addressing, but currently we are in <a href="https://en.wikipedia.org/wiki/Protected_mode">protected mode</a>. We will use a common pattern to find the address of the <code>startup_32</code> function. We need to define a label, make a call to it and pop the top of the stack to a register:</p>
<pre><code class="language-assembly">call label
label: pop %reg
</code></pre>
<p>After this, the register indicated by <code>%reg</code> will contain the address of <code>label</code>. Let's look at the code which uses this pattern to search for the <code>startup_32</code> function in the Linux kernel:</p>
<pre><code class="language-assembly">        leal	(BP_scratch+4)(%esi), %esp
        call	1f
1:      popl	%ebp
        subl	$1b, %ebp
</code></pre>
<p>As you remember from the previous part, the <code>esi</code> register contains the address of the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/include/uapi/asm/bootparam.h#L113">boot_params</a> structure which was filled before we moved to the protected mode. The <code>boot_params</code> structure contains a special field <code>scratch</code> with an offset of <code>0x1e4</code>. This four byte field is a temporary stack for the <code>call</code> instruction. We set <code>esp</code> to the address four bytes after the <code>BP_scratch</code> field of the <code>boot_params</code> structure. We add <code>4</code> bytes to the base of the <code>BP_scratch</code> field because, as just described, it will be a temporary stack and the stack grows from the top to bottom in the <code>x86_64</code> architecture. So our stack pointer will point to the top of the temporary stack. Next, we can see the pattern that I've described above. We make a call to the <code>1f</code> label and pop the top of the stack onto <code>ebp</code>. This works because <code>call</code> stores the return address of the current function on the top of the stack. We now have the address of the <code>1f</code> label and can now easily get the address of the <code>startup_32</code> function. We just need to subtract the address of the label from the address we got from the stack:</p>
<pre><code>startup_32 (0x0)     +-----------------------+
                     |                       |
                     |                       |
                     |                       |
                     |                       |
                     |                       |
                     |                       |
                     |                       |
                     |                       |
1f (0x0 + 1f offset) +-----------------------+ %ebp - real physical address
                     |                       |
                     |                       |
                     +-----------------------+
</code></pre>
<p>The <code>startup_32</code> function is linked to run at the address <code>0x0</code> and this means that <code>1f</code> has the address <code>0x0 + offset to 1f</code>, which is approximately <code>0x21</code> bytes. The <code>ebp</code> register contains the real physical address of the <code>1f</code> label. So, if we subtract <code>1f</code> from the <code>ebp</code> register, we will get the real physical address of the <code>startup_32</code> function. The Linux kernel <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">boot protocol</a> says the base of the protected mode kernel is <code>0x100000</code>. We can verify this with <a href="https://en.wikipedia.org/wiki/GNU_Debugger">gdb</a>. Let's start the debugger and add a breakpoint at the address of <code>1f</code>, which is <code>0x100021</code>. If this is correct we will see the value <code>0x100021</code> in the <code>ebp</code> register:</p>
<pre><code>$ gdb
(gdb)$ target remote :1234
Remote debugging using :1234
0x0000fff0 in ?? ()
(gdb)$ br *0x100022
Breakpoint 1 at 0x100022
(gdb)$ c
Continuing.

Breakpoint 1, 0x00100022 in ?? ()
(gdb)$ i r
eax            0x18	0x18
ecx            0x0	0x0
edx            0x0	0x0
ebx            0x0	0x0
esp            0x144a8	0x144a8
ebp            0x100021	0x100021
esi            0x142c0	0x142c0
edi            0x0	0x0
eip            0x100022	0x100022
eflags         0x46	[ PF ZF ]
cs             0x10	0x10
ss             0x18	0x18
ds             0x18	0x18
es             0x18	0x18
fs             0x18	0x18
gs             0x18	0x18
</code></pre>
<p>If we execute the next instruction, <code>subl $1b, %ebp</code>, we will see:</p>
<pre><code>(gdb) nexti
...
...
...
ebp            0x100000	0x100000
...
...
...
</code></pre>
<p>Ok, we've verified that the address of the <code>startup_32</code> function is <code>0x100000</code>. After we know the address of the <code>startup_32</code> label, we can prepare for the transition to <a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a>. Our next goal is to setup the stack and verify that the CPU supports long mode and <a href="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a>.</p>
<h2 id="stack-setup-and-cpu-verification"><a class="header" href="#stack-setup-and-cpu-verification">Stack setup and CPU verification</a></h2>
<p>We can't set up the stack until we know where in memory the <code>startup_32</code> label is. If we imagine the stack as an array, the stack pointer register <code>esp</code> must point to the end of it. Of course, we can define an array in our code, but we need to know its actual address to configure the stack pointer correctly. Let's look at the code:</p>
<pre><code class="language-assembly">	movl	$boot_stack_end, %eax
	addl	%ebp, %eax
	movl	%eax, %esp
</code></pre>
<p>The <code>boot_stack_end</code> label is also defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly source code file  and is located in the <a href="https://en.wikipedia.org/wiki/.bss">.bss</a> section:</p>
<pre><code class="language-assembly">	.bss
	.balign 4
boot_heap:
	.fill BOOT_HEAP_SIZE, 1, 0
boot_stack:
	.fill BOOT_STACK_SIZE, 1, 0
boot_stack_end:
</code></pre>
<p>First of all, we put the address of <code>boot_stack_end</code> into the <code>eax</code> register, so the <code>eax</code> register contains the address of <code>boot_stack_end</code> as it was linked, which is <code>0x0 + boot_stack_end</code>. To get the real address of <code>boot_stack_end</code>, we need to add the real address of the <code>startup_32</code> function. We've already found this address and put it into the <code>ebp</code> register. In the end, the  <code>eax</code> register will contain the real address of <code>boot_stack_end</code> and we just need to set the stack pointer to it.</p>
<p>After we have set up the stack, the next step is CPU verification. Since we are transitioning to <code>long mode</code>, we need to check that the CPU supports <code>long mode</code> and <code>SSE</code>. We will do this with a call to the <code>verify_cpu</code> function:</p>
<pre><code class="language-assembly">	call	verify_cpu
	testl	%eax, %eax
	jnz	no_longmode
</code></pre>
<p>This function is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/kernel/verify_cpu.S">arch/x86/kernel/verify_cpu.S</a> assembly file and just contains a couple of calls to the <a href="https://en.wikipedia.org/wiki/CPUID">cpuid</a> instruction. This instruction is used to get information about the processor. In our case, it checks for <code>long mode</code> and <code>SSE</code> support and sets the <code>eax</code> register to <code>0</code> on success and <code>1</code> on failure.</p>
<p>If the value of <code>eax</code> is not zero, we jump to the <code>no_longmode</code> label which just stops the CPU with the <code>hlt</code> instruction while no hardware interrupt can happen:</p>
<pre><code class="language-assembly">no_longmode:
1:
	hlt
	jmp     1b
</code></pre>
<p>If the value of the <code>eax</code> register is zero, everything is ok and we can continue.</p>
<h2 id="calculate-the-relocation-address"><a class="header" href="#calculate-the-relocation-address">Calculate the relocation address</a></h2>
<p>The next step is to calculate the relocation address for decompression if needed. First, we need to know what it means for a kernel to be <code>relocatable</code>. We already know that the base address of the 32-bit entry point of the Linux kernel is <code>0x100000</code>, but that is a 32-bit entry point. The default base address of the Linux kernel is determined by the value of the <code>CONFIG_PHYSICAL_START</code> kernel configuration option. Its default value is <code>0x1000000</code> or <code>16 MB</code>. The main problem here is that if the Linux kernel crashes, a kernel developer must have a <code>rescue kernel</code> for <a href="https://www.kernel.org/doc/Documentation/kdump/kdump.txt">kdump</a> which is configured to load from a different address. The Linux kernel provides a special configuration option to solve this problem: <code>CONFIG_RELOCATABLE</code>. As we can read in the documentation of the Linux kernel:</p>
<pre><code>This builds a kernel image that retains relocation information
so it can be loaded someplace besides the default 1MB.

Note: If CONFIG_RELOCATABLE=y, then the kernel runs from the address
it has been loaded at and the compile time physical address
(CONFIG_PHYSICAL_START) is used as the minimum location.
</code></pre>
<p>Now that we know where to start, let's get to it.</p>
<h2 id="reload-the-segments-if-needed-1"><a class="header" href="#reload-the-segments-if-needed-1">Reload the segments if needed</a></h2>
<p>As indicated above, we start in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly source code file. We first see the definition of a special section attribute before the definition of the <code>startup_32</code> function:</p>
<pre><code class="language-assembly">    __HEAD
    .code32
ENTRY(startup_32)
</code></pre>
<p><code>__HEAD</code> is a macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init.h">include/linux/init.h</a> header file and expands to the definition of the following section:</p>
<pre><code class="language-C">#define __HEAD		.section	&quot;.head.text&quot;,&quot;ax&quot;
</code></pre>
<p>Here, <code>.head.text</code> is the name of the section and <code>ax</code> is a set of flags. In our case, these flags show us that this section is <a href="https://en.wikipedia.org/wiki/Executable">executable</a>. In simple terms, this means that a Linux kernel with this option set can be booted from different addresses. Technically, this is done by compiling the decompressor as <a href="https://en.wikipedia.org/wiki/Position-independent_code">position independent code</a>. If we look at <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/Makefile">arch/x86/boot/compressed/Makefile</a>, we can see that the decompressor is indeed compiled with the <code>-fPIC</code> flag:</p>
<pre><code class="language-Makefile">KBUILD_CFLAGS += -fno-strict-aliasing -fPIC
</code></pre>
<p>When we are using position-independent code an address is obtained by adding the address field of the instruction to the value of the program counter. We can load code which uses such addressing from any address. That's why we had to get the real physical address of <code>startup_32</code>. Now let's get back to the Linux kernel code. Our current goal is to calculate an address where we can relocate the kernel for decompression. The calculation of this address depends on the <code>CONFIG_RELOCATABLE</code> kernel configuration option. Let's look at the code:</p>
<pre><code class="language-assembly">#ifdef CONFIG_RELOCATABLE
	movl	%ebp, %ebx
	movl	BP_kernel_alignment(%esi), %eax
	decl	%eax
	addl	%eax, %ebx
	notl	%eax
	andl	%eax, %ebx
	cmpl	$LOAD_PHYSICAL_ADDR, %ebx
	jge	1f
#endif
	movl	$LOAD_PHYSICAL_ADDR, %ebx
</code></pre>
<p>Remember that the value of the <code>ebp</code> register is the physical address of the <code>startup_32</code> label. If the <code>CONFIG_RELOCATABLE</code> kernel configuration option is enabled during kernel configuration, we put this address in the <code>ebx</code> register, align it to a multiple of <code>2MB</code> and compare it with the result of the <code>LOAD_PHYSICAL_ADDR</code> macro. <code>LOAD_PHYSICAL_ADDR</code> is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/include/asm/boot.h">arch/x86/include/asm/boot.h</a> header file and it looks like this:</p>
<pre><code class="language-C">#define LOAD_PHYSICAL_ADDR ((CONFIG_PHYSICAL_START \
				+ (CONFIG_PHYSICAL_ALIGN - 1)) \
				&amp; ~(CONFIG_PHYSICAL_ALIGN - 1))
</code></pre>
<p>As we can see it just expands to the aligned <code>CONFIG_PHYSICAL_ALIGN</code> value which represents the physical address where the kernel will be loaded. After comparing <code>LOAD_PHYSICAL_ADDR</code> and the value of the <code>ebx</code> register, we add the offset from <code>startup_32</code> where we will decompress the compressed kernel image. If the <code>CONFIG_RELOCATABLE</code> option is not enabled during kernel configuration, we just add <code>z_extract_offset</code> to the default address where the kernel is loaded.</p>
<p>After all of these calculations, <code>ebp</code> will contain the address where we loaded the kernel and <code>ebx</code> will contain the address where the decompressed kernel will be relocated. But that is not the end. The compressed kernel image should be moved to the end of the decompression buffer to simplify calculations regarding where the kernel will be located later. For this:</p>
<pre><code class="language-assembly">1:
    movl	BP_init_size(%esi), %eax
    subl	$_end, %eax
    addl	%eax, %ebx
</code></pre>
<p>we put the value from the <code>boot_params.BP_init_size</code> field (or the kernel setup header value from <code>hdr.init_size</code>) in the <code>eax</code> register. The <code>BP_init_size</code> field contains the larger of the compressed and uncompressed <a href="https://en.wikipedia.org/wiki/Vmlinux">vmlinux</a> sizes. Next we subtract the address of the <code>_end</code> symbol from this value and add the result of the subtraction to the <code>ebx</code> register which will store the base address for kernel decompression.</p>
<h2 id="preparation-before-entering-long-mode"><a class="header" href="#preparation-before-entering-long-mode">Preparation before entering long mode</a></h2>
<p>After we get the address to relocate the compressed kernel image to, we need to do one last step before we can transition to 64-bit mode. First, we need to update the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a> with 64-bit segments because a relocatable kernel is runnable at any address below 512GB:</p>
<pre><code class="language-assembly">	addl	%ebp, gdt+2(%ebp)
	lgdt	gdt(%ebp)
</code></pre>
<p>Here we adjust the base address of the Global Descriptor table to the address where we actually loaded the kernel and load the <code>Global Descriptor Table</code> with the <code>lgdt</code> instruction.</p>
<p>To understand the magic with <code>gdt</code> offsets we need to look at the definition of the <code>Global Descriptor Table</code>. We can find its definition in the same source code <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">file</a>:</p>
<pre><code class="language-assembly">	.data
gdt64:
	.word	gdt_end - gdt
	.long	0
	.word	0
	.quad   0
gdt:
	.word	gdt_end - gdt
	.long	gdt
	.word	0
	.quad	0x00cf9a000000ffff	/* __KERNEL32_CS */
	.quad	0x00af9a000000ffff	/* __KERNEL_CS */
	.quad	0x00cf92000000ffff	/* __KERNEL_DS */
	.quad	0x0080890000000000	/* TS descriptor */
	.quad   0x0000000000000000	/* TS continued */
gdt_end:
</code></pre>
<p>We can see that it is located in the <code>.data</code> section and contains five descriptors: the first is a <code>32-bit</code> descriptor for the kernel code segment, a <code>64-bit</code> kernel segment, a kernel data segment and two task descriptors.</p>
<p>We already loaded the <code>Global Descriptor Table</code> in the previous <a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-3.md">part</a>, and now we're doing almost the same here, but we set descriptors to use <code>CS.L = 1</code> and <code>CS.D = 0</code> for execution in <code>64</code> bit mode. As we can see, the definition of the <code>gdt</code> starts with a two byte value: <code>gdt_end - gdt</code> which represents the address of the last byte in the <code>gdt</code> table or the table limit. The next four bytes contain the base address of the <code>gdt</code>.</p>
<p>After we have loaded the <code>Global Descriptor Table</code> with the <code>lgdt</code> instruction, we must enable <a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">PAE</a> by putting the value of the <code>cr4</code> register into <code>eax</code>, setting the 5th bit and loading it back into <code>cr4</code>:</p>
<pre><code class="language-assembly">	movl	%cr4, %eax
	orl	$X86_CR4_PAE, %eax
	movl	%eax, %cr4
</code></pre>
<p>Now we are almost finished with the preparations needed to move into 64-bit mode. The last step is to build page tables, but before that, here is some information about long mode.</p>
<h2 id="long-mode"><a class="header" href="#long-mode">Long mode</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Long_mode">Long mode</a> is the native mode for <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> processors. First, let's look at some differences between <code>x86_64</code> and <code>x86</code>.</p>
<p><code>64-bit</code> mode provides the following features:</p>
<ul>
<li>8 new general purpose registers from <code>r8</code> to <code>r15</code></li>
<li>All general purpose registers are 64-bit now</li>
<li>A 64-bit instruction pointer - <code>RIP</code></li>
<li>A new operating mode - Long mode;</li>
<li>64-Bit Addresses and Operands;</li>
<li>RIP Relative Addressing (we will see an example of this in the coming parts).</li>
</ul>
<p>Long mode is an extension of the legacy protected mode. It consists of two sub-modes:</p>
<ul>
<li>64-bit mode;</li>
<li>compatibility mode.</li>
</ul>
<p>To switch into <code>64-bit</code> mode we need to do the following things:</p>
<ul>
<li>Enable <a href="https://en.wikipedia.org/wiki/Physical_Address_Extension">PAE</a>;</li>
<li>Build page tables and load the address of the top level page table into the <code>cr3</code> register;</li>
<li>Enable <code>EFER.LME</code>;</li>
<li>Enable paging.</li>
</ul>
<p>We already enabled <code>PAE</code> by setting the <code>PAE</code> bit in the <code>cr4</code> control register. Our next goal is to build the structure for <a href="https://en.wikipedia.org/wiki/Paging">paging</a>. We will discuss this in the next paragraph.</p>
<h2 id="early-page-table-initialization"><a class="header" href="#early-page-table-initialization">Early page table initialization</a></h2>
<p>We already know that before we can move into <code>64-bit</code> mode, we need to build page tables. Let's look at how the early <code>4G</code> boot page tables are built.</p>
<p><strong>NOTE: I will not describe the theory of virtual memory here. If you want to know more about virtual memory, check out the links at the end of this part.</strong></p>
<p>The Linux kernel uses <code>4-level</code> paging, and we generally build 6 page tables:</p>
<ul>
<li>One <code>PML4</code> or <code>Page Map Level 4</code> table with one entry;</li>
<li>One <code>PDP</code> or <code>Page Directory Pointer</code> table with four entries;</li>
<li>Four Page Directory tables with a total of <code>2048</code> entries.</li>
</ul>
<p>Let's look at how this is implemented. First, we clear the buffer for the page tables in memory. Every table is <code>4096</code> bytes, so we need clear a <code>24</code> kilobyte buffer:</p>
<pre><code class="language-assembly">	leal	pgtable(%ebx), %edi
	xorl	%eax, %eax
	movl	$(BOOT_INIT_PGT_SIZE/4), %ecx
	rep	stosl
</code></pre>
<p>We put the address of <code>pgtable</code> with an offset of <code>ebx</code> (remember that <code>ebx</code> points to the location in memory where the kernel will be decompressed later) into the <code>edi</code> register, clear the <code>eax</code> register and set the <code>ecx</code> register to <code>6144</code>.</p>
<p>The <code>rep stosl</code> instruction will write the value of <code>eax</code> to the memory location where <code>edi</code> points to, increment <code>edi</code> by <code>4</code>, and decrement <code>ecx</code> by <code>1</code>. This operation will be repeated while the value of the <code>ecx</code> register is greater than zero. That's why we put <code>6144</code> or <code>BOOT_INIT_PGT_SIZE/4</code> in <code>ecx</code>.</p>
<p><code>pgtable</code> is defined at the end of the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly file:</p>
<pre><code class="language-assembly">	.section &quot;.pgtable&quot;,&quot;a&quot;,@nobits
	.balign 4096
pgtable:
	.fill BOOT_PGT_SIZE, 1, 0
</code></pre>
<p>As we can see, it is located in the <code>.pgtable</code> section and its size depends on the <code>CONFIG_X86_VERBOSE_BOOTUP</code> kernel configuration option:</p>
<pre><code class="language-C">#  ifdef CONFIG_X86_VERBOSE_BOOTUP
#   define BOOT_PGT_SIZE	(19*4096)
#  else /* !CONFIG_X86_VERBOSE_BOOTUP */
#   define BOOT_PGT_SIZE	(17*4096)
#  endif
# else /* !CONFIG_RANDOMIZE_BASE */
#  define BOOT_PGT_SIZE		BOOT_INIT_PGT_SIZE
# endif
</code></pre>
<p>After we have a buffer for the <code>pgtable</code> structure, we can start to build the top level page table - <code>PML4</code> - with:</p>
<pre><code class="language-assembly">	leal	pgtable + 0(%ebx), %edi
	leal	0x1007 (%edi), %eax
	movl	%eax, 0(%edi)
</code></pre>
<p>Here again, we put the address of <code>pgtable</code> relative to <code>ebx</code> or in other words relative to address of <code>startup_32</code> in the <code>edi</code> register. Next, we put this address with an offset of <code>0x1007</code> into the <code>eax</code> register. <code>0x1007</code> is the result of adding the size of the <code>PML4</code> table which is <code>4096</code> or <code>0x1000</code> bytes with <code>7</code>. The <code>7</code> here represents the flags associated with the <code>PML4</code> entry. In our case, these flags are <code>PRESENT+RW+USER</code>. In the end, we just write the address of the first <code>PDP</code> entry to the <code>PML4</code> table.</p>
<p>In the next step we will build four <code>Page Directory</code> entries in the <code>Page Directory Pointer</code> table with the same <code>PRESENT+RW+USE</code> flags:</p>
<pre><code class="language-assembly">	leal	pgtable + 0x1000(%ebx), %edi
	leal	0x1007(%edi), %eax
	movl	$4, %ecx
1:  movl	%eax, 0x00(%edi)
	addl	$0x00001000, %eax
	addl	$8, %edi
	decl	%ecx
	jnz	1b
</code></pre>
<p>We set <code>edi</code> to the base address of the page directory pointer which is at an offset of <code>4096</code> or <code>0x1000</code> bytes from the <code>pgtable</code> table and <code>eax</code> to the address of the first page directory pointer entry. We also set <code>ecx</code> to <code>4</code> to act as a counter in the following loop and write the address of the first page directory pointer table entry to the <code>edi</code> register. After this, <code>edi</code> will contain the address of the first page directory pointer entry with flags <code>0x7</code>. Next we calculate the address of the following page directory pointer entries — each entry is <code>8</code> bytes — and write their addresses to <code>eax</code>. The last step in building the paging structure is to build the <code>2048</code> page table entries with <code>2-MByte</code> pages:</p>
<pre><code class="language-assembly">	leal	pgtable + 0x2000(%ebx), %edi
	movl	$0x00000183, %eax
	movl	$2048, %ecx
1:  movl	%eax, 0(%edi)
	addl	$0x00200000, %eax
	addl	$8, %edi
	decl	%ecx
	jnz	1b
</code></pre>
<p>Here we do almost the same things that we did in the previous example, all entries are associated with these flags - <code>$0x00000183</code> - <code>PRESENT + WRITE + MBZ</code>. In the end, we will have a page table with <code>2048</code> <code>2-MByte</code> pages, which represents a 4 Gigabyte block of memory:</p>
<pre><code class="language-python">&gt;&gt;&gt; 2048 * 0x00200000
4294967296
</code></pre>
<p>Since we've just finished building our early page table structure which maps <code>4</code> gigabytes of memory, we can put the address of the high-level page table - <code>PML4</code> - into the <code>cr3</code> control register:</p>
<pre><code class="language-assembly">	leal	pgtable(%ebx), %eax
	movl	%eax, %cr3
</code></pre>
<p>That's all. We are now prepared to transition to long mode.</p>
<h2 id="the-transition-to-64-bit-mode-1"><a class="header" href="#the-transition-to-64-bit-mode-1">The transition to 64-bit mode</a></h2>
<p>First of all we need to set the <code>EFER.LME</code> flag in the <a href="http://en.wikipedia.org/wiki/Model-specific_register">MSR</a> to <code>0xC0000080</code>:</p>
<pre><code class="language-assembly">	movl	$MSR_EFER, %ecx
	rdmsr
	btsl	$_EFER_LME, %eax
	wrmsr
</code></pre>
<p>Here we put the <code>MSR_EFER</code> flag (which is defined in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/include/asm/msr-index.h">arch/x86/include/asm/msr-index.h</a>) in the <code>ecx</code> register and execute the <code>rdmsr</code> instruction which reads the <a href="http://en.wikipedia.org/wiki/Model-specific_register">MSR</a> register. After <code>rdmsr</code> executes, the resulting data is stored in <code>edx:eax</code> according to the <code>MSR</code> register specified in <code>ecx</code>. We check the current <code>EFER_LME</code> bit, transfer it into the carry flag and update the bit, all with the <code>btsl</code> instruction. Then we write data from <code>edx:eax</code> back to the <code>MSR</code> register with the <code>wrmsr</code> instruction.</p>
<p>In the next step, we push the address of the kernel segment code to the stack (we defined it in the GDT) and put the address of the <code>startup_64</code> routine in <code>eax</code>.</p>
<pre><code class="language-assembly">	pushl	$__KERNEL_CS
	leal	startup_64(%ebp), %eax
</code></pre>
<p>After this we push <code>eax</code> to the stack and enable paging by setting the <code>PG</code> and <code>PE</code> bits in the <code>cr0</code> register:</p>
<pre><code class="language-assembly">	pushl	%eax
    movl	$(X86_CR0_PG | X86_CR0_PE), %eax
	movl	%eax, %cr0
</code></pre>
<p>We then execute the <code>lret</code> instruction:</p>
<pre><code class="language-assembly">lret
</code></pre>
<p>Remember that we pushed the address of the <code>startup_64</code> function to the stack in the previous step. The CPU extracts <code>startup_64</code>'s address from the stack and jumps there.</p>
<p>After all of these steps we're finally in 64-bit mode:</p>
<pre><code class="language-assembly">	.code64
	.org 0x200
ENTRY(startup_64)
....
....
....
</code></pre>
<p>That's all!</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This is the end of the fourth part of the Linux kernel booting process. If you have any questions or suggestions, ping me on twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p>In the next part, we will learn about many things, including how kernel decompression works.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you find any mistakes please send a PR to <a href="https://github.com/0xAX/linux-internals">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Protected_mode">Protected mode</a></li>
<li><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel® 64 and IA-32 Architectures Software Developer’s Manual 3A</a></li>
<li><a href="http://www.eecs.umich.edu/courses/eecs373/readings/Linker.pdf">GNU linker</a></li>
<li><a href="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a></li>
<li><a href="http://en.wikipedia.org/wiki/Paging">Paging</a></li>
<li><a href="http://en.wikipedia.org/wiki/Model-specific_register">Model specific register</a></li>
<li><a href="http://www.chemie.fu-berlin.de/chemnet/use/info/gas/gas_7.html">.fill instruction</a></li>
<li><a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-3.md">Previous part</a></li>
<li><a href="http://wiki.osdev.org/Paging">Paging on osdev.org</a></li>
<li><a href="https://www.cs.rutgers.edu/%7Epxk/416/notes/09a-paging.html">Paging Systems</a></li>
<li><a href="http://www.cirosantilli.com/x86-paging/">x86 Paging Tutorial</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Booting/linux-bootstrap-3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Booting/linux-bootstrap-5.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Booting/linux-bootstrap-3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Booting/linux-bootstrap-5.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
