<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linux Insides</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="kernel-boot-process"><a class="header" href="#kernel-boot-process">Kernel Boot Process</a></h1>
<p>This chapter describes the Linux kernel boot process. Here you will see a series of posts which describes the full cycle of the kernel loading process:</p>
<ul>
<li><a href="Booting/linux-bootstrap-1.html">From the bootloader to kernel</a> - describes all stages from turning on the computer to running the first instruction of the kernel.</li>
<li><a href="Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a> - describes first steps in the kernel setup code. You will see heap initialization, query of different parameters like EDD, IST and etc...</li>
<li><a href="Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a> - describes video mode initialization in the kernel setup code and transition to protected mode.</li>
<li><a href="Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a> - describes preparation for transition into 64-bit mode and details of transition.</li>
<li><a href="Booting/linux-bootstrap-5.html">Kernel Decompression</a> - describes preparation before kernel decompression and details of direct decompression.</li>
<li><a href="Booting/linux-bootstrap-6.html">Kernel load address randomization</a> - describes randomization of the Linux kernel load address.</li>
</ul>
<p>This chapter coincides with <code>Linux kernel v4.17</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-booting-process-part-1"><a class="header" href="#kernel-booting-process-part-1">Kernel booting process. Part 1.</a></h1>
<h2 id="from-the-bootloader-to-the-kernel"><a class="header" href="#from-the-bootloader-to-the-kernel">From the bootloader to the kernel</a></h2>
<p>If you read my previous <a href="https://0xax.github.io/categories/assembler/">blog posts</a>, you might have noticed that I  have been involved with low-level programming for some time. I wrote some posts about assembly programming for <code>x86_64</code> Linux and, at the same time, started to dive into the Linux kernel source code.</p>
<p>I have a great interest in understanding how low-level things work, how programs run on my computer, how they are located in memory, how the kernel manages processes and memory, how the network stack works at a low level, and many many other things. So, I decided to write yet another series of posts about the Linux kernel for the <strong>x86_64</strong> architecture.</p>
<p>Note that I'm not a professional kernel hacker and I don't write code for the kernel at work. It's just a hobby. I just like low-level stuff, and it is interesting for me to see how these things work. So if you notice anything confusing, or if you have any questions/remarks, ping me on Twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>. I appreciate it.</p>
<p>All posts will also be accessible at <a href="https://github.com/0xAX/linux-insides">github repo</a> and, if you find something wrong with my English or the post content, feel free to send a pull request.</p>
<p><em>Note that this isn't official documentation, just learning and sharing knowledge.</em></p>
<p><strong>Required knowledge</strong></p>
<ul>
<li>Understanding C code</li>
<li>Understanding assembly code (AT&amp;T syntax)</li>
</ul>
<p>Anyway, if you're just starting to learn such tools, I will try to explain some parts during this and the following posts. Alright, this is the end of the simple introduction. Let's start to dive into the Linux kernel and low-level stuff!</p>
<p>I started writing these posts at the time of the <code>3.18</code> Linux kernel, and many things have changed since that time. If there are changes, I will update the posts accordingly.</p>
<h2 id="the-magical-power-button-what-happens-next"><a class="header" href="#the-magical-power-button-what-happens-next">The Magical Power Button, What happens next?</a></h2>
<p>Although this is a series of posts about the Linux kernel, we won't start directly from the kernel code. As soon as you press the magical power button on your laptop or desktop computer, it starts working. The motherboard sends a signal to the <a href="https://en.wikipedia.org/wiki/Power_supply">power supply</a> device. After receiving the signal, the power supply provides the proper amount of electricity to the computer. Once the motherboard receives the <a href="https://en.wikipedia.org/wiki/Power_good_signal">power good signal</a>, it tries to start the CPU. The CPU resets all leftover data in its registers and sets predefined values for each of them.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Intel_80386">80386</a> and later CPUs define the following predefined data in CPU registers after the computer resets:</p>
<pre><code>IP          0xfff0
CS selector 0xf000
CS base     0xffff0000
</code></pre>
<p>The processor starts working in <a href="https://en.wikipedia.org/wiki/Real_mode">real mode</a>. Let's back up a little and try to understand <a href="https://en.wikipedia.org/wiki/Memory_segmentation">memory segmentation</a> in this mode. Real mode is supported on all x86-compatible processors, from the <a href="https://en.wikipedia.org/wiki/Intel_8086">8086</a> CPU all the way to the modern Intel 64-bit CPUs. The <code>8086</code> processor has a 20-bit address bus, which means that it could work with a <code>0-0xFFFFF</code> or <code>1 megabyte</code> address space. But it only has <code>16-bit</code> registers, which have a maximum address of <code>2^16 - 1</code> or <code>0xffff</code> (64 kilobytes).</p>
<p><a href="https://en.wikipedia.org/wiki/Memory_segmentation">Memory segmentation</a> is used to make use of all the address space available. All memory is divided into small, fixed-size segments of <code>65536</code> bytes (64 KB). Since we cannot address memory above <code>64 KB</code> with 16-bit registers, an alternate method was devised.</p>
<p>An address consists of two parts: a segment selector, which has a base address; and an offset from this base address. In real mode, the associated base address of a segment selector is <code>Segment Selector * 16</code>. Thus, to get a physical address in memory, we need to multiply the segment selector part by <code>16</code> and add the offset to it:</p>
<pre><code>PhysicalAddress = Segment Selector * 16 + Offset
</code></pre>
<p>For example, if <code>CS:IP</code> is <code>0x2000:0x0010</code>, then the corresponding physical address will be:</p>
<pre><code class="language-python">&gt;&gt;&gt; hex((0x2000 &lt;&lt; 4) + 0x0010)
'0x20010'
</code></pre>
<p>But, if we take the largest segment selector and offset, <code>0xffff:0xffff</code>, then the resulting address will be:</p>
<pre><code class="language-python">&gt;&gt;&gt; hex((0xffff &lt;&lt; 4) + 0xffff)
'0x10ffef'
</code></pre>
<p>which is <code>65520</code> bytes past the first megabyte. Since only one megabyte is accessible in real mode, <code>0x10ffef</code> becomes <code>0x00ffef</code> with the <a href="https://en.wikipedia.org/wiki/A20_line">A20 line</a> disabled.</p>
<p>Ok, now we know a little bit about real mode and its memory addressing. Let's get back to discussing register values after reset.</p>
<p>The <code>CS</code> register consists of two parts: the visible segment selector and the hidden base address.  In real-address mode, the base address is normally formed by shifting the 16-bit segment selector value 4 bits to the left to produce a 20-bit base address. However, during a hardware reset the segment selector in the CS register is loaded with <code>0xf000</code> and the base address is loaded with <code>0xffff0000</code>. The processor uses this special base address until <code>CS</code> changes.</p>
<p>The starting address is formed by adding the base address to the value in the EIP register:</p>
<pre><code class="language-python">&gt;&gt;&gt; 0xffff0000 + 0xfff0
'0xfffffff0'
</code></pre>
<p>We get <code>0xfffffff0</code>, which is 16 bytes below 4GB. This point is called the <a href="https://en.wikipedia.org/wiki/Reset_vector">reset vector</a>. It's the memory location at which the CPU expects to find the first instruction to execute after reset. It contains a <a href="https://en.wikipedia.org/wiki/JMP_%28x86_instruction%29">jump</a> (<code>jmp</code>) instruction that usually points to the <a href="https://en.wikipedia.org/wiki/BIOS">BIOS</a> (Basic Input/Output System) entry point. For example, if we look in the <a href="https://www.coreboot.org/">coreboot</a> source code (<a href="https://review.coreboot.org/plugins/gitiles/coreboot/+/refs/heads/4.11_branch/src/cpu/x86/16bit/reset16.inc">src/cpu/x86/16bit/reset16.inc</a>), we see:</p>
<pre><code class="language-assembly">    .section &quot;.reset&quot;, &quot;ax&quot;, %progbits
    .code16
.globl	_start
_start:
    .byte  0xe9
    .int   _start16bit - ( . + 2 )
    ...
</code></pre>
<p>Here we can see the <code>jmp</code> instruction <a href="http://ref.x86asm.net/coder32.html#xE9">opcode</a>, which is <code>0xe9</code>, and its destination address at <code>_start16bit - ( . + 2)</code>.</p>
<p>We also see that the <code>reset</code> section is <code>16</code> bytes and is compiled to start from the address <code>0xfffffff0</code> (<a href="https://review.coreboot.org/plugins/gitiles/coreboot/+/refs/heads/4.11_branch/src/cpu/x86/16bit/reset16.ld">src/cpu/x86/16bit/reset16.ld</a>):</p>
<pre><code>SECTIONS {
    /* Trigger an error if I have an unusable start address */
    _bogus = ASSERT(_start16bit &gt;= 0xffff0000, &quot;_start16bit too low. Please report.&quot;);
    _ROMTOP = 0xfffffff0;
    . = _ROMTOP;
    .reset . : {
        *(.reset);
        . = 15;
        BYTE(0x00);
    }
}
</code></pre>
<p>Now the BIOS starts. After initializing and checking the hardware, the BIOS needs to find a bootable device. A boot order is stored in the BIOS configuration, controlling which devices the BIOS attempts to boot from. When attempting to boot from a hard drive, the BIOS tries to find a boot sector. On hard drives partitioned with an <a href="https://en.wikipedia.org/wiki/Master_boot_record">MBR partition layout</a>, the boot sector is stored in the first <code>446</code> bytes of the first sector, where each sector is <code>512</code> bytes. The final two bytes of the first sector are <code>0x55</code> and <code>0xaa</code>, which designates to the BIOS that this device is bootable. Once the BIOS finds the boot sector, it copies it into a fixed memory location at 0x7c00, jumps to there and start executing it.</p>
<p>For example:</p>
<pre><code class="language-assembly">;
; Note: this example is written in Intel Assembly syntax
;
[BITS 16]

boot:
    mov al, '!'
    mov ah, 0x0e
    mov bh, 0x00
    mov bl, 0x07

    int 0x10
    jmp $

times 510-($-$$) db 0

db 0x55
db 0xaa
</code></pre>
<p>Build and run this with:</p>
<pre><code>nasm -f bin boot.nasm &amp;&amp; qemu-system-x86_64 boot
</code></pre>
<p>This will instruct <a href="https://www.qemu.org/">QEMU</a> to use the <code>boot</code> binary that we just built as a disk image. Since the binary generated by the assembly code above fulfills the requirements of the boot sector (we end it with the magic sequence), QEMU will treat the binary as the master boot record (MBR) of a disk image. Note that when providing a boot binary image to QEMU, setting the origin to 0x7c00 (using <code>[ORG  0x7c00]</code>)
is unneeded.</p>
<p>You will see:</p>
<p><img src="Booting/images/simple_bootloader.png" alt="Simple bootloader which prints only !" /></p>
<p>In this example, we can see that the code will be executed in <code>16-bit</code> real mode. After starting, it calls the <a href="http://www.ctyme.com/intr/rb-0106.htm">0x10</a> interrupt, which just prints the <code>!</code> symbol. The times directive will pad that number of bytes up to 510th byte with zeros and finishes with the two magic bytes <code>0xaa</code> and <code>0x55</code>.</p>
<p>You can see a binary dump of this using the <code>objdump</code> utility:</p>
<pre><code>nasm -f bin boot.nasm
objdump -D -b binary -mi386 -Maddr16,data16,intel boot
</code></pre>
<p>A real-world boot sector has code for continuing the boot process and a partition table instead of a bunch of 0's and an exclamation mark. :) From this point onwards, the BIOS hands control over to the bootloader.</p>
<p><strong>NOTE</strong>: As explained above, the CPU is in real mode. In real mode, calculating the physical address in memory is done as follows:</p>
<pre><code>PhysicalAddress = Segment Selector * 16 + Offset
</code></pre>
<p>just as explained above. We have only 16-bit general purpose registers, which has a maximum value of <code>0xffff</code>, so if we take the largest values the result will be:</p>
<pre><code class="language-python">&gt;&gt;&gt; hex((0xffff * 16) + 0xffff)
'0x10ffef'
</code></pre>
<p>where <code>0x10ffef</code> is equal to <code>(1MB + 64KB - 16B) - 1</code>. An <a href="https://en.wikipedia.org/wiki/Intel_8086">8086</a> processor (which was the first processor with real mode), in contrast, has a 20-bit address line. Since <code>2^20 = 1048576</code> is 1MB and <code>2^20 - 1</code> is the maximum address that could be used, this means that the actual available memory is 1MB.</p>
<p>In general, real mode's memory map is as follows:</p>
<pre><code>0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table
0x00000400 - 0x000004FF - BIOS Data Area
0x00000500 - 0x00007BFF - Unused
0x00007C00 - 0x00007DFF - Our Bootloader
0x00007E00 - 0x0009FFFF - Unused
0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory
0x000B0000 - 0x000B7777 - Monochrome Video Memory
0x000B8000 - 0x000BFFFF - Color Video Memory
0x000C0000 - 0x000C7FFF - Video ROM BIOS
0x000C8000 - 0x000EFFFF - BIOS Shadow Area
0x000F0000 - 0x000FFFFF - System BIOS
</code></pre>
<p>At the beginning of this post, I wrote that the first instruction executed by the CPU is located at address <code>0xFFFFFFF0</code>, which is much larger than <code>0xFFFFF</code> (1MB). How can the CPU access this address in real mode? The answer is in the <a href="https://www.coreboot.org/Developer_Manual/Memory_map">coreboot</a> documentation:</p>
<pre><code>0xFFFE_0000 - 0xFFFF_FFFF: 128 kilobyte ROM mapped into address space
</code></pre>
<p>At the start of execution, the BIOS is not in RAM, but in ROM.</p>
<h2 id="bootloader"><a class="header" href="#bootloader">Bootloader</a></h2>
<p>There are a number of bootloaders that can boot Linux, such as <a href="https://www.gnu.org/software/grub/">GRUB 2</a> and <a href="http://www.syslinux.org/wiki/index.php/The_Syslinux_Project">syslinux</a>. The Linux kernel has a <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/boot.txt">Boot protocol</a> which specifies the requirements for a bootloader to implement Linux support. This example will describe GRUB 2.</p>
<p>Continuing from before, now that the BIOS has chosen a boot device and transferred control to the boot sector code, execution starts from <a href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/boot.S;hb=HEAD">boot.img</a>. Its code is very simple, due to the limited amount of space available. It contains a pointer which is used to jump to the location of GRUB 2's core image. The core image begins with <a href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/boot/i386/pc/diskboot.S;hb=HEAD">diskboot.img</a>, which is usually stored immediately after the first sector in the unused space before the first partition. The above code loads the rest of the core image, which contains GRUB 2's kernel and drivers for handling filesystems, into memory. After loading the rest of the core image, it executes the <a href="http://git.savannah.gnu.org/gitweb/?p=grub.git;a=blob;f=grub-core/kern/main.c">grub_main</a> function.</p>
<p>The <code>grub_main</code> function initializes the console, gets the base address for modules, sets the root device, loads/parses the grub configuration file, loads modules, etc. At the end of execution, the <code>grub_main</code> function moves grub to normal mode. The <code>grub_normal_execute</code> function (from the <code>grub-core/normal/main.c</code> source code file) completes the final preparations and shows a menu to select an operating system. When we select one of the grub menu entries, the <code>grub_menu_execute_entry</code> function runs, executing the grub <code>boot</code> command and booting the selected operating system.</p>
<p>As we can read in the kernel boot protocol, the bootloader must read and fill some fields of the kernel setup header, which starts at offset <code>0x01f1</code> from the kernel setup code. You may look at the boot <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/setup.ld">linker script</a> to confirm the value of this offset. The kernel header <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S">arch/x86/boot/header.S</a> starts from:</p>
<pre><code class="language-assembly">    .globl hdr
hdr:
    setup_sects: .byte 0
    root_flags:  .word ROOT_RDONLY
    syssize:     .long 0
    ram_size:    .word 0
    vid_mode:    .word SVGA_MODE
    root_dev:    .word 0
    boot_flag:   .word 0xAA55
</code></pre>
<p>The bootloader must fill this and the rest of the headers (which are only marked as being type <code>write</code> in the Linux boot protocol, such as in <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/boot.txt#L354">this example</a>) with values either received from the command line or calculated during booting. (We will not go over full descriptions and explanations for all fields of the kernel setup header for now, but we shall do so when discussing how the kernel uses them. You can find a description of all fields in the <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/boot.txt#L156">boot protocol</a>.)</p>
<p>As we can see in the kernel boot protocol, memory will be mapped as follows after loading the kernel:</p>
<pre><code class="language-shell">         | Protected-mode kernel  |
100000   +------------------------+
         | I/O memory hole        |
0A0000   +------------------------+
         | Reserved for BIOS      | Leave as much as possible unused
         ~                        ~
         | Command line           | (Can also be below the X+10000 mark)
X+10000  +------------------------+
         | Stack/heap             | For use by the kernel real-mode code.
X+08000  +------------------------+
         | Kernel setup           | The kernel real-mode code.
         | Kernel boot sector     | The kernel legacy boot sector.
       X +------------------------+
         | Boot loader            | &lt;- Boot sector entry point 0x7C00
001000   +------------------------+
         | Reserved for MBR/BIOS  |
000800   +------------------------+
         | Typically used by MBR  |
000600   +------------------------+
         | BIOS use only          |
000000   +------------------------+

</code></pre>
<p>When the bootloader transfers control to the kernel, it starts at:</p>
<pre><code>X + sizeof(KernelBootSector) + 1
</code></pre>
<p>where <code>X</code> is the address of the kernel boot sector being loaded. In my case, <code>X</code> is <code>0x10000</code>, as we can see in a memory dump:</p>
<p><img src="Booting/images/kernel_first_address.png" alt="kernel first address" /></p>
<h2 id="how-to-get-this-memory-dump-in-real-mode"><a class="header" href="#how-to-get-this-memory-dump-in-real-mode">How to get this memory dump in real mode?</a></h2>
<pre><code>root@parallels-vm:/usr/src/linux# more arch/x86/kernel/vmlinux.lds
...
SECTIONS
{
 . = (0xffffffff80000000 + ALIGN(0x1000000, 0x200000));
 phys_startup_64 = ABSOLUTE(startup_64 - 0xffffffff80000000);
 .text : AT(ADDR(.text) - 0xffffffff80000000) {
  _text = .;
  _stext = .;
....
</code></pre>
<pre><code>root@parallels-vm:/usr/src/linux# nm vmlinux|grep startup_64
0000000001000000 A phys_startup_64
ffffffff81000030 T secondary_startup_64
ffffffff810001f0 T __startup_64
ffffffff81000000 T startup_64
</code></pre>
<p>Here we can see the memory address of the entry point, which is <code>0x0000000001000000</code>. Let's go ahead.</p>
<p>Before trying to debug the kernel, please see <a href="http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/">Booting a Custom Linux Kernel in QEMU and Debugging It With GDB</a></p>
<h4 id="step-1"><a class="header" href="#step-1">Step 1</a></h4>
<p>Booting in QEMU</p>
<pre><code>qemu-system-x86_64 -kernel /usr/src/linux-4.14.207/arch/x86_64/boot/bzImage -nographic -append &quot;console=ttyS0 nokaslr&quot; -initrd /data/busybox/busybox-1.28.0/initramfs.cpio.gz -S -s
</code></pre>
<h4 id="step-2"><a class="header" href="#step-2">Step 2</a></h4>
<p>Attaching GDB to QEMU</p>
<pre><code>gdb vmlinux
(gdb) target remote :1234
(gdb) hbreak *0x0000000001000000
(gdb) c
(gdb) dump binary memory /tmp/dump 0x0000 0x20000
</code></pre>
<h4 id="step-3"><a class="header" href="#step-3">Step 3</a></h4>
<pre><code>root@parallels-vm:/# hd /tmp/dump |grep -A 31 MZ
00010000  4d 5a ea 07 00 c0 07 8c  c8 8e d8 8e c0 8e d0 31  |MZ.............1|
00010010  e4 fb fc be 40 00 ac 20  c0 74 09 b4 0e bb 07 00  |....@.. .t......|
00010020  cd 10 eb f2 31 c0 cd 16  cd 19 ea f0 ff 00 f0 00  |....1...........|
00010030  00 00 00 00 00 00 00 00  00 00 00 00 82 00 00 00  |................|
00010040  55 73 65 20 61 20 62 6f  6f 74 20 6c 6f 61 64 65  |Use a boot loade|
00010050  72 2e 0d 0a 0a 52 65 6d  6f 76 65 20 64 69 73 6b  |r....Remove disk|
00010060  20 61 6e 64 20 70 72 65  73 73 20 61 6e 79 20 6b  | and press any k|
00010070  65 79 20 74 6f 20 72 65  62 6f 6f 74 2e 2e 2e 0d  |ey to reboot....|
00010080  0a 00 50 45 00 00 64 86  04 00 00 00 00 00 00 00  |..PE..d.........|
00010090  00 00 01 00 00 00 a0 00  06 02 0b 02 02 14 20 d5  |.............. .|
000100a0  80 00 00 00 00 00 e0 b8  79 01 80 46 00 00 00 02  |........y..F....|
000100b0  00 00 00 00 00 00 00 00  00 00 20 00 00 00 20 00  |.......... ... .|
000100c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000100d0  00 00 00 90 fa 01 00 02  00 00 00 00 00 00 0a 00  |................|
000100e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00010100  00 00 00 00 00 00 06 00  00 00 00 00 00 00 00 00  |................|
00010110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00010130  00 00 00 00 00 00 00 00  00 00 2e 73 65 74 75 70  |...........setup|
00010140  00 00 e0 41 00 00 00 02  00 00 e0 41 00 00 00 02  |...A.......A....|
00010150  00 00 00 00 00 00 00 00  00 00 00 00 00 00 20 00  |.............. .|
00010160  50 60 2e 72 65 6c 6f 63  00 00 20 00 00 00 e0 43  |P`.reloc.. ....C|
00010170  00 00 20 00 00 00 e0 43  00 00 00 00 00 00 00 00  |.. ....C........|
00010180  00 00 00 00 00 00 40 00  10 42 2e 74 65 78 74 00  |......@..B.text.|
00010190  00 00 20 93 80 00 00 44  00 00 20 93 80 00 00 44  |.. ....D.. ....D|
000101a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 20 00  |.............. .|
000101b0  50 60 2e 62 73 73 00 00  00 00 e0 b8 79 01 20 d7  |P`.bss......y. .|
000101c0  80 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000101d0  00 00 00 00 00 00 80 00  00 c8 00 00 00 00 00 00  |................|
000101e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 ff  |................|
000101f0  ff 21 01 00 32 09 08 00  00 00 ff ff 00 00 55 aa  |.!..2.........U.|
</code></pre>
<p>The bootloader has now loaded the Linux kernel into memory, filled the header fields, and then jumped to the corresponding memory address. We now move directly to the kernel setup code.</p>
<h2 id="the-beginning-of-the-kernel-setup-stage"><a class="header" href="#the-beginning-of-the-kernel-setup-stage">The Beginning of the Kernel Setup Stage</a></h2>
<p>Finally, we are in the kernel! Technically, the kernel hasn't run yet. First, the kernel setup part must configure stuff such as the decompressor and some memory management related things, to name a few. After all these things are done, the kernel setup part will decompress the actual kernel and jump to it. Execution of the setup part starts from <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S">arch/x86/boot/header.S</a> at the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L292">_start</a> symbol.</p>
<p>It may look a bit strange at first sight, as there are several instructions before it. A long time ago, the Linux kernel had its own bootloader. Now, however, if you run, for example,</p>
<pre><code>qemu-system-x86_64 vmlinuz-3.18-generic
</code></pre>
<p>then you will see:</p>
<p><img src="Booting/images/try_vmlinuz_in_qemu.png" alt="Try vmlinuz in qemu" /></p>
<p>Actually, the file <code>header.S</code> starts with the magic number <a href="https://en.wikipedia.org/wiki/DOS_MZ_executable">MZ</a> (see image above), the error message that displays and, following that, the <a href="https://en.wikipedia.org/wiki/Portable_Executable">PE</a> header:</p>
<pre><code class="language-assembly">#ifdef CONFIG_EFI_STUB
# &quot;MZ&quot;, MS-DOS header
.byte 0x4d
.byte 0x5a
#endif
...
...
...
pe_header:
    .ascii &quot;PE&quot;
    .word 0
</code></pre>
<p>It needs this to load an operating system with <a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a> support. We won't be looking into its inner workings right now but will cover it in upcoming chapters.</p>
<p>The actual kernel setup entry point is:</p>
<pre><code class="language-assembly">// header.S line 292
.globl _start
_start:
</code></pre>
<p>The bootloader (GRUB 2 and others) knows about this point (at an offset of <code>0x200</code> from <code>MZ</code>) and jumps directly to it, despite the fact that <code>header.S</code> starts from the <code>.bstext</code> section, which prints an error message:</p>
<pre><code>//
// arch/x86/boot/setup.ld
//
. = 0;                    // current position
.bstext : { *(.bstext) }  // put .bstext section to position 0
.bsdata : { *(.bsdata) }
</code></pre>
<p>The kernel setup entry point is:</p>
<pre><code class="language-assembly">    .globl _start
_start:
    .byte  0xeb
    .byte  start_of_setup-1f
1:
    //
    // rest of the header
    //
</code></pre>
<p>Here we can see a <code>jmp</code> instruction opcode (<code>0xeb</code>) that jumps to the <code>start_of_setup-1f</code> point. In <code>Nf</code> notation, <code>2f</code>, for example, refers to the local label <code>2:</code>. In our case, it's label <code>1:</code> that is present right after the jump, and contains the rest of the setup <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/boot.txt#L156">header</a>. Right after the setup header, we see the <code>.entrytext</code> section, which starts at the <code>start_of_setup</code> label.</p>
<p>This is the first code that actually runs (aside from the previous jump instructions, of course). After the kernel setup part receives control from the bootloader, the first <code>jmp</code> instruction is located at the <code>0x200</code> offset from the start of the kernel real mode, i.e., after the first 512 bytes. This can be seen in both the Linux kernel boot protocol and the GRUB 2 source code:</p>
<pre><code class="language-C">segment = grub_linux_real_target &gt;&gt; 4;
state.gs = state.fs = state.es = state.ds = state.ss = segment;
state.cs = segment + 0x20;
</code></pre>
<p>In my case, the kernel is loaded at the physical address <code>0x10000</code>. This means that segment registers have the following values after kernel setup starts:</p>
<pre><code>gs = fs = es = ds = ss = 0x1000
cs = 0x1020
</code></pre>
<p>After the jump to <code>start_of_setup</code>, the kernel needs to do the following:</p>
<ul>
<li>Make sure that all segment register values are equal</li>
<li>Set up a correct stack, if needed</li>
<li>Set up <a href="https://en.wikipedia.org/wiki/.bss">bss</a></li>
<li>Jump to the C code in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c">arch/x86/boot/main.c</a></li>
</ul>
<p>Let's look at the implementation.</p>
<h2 id="aligning-the-segment-registers"><a class="header" href="#aligning-the-segment-registers">Aligning the Segment Registers</a></h2>
<p>First of all, the kernel ensures that the <code>ds</code> and <code>es</code> segment registers point to the same address. Next, it clears the direction flag using the <code>cld</code> instruction:</p>
<pre><code class="language-assembly">    movw    %ds, %ax
    movw    %ax, %es
    cld
</code></pre>
<p>As I wrote earlier, <code>grub2</code> loads kernel setup code at address <code>0x10000</code> by default and <code>cs</code> at <code>0x1020</code> because execution doesn't start from the start of the file, but from the jump here:</p>
<pre><code class="language-assembly">_start:
    .byte 0xeb
    .byte start_of_setup-1f
</code></pre>
<p>which is at a <code>512</code> byte offset from <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L46">4d 5a</a>. We also need to align <code>cs</code> from <code>0x1020</code> to <code>0x1000</code>, as well as all other segment registers. After that, we set up the stack:</p>
<pre><code class="language-assembly">    pushw   %ds
    pushw   $6f
    lretw
</code></pre>
<p>which pushes the value of <code>ds</code> to the stack, followed by the address of the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L602">6</a> label and executes the <code>lretw</code> instruction. When the <code>lretw</code> instruction is called, it loads the address of label <code>6</code> into the <a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a> register and loads <code>cs</code> with the value of <code>ds</code>. Afterward, <code>ds</code> and <code>cs</code> will have the same values.</p>
<h2 id="stack-setup"><a class="header" href="#stack-setup">Stack Setup</a></h2>
<p>Almost all of the setup code is for preparing the C language environment in real mode. The next <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L575">step</a> is checking the <code>ss</code> register's value and setting up a correct stack if <code>ss</code> is wrong:</p>
<pre><code class="language-assembly">    movw    %ss, %dx
    cmpw    %ax, %dx
    movw    %sp, %dx
    je      2f
</code></pre>
<p>This can lead to 3 different scenarios:</p>
<ul>
<li><code>ss</code> has a valid value <code>0x1000</code> (as do all the other segment registers besides <code>cs</code>)</li>
<li><code>ss</code> is invalid and the <code>CAN_USE_HEAP</code> flag is set     (see below)</li>
<li><code>ss</code> is invalid and the <code>CAN_USE_HEAP</code> flag is not set (see below)</li>
</ul>
<p>Let's look at all three of these scenarios in turn:</p>
<ul>
<li><code>ss</code> has a correct address (<code>0x1000</code>). In this case, we go to label <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L589">2</a>:</li>
</ul>
<pre><code class="language-assembly">2:  andw    $~3, %dx
    jnz     3f
    movw    $0xfffc, %dx
3:  movw    %ax, %ss
    movzwl  %dx, %esp
    sti
</code></pre>
<p>Here we set the alignment of <code>dx</code> (which contains the value of <code>sp</code> as given by the bootloader) to <code>4</code> bytes and check if it is zero. If it is, we set <code>dx</code> to <code>0xfffc</code> (The last 4-byte aligned address in a 64KB segment). If it is not zero, we continue to use the value of <code>sp</code> given by the bootloader (<code>0xf7f4</code> in my case). Afterwards, we put the value of <code>ax</code> (<code>0x1000</code>) into <code>ss</code>. We now have a correct stack:</p>
<p><img src="Booting/images/stack1.png" alt="stack" /></p>
<ul>
<li>The second scenario, (<code>ss</code> != <code>ds</code>). First, we put the value of <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/setup.ld">_end</a> (the address of the end of the setup code) into <code>dx</code> and check the <code>loadflags</code> header field using the <code>testb</code> instruction to see whether we can use the heap. <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L320">loadflags</a> is a bitmask header defined as:</li>
</ul>
<pre><code class="language-C">#define LOADED_HIGH     (1&lt;&lt;0)
#define QUIET_FLAG      (1&lt;&lt;5)
#define KEEP_SEGMENTS   (1&lt;&lt;6)
#define CAN_USE_HEAP    (1&lt;&lt;7)
</code></pre>
<p>and as we can read in the boot protocol:</p>
<pre><code>Field name: loadflags

  This field is a bitmask.

  Bit 7 (write): CAN_USE_HEAP
    Set this bit to 1 to indicate that the value entered in the
    heap_end_ptr is valid.  If this field is clear, some setup code
    functionality will be disabled.
</code></pre>
<p>If the <code>CAN_USE_HEAP</code> bit is set, we put <code>heap_end_ptr</code> into <code>dx</code> (which points to <code>_end</code>) and add <code>STACK_SIZE</code> (the minimum stack size, <code>1024</code> bytes) to it. After this, if <code>dx</code> is not carried (it will not be carried, <code>dx = _end + 1024</code>), jump to label <code>2</code> (as in the previous case) and make a correct stack.</p>
<p><img src="Booting/images/stack2.png" alt="stack" /></p>
<ul>
<li>When <code>CAN_USE_HEAP</code> is not set, we just use a minimal stack from <code>_end</code> to <code>_end + STACK_SIZE</code>:</li>
</ul>
<p><img src="Booting/images/minimal_stack.png" alt="minimal stack" /></p>
<h2 id="bss-setup"><a class="header" href="#bss-setup">BSS Setup</a></h2>
<p>The last two steps that need to happen before we can jump to the main C code are setting up the <a href="https://en.wikipedia.org/wiki/.bss">BSS</a> area and checking the &quot;magic&quot; signature. First, signature checking:</p>
<pre><code class="language-assembly">    cmpl    $0x5a5aaa55, setup_sig
    jne     setup_bad
</code></pre>
<p>This simply compares the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/setup.ld">setup_sig</a> with the magic number <code>0x5a5aaa55</code>. If they are not equal, a fatal error is reported.</p>
<p>If the magic number matches, knowing we have a set of correct segment registers and a stack, we only need to set up the BSS section before jumping into the C code.</p>
<p>The BSS section is used to store statically allocated, uninitialized data. Linux carefully ensures this area of memory is first zeroed using the following code:</p>
<pre><code class="language-assembly">    movw    $__bss_start, %di
    movw    $_end+3, %cx
    xorl    %eax, %eax
    subw    %di, %cx
    shrw    $2, %cx
    rep; stosl
</code></pre>
<p>First, the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/setup.ld">__bss_start</a> address is moved into <code>di</code>. Next, the <code>_end + 3</code> address (+3 - aligns to 4 bytes) is moved into <code>cx</code>. The <code>eax</code> register is cleared (using the <code>xor</code> instruction), and the bss section size (<code>cx - di</code>) is calculated and put into <code>cx</code>. Then, <code>cx</code> is divided by four (the size of a 'word'), and the <code>stosl</code> instruction is used repeatedly, storing the value of <code>eax</code> (zero) into the address pointed to by <code>di</code>, automatically increasing <code>di</code> by four, repeating until <code>cx</code> reaches zero. The net effect of this code is that zeros are written through all words in memory from <code>__bss_start</code> to <code>_end</code>:</p>
<p><img src="Booting/images/bss.png" alt="bss" /></p>
<h2 id="jump-to-main"><a class="header" href="#jump-to-main">Jump to main</a></h2>
<p>That's all! We have the stack and BSS, so we can jump to the <code>main()</code> C function:</p>
<pre><code class="language-assembly">    call main
</code></pre>
<p>The <code>main()</code> function is located in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c">arch/x86/boot/main.c</a>. You can read about what this does in the next part.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This is the end of the first part about Linux kernel insides. If you have questions or suggestions, ping me on Twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a>, or just create an <a href="https://github.com/0xAX/linux-internals/issues/new">issue</a>. In the next part, we will see the first C code that executes in the Linux kernel setup, the implementation of memory routines such as <code>memset</code>, <code>memcpy</code>, <code>earlyprintk</code>, early console implementation and initialization, and much more.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-internals">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="http://css.csail.mit.edu/6.858/2014/readings/i386.pdf">Intel 80386 programmer's reference manual 1986</a></li>
<li><a href="https://www.cs.cmu.edu/%7E410/doc/minimal_boot.pdf">Minimal Boot Loader for Intel® Architecture</a></li>
<li><a href="https://github.com/Stefan20162016/linux-insides-code/blob/master/bootloader.asm">Minimal Boot Loader in Assembler with comments</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8086">8086</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_80386">80386</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reset_vector">Reset vector</a></li>
<li><a href="https://en.wikipedia.org/wiki/Real_mode">Real mode</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">Linux kernel boot protocol</a></li>
<li><a href="https://www.coreboot.org/Developer_Manual">coreboot developer manual</a></li>
<li><a href="http://www.ctyme.com/intr/int.htm">Ralf Brown's Interrupt List</a></li>
<li><a href="https://en.wikipedia.org/wiki/Power_supply">Power supply</a></li>
<li><a href="https://en.wikipedia.org/wiki/Power_good_signal">Power good signal</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-booting-process-part-2"><a class="header" href="#kernel-booting-process-part-2">Kernel booting process. Part 2.</a></h1>
<h2 id="first-steps-in-the-kernel-setup"><a class="header" href="#first-steps-in-the-kernel-setup">First steps in the kernel setup</a></h2>
<p>We started to dive into the Linux kernel's insides in the previous <a href="Booting/linux-bootstrap-1.html">part</a> and saw the initial part of the kernel setup code. We stopped at the first call to the <code>main</code> function (which is the first function written in C) from <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c">arch/x86/boot/main.c</a>.</p>
<p>In this part, we will continue to research the kernel setup code and go over</p>
<ul>
<li>what <code>protected mode</code> is,</li>
<li>the transition into it,</li>
<li>the initialization of the heap and the console,</li>
<li>memory detection, CPU validation and keyboard initialization</li>
<li>and much much more.</li>
</ul>
<p>So, let's go ahead.</p>
<h2 id="protected-mode"><a class="header" href="#protected-mode">Protected mode</a></h2>
<p>Before we can move to the native Intel64 <a href="http://en.wikipedia.org/wiki/Long_mode">Long Mode</a>, the kernel must switch the CPU into protected mode.</p>
<p>What is <a href="https://en.wikipedia.org/wiki/Protected_mode">protected mode</a>? Protected mode was first added to the x86 architecture in 1982 and was the main mode of Intel processors from the <a href="http://en.wikipedia.org/wiki/Intel_80286">80286</a> processor until Intel 64 and long mode came.</p>
<p>The main reason to move away from <a href="http://wiki.osdev.org/Real_Mode">Real mode</a> is that there is very limited access to the RAM. As you may remember from the previous part, there are only 2<sup>20</sup> bytes or 1 Megabyte, sometimes even only 640 Kilobytes of RAM available in Real mode.</p>
<p>Protected mode brought many changes, but the main one is the difference in memory management. The 20-bit address bus was replaced with a 32-bit address bus. It allowed access to 4 Gigabytes of memory vs the 1 Megabyte in Real mode. Also, <a href="http://en.wikipedia.org/wiki/Paging">paging</a> support was added, which you can read about in the next sections.</p>
<p>Memory management in Protected mode is divided into two, almost independent parts:</p>
<ul>
<li>Segmentation</li>
<li>Paging</li>
</ul>
<p>Here we will only talk about segmentation. Paging will be discussed in the next sections.</p>
<p>As you can read in the previous part, addresses consist of two parts in Real mode:</p>
<ul>
<li>Base address of the segment</li>
<li>Offset from the segment base</li>
</ul>
<p>And we can get the physical address if we know these two parts by:</p>
<pre><code>PhysicalAddress = Segment Base * 16 + Offset
</code></pre>
<p>Memory segmentation was completely redone in protected mode. There are no 64 Kilobyte fixed-size segments. Instead, the size and location of each segment is described by an associated data structure called the <em>Segment Descriptor</em>. These segment descriptors are stored in a data structure called the <code>Global Descriptor Table</code> (GDT).</p>
<p>The GDT is a structure which resides in memory. It has no fixed place in the memory, so its address is stored in the special <code>GDTR</code> register. Later we will see how the GDT is loaded in the Linux kernel code. There will be an operation for loading it from memory, something like:</p>
<pre><code class="language-assembly">lgdt gdt
</code></pre>
<p>where the <code>lgdt</code> instruction loads the base address and limit(size) of the global descriptor table to the <code>GDTR</code> register. <code>GDTR</code> is a 48-bit register and consists of two parts:</p>
<ul>
<li>the size(16-bit) of the global descriptor table;</li>
<li>the address(32-bit) of the global descriptor table.</li>
</ul>
<p>As mentioned above, the GDT contains <code>segment descriptors</code> which describe memory segments.  Each descriptor is 64-bits in size. The general scheme of a descriptor is:</p>
<pre><code> 63         56         51   48    45           39        32 
------------------------------------------------------------
|             | |B| |A|       | |   | |0|E|W|A|            |
| BASE 31:24  |G|/|L|V| LIMIT |P|DPL|S|  TYPE | BASE 23:16 |
|             | |D| |L| 19:16 | |   | |1|C|R|A|            |
------------------------------------------------------------

 31                         16 15                         0 
------------------------------------------------------------
|                             |                            |
|        BASE 15:0            |       LIMIT 15:0           |
|                             |                            |
------------------------------------------------------------
</code></pre>
<p>Don't worry, I know it looks a little scary after Real mode, but it's easy. For example LIMIT 15:0 means that bits 0-15 of the segment limit are located at the beginning of the Descriptor. The rest of it is in LIMIT 19:16, which is located at bits 48-51 of the Descriptor. So, the size of Limit is 0-19 i.e 20-bits. Let's take a closer look at it:</p>
<ol>
<li>Limit[20-bits] is split between bits 0-15 and 48-51. It defines the <code>length_of_segment - 1</code>. It depends on the <code>G</code>(Granularity) bit.</li>
</ol>
<ul>
<li>if <code>G</code> (bit 55) is 0 and the segment limit is 0, the size of the segment is 1 Byte</li>
<li>if <code>G</code> is 1 and the segment limit is 0, the size of the segment is 4096 Bytes</li>
<li>if <code>G</code> is 0 and the segment limit is 0xfffff, the size of the segment is 1 Megabyte</li>
<li>if <code>G</code> is 1 and the segment limit is 0xfffff, the size of the segment is 4 Gigabytes</li>
</ul>
<p>So, what this means is</p>
<ul>
<li>if G is 0, Limit is interpreted in terms of 1 Byte and the maximum size of the segment can be 1 Megabyte.</li>
<li>if G is 1, Limit is interpreted in terms of 4096 Bytes = 4 KBytes = 1 Page and the maximum size of the segment can be 4 Gigabytes. Actually, when G is 1, the value of Limit is shifted to the left by 12 bits. So, 20 bits + 12 bits = 32 bits and 2<sup>32</sup> = 4 Gigabytes.</li>
</ul>
<ol start="2">
<li>
<p>Base[32-bits] is split between bits 16-31, 32-39 and 56-63. It defines the physical address of the segment's starting location.</p>
</li>
<li>
<p>Type/Attribute[5-bits] is represented by bits 40-44. It defines the type of segment and how it can be accessed.</p>
</li>
</ol>
<ul>
<li>The <code>S</code> flag at bit 44 specifies the descriptor type. If <code>S</code> is 0 then this segment is a system segment, whereas if <code>S</code> is 1 then this is a code or data segment (Stack segments are data segments which must be read/write segments).</li>
</ul>
<p>To determine if the segment is a code or data segment, we can check its Ex(bit 43) Attribute (marked as 0 in the above diagram). If it is 0, then the segment is a Data segment, otherwise, it is a code segment.</p>
<p>A segment can be of one of the following types:</p>
<pre><code>--------------------------------------------------------------------------------------
|           Type Field        | Descriptor Type | Description                        |
|-----------------------------|-----------------|------------------------------------|
| Decimal                     |                 |                                    |
|             0    E    W   A |                 |                                    |
| 0           0    0    0   0 | Data            | Read-Only                          |
| 1           0    0    0   1 | Data            | Read-Only, accessed                |
| 2           0    0    1   0 | Data            | Read/Write                         |
| 3           0    0    1   1 | Data            | Read/Write, accessed               |
| 4           0    1    0   0 | Data            | Read-Only, expand-down             |
| 5           0    1    0   1 | Data            | Read-Only, expand-down, accessed   |
| 6           0    1    1   0 | Data            | Read/Write, expand-down            |
| 7           0    1    1   1 | Data            | Read/Write, expand-down, accessed  |
|                  C    R   A |                 |                                    |
| 8           1    0    0   0 | Code            | Execute-Only                       |
| 9           1    0    0   1 | Code            | Execute-Only, accessed             |
| 10          1    0    1   0 | Code            | Execute/Read                       |
| 11          1    0    1   1 | Code            | Execute/Read, accessed             |
| 12          1    1    0   0 | Code            | Execute-Only, conforming           |
| 14          1    1    0   1 | Code            | Execute-Only, conforming, accessed |
| 13          1    1    1   0 | Code            | Execute/Read, conforming           |
| 15          1    1    1   1 | Code            | Execute/Read, conforming, accessed |
--------------------------------------------------------------------------------------
</code></pre>
<p>As we can see the first bit(bit 43) is <code>0</code> for a <em>data</em> segment and <code>1</code> for a <em>code</em> segment. The next three bits (40, 41, 42) are either <code>EWA</code>(<em>E</em>xpansion <em>W</em>ritable <em>A</em>ccessible) or CRA(<em>C</em>onforming <em>R</em>eadable <em>A</em>ccessible).</p>
<ul>
<li>if E(bit 42) is 0, expand up, otherwise, expand down. Read more <a href="http://www.sudleyplace.com/dpmione/expanddown.html">here</a>.</li>
<li>if W(bit 41)(for Data Segments) is 1, write access is allowed, and if it is 0, the segment is read-only. Note that read access is always allowed on data segments.</li>
<li>A(bit 40) controls whether the segment can be accessed by the processor or not.</li>
<li>C(bit 43) is the conforming bit(for code selectors). If C is 1, the segment code can be executed from a lower level privilege (e.g. user) level. If C is 0, it can only be executed from the same privilege level.</li>
<li>R(bit 41) controls read access to code segments; when it is 1, the segment can be read from. Write access is never granted for code segments.</li>
</ul>
<ol start="4">
<li>
<p>DPL[2-bits] (Descriptor Privilege Level) comprises the bits 45-46. It defines the privilege level of the segment. It can be 0-3 where 0 is the most privileged level.</p>
</li>
<li>
<p>The P flag(bit 47) indicates if the segment is present in memory or not. If P is 0, the segment will be presented as <em>invalid</em> and the processor will refuse to read from this segment.</p>
</li>
<li>
<p>AVL flag(bit 52) - Available and reserved bits. It is ignored in Linux.</p>
</li>
<li>
<p>The L flag(bit 53) indicates whether a code segment contains native 64-bit code. If it is set, then the code segment executes in 64-bit mode.</p>
</li>
<li>
<p>The D/B flag(bit 54)  (Default/Big flag) represents the operand size i.e 16/32 bits. If set, operand size is 32 bits. Otherwise, it is 16 bits.</p>
</li>
</ol>
<p>Segment registers contain segment selectors as in real mode. However, in protected mode, a segment selector is handled differently. Each Segment Descriptor has an associated Segment Selector which is a 16-bit structure:</p>
<pre><code> 15             3 2  1     0
-----------------------------
|      Index     | TI | RPL |
-----------------------------
</code></pre>
<p>Where,</p>
<ul>
<li><strong>Index</strong> stores the index number of the descriptor in the GDT.</li>
<li><strong>TI</strong>(Table Indicator) indicates where to search for the descriptor. If it is 0 then the descriptor is searched for in the Global Descriptor Table(GDT). Otherwise, it will be searched for in the Local Descriptor Table(LDT).</li>
<li>And <strong>RPL</strong> contains the Requester's Privilege Level.</li>
</ul>
<p>Every segment register has a visible and a hidden part.</p>
<ul>
<li>Visible - The Segment Selector is stored here.</li>
<li>Hidden -  The Segment Descriptor (which contains the base, limit, attributes &amp; flags) is stored here.</li>
</ul>
<p>The following steps are needed to get a physical address in protected mode:</p>
<ul>
<li>The segment selector must be loaded in one of the segment registers.</li>
<li>The CPU tries to find a segment descriptor at the offset <code>GDT address + Index</code> from the selector and then loads the descriptor into the <em>hidden</em> part of the segment register.</li>
<li>If paging is disabled, the linear address of the segment, or its physical address, is given by the formula: Base address (found in the descriptor obtained in the previous step) + Offset.</li>
</ul>
<p>Schematically it will look like this:</p>
<p><img src="Booting/images/linear_address.png" alt="linear address" /></p>
<p>The algorithm for the transition from real mode into protected mode is:</p>
<ul>
<li>Disable interrupts</li>
<li>Describe and load the GDT with the <code>lgdt</code> instruction</li>
<li>Set the PE (Protection Enable) bit in CR0 (Control Register 0)</li>
<li>Jump to protected mode code</li>
</ul>
<p>We will see the complete transition to protected mode in the Linux kernel in the next part, but before we can move to protected mode, we need to do some more preparations.</p>
<p>Let's look at <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c">arch/x86/boot/main.c</a>. We can see some routines there which perform keyboard initialization, heap initialization, etc... Let's take a look.</p>
<h2 id="copying-boot-parameters-into-the-zeropage"><a class="header" href="#copying-boot-parameters-into-the-zeropage">Copying boot parameters into the &quot;zeropage&quot;</a></h2>
<p>We will start from the <code>main</code> routine in &quot;main.c&quot;. The first function which is called in <code>main</code> is <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c"><code>copy_boot_params(void)</code></a>. It copies the kernel setup header into the corresponding field of the <code>boot_params</code> structure which is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/include/uapi/asm/bootparam.h">arch/x86/include/uapi/asm/bootparam.h</a> header file.</p>
<p>The <code>boot_params</code> structure contains the <code>struct setup_header hdr</code> field. This structure contains the same fields as defined in the <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">linux boot protocol</a> and is filled by the boot loader and also at kernel compile/build time. <code>copy_boot_params</code> does two things:</p>
<ol>
<li>
<p>It copies <code>hdr</code> from <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L280">header.S</a> to the <code>setup_header</code> field in <code>boot_params</code> structure.</p>
</li>
<li>
<p>It updates the pointer to the kernel command line if the kernel was loaded with the old command line protocol.</p>
</li>
</ol>
<p>Note that it copies <code>hdr</code> with the <code>memcpy</code> function, defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/copy.S">copy.S</a> source file. Let's have a look inside:</p>
<pre><code class="language-assembly">GLOBAL(memcpy)
    pushw   %si
    pushw   %di
    movw    %ax, %di
    movw    %dx, %si
    pushw   %cx
    shrw    $2, %cx
    rep; movsl
    popw    %cx
    andw    $3, %cx
    rep; movsb
    popw    %di
    popw    %si
    retl
ENDPROC(memcpy)
</code></pre>
<p>Yeah, we just moved to C code and now assembly again :) First of all, we can see that <code>memcpy</code> and other routines which are defined here, start and end with the two macros: <code>GLOBAL</code> and <code>ENDPROC</code>. <code>GLOBAL</code> is described in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/include/asm/linkage.h">arch/x86/include/asm/linkage.h</a> which defines the <code>globl</code> directive and its label. <code>ENDPROC</code> is described in <a href="https://github.com/torvalds/linux/blob/v4.16/include/linux/linkage.h">include/linux/linkage.h</a> and marks the <code>name</code> symbol as a function name and ends with the size of the <code>name</code> symbol.</p>
<p>The implementation of <code>memcpy</code> is simple. At first, it pushes values from the <code>si</code> and <code>di</code> registers to the stack to preserve their values because they will change during the <code>memcpy</code>. As we can see in the <code>REALMODE_CFLAGS</code> in <code>arch/x86/Makefile</code>, the kernel build system uses the <code>-mregparm=3</code> option of GCC, so functions get the first three parameters from <code>ax</code>, <code>dx</code> and <code>cx</code> registers.  Calling <code>memcpy</code> looks like this:</p>
<pre><code class="language-c">memcpy(&amp;boot_params.hdr, &amp;hdr, sizeof hdr);
</code></pre>
<p>So,</p>
<ul>
<li><code>ax</code> will contain the address of <code>boot_params.hdr</code></li>
<li><code>dx</code> will contain the address of <code>hdr</code></li>
<li><code>cx</code> will contain the size of <code>hdr</code> in bytes.</li>
</ul>
<p><code>memcpy</code> puts the address of <code>boot_params.hdr</code> into <code>di</code> and saves <code>cx</code> on the stack. After this it shifts the value right 2 times (or divides it by 4) and copies four bytes from the address at <code>si</code> to the address at <code>di</code>. After this, we restore the size of <code>hdr</code> again, align it by 4 bytes and copy the rest of the bytes from the address at <code>si</code> to the address at <code>di</code> byte by byte (if there is more). Now the values of <code>si</code> and <code>di</code> are restored from the stack and the copying operation is finished.</p>
<h2 id="console-initialization"><a class="header" href="#console-initialization">Console initialization</a></h2>
<p>After <code>hdr</code> is copied into <code>boot_params.hdr</code>, the next step is to initialize the console by calling the <code>console_init</code> function,  defined in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/early_serial_console.c">arch/x86/boot/early_serial_console.c</a>.</p>
<p>It tries to find the <code>earlyprintk</code> option in the command line and if the search was successful, it parses the port address and baud rate of the serial port and initializes the serial port. The value of the <code>earlyprintk</code> command line option can be one of these:</p>
<ul>
<li>serial,0x3f8,115200</li>
<li>serial,ttyS0,115200</li>
<li>ttyS0,115200</li>
</ul>
<p>After serial port initialization we can see the first output:</p>
<pre><code class="language-C">if (cmdline_find_option_bool(&quot;debug&quot;))
    puts(&quot;early console in setup code\n&quot;);
</code></pre>
<p>The definition of <code>puts</code> is in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/tty.c">tty.c</a>. As we can see it prints character by character in a loop by calling the <code>putchar</code> function. Let's look into the <code>putchar</code> implementation:</p>
<pre><code class="language-C">void __attribute__((section(&quot;.inittext&quot;))) putchar(int ch)
{
    if (ch == '\n')
        putchar('\r');

    bios_putchar(ch);

    if (early_serial_base != 0)
        serial_putchar(ch);
}
</code></pre>
<p><code>__attribute__((section(&quot;.inittext&quot;)))</code> means that this code will be in the <code>.inittext</code> section. We can find it in the linker file <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/setup.ld">setup.ld</a>.</p>
<p>First of all, <code>putchar</code> checks for the <code>\n</code> symbol and if it is found, prints <code>\r</code> before. After that it prints the character on the VGA screen by calling the BIOS with the <code>0x10</code> interrupt call:</p>
<pre><code class="language-C">static void __attribute__((section(&quot;.inittext&quot;))) bios_putchar(int ch)
{
    struct biosregs ireg;

    initregs(&amp;ireg);
    ireg.bx = 0x0007;
    ireg.cx = 0x0001;
    ireg.ah = 0x0e;
    ireg.al = ch;
    intcall(0x10, &amp;ireg, NULL);
}
</code></pre>
<p>Here <code>initregs</code> takes the <code>biosregs</code> structure and first fills <code>biosregs</code> with zeros using the <code>memset</code> function and then fills it with register values.</p>
<pre><code class="language-C">    memset(reg, 0, sizeof *reg);
    reg-&gt;eflags |= X86_EFLAGS_CF;
    reg-&gt;ds = ds();
    reg-&gt;es = ds();
    reg-&gt;fs = fs();
    reg-&gt;gs = gs();
</code></pre>
<p>Let's look at the implementation of <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/copy.S#L36">memset</a>:</p>
<pre><code class="language-assembly">GLOBAL(memset)
    pushw   %di
    movw    %ax, %di
    movzbl  %dl, %eax
    imull   $0x01010101,%eax
    pushw   %cx
    shrw    $2, %cx
    rep; stosl
    popw    %cx
    andw    $3, %cx
    rep; stosb
    popw    %di
    retl
ENDPROC(memset)
</code></pre>
<p>As you can read above, it uses the same calling conventions as the <code>memcpy</code> function, which means that the function gets its parameters from the <code>ax</code>, <code>dx</code> and <code>cx</code> registers.</p>
<p>The implementation of <code>memset</code> is similar to that of memcpy. It saves the value of the <code>di</code> register on the stack and puts the value of<code>ax</code>, which stores the address of the <code>biosregs</code> structure, into <code>di</code> . Next is the <code>movzbl</code> instruction, which copies the value of <code>dl</code> to the lowermost byte of the <code>eax</code> register. The remaining 3 high bytes of <code>eax</code> will be filled with zeros.</p>
<p>The next instruction multiplies <code>eax</code> with <code>0x01010101</code>. It needs to because <code>memset</code> will copy 4 bytes at the same time. For example, if we need to fill a structure whose size is 4 bytes with the value <code>0x7</code> with memset, <code>eax</code> will contain the <code>0x00000007</code>. So if we multiply <code>eax</code> with <code>0x01010101</code>, we will get <code>0x07070707</code> and now we can copy these 4 bytes into the structure. <code>memset</code> uses the <code>rep; stosl</code> instruction to copy <code>eax</code> into <code>es:di</code>.</p>
<p>The rest of the <code>memset</code> function does almost the same thing as <code>memcpy</code>.</p>
<p>After the <code>biosregs</code> structure is filled with <code>memset</code>, <code>bios_putchar</code> calls the <a href="http://www.ctyme.com/intr/rb-0106.htm">0x10</a> interrupt which prints a character. Afterwards it checks if the serial port was initialized or not and writes a character there with <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/tty.c">serial_putchar</a> and <code>inb/outb</code> instructions if it was set.</p>
<h2 id="heap-initialization"><a class="header" href="#heap-initialization">Heap initialization</a></h2>
<p>After the stack and bss section have been prepared in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S">header.S</a> (see previous <a href="Booting/linux-bootstrap-1.html">part</a>), the kernel needs to initialize the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c">heap</a> with the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c"><code>init_heap</code></a> function.</p>
<p>First of all <code>init_heap</code> checks the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/include/uapi/asm/bootparam.h#L24"><code>CAN_USE_HEAP</code></a> flag from the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S#L320"><code>loadflags</code></a> structure in the kernel setup header and calculates the end of the stack if this flag was set:</p>
<pre><code class="language-C">    char *stack_end;

    if (boot_params.hdr.loadflags &amp; CAN_USE_HEAP) {
        asm(&quot;leal %P1(%%esp),%0&quot;
            : &quot;=r&quot; (stack_end) : &quot;i&quot; (-STACK_SIZE));
</code></pre>
<p>or in other words <code>stack_end = esp - STACK_SIZE</code>.</p>
<p>Then there is the <code>heap_end</code> calculation:</p>
<pre><code class="language-C">     heap_end = (char *)((size_t)boot_params.hdr.heap_end_ptr + 0x200);
</code></pre>
<p>which means <code>heap_end_ptr</code> or <code>_end</code> + <code>512</code> (<code>0x200h</code>). The last check is whether <code>heap_end</code> is greater than <code>stack_end</code>. If it is then <code>stack_end</code> is assigned to <code>heap_end</code> to make them equal.</p>
<p>Now the heap is initialized and we can use it using the <code>GET_HEAP</code> method. We will see what it is used for, how to use it and how it is implemented in the next posts.</p>
<h2 id="cpu-validation"><a class="header" href="#cpu-validation">CPU validation</a></h2>
<p>The next step as we can see is cpu validation through the <code>validate_cpu</code> function from <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/cpu.c">arch/x86/boot/cpu.c</a> source code file.</p>
<p>It calls the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/cpucheck.c"><code>check_cpu</code></a> function and passes cpu level and required cpu level to it and checks that the kernel launches on the right cpu level.</p>
<pre><code class="language-C">check_cpu(&amp;cpu_level, &amp;req_level, &amp;err_flags);
if (cpu_level &lt; req_level) {
    ...
    return -1;
}
</code></pre>
<p>The <code>check_cpu</code> function checks the CPU's flags, the presence of <a href="http://en.wikipedia.org/wiki/Long_mode">long mode</a> in the case of x86_64(64-bit) CPU, checks the processor's vendor and makes preparations for certain vendors like turning on SSE+SSE2 for AMD if they are missing, etc.</p>
<p>at the next step, we may see a call to the <code>set_bios_mode</code> function after setup code found that a CPU is suitable. As we may see, this function is implemented only for the <code>x86_64</code> mode:</p>
<pre><code class="language-C">static void set_bios_mode(void)
{
#ifdef CONFIG_X86_64
	struct biosregs ireg;

	initregs(&amp;ireg);
	ireg.ax = 0xec00;
	ireg.bx = 2;
	intcall(0x15, &amp;ireg, NULL);
#endif
}
</code></pre>
<p>The <code>set_bios_mode</code> function executes the <code>0x15</code> BIOS interrupt to tell the BIOS that <a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a> (if <code>bx == 2</code>) will be used.</p>
<h2 id="memory-detection"><a class="header" href="#memory-detection">Memory detection</a></h2>
<p>The next step is memory detection through the <code>detect_memory</code> function. <code>detect_memory</code> basically provides a map of available RAM to the CPU. It uses different programming interfaces for memory detection like <code>0xe820</code>, <code>0xe801</code> and <code>0x88</code>. We will see only the implementation of the <strong>0xE820</strong> interface here.</p>
<p>Let's look at the implementation of the <code>detect_memory_e820</code> function from the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/memory.c">arch/x86/boot/memory.c</a> source file. First of all, the <code>detect_memory_e820</code> function initializes the <code>biosregs</code> structure as we saw above and fills registers with special values for the <code>0xe820</code> call:</p>
<pre><code class="language-assembly">    initregs(&amp;ireg);
    ireg.ax  = 0xe820;
    ireg.cx  = sizeof buf;
    ireg.edx = SMAP;
    ireg.di  = (size_t)&amp;buf;
</code></pre>
<ul>
<li><code>ax</code> contains the number of the function (0xe820 in our case)</li>
<li><code>cx</code> contains the size of the buffer which will contain data about the memory</li>
<li><code>edx</code> must contain the <code>SMAP</code> magic number</li>
<li><code>es:di</code> must contain the address of the buffer which will contain memory data</li>
<li><code>ebx</code> has to be zero.</li>
</ul>
<p>Next is a loop where data about the memory will be collected. It starts with a call to the <code>0x15</code> BIOS interrupt, which writes one line from the address allocation table. For getting the next line we need to call this interrupt again (which we do in the loop). Before the next call <code>ebx</code> must contain the value returned previously:</p>
<pre><code class="language-C">    intcall(0x15, &amp;ireg, &amp;oreg);
    ireg.ebx = oreg.ebx;
</code></pre>
<p>Ultimately, this function collects data from the address allocation table and writes this data into the <code>e820_entry</code> array:</p>
<ul>
<li>start of memory segment</li>
<li>size  of memory segment</li>
<li>type of memory segment (whether the particular segment is usable or reserved)</li>
</ul>
<p>You can see the result of this in the <code>dmesg</code> output, something like:</p>
<pre><code>[    0.000000] e820: BIOS-provided physical RAM map:
[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable
[    0.000000] BIOS-e820: [mem 0x000000000009fc00-0x000000000009ffff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000000f0000-0x00000000000fffff] reserved
[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000003ffdffff] usable
[    0.000000] BIOS-e820: [mem 0x000000003ffe0000-0x000000003fffffff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000fffc0000-0x00000000ffffffff] reserved
</code></pre>
<h2 id="keyboard-initialization"><a class="header" href="#keyboard-initialization">Keyboard initialization</a></h2>
<p>The next step is the initialization of the keyboard with a call to the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c"><code>keyboard_init</code></a> function. At first <code>keyboard_init</code> initializes registers using the <code>initregs</code> function. It then calls the <a href="http://www.ctyme.com/intr/rb-1756.htm">0x16</a> interrupt to query the status of the keyboard.</p>
<pre><code class="language-c">    initregs(&amp;ireg);
    ireg.ah = 0x02;     /* Get keyboard status */
    intcall(0x16, &amp;ireg, &amp;oreg);
    boot_params.kbd_status = oreg.al;
</code></pre>
<p>After this it calls <a href="http://www.ctyme.com/intr/rb-1757.htm">0x16</a> again to set the repeat rate and delay.</p>
<pre><code class="language-c">    ireg.ax = 0x0305;   /* Set keyboard repeat rate */
    intcall(0x16, &amp;ireg, NULL);
</code></pre>
<h2 id="querying"><a class="header" href="#querying">Querying</a></h2>
<p>The next couple of steps are queries for different parameters. We will not dive into details about these queries but we will get back to them in later parts. Let's take a short look at these functions:</p>
<p>The first step is getting <a href="http://en.wikipedia.org/wiki/SpeedStep">Intel SpeedStep</a> information by calling the <code>query_ist</code> function. It checks the CPU level and if it is correct, calls <code>0x15</code> to get the info and saves the result to <code>boot_params</code>.</p>
<p>Next, the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/apm.c#L21">query_apm_bios</a> function gets <a href="http://en.wikipedia.org/wiki/Advanced_Power_Management">Advanced Power Management</a> information from the BIOS. <code>query_apm_bios</code> calls the <code>0x15</code> BIOS interruption too, but with <code>ah</code> = <code>0x53</code> to check <code>APM</code> installation. After <code>0x15</code> finishes executing, the <code>query_apm_bios</code> functions check the <code>PM</code> signature (it must be <code>0x504d</code>), the carry flag (it must be 0 if <code>APM</code> supported) and the value of the <code>cx</code> register (if it's 0x02, the protected mode interface is supported).</p>
<p>Next, it calls <code>0x15</code> again, but with <code>ax = 0x5304</code> to disconnect the <code>APM</code> interface and connect the 32-bit protected mode interface. In the end, it fills <code>boot_params.apm_bios_info</code> with values obtained from the BIOS.</p>
<p>Note that <code>query_apm_bios</code> will be executed only if the <code>CONFIG_APM</code> or <code>CONFIG_APM_MODULE</code> compile time flag was set in the configuration file:</p>
<pre><code class="language-C">#if defined(CONFIG_APM) || defined(CONFIG_APM_MODULE)
    query_apm_bios();
#endif
</code></pre>
<p>The last is the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/edd.c#L122"><code>query_edd</code></a> function, which queries <code>Enhanced Disk Drive</code> information from the BIOS. Let's look at how <code>query_edd</code> is implemented.</p>
<p>First of all, it reads the <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/admin-guide/kernel-parameters.rst">edd</a> option from the kernel's command line and if it was set to <code>off</code> then <code>query_edd</code> just returns.</p>
<p>If EDD is enabled, <code>query_edd</code> goes over BIOS-supported hard disks and queries EDD information in the following loop:</p>
<pre><code class="language-C">for (devno = 0x80; devno &lt; 0x80+EDD_MBR_SIG_MAX; devno++) {
    if (!get_edd_info(devno, &amp;ei) &amp;&amp; boot_params.eddbuf_entries &lt; EDDMAXNR) {
        memcpy(edp, &amp;ei, sizeof ei);
        edp++;
        boot_params.eddbuf_entries++;
    }
    ...
    ...
    ...
    }
</code></pre>
<p>where <code>0x80</code> is the first hard drive and the value of the <code>EDD_MBR_SIG_MAX</code> macro is 16. It collects data into an array of <a href="https://github.com/torvalds/linux/blob/v4.16/include/uapi/linux/edd.h">edd_info</a> structures. <code>get_edd_info</code> checks that EDD is present by invoking the <code>0x13</code> interrupt with <code>ah</code> as <code>0x41</code> and if EDD is present, <code>get_edd_info</code> again calls the <code>0x13</code> interrupt, but with <code>ah</code> as <code>0x48</code> and <code>si</code> containing the address of the buffer where EDD information will be stored.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>This is the end of the second part about the insides of the Linux kernel. In the next part, we will see video mode setting and the rest of the preparations before the transition to protected mode and directly transitioning into it.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-internals">linux-insides</a>.</strong></p>
<h2 id="links-1"><a class="header" href="#links-1">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Protected_mode">Protected mode</a></li>
<li><a href="http://wiki.osdev.org/Protected_Mode">Protected mode</a></li>
<li><a href="http://en.wikipedia.org/wiki/Long_mode">Long mode</a></li>
<li><a href="http://www.codeproject.com/Articles/45788/The-Real-Protected-Long-mode-assembly-tutorial-for">Nice explanation of CPU Modes with code</a></li>
<li><a href="http://www.sudleyplace.com/dpmione/expanddown.html">How to Use Expand Down Segments on Intel 386 and Later CPUs</a></li>
<li><a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/earlyprintk.txt">earlyprintk documentation</a></li>
<li><a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/admin-guide/kernel-parameters.rst">Kernel Parameters</a></li>
<li><a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/admin-guide/serial-console.rst">Serial console</a></li>
<li><a href="http://en.wikipedia.org/wiki/SpeedStep">Intel SpeedStep</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Power_Management">APM</a></li>
<li><a href="http://www.t13.org/documents/UploadedDocuments/docs2004/d1572r3-EDD3.pdf">EDD specification</a></li>
<li><a href="http://www.tldp.org/HOWTO/Linux-i386-Boot-Code-HOWTO/setup.html">TLDP documentation for Linux Boot Process</a> (old)</li>
<li><a href="Booting/linux-bootstrap-1.html">Previous Part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-booting-process-part-3"><a class="header" href="#kernel-booting-process-part-3">Kernel booting process. Part 3.</a></h1>
<h2 id="video-mode-initialization-and-transition-to-protected-mode"><a class="header" href="#video-mode-initialization-and-transition-to-protected-mode">Video mode initialization and transition to protected mode</a></h2>
<p>This is the third part of the <code>Kernel booting process</code> series. In the previous <a href="Booting/linux-bootstrap-2.html#kernel-booting-process-part-2">part</a>, we stopped right before the call to the <code>set_video</code> routine from <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c">main.c</a>.</p>
<p>In this part, we will look at:</p>
<ul>
<li>Video mode initialization in the kernel setup code,</li>
<li>the preparations made before switching into protected mode,</li>
<li>the transition to protected mode</li>
</ul>
<p><strong>NOTE</strong> If you don't know anything about protected mode, you can find some information about it in the previous <a href="Booting/linux-bootstrap-2.html#protected-mode">part</a>. Also, there are a couple of <a href="Booting/linux-bootstrap-2.html#links">links</a> which can help you.</p>
<p>As I wrote above, we will start from the <code>set_video</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/video.c">arch/x86/boot/video.c</a> source code file. We can see that it starts by first getting the video mode from the <code>boot_params.hdr</code> structure:</p>
<pre><code class="language-C">u16 mode = boot_params.hdr.vid_mode;
</code></pre>
<p>which we filled in the <code>copy_boot_params</code> function (you can read about it in the previous post). <code>vid_mode</code> is an obligatory field which is filled by the bootloader. You can find information about it in the kernel <code>boot protocol</code>:</p>
<pre><code>Offset	Proto	Name		Meaning
/Size
01FA/2	ALL	    vid_mode	Video mode control
</code></pre>
<p>As we can read from the Linux kernel boot protocol:</p>
<pre><code>vga=&lt;mode&gt;
	&lt;mode&gt; here is either an integer (in C notation, either
	decimal, octal, or hexadecimal) or one of the strings
	&quot;normal&quot; (meaning 0xFFFF), &quot;ext&quot; (meaning 0xFFFE) or &quot;ask&quot;
	(meaning 0xFFFD). This value should be entered into the
	vid_mode field, as it is used by the kernel before the command
	line is parsed.
</code></pre>
<p>So we can add the <code>vga</code> option to the grub (or another bootloader's) configuration file and it will pass this option to the kernel command line. This option can have different values as mentioned in the description. For example, it can be an integer number <code>0xFFFD</code> or <code>ask</code>. If you pass <code>ask</code> to <code>vga</code>, you will see a menu like this:</p>
<p><img src="Booting/images/video_mode_setup_menu.png" alt="video mode setup menu" /></p>
<p>which will ask to select a video mode. We will look at its implementation, but before diving into the implementation we have to look at some other things.</p>
<h2 id="kernel-data-types"><a class="header" href="#kernel-data-types">Kernel data types</a></h2>
<p>Earlier we saw definitions of different data types like <code>u16</code> etc. in the kernel setup code. Let's look at a couple of data types provided by the kernel:</p>
<table><thead><tr><th>Type</th><th>char</th><th>short</th><th>int</th><th>long</th><th>u8</th><th>u16</th><th>u32</th><th>u64</th></tr></thead><tbody>
<tr><td>Size</td><td>1</td><td>2</td><td>4</td><td>8</td><td>1</td><td>2</td><td>4</td><td>8</td></tr>
</tbody></table>
<p>If you read the source code of the kernel, you'll see these very often and so it will be good to remember them.</p>
<h2 id="heap-api"><a class="header" href="#heap-api">Heap API</a></h2>
<p>After we get <code>vid_mode</code> from <code>boot_params.hdr</code> in the <code>set_video</code> function, we can see the call to the <code>RESET_HEAP</code> function. <code>RESET_HEAP</code> is a macro which is defined in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/boot.h">arch/x86/boot/boot.h</a> header file.</p>
<p>This macro is defined as:</p>
<pre><code class="language-C">#define RESET_HEAP() ((void *)( HEAP = _end ))
</code></pre>
<p>If you have read the second part, you will remember that we initialized the heap with the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c"><code>init_heap</code></a> function. We have a couple of utility macros and functions for managing the heap which are defined in <code>arch/x86/boot/boot.h</code> header file.</p>
<p>They are:</p>
<pre><code class="language-C">#define RESET_HEAP()
</code></pre>
<p>As we saw just above, it resets the heap by setting the <code>HEAP</code> variable to <code>_end</code>, where <code>_end</code> is just <code>extern char _end[];</code></p>
<p>Next is the <code>GET_HEAP</code> macro:</p>
<pre><code class="language-C">#define GET_HEAP(type, n) \
	((type *)__get_heap(sizeof(type),__alignof__(type),(n)))
</code></pre>
<p>for heap allocation. It calls the internal function <code>__get_heap</code> with 3 parameters:</p>
<ul>
<li>the size of the datatype to be allocated for</li>
<li><code>__alignof__(type)</code> specifies how variables of this type are to be aligned</li>
<li><code>n</code> specifies how many items to allocate</li>
</ul>
<p>The implementation of <code>__get_heap</code> is:</p>
<pre><code class="language-C">static inline char *__get_heap(size_t s, size_t a, size_t n)
{
	char *tmp;

	HEAP = (char *)(((size_t)HEAP+(a-1)) &amp; ~(a-1));
	tmp = HEAP;
	HEAP += s*n;
	return tmp;
}
</code></pre>
<p>and we will further see its usage, something like:</p>
<pre><code class="language-C">saved.data = GET_HEAP(u16, saved.x * saved.y);
</code></pre>
<p>Let's try to understand how <code>__get_heap</code> works. We can see here that <code>HEAP</code> (which is equal to <code>_end</code> after <code>RESET_HEAP()</code>) is assigned the address of the aligned memory according to the <code>a</code> parameter. After this we save the memory address from <code>HEAP</code> to the <code>tmp</code> variable, move <code>HEAP</code> to the end of the allocated block and return <code>tmp</code> which is the start address of allocated memory.</p>
<p>And the last function is:</p>
<pre><code class="language-C">static inline bool heap_free(size_t n)
{
	return (int)(heap_end - HEAP) &gt;= (int)n;
}
</code></pre>
<p>which subtracts value of the <code>HEAP</code> pointer from the <code>heap_end</code> (we calculated it in the previous <a href="Booting/linux-bootstrap-2.html">part</a>) and returns 1 if there is enough memory available for <code>n</code>.</p>
<p>That's all. Now we have a simple API for heap and can setup video mode.</p>
<h2 id="set-up-video-mode"><a class="header" href="#set-up-video-mode">Set up video mode</a></h2>
<p>Now we can move directly to video mode initialization. We stopped at the <code>RESET_HEAP()</code> call in the <code>set_video</code> function. Next is the call to  <code>store_mode_params</code> which stores video mode parameters in the <code>boot_params.screen_info</code> structure which is defined in <a href="https://github.com/torvalds/linux/blob/v4.16/include/uapi/linux/screen_info.h">include/uapi/linux/screen_info.h</a> header file.</p>
<p>If we look at the <code>store_mode_params</code> function, we can see that it starts with a call to the <code>store_cursor_position</code> function. As you can understand from the function name, it gets information about the cursor and stores it.</p>
<p>First of all, <code>store_cursor_position</code> initializes two variables which have type <code>biosregs</code> with <code>AH = 0x3</code>, and calls the <code>0x10</code> BIOS interruption. After the interruption is successfully executed, it returns row and column in the <code>DL</code> and <code>DH</code> registers. Row and column will be stored in the <code>orig_x</code> and <code>orig_y</code> fields of the <code>boot_params.screen_info</code> structure.</p>
<p>After <code>store_cursor_position</code> is executed, the <code>store_video_mode</code> function will be called. It just gets the current video mode and stores it in <code>boot_params.screen_info.orig_video_mode</code>.</p>
<p>After this, <code>store_mode_params</code> checks the current video mode and sets the <code>video_segment</code>. After the BIOS transfers control to the boot sector, the following addresses are for video memory:</p>
<pre><code>0xB000:0x0000 	32 Kb 	Monochrome Text Video Memory
0xB800:0x0000 	32 Kb 	Color Text Video Memory
</code></pre>
<p>So we set the <code>video_segment</code> variable to <code>0xb000</code> if the current video mode is MDA, HGC, or VGA in monochrome mode and to <code>0xb800</code> if the current video mode is in color mode. After setting up the address of the video segment, the font size needs to be stored in <code>boot_params.screen_info.orig_video_points</code> with:</p>
<pre><code class="language-C">set_fs(0);
font_size = rdfs16(0x485);
boot_params.screen_info.orig_video_points = font_size;
</code></pre>
<p>First of all, we put 0 in the <code>FS</code> register with the <code>set_fs</code> function. We already saw functions like <code>set_fs</code> in the previous part. They are all defined in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/boot.h">arch/x86/boot/boot.h</a>. Next, we read the value which is located at address <code>0x485</code> (this memory location is used to get the font size) and save the font size in <code>boot_params.screen_info.orig_video_points</code>.</p>
<pre><code class="language-C">x = rdfs16(0x44a);
y = (adapter == ADAPTER_CGA) ? 25 : rdfs8(0x484)+1;
</code></pre>
<p>Next, we get the amount of columns by address <code>0x44a</code> and rows by address <code>0x484</code> and store them in <code>boot_params.screen_info.orig_video_cols</code> and <code>boot_params.screen_info.orig_video_lines</code>. After this, execution of <code>store_mode_params</code> is finished.</p>
<p>Next we can see the <code>save_screen</code> function which just saves the contents of the screen to the heap. This function collects all the data which we got in the previous functions (like the rows and columns, and stuff) and stores it in the <code>saved_screen</code> structure, which is defined as:</p>
<pre><code class="language-C">static struct saved_screen {
	int x, y;
	int curx, cury;
	u16 *data;
} saved;
</code></pre>
<p>It then checks whether the heap has free space for it with:</p>
<pre><code class="language-C">if (!heap_free(saved.x*saved.y*sizeof(u16)+512))
		return;
</code></pre>
<p>and allocates space in the heap if it is enough and stores <code>saved_screen</code> in it.</p>
<p>The next call is <code>probe_cards(0)</code> from <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/video-mode.c">arch/x86/boot/video-mode.c</a> source code file. It goes over all video_cards and collects the number of modes provided by the cards. Here is the interesting part, we can see the loop:</p>
<pre><code class="language-C">for (card = video_cards; card &lt; video_cards_end; card++) {
  /* collecting number of modes here */
}
</code></pre>
<p>but <code>video_cards</code> is not declared anywhere. The answer is simple: every video mode presented in the x86 kernel setup code has a definition that looks like this:</p>
<pre><code class="language-C">static __videocard video_vga = {
	.card_name	= &quot;VGA&quot;,
	.probe		= vga_probe,
	.set_mode	= vga_set_mode,
};
</code></pre>
<p>where <code>__videocard</code> is a macro:</p>
<pre><code class="language-C">#define __videocard struct card_info __attribute__((used,section(&quot;.videocards&quot;)))
</code></pre>
<p>which means that the <code>card_info</code> structure:</p>
<pre><code class="language-C">struct card_info {
	const char *card_name;
	int (*set_mode)(struct mode_info *mode);
	int (*probe)(void);
	struct mode_info *modes;
	int nmodes;
	int unsafe;
	u16 xmode_first;
	u16 xmode_n;
};
</code></pre>
<p>is in the <code>.videocards</code> segment. Let's look in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/setup.ld">arch/x86/boot/setup.ld</a> linker script, where we can find:</p>
<pre><code>	.videocards	: {
		video_cards = .;
		*(.videocards)
		video_cards_end = .;
	}
</code></pre>
<p>It means that <code>video_cards</code> is just a memory address and all <code>card_info</code> structures are placed in this segment. It means that all <code>card_info</code> structures are placed between <code>video_cards</code> and <code>video_cards_end</code>, so we can use a loop to go over all of it. After <code>probe_cards</code> executes we have a bunch of structures like <code>static __videocard video_vga</code> with the <code>nmodes</code> (the number of video modes) filled in.</p>
<p>After the <code>probe_cards</code> function is done, we move to the main loop in the <code>set_video</code> function. There is an infinite loop which tries to set up the video mode with the <code>set_mode</code> function or prints a menu if we passed <code>vid_mode=ask</code> to the kernel command line or if video mode is undefined.</p>
<p>The <code>set_mode</code> function is defined in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/video-mode.c">video-mode.c</a> and gets only one parameter, <code>mode</code>, which is the number of video modes (we got this value from the menu or in the start of <code>setup_video</code>, from the kernel setup header).</p>
<p>The <code>set_mode</code> function checks the <code>mode</code> and calls the <code>raw_set_mode</code> function. The <code>raw_set_mode</code> calls the selected card's <code>set_mode</code> function, i.e. <code>card-&gt;set_mode(struct mode_info*)</code>. We can get access to this function from the <code>card_info</code> structure. Every video mode defines this structure with values filled depending upon the video mode (for example for <code>vga</code> it is the <code>video_vga.set_mode</code> function. See the above example of the <code>card_info</code> structure for <code>vga</code>). <code>video_vga.set_mode</code> is <code>vga_set_mode</code>, which checks the vga mode and calls the respective function:</p>
<pre><code class="language-C">static int vga_set_mode(struct mode_info *mode)
{
	vga_set_basic_mode();

	force_x = mode-&gt;x;
	force_y = mode-&gt;y;

	switch (mode-&gt;mode) {
	case VIDEO_80x25:
		break;
	case VIDEO_8POINT:
		vga_set_8font();
		break;
	case VIDEO_80x43:
		vga_set_80x43();
		break;
	case VIDEO_80x28:
		vga_set_14font();
		break;
	case VIDEO_80x30:
		vga_set_80x30();
		break;
	case VIDEO_80x34:
		vga_set_80x34();
		break;
	case VIDEO_80x60:
		vga_set_80x60();
		break;
	}
	return 0;
}
</code></pre>
<p>Every function which sets up video mode just calls the <code>0x10</code> BIOS interrupt with a certain value in the <code>AH</code> register.</p>
<p>After we have set the video mode, we pass it to <code>boot_params.hdr.vid_mode</code>.</p>
<p>Next, <code>vesa_store_edid</code> is called. This function simply stores the <a href="https://en.wikipedia.org/wiki/Extended_Display_Identification_Data">EDID</a> (<strong>E</strong>xtended <strong>D</strong>isplay <strong>I</strong>dentification <strong>D</strong>ata) information for kernel use. After this <code>store_mode_params</code> is called again. Lastly, if <code>do_restore</code> is set, the screen is restored to an earlier state.</p>
<p>Having done this, the video mode setup is complete and now we can switch to the protected mode.</p>
<h2 id="last-preparation-before-transition-into-protected-mode"><a class="header" href="#last-preparation-before-transition-into-protected-mode">Last preparation before transition into protected mode</a></h2>
<p>We can see the last function call - <code>go_to_protected_mode</code> - in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/main.c">arch/x86/boot/main.c</a>. As the comment says: <code>Do the last things and invoke protected mode</code>, so let's see what these last things are and switch into protected mode.</p>
<p>The <code>go_to_protected_mode</code> function is defined in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/pm.c">arch/x86/boot/pm.c</a>. It contains some functions which make the last preparations before we can jump into protected mode, so let's look at it and try to understand what it does and how it works.</p>
<p>First is the call to the <code>realmode_switch_hook</code> function in <code>go_to_protected_mode</code>. This function invokes the real mode switch hook if it is present and disables <a href="http://en.wikipedia.org/wiki/Non-maskable_interrupt">NMI</a>. Hooks are used if the bootloader runs in a hostile environment. You can read more about hooks in the <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">boot protocol</a> (see <strong>ADVANCED BOOT LOADER HOOKS</strong>).</p>
<p>The <code>realmode_switch</code> hook presents a pointer to the 16-bit real mode far subroutine which disables non-maskable interrupts. After the <code>realmode_switch</code> hook (it isn't present for me) is checked, Non-Maskable Interrupts(NMI) is disabled:</p>
<pre><code class="language-assembly">asm volatile(&quot;cli&quot;);
outb(0x80, 0x70);	/* Disable NMI */
io_delay();
</code></pre>
<p>At first, there is an inline assembly statement with a <code>cli</code> instruction which clears the interrupt flag (<code>IF</code>). After this, external interrupts are disabled. The next line disables NMI (non-maskable interrupt).</p>
<p>An interrupt is a signal to the CPU which is emitted by hardware or software. After getting such a signal, the CPU suspends the current instruction sequence, saves its state and transfers control to the interrupt handler. After the interrupt handler has finished its work, it transfers control back to the interrupted instruction. Non-maskable interrupts (NMI) are interrupts which are always processed, independently of permission. They cannot be ignored and are typically used to signal for non-recoverable hardware errors. We will not dive into the details of interrupts now but we will be discussing them in the coming posts.</p>
<p>Let's get back to the code. We can see in the second line that we are writing the byte <code>0x80</code> (disabled bit) to <code>0x70</code> (the CMOS Address register). After that, a call to the <code>io_delay</code> function occurs. <code>io_delay</code> causes a small delay and looks like:</p>
<pre><code class="language-C">static inline void io_delay(void)
{
	const u16 DELAY_PORT = 0x80;
	asm volatile(&quot;outb %%al,%0&quot; : : &quot;dN&quot; (DELAY_PORT));
}
</code></pre>
<p>To output any byte to the port <code>0x80</code> should delay exactly 1 microsecond. So we can write any value (the value from <code>AL</code> in our case) to the <code>0x80</code> port. After this delay the <code>realmode_switch_hook</code> function has finished execution and we can move to the next function.</p>
<p>The next function is <code>enable_a20</code>, which enables the <a href="http://en.wikipedia.org/wiki/A20_line">A20 line</a>. This function is defined in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/a20.c">arch/x86/boot/a20.c</a> and it tries to enable the A20 gate with different methods. The first is the <code>a20_test_short</code> function which checks if A20 is already enabled or not with the <code>a20_test</code> function:</p>
<pre><code class="language-C">static int a20_test(int loops)
{
	int ok = 0;
	int saved, ctr;

	set_fs(0x0000);
	set_gs(0xffff);

	saved = ctr = rdfs32(A20_TEST_ADDR);

	while (loops--) {
		wrfs32(++ctr, A20_TEST_ADDR);
		io_delay();	/* Serialize and make delay constant */
		ok = rdgs32(A20_TEST_ADDR+0x10) ^ ctr;
		if (ok)
			break;
	}

	wrfs32(saved, A20_TEST_ADDR);
	return ok;
}
</code></pre>
<p>First of all, we put <code>0x0000</code> in the <code>FS</code> register and <code>0xffff</code> in the <code>GS</code> register. Next, we read the value at the address <code>A20_TEST_ADDR</code> (it is <code>0x200</code>) and put this value into the variables <code>saved</code> and <code>ctr</code>.</p>
<p>Next, we write an updated <code>ctr</code> value into <code>fs:A20_TEST_ADDR</code> or <code>fs:0x200</code> with the <code>wrfs32</code> function, then delay for 1ms, and then read the value from the <code>GS</code> register into the address <code>A20_TEST_ADDR+0x10</code>. In a case when <code>a20</code> line is disabled, the address will be overlapped, in other case if it's not zero <code>a20</code> line is already enabled the A20 line.</p>
<p>If A20 is disabled, we try to enable it with a different method which you can find in <code>a20.c</code>. For example, it can be done with a call to the <code>0x15</code> BIOS interrupt with <code>AH=0x2041</code>.</p>
<p>If the <code>enable_a20</code> function finished with a failure, print an error message and call the function <code>die</code>. You can remember it from the first source code file where we started - <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/header.S">arch/x86/boot/header.S</a>:</p>
<pre><code class="language-assembly">die:
	hlt
	jmp	die
	.size	die, .-die
</code></pre>
<p>After the A20 gate is successfully enabled, the <code>reset_coprocessor</code> function is called:</p>
<pre><code class="language-C">outb(0, 0xf0);
outb(0, 0xf1);
</code></pre>
<p>This function clears the Math Coprocessor by writing <code>0</code> to <code>0xf0</code> and then resets it by writing <code>0</code> to <code>0xf1</code>.</p>
<p>After this, the <code>mask_all_interrupts</code> function is called:</p>
<pre><code class="language-C">outb(0xff, 0xa1);       /* Mask all interrupts on the secondary PIC */
outb(0xfb, 0x21);       /* Mask all but cascade on the primary PIC */
</code></pre>
<p>This masks all interrupts on the secondary PIC (Programmable Interrupt Controller) and primary PIC except for IRQ2 on the primary PIC.</p>
<p>And after all of these preparations, we can see the actual transition into protected mode.</p>
<h2 id="set-up-the-interrupt-descriptor-table"><a class="header" href="#set-up-the-interrupt-descriptor-table">Set up the Interrupt Descriptor Table</a></h2>
<p>Now we set up the Interrupt Descriptor table (IDT) in the <code>setup_idt</code> function:</p>
<pre><code class="language-C">static void setup_idt(void)
{
	static const struct gdt_ptr null_idt = {0, 0};
	asm volatile(&quot;lidtl %0&quot; : : &quot;m&quot; (null_idt));
}
</code></pre>
<p>which sets up the Interrupt Descriptor Table (describes interrupt handlers and etc.). For now, the IDT is not installed (we will see it later), but now we just load the IDT with the <code>lidtl</code> instruction. <code>null_idt</code> contains the address and size of the IDT, but for now they are just zero. <code>null_idt</code> is a <code>gdt_ptr</code> structure, it is defined as:</p>
<pre><code class="language-C">struct gdt_ptr {
	u16 len;
	u32 ptr;
} __attribute__((packed));
</code></pre>
<p>where we can see the 16-bit length(<code>len</code>) of the IDT and the 32-bit pointer to it (More details about the IDT and interruptions will be seen in the next posts). <code> __attribute__((packed))</code> means that the size of <code>gdt_ptr</code> is the minimum required size. So the size of the <code>gdt_ptr</code> will be 6 bytes here or 48 bits. (Next we will load the pointer to the <code>gdt_ptr</code> to the <code>GDTR</code> register and you might remember from the previous post that it is 48-bits in size).</p>
<h2 id="set-up-global-descriptor-table"><a class="header" href="#set-up-global-descriptor-table">Set up Global Descriptor Table</a></h2>
<p>Next is the setup of the Global Descriptor Table (GDT). We can see the <code>setup_gdt</code> function which sets up the GDT (you can read about it in the post <a href="Booting/linux-bootstrap-2.html#protected-mode">Kernel booting process. Part 2.</a>). There is a definition of the <code>boot_gdt</code> array in this function, which contains the definition of the three segments:</p>
<pre><code class="language-C">static const u64 boot_gdt[] __attribute__((aligned(16))) = {
	[GDT_ENTRY_BOOT_CS] = GDT_ENTRY(0xc09b, 0, 0xfffff),
	[GDT_ENTRY_BOOT_DS] = GDT_ENTRY(0xc093, 0, 0xfffff),
	[GDT_ENTRY_BOOT_TSS] = GDT_ENTRY(0x0089, 4096, 103),
};
</code></pre>
<p>for code, data and TSS (Task State Segment). We will not use the task state segment for now, it was added there to make Intel VT happy as we can see in the comment line (if you're interested you can find the commit which describes it - <a href="https://github.com/torvalds/linux/commit/88089519f302f1296b4739be45699f06f728ec31">here</a>). Let's look at <code>boot_gdt</code>. First of all note that it has the <code>__attribute__((aligned(16)))</code> attribute. It means that this structure will be aligned by 16 bytes.</p>
<p>Let's look at a simple example:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

struct aligned {
	int a;
}__attribute__((aligned(16)));

struct nonaligned {
	int b;
};

int main(void)
{
	struct aligned    a;
	struct nonaligned na;

	printf(&quot;Not aligned - %zu \n&quot;, sizeof(na));
	printf(&quot;Aligned - %zu \n&quot;, sizeof(a));

	return 0;
}
</code></pre>
<p>Technically a structure which contains one <code>int</code> field must be 4 bytes in size, but an <code>aligned</code> structure will need 16 bytes to store in memory:</p>
<pre><code>$ gcc test.c -o test &amp;&amp; test
Not aligned - 4
Aligned - 16
</code></pre>
<p>The <code>GDT_ENTRY_BOOT_CS</code> has index - 2 here, <code>GDT_ENTRY_BOOT_DS</code> is <code>GDT_ENTRY_BOOT_CS + 1</code> and etc. It starts from 2, because the first is a mandatory null descriptor (index - 0) and the second is not used (index - 1).</p>
<p><code>GDT_ENTRY</code> is a macro which takes flags, base, limit and builds a GDT entry. For example, let's look at the code segment entry. <code>GDT_ENTRY</code> takes the following values:</p>
<ul>
<li>base  - 0</li>
<li>limit - 0xfffff</li>
<li>flags - 0xc09b</li>
</ul>
<p>What does this mean? The segment's base address is 0, and the limit (size of segment) is - <code>0xfffff</code> (1 MB). Let's look at the flags. It is <code>0xc09b</code> and it will be:</p>
<pre><code>1100 0000 1001 1011
</code></pre>
<p>in binary. Let's try to understand what every bit means. We will go through all bits from left to right:</p>
<ul>
<li>1    - (G) granularity bit</li>
<li>1    - (D) if 0 16-bit segment; 1 = 32-bit segment</li>
<li>0    - (L) executed in 64-bit mode if 1</li>
<li>0    - (AVL) available for use by system software</li>
<li>0000 - 4-bit length 19:16 bits in the descriptor</li>
<li>1    - (P) segment presence in memory</li>
<li>00   - (DPL) - privilege level, 0 is the highest privilege</li>
<li>1    - (S) code or data segment, not a system segment</li>
<li>101  - segment type execute/read/</li>
<li>1    - accessed bit</li>
</ul>
<p>You can read more about every bit in the previous <a href="Booting/linux-bootstrap-2.html">post</a> or in the <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel® 64 and IA-32 Architectures Software Developer's Manuals 3A</a>.</p>
<p>After this we get the length of the GDT with:</p>
<pre><code class="language-C">gdt.len = sizeof(boot_gdt)-1;
</code></pre>
<p>We get the size of <code>boot_gdt</code> and subtract 1 (the last valid address in the GDT).</p>
<p>Next we get a pointer to the GDT with:</p>
<pre><code class="language-C">gdt.ptr = (u32)&amp;boot_gdt + (ds() &lt;&lt; 4);
</code></pre>
<p>Here we just get the address of <code>boot_gdt</code> and add it to the address of the data segment left-shifted by 4 bits (remember we're in real mode now).</p>
<p>Lastly we execute the <code>lgdtl</code> instruction to load the GDT into the GDTR register:</p>
<pre><code class="language-C">asm volatile(&quot;lgdtl %0&quot; : : &quot;m&quot; (gdt));
</code></pre>
<h2 id="actual-transition-into-protected-mode"><a class="header" href="#actual-transition-into-protected-mode">Actual transition into protected mode</a></h2>
<p>This is the end of the <code>go_to_protected_mode</code> function. We loaded the IDT and GDT, disabled interrupts and now can switch the CPU into protected mode. The last step is calling the <code>protected_mode_jump</code> function with two parameters:</p>
<pre><code class="language-C">protected_mode_jump(boot_params.hdr.code32_start, (u32)&amp;boot_params + (ds() &lt;&lt; 4));
</code></pre>
<p>which is defined in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/pmjump.S">arch/x86/boot/pmjump.S</a>.</p>
<p>It takes two parameters:</p>
<ul>
<li>address of the protected mode entry point</li>
<li>address of <code>boot_params</code></li>
</ul>
<p>Let's look inside <code>protected_mode_jump</code>. As I wrote above, you can find it in <code>arch/x86/boot/pmjump.S</code>. The first parameter will be in the <code>eax</code> register and the second one is in <code>edx</code>.</p>
<p>First of all, we put the address of <code>boot_params</code> in the <code>esi</code> register and the address of the code segment register <code>cs</code> in <code>bx</code>. </p>
<pre><code class="language-assembly">GLOBAL(protected_mode_jump)
	movl	%edx, %esi	# Pointer to boot_params table

	xorl	%ebx, %ebx
	movw	%cs, %bx
</code></pre>
<p>After this, we shift <code>bx</code> by 4 bits and add it to the memory location labeled <code>2</code> (which is <code>(cs &lt;&lt; 4) + in_pm32</code>, the physical address to jump after transitioned to 32-bit mode) and jump to label <code>1</code>. </p>
<pre><code class="language-assembly">	shll	$4, %ebx
	addl	%ebx, 2f 	# Add %ebx to the value stored at label 2
	jmp	1f		# Short jump to serialize on 386/486
</code></pre>
<p>So after this <code>in_pm32</code> in label <code>2</code> will be overwritten with <code>(cs &lt;&lt; 4) + in_pm32</code>.</p>
<p>Next we put the data segment and the task state segment in the <code>cx</code> and <code>di</code> registers with:</p>
<pre><code class="language-assembly">	movw	$__BOOT_DS, %cx
	movw	$__BOOT_TSS, %di
</code></pre>
<p>As you can read above <code>GDT_ENTRY_BOOT_CS</code> has index 2 and every GDT entry is 8 byte, so <code>CS</code> will be <code>2 * 8 = 16</code>, <code>__BOOT_DS</code> is 24 etc.</p>
<p>Next, we set the <code>PE</code> (Protection Enable) bit in the <code>CR0</code> control register:</p>
<pre><code class="language-assembly">	movl	%cr0, %edx
	orb	$X86_CR0_PE, %dl
	movl	%edx, %cr0
</code></pre>
<p>and make a long jump to protected mode:</p>
<pre><code class="language-assembly">	.byte	0x66, 0xea
2:	.long	in_pm32
	.word	__BOOT_CS
</code></pre>
<p>where:</p>
<ul>
<li><code>0x66</code> is the operand-size prefix which allows us to mix 16-bit and 32-bit code</li>
<li><code>0xea</code> - is the jump opcode</li>
<li><code>in_pm32</code> is the segment offset under protect mode, which has value <code>(cs &lt;&lt; 4) + in_pm32</code> derived from real mode</li>
<li><code>__BOOT_CS</code> is the code segment we want to jump to.</li>
</ul>
<p>After this we are finally in protected mode:</p>
<pre><code class="language-assembly">.code32
.section &quot;.text32&quot;,&quot;ax&quot;
</code></pre>
<p>Let's look at the first steps taken in protected mode. First of all we set up the data segment with:</p>
<pre><code class="language-assembly">movl	%ecx, %ds
movl	%ecx, %es
movl	%ecx, %fs
movl	%ecx, %gs
movl	%ecx, %ss
</code></pre>
<p>If you paid attention, you can remember that we saved <code>$__BOOT_DS</code> in the <code>cx</code> register. Now we fill it with all segment registers besides <code>cs</code> (<code>cs</code> is already <code>__BOOT_CS</code>).</p>
<p>And setup a valid stack for debugging purposes:</p>
<pre><code class="language-assembly">addl	%ebx, %esp
</code></pre>
<p>The last step before the jump into 32-bit entry point is to clear the general purpose registers:</p>
<pre><code class="language-assembly">xorl	%ecx, %ecx
xorl	%edx, %edx
xorl	%ebx, %ebx
xorl	%ebp, %ebp
xorl	%edi, %edi
</code></pre>
<p>And jump to the 32-bit entry point in the end:</p>
<pre><code>jmpl	*%eax
</code></pre>
<p>Remember that <code>eax</code> contains the address of the 32-bit entry (we passed it as the first parameter into <code>protected_mode_jump</code>).</p>
<p>That's all. We're in protected mode and stop at its entry point. We will see what happens next in the next part.</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>This is the end of the third part about Linux kernel insides. In the next part, we will look at the first steps we take in protected mode and transition into <a href="http://en.wikipedia.org/wiki/Long_mode">long mode</a>.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes, please send me a PR with corrections at <a href="https://github.com/0xAX/linux-internals">linux-insides</a>.</strong></p>
<h2 id="links-2"><a class="header" href="#links-2">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Video_Graphics_Array">VGA</a></li>
<li><a href="http://en.wikipedia.org/wiki/VESA_BIOS_Extensions">VESA BIOS Extensions</a></li>
<li><a href="http://en.wikipedia.org/wiki/Data_structure_alignment">Data structure alignment</a></li>
<li><a href="http://en.wikipedia.org/wiki/Non-maskable_interrupt">Non-maskable interrupt</a></li>
<li><a href="http://en.wikipedia.org/wiki/A20_line">A20</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Designated-Inits.html">GCC designated inits</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html">GCC type attributes</a></li>
<li><a href="Booting/linux-bootstrap-2.html">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-booting-process-part-4"><a class="header" href="#kernel-booting-process-part-4">Kernel booting process. Part 4.</a></h1>
<h2 id="the-transition-to-64-bit-mode"><a class="header" href="#the-transition-to-64-bit-mode">The Transition to 64-bit mode</a></h2>
<p>This is the fourth part of the <code>Kernel booting process</code>. Here, we will learn about the first steps taken in <a href="http://en.wikipedia.org/wiki/Protected_mode">protected mode</a>, like checking if the CPU supports <a href="http://en.wikipedia.org/wiki/Long_mode">long mode</a> and <a href="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a>. We will initialize the page tables with <a href="http://en.wikipedia.org/wiki/Paging">paging</a> and, at the end, transition the CPU to <a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a>.</p>
<p><strong>NOTE: there will be lots of assembly code in this part, so if you are not familiar with that, you might want to consult a book about it</strong></p>
<p>In the previous <a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-3.md">part</a> we stopped at the jump to the <code>32-bit</code> entry point in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/pmjump.S">arch/x86/boot/pmjump.S</a>:</p>
<pre><code class="language-assembly">jmpl	*%eax
</code></pre>
<p>You will recall that the <code>eax</code> register contains the address of the 32-bit entry point. We can read about this in the <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">linux kernel x86 boot protocol</a>:</p>
<pre><code>When using bzImage, the protected-mode kernel was relocated to 0x100000
</code></pre>
<p>Let's make sure that this is so by looking at the register values at the 32-bit entry point:</p>
<pre><code>eax            0x100000	1048576
ecx            0x0	    0
edx            0x0	    0
ebx            0x0	    0
esp            0x1ff5c	0x1ff5c
ebp            0x0	    0x0
esi            0x14470	83056
edi            0x0	    0
eip            0x100000	0x100000
eflags         0x46	    [ PF ZF ]
cs             0x10	16
ss             0x18	24
ds             0x18	24
es             0x18	24
fs             0x18	24
gs             0x18	24
</code></pre>
<p>We can see here that the <code>cs</code> register contains a value of <code>0x10</code> (as you might recall from the <a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-3.md">previous part</a>, this is the second index in the <code>Global Descriptor Table</code>), the <code>eip</code> register contains the value <code>0x100000</code> and the base address of all segments including the code segment are zero.</p>
<p>So, the physical address where the kernel is loaded would be <code>0:0x100000</code> or just <code>0x100000</code>, as specified by the boot protocol. Now let's start with the <code>32-bit</code> entry point.</p>
<h2 id="the-32-bit-entry-point"><a class="header" href="#the-32-bit-entry-point">The 32-bit entry point</a></h2>
<p>The <code>32-bit</code> entry point is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly source code file:</p>
<pre><code class="language-assembly">	__HEAD
	.code32
ENTRY(startup_32)
....
....
....
ENDPROC(startup_32)
</code></pre>
<p>First, why is the directory named <code>compressed</code>? The answer to that is that <code>bzimage</code> is a gzipped package consisting of <code>vmlinux</code>,   <code>header</code> and <code> kernel setup code</code>. We looked at kernel setup code in all of the previous parts. The main goal of the code in <code>head_64.S</code> is to prepare to enter long mode, enter it and then decompress the kernel. We will look at all of the steps leading to kernel decompression in this part.</p>
<p>You will find two files in the <code>arch/x86/boot/compressed</code> directory:</p>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_32.S">head_32.S</a></li>
<li><a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">head_64.S</a></li>
</ul>
<p>but we will consider only the <code>head_64.S</code> source code file because, as you may remember, this book is only <code>x86_64</code> related; Let's look at <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/Makefile">arch/x86/boot/compressed/Makefile</a>. We can find the following <code>make</code> target here:</p>
<pre><code class="language-Makefile">vmlinux-objs-y := $(obj)/vmlinux.lds $(obj)/head_$(BITS).o $(obj)/misc.o \
	$(obj)/string.o $(obj)/cmdline.o \
	$(obj)/piggy.o $(obj)/cpuflags.o
</code></pre>
<p>The first line contains this- <code>$(obj)/head_$(BITS).o</code>.</p>
<p>This means that we will select which file to link based on what <code>$(BITS)</code> is set to, either <code>head_32.o</code> or <code>head_64.o</code>. The <code>$(BITS)</code> variable is defined elsewhere in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/Makefile">arch/x86/Makefile</a> based on the kernel configuration:</p>
<pre><code class="language-Makefile">ifeq ($(CONFIG_X86_32),y)
        BITS := 32
        ...
        ...
else
        BITS := 64
        ...
        ...
endif
</code></pre>
<p>Now that we know where to start, let's get to it.</p>
<h2 id="reload-the-segments-if-needed"><a class="header" href="#reload-the-segments-if-needed">Reload the segments if needed</a></h2>
<p>As indicated above, we start in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly source code file. We first see the definition of a special section attribute before the definition of the <code>startup_32</code> function:</p>
<pre><code class="language-assembly">    __HEAD
    .code32
ENTRY(startup_32)
</code></pre>
<p><code>__HEAD</code> is a macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init.h">include/linux/init.h</a> header file and expands to the definition of the following section:</p>
<pre><code class="language-C">#define __HEAD		.section	&quot;.head.text&quot;,&quot;ax&quot;
</code></pre>
<p>Here, <code>.head.text</code> is the name of the section and <code>ax</code> is a set of flags. In our case, these flags show us that this section is <a href="https://en.wikipedia.org/wiki/Executable">executable</a> or in other words contains code. We can find the definition of this section in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/vmlinux.lds.S">arch/x86/boot/compressed/vmlinux.lds.S</a> linker script:</p>
<pre><code>SECTIONS
{
	. = 0;
	.head.text : {
		_head = . ;
		HEAD_TEXT
		_ehead = . ;
     }
     ...
     ...
     ...
}
</code></pre>
<p>If you are not familiar with the syntax of the <code>GNU LD</code> linker scripting language, you can find more information in its <a href="https://sourceware.org/binutils/docs/ld/Scripts.html#Scripts">documentation</a>. In short, the <code>.</code> symbol is a special linker variable, the location counter. The value assigned to it is an offset relative to the segment. In our case, we set the location counter to zero. This means that our code is linked to run from an offset of <code>0</code> in memory. This is also stated in the comments:</p>
<pre><code>Be careful parts of head_64.S assume startup_32 is at address 0.
</code></pre>
<p>Now that we have our bearings, let's look at the contents of the <code>startup_32</code> function.</p>
<p>In the beginning of the <code>startup_32</code> function, we can see the <code>cld</code> instruction which clears the <code>DF</code> bit in the <a href="https://en.wikipedia.org/wiki/FLAGS_register">flags</a> register. When the direction flag is clear, all string operations like <a href="http://x86.renejeschke.de/html/file_module_x86_id_306.html">stos</a>, <a href="http://x86.renejeschke.de/html/file_module_x86_id_287.html">scas</a> and others will increment the index registers <code>esi</code> or <code>edi</code>. We need to clear the direction flag because later we will use strings operations to perform various operations such as clearing space for page tables.</p>
<p>After we have cleared the <code>DF</code> bit, the next step is to check the <code>KEEP_SEGMENTS</code> flag in the <code>loadflags</code> kernel setup header field. If you remember, we already talked about <code>loadflags</code> in the very first <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-1">part</a> of this book. There we checked the <code>CAN_USE_HEAP</code> flag to query the ability to use the heap. Now we need to check the <code>KEEP_SEGMENTS</code> flag. This flag is described in the Linux <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">boot protocol</a> documentation:</p>
<pre><code>Bit 6 (write): KEEP_SEGMENTS
  Protocol: 2.07+
  - If 0, reload the segment registers in the 32bit entry point.
  - If 1, do not reload the segment registers in the 32bit entry point.
    Assume that %cs %ds %ss %es are all set to flat segments with
		a base of 0 (or the equivalent for their environment).
</code></pre>
<p>So, if the <code>KEEP_SEGMENTS</code> bit is not set in <code>loadflags</code>, we need to set the <code>ds</code>, <code>ss</code> and <code>es</code> segment registers to the index of the data segment with a base of <code>0</code>. That we do:</p>
<pre><code class="language-C">	testb $KEEP_SEGMENTS, BP_loadflags(%esi)
	jnz 1f

	cli
	movl	$(__BOOT_DS), %eax
	movl	%eax, %ds
	movl	%eax, %es
	movl	%eax, %ss
</code></pre>
<p>Remember that <code>__BOOT_DS</code> is <code>0x18</code> (the index of the data segment in the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a>). If <code>KEEP_SEGMENTS</code> is set, we jump to the nearest <code>1f</code> label or update segment registers with <code>__BOOT_DS</code> if they are not set. This is all pretty easy, but here's something to consider. If you've read the previous <a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-3.md">part</a>, you may remember that we already updated these segment registers right after we switched to <a href="https://en.wikipedia.org/wiki/Protected_mode">protected mode</a> in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/pmjump.S">arch/x86/boot/pmjump.S</a>. So why do we need to care about the values in the segment registers again? The answer is easy. The Linux kernel also has a 32-bit boot protocol and if a bootloader uses <em>that</em> to load the Linux kernel, all the code before the <code>startup_32</code> function will be missed. In this case, the <code>startup_32</code> function would be the first entry point to the Linux kernel right after the bootloader and there are no guarantees that the segment registers will be in a known state.</p>
<p>After we have checked the <code>KEEP_SEGMENTS</code> flag and set the segment registers to a correct value, the next step is to calculate the difference between where the kernel is compiled to run, and where we loaded it. Remember that <code>setup.ld.S</code> contains the following definition: <code>. = 0</code> at the start of the <code>.head.text</code> section. This means that the code in this section is compiled to run at the address <code>0</code>. We can see this in the output of <code>objdump</code>:</p>
<pre><code>arch/x86/boot/compressed/vmlinux:     file format elf64-x86-64


Disassembly of section .head.text:

0000000000000000 &lt;startup_32&gt;:
   0:   fc                      cld
   1:   f6 86 11 02 00 00 40    testb  $0x40,0x211(%rsi)
</code></pre>
<p>The <code>objdump</code> util tells us that the address of the <code>startup_32</code> function is <code>0</code> but that isn't so. We now need to know where we actually are. This is pretty simple to do in <a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a> because it supports <code>rip</code> relative addressing, but currently we are in <a href="https://en.wikipedia.org/wiki/Protected_mode">protected mode</a>. We will use a common pattern to find the address of the <code>startup_32</code> function. We need to define a label, make a call to it and pop the top of the stack to a register:</p>
<pre><code class="language-assembly">call label
label: pop %reg
</code></pre>
<p>After this, the register indicated by <code>%reg</code> will contain the address of <code>label</code>. Let's look at the code which uses this pattern to search for the <code>startup_32</code> function in the Linux kernel:</p>
<pre><code class="language-assembly">        leal	(BP_scratch+4)(%esi), %esp
        call	1f
1:      popl	%ebp
        subl	$1b, %ebp
</code></pre>
<p>As you remember from the previous part, the <code>esi</code> register contains the address of the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/include/uapi/asm/bootparam.h#L113">boot_params</a> structure which was filled before we moved to the protected mode. The <code>boot_params</code> structure contains a special field <code>scratch</code> with an offset of <code>0x1e4</code>. This four byte field is a temporary stack for the <code>call</code> instruction. We set <code>esp</code> to the address four bytes after the <code>BP_scratch</code> field of the <code>boot_params</code> structure. We add <code>4</code> bytes to the base of the <code>BP_scratch</code> field because, as just described, it will be a temporary stack and the stack grows from the top to bottom in the <code>x86_64</code> architecture. So our stack pointer will point to the top of the temporary stack. Next, we can see the pattern that I've described above. We make a call to the <code>1f</code> label and pop the top of the stack onto <code>ebp</code>. This works because <code>call</code> stores the return address of the current function on the top of the stack. We now have the address of the <code>1f</code> label and can now easily get the address of the <code>startup_32</code> function. We just need to subtract the address of the label from the address we got from the stack:</p>
<pre><code>startup_32 (0x0)     +-----------------------+
                     |                       |
                     |                       |
                     |                       |
                     |                       |
                     |                       |
                     |                       |
                     |                       |
                     |                       |
1f (0x0 + 1f offset) +-----------------------+ %ebp - real physical address
                     |                       |
                     |                       |
                     +-----------------------+
</code></pre>
<p>The <code>startup_32</code> function is linked to run at the address <code>0x0</code> and this means that <code>1f</code> has the address <code>0x0 + offset to 1f</code>, which is approximately <code>0x21</code> bytes. The <code>ebp</code> register contains the real physical address of the <code>1f</code> label. So, if we subtract <code>1f</code> from the <code>ebp</code> register, we will get the real physical address of the <code>startup_32</code> function. The Linux kernel <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">boot protocol</a> says the base of the protected mode kernel is <code>0x100000</code>. We can verify this with <a href="https://en.wikipedia.org/wiki/GNU_Debugger">gdb</a>. Let's start the debugger and add a breakpoint at the address of <code>1f</code>, which is <code>0x100021</code>. If this is correct we will see the value <code>0x100021</code> in the <code>ebp</code> register:</p>
<pre><code>$ gdb
(gdb)$ target remote :1234
Remote debugging using :1234
0x0000fff0 in ?? ()
(gdb)$ br *0x100022
Breakpoint 1 at 0x100022
(gdb)$ c
Continuing.

Breakpoint 1, 0x00100022 in ?? ()
(gdb)$ i r
eax            0x18	0x18
ecx            0x0	0x0
edx            0x0	0x0
ebx            0x0	0x0
esp            0x144a8	0x144a8
ebp            0x100021	0x100021
esi            0x142c0	0x142c0
edi            0x0	0x0
eip            0x100022	0x100022
eflags         0x46	[ PF ZF ]
cs             0x10	0x10
ss             0x18	0x18
ds             0x18	0x18
es             0x18	0x18
fs             0x18	0x18
gs             0x18	0x18
</code></pre>
<p>If we execute the next instruction, <code>subl $1b, %ebp</code>, we will see:</p>
<pre><code>(gdb) nexti
...
...
...
ebp            0x100000	0x100000
...
...
...
</code></pre>
<p>Ok, we've verified that the address of the <code>startup_32</code> function is <code>0x100000</code>. After we know the address of the <code>startup_32</code> label, we can prepare for the transition to <a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a>. Our next goal is to setup the stack and verify that the CPU supports long mode and <a href="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a>.</p>
<h2 id="stack-setup-and-cpu-verification"><a class="header" href="#stack-setup-and-cpu-verification">Stack setup and CPU verification</a></h2>
<p>We can't set up the stack until we know where in memory the <code>startup_32</code> label is. If we imagine the stack as an array, the stack pointer register <code>esp</code> must point to the end of it. Of course, we can define an array in our code, but we need to know its actual address to configure the stack pointer correctly. Let's look at the code:</p>
<pre><code class="language-assembly">	movl	$boot_stack_end, %eax
	addl	%ebp, %eax
	movl	%eax, %esp
</code></pre>
<p>The <code>boot_stack_end</code> label is also defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly source code file  and is located in the <a href="https://en.wikipedia.org/wiki/.bss">.bss</a> section:</p>
<pre><code class="language-assembly">	.bss
	.balign 4
boot_heap:
	.fill BOOT_HEAP_SIZE, 1, 0
boot_stack:
	.fill BOOT_STACK_SIZE, 1, 0
boot_stack_end:
</code></pre>
<p>First of all, we put the address of <code>boot_stack_end</code> into the <code>eax</code> register, so the <code>eax</code> register contains the address of <code>boot_stack_end</code> as it was linked, which is <code>0x0 + boot_stack_end</code>. To get the real address of <code>boot_stack_end</code>, we need to add the real address of the <code>startup_32</code> function. We've already found this address and put it into the <code>ebp</code> register. In the end, the  <code>eax</code> register will contain the real address of <code>boot_stack_end</code> and we just need to set the stack pointer to it.</p>
<p>After we have set up the stack, the next step is CPU verification. Since we are transitioning to <code>long mode</code>, we need to check that the CPU supports <code>long mode</code> and <code>SSE</code>. We will do this with a call to the <code>verify_cpu</code> function:</p>
<pre><code class="language-assembly">	call	verify_cpu
	testl	%eax, %eax
	jnz	no_longmode
</code></pre>
<p>This function is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/kernel/verify_cpu.S">arch/x86/kernel/verify_cpu.S</a> assembly file and just contains a couple of calls to the <a href="https://en.wikipedia.org/wiki/CPUID">cpuid</a> instruction. This instruction is used to get information about the processor. In our case, it checks for <code>long mode</code> and <code>SSE</code> support and sets the <code>eax</code> register to <code>0</code> on success and <code>1</code> on failure.</p>
<p>If the value of <code>eax</code> is not zero, we jump to the <code>no_longmode</code> label which just stops the CPU with the <code>hlt</code> instruction while no hardware interrupt can happen:</p>
<pre><code class="language-assembly">no_longmode:
1:
	hlt
	jmp     1b
</code></pre>
<p>If the value of the <code>eax</code> register is zero, everything is ok and we can continue.</p>
<h2 id="calculate-the-relocation-address"><a class="header" href="#calculate-the-relocation-address">Calculate the relocation address</a></h2>
<p>The next step is to calculate the relocation address for decompression if needed. First, we need to know what it means for a kernel to be <code>relocatable</code>. We already know that the base address of the 32-bit entry point of the Linux kernel is <code>0x100000</code>, but that is a 32-bit entry point. The default base address of the Linux kernel is determined by the value of the <code>CONFIG_PHYSICAL_START</code> kernel configuration option. Its default value is <code>0x1000000</code> or <code>16 MB</code>. The main problem here is that if the Linux kernel crashes, a kernel developer must have a <code>rescue kernel</code> for <a href="https://www.kernel.org/doc/Documentation/kdump/kdump.txt">kdump</a> which is configured to load from a different address. The Linux kernel provides a special configuration option to solve this problem: <code>CONFIG_RELOCATABLE</code>. As we can read in the documentation of the Linux kernel:</p>
<pre><code>This builds a kernel image that retains relocation information
so it can be loaded someplace besides the default 1MB.

Note: If CONFIG_RELOCATABLE=y, then the kernel runs from the address
it has been loaded at and the compile time physical address
(CONFIG_PHYSICAL_START) is used as the minimum location.
</code></pre>
<p>Now that we know where to start, let's get to it.</p>
<h2 id="reload-the-segments-if-needed-1"><a class="header" href="#reload-the-segments-if-needed-1">Reload the segments if needed</a></h2>
<p>As indicated above, we start in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly source code file. We first see the definition of a special section attribute before the definition of the <code>startup_32</code> function:</p>
<pre><code class="language-assembly">    __HEAD
    .code32
ENTRY(startup_32)
</code></pre>
<p><code>__HEAD</code> is a macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init.h">include/linux/init.h</a> header file and expands to the definition of the following section:</p>
<pre><code class="language-C">#define __HEAD		.section	&quot;.head.text&quot;,&quot;ax&quot;
</code></pre>
<p>Here, <code>.head.text</code> is the name of the section and <code>ax</code> is a set of flags. In our case, these flags show us that this section is <a href="https://en.wikipedia.org/wiki/Executable">executable</a>. In simple terms, this means that a Linux kernel with this option set can be booted from different addresses. Technically, this is done by compiling the decompressor as <a href="https://en.wikipedia.org/wiki/Position-independent_code">position independent code</a>. If we look at <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/Makefile">arch/x86/boot/compressed/Makefile</a>, we can see that the decompressor is indeed compiled with the <code>-fPIC</code> flag:</p>
<pre><code class="language-Makefile">KBUILD_CFLAGS += -fno-strict-aliasing -fPIC
</code></pre>
<p>When we are using position-independent code an address is obtained by adding the address field of the instruction to the value of the program counter. We can load code which uses such addressing from any address. That's why we had to get the real physical address of <code>startup_32</code>. Now let's get back to the Linux kernel code. Our current goal is to calculate an address where we can relocate the kernel for decompression. The calculation of this address depends on the <code>CONFIG_RELOCATABLE</code> kernel configuration option. Let's look at the code:</p>
<pre><code class="language-assembly">#ifdef CONFIG_RELOCATABLE
	movl	%ebp, %ebx
	movl	BP_kernel_alignment(%esi), %eax
	decl	%eax
	addl	%eax, %ebx
	notl	%eax
	andl	%eax, %ebx
	cmpl	$LOAD_PHYSICAL_ADDR, %ebx
	jge	1f
#endif
	movl	$LOAD_PHYSICAL_ADDR, %ebx
</code></pre>
<p>Remember that the value of the <code>ebp</code> register is the physical address of the <code>startup_32</code> label. If the <code>CONFIG_RELOCATABLE</code> kernel configuration option is enabled during kernel configuration, we put this address in the <code>ebx</code> register, align it to a multiple of <code>2MB</code> and compare it with the result of the <code>LOAD_PHYSICAL_ADDR</code> macro. <code>LOAD_PHYSICAL_ADDR</code> is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/include/asm/boot.h">arch/x86/include/asm/boot.h</a> header file and it looks like this:</p>
<pre><code class="language-C">#define LOAD_PHYSICAL_ADDR ((CONFIG_PHYSICAL_START \
				+ (CONFIG_PHYSICAL_ALIGN - 1)) \
				&amp; ~(CONFIG_PHYSICAL_ALIGN - 1))
</code></pre>
<p>As we can see it just expands to the aligned <code>CONFIG_PHYSICAL_ALIGN</code> value which represents the physical address where the kernel will be loaded. After comparing <code>LOAD_PHYSICAL_ADDR</code> and the value of the <code>ebx</code> register, we add the offset from <code>startup_32</code> where we will decompress the compressed kernel image. If the <code>CONFIG_RELOCATABLE</code> option is not enabled during kernel configuration, we just add <code>z_extract_offset</code> to the default address where the kernel is loaded.</p>
<p>After all of these calculations, <code>ebp</code> will contain the address where we loaded the kernel and <code>ebx</code> will contain the address where the decompressed kernel will be relocated. But that is not the end. The compressed kernel image should be moved to the end of the decompression buffer to simplify calculations regarding where the kernel will be located later. For this:</p>
<pre><code class="language-assembly">1:
    movl	BP_init_size(%esi), %eax
    subl	$_end, %eax
    addl	%eax, %ebx
</code></pre>
<p>we put the value from the <code>boot_params.BP_init_size</code> field (or the kernel setup header value from <code>hdr.init_size</code>) in the <code>eax</code> register. The <code>BP_init_size</code> field contains the larger of the compressed and uncompressed <a href="https://en.wikipedia.org/wiki/Vmlinux">vmlinux</a> sizes. Next we subtract the address of the <code>_end</code> symbol from this value and add the result of the subtraction to the <code>ebx</code> register which will store the base address for kernel decompression.</p>
<h2 id="preparation-before-entering-long-mode"><a class="header" href="#preparation-before-entering-long-mode">Preparation before entering long mode</a></h2>
<p>After we get the address to relocate the compressed kernel image to, we need to do one last step before we can transition to 64-bit mode. First, we need to update the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a> with 64-bit segments because a relocatable kernel is runnable at any address below 512GB:</p>
<pre><code class="language-assembly">	addl	%ebp, gdt+2(%ebp)
	lgdt	gdt(%ebp)
</code></pre>
<p>Here we adjust the base address of the Global Descriptor table to the address where we actually loaded the kernel and load the <code>Global Descriptor Table</code> with the <code>lgdt</code> instruction.</p>
<p>To understand the magic with <code>gdt</code> offsets we need to look at the definition of the <code>Global Descriptor Table</code>. We can find its definition in the same source code <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">file</a>:</p>
<pre><code class="language-assembly">	.data
gdt64:
	.word	gdt_end - gdt
	.long	0
	.word	0
	.quad   0
gdt:
	.word	gdt_end - gdt
	.long	gdt
	.word	0
	.quad	0x00cf9a000000ffff	/* __KERNEL32_CS */
	.quad	0x00af9a000000ffff	/* __KERNEL_CS */
	.quad	0x00cf92000000ffff	/* __KERNEL_DS */
	.quad	0x0080890000000000	/* TS descriptor */
	.quad   0x0000000000000000	/* TS continued */
gdt_end:
</code></pre>
<p>We can see that it is located in the <code>.data</code> section and contains five descriptors: the first is a <code>32-bit</code> descriptor for the kernel code segment, a <code>64-bit</code> kernel segment, a kernel data segment and two task descriptors.</p>
<p>We already loaded the <code>Global Descriptor Table</code> in the previous <a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-3.md">part</a>, and now we're doing almost the same here, but we set descriptors to use <code>CS.L = 1</code> and <code>CS.D = 0</code> for execution in <code>64</code> bit mode. As we can see, the definition of the <code>gdt</code> starts with a two byte value: <code>gdt_end - gdt</code> which represents the address of the last byte in the <code>gdt</code> table or the table limit. The next four bytes contain the base address of the <code>gdt</code>.</p>
<p>After we have loaded the <code>Global Descriptor Table</code> with the <code>lgdt</code> instruction, we must enable <a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">PAE</a> by putting the value of the <code>cr4</code> register into <code>eax</code>, setting the 5th bit and loading it back into <code>cr4</code>:</p>
<pre><code class="language-assembly">	movl	%cr4, %eax
	orl	$X86_CR4_PAE, %eax
	movl	%eax, %cr4
</code></pre>
<p>Now we are almost finished with the preparations needed to move into 64-bit mode. The last step is to build page tables, but before that, here is some information about long mode.</p>
<h2 id="long-mode"><a class="header" href="#long-mode">Long mode</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Long_mode">Long mode</a> is the native mode for <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> processors. First, let's look at some differences between <code>x86_64</code> and <code>x86</code>.</p>
<p><code>64-bit</code> mode provides the following features:</p>
<ul>
<li>8 new general purpose registers from <code>r8</code> to <code>r15</code></li>
<li>All general purpose registers are 64-bit now</li>
<li>A 64-bit instruction pointer - <code>RIP</code></li>
<li>A new operating mode - Long mode;</li>
<li>64-Bit Addresses and Operands;</li>
<li>RIP Relative Addressing (we will see an example of this in the coming parts).</li>
</ul>
<p>Long mode is an extension of the legacy protected mode. It consists of two sub-modes:</p>
<ul>
<li>64-bit mode;</li>
<li>compatibility mode.</li>
</ul>
<p>To switch into <code>64-bit</code> mode we need to do the following things:</p>
<ul>
<li>Enable <a href="https://en.wikipedia.org/wiki/Physical_Address_Extension">PAE</a>;</li>
<li>Build page tables and load the address of the top level page table into the <code>cr3</code> register;</li>
<li>Enable <code>EFER.LME</code>;</li>
<li>Enable paging.</li>
</ul>
<p>We already enabled <code>PAE</code> by setting the <code>PAE</code> bit in the <code>cr4</code> control register. Our next goal is to build the structure for <a href="https://en.wikipedia.org/wiki/Paging">paging</a>. We will discuss this in the next paragraph.</p>
<h2 id="early-page-table-initialization"><a class="header" href="#early-page-table-initialization">Early page table initialization</a></h2>
<p>We already know that before we can move into <code>64-bit</code> mode, we need to build page tables. Let's look at how the early <code>4G</code> boot page tables are built.</p>
<p><strong>NOTE: I will not describe the theory of virtual memory here. If you want to know more about virtual memory, check out the links at the end of this part.</strong></p>
<p>The Linux kernel uses <code>4-level</code> paging, and we generally build 6 page tables:</p>
<ul>
<li>One <code>PML4</code> or <code>Page Map Level 4</code> table with one entry;</li>
<li>One <code>PDP</code> or <code>Page Directory Pointer</code> table with four entries;</li>
<li>Four Page Directory tables with a total of <code>2048</code> entries.</li>
</ul>
<p>Let's look at how this is implemented. First, we clear the buffer for the page tables in memory. Every table is <code>4096</code> bytes, so we need clear a <code>24</code> kilobyte buffer:</p>
<pre><code class="language-assembly">	leal	pgtable(%ebx), %edi
	xorl	%eax, %eax
	movl	$(BOOT_INIT_PGT_SIZE/4), %ecx
	rep	stosl
</code></pre>
<p>We put the address of <code>pgtable</code> with an offset of <code>ebx</code> (remember that <code>ebx</code> points to the location in memory where the kernel will be decompressed later) into the <code>edi</code> register, clear the <code>eax</code> register and set the <code>ecx</code> register to <code>6144</code>.</p>
<p>The <code>rep stosl</code> instruction will write the value of <code>eax</code> to the memory location where <code>edi</code> points to, increment <code>edi</code> by <code>4</code>, and decrement <code>ecx</code> by <code>1</code>. This operation will be repeated while the value of the <code>ecx</code> register is greater than zero. That's why we put <code>6144</code> or <code>BOOT_INIT_PGT_SIZE/4</code> in <code>ecx</code>.</p>
<p><code>pgtable</code> is defined at the end of the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly file:</p>
<pre><code class="language-assembly">	.section &quot;.pgtable&quot;,&quot;a&quot;,@nobits
	.balign 4096
pgtable:
	.fill BOOT_PGT_SIZE, 1, 0
</code></pre>
<p>As we can see, it is located in the <code>.pgtable</code> section and its size depends on the <code>CONFIG_X86_VERBOSE_BOOTUP</code> kernel configuration option:</p>
<pre><code class="language-C">#  ifdef CONFIG_X86_VERBOSE_BOOTUP
#   define BOOT_PGT_SIZE	(19*4096)
#  else /* !CONFIG_X86_VERBOSE_BOOTUP */
#   define BOOT_PGT_SIZE	(17*4096)
#  endif
# else /* !CONFIG_RANDOMIZE_BASE */
#  define BOOT_PGT_SIZE		BOOT_INIT_PGT_SIZE
# endif
</code></pre>
<p>After we have a buffer for the <code>pgtable</code> structure, we can start to build the top level page table - <code>PML4</code> - with:</p>
<pre><code class="language-assembly">	leal	pgtable + 0(%ebx), %edi
	leal	0x1007 (%edi), %eax
	movl	%eax, 0(%edi)
</code></pre>
<p>Here again, we put the address of <code>pgtable</code> relative to <code>ebx</code> or in other words relative to address of <code>startup_32</code> in the <code>edi</code> register. Next, we put this address with an offset of <code>0x1007</code> into the <code>eax</code> register. <code>0x1007</code> is the result of adding the size of the <code>PML4</code> table which is <code>4096</code> or <code>0x1000</code> bytes with <code>7</code>. The <code>7</code> here represents the flags associated with the <code>PML4</code> entry. In our case, these flags are <code>PRESENT+RW+USER</code>. In the end, we just write the address of the first <code>PDP</code> entry to the <code>PML4</code> table.</p>
<p>In the next step we will build four <code>Page Directory</code> entries in the <code>Page Directory Pointer</code> table with the same <code>PRESENT+RW+USE</code> flags:</p>
<pre><code class="language-assembly">	leal	pgtable + 0x1000(%ebx), %edi
	leal	0x1007(%edi), %eax
	movl	$4, %ecx
1:  movl	%eax, 0x00(%edi)
	addl	$0x00001000, %eax
	addl	$8, %edi
	decl	%ecx
	jnz	1b
</code></pre>
<p>We set <code>edi</code> to the base address of the page directory pointer which is at an offset of <code>4096</code> or <code>0x1000</code> bytes from the <code>pgtable</code> table and <code>eax</code> to the address of the first page directory pointer entry. We also set <code>ecx</code> to <code>4</code> to act as a counter in the following loop and write the address of the first page directory pointer table entry to the <code>edi</code> register. After this, <code>edi</code> will contain the address of the first page directory pointer entry with flags <code>0x7</code>. Next we calculate the address of the following page directory pointer entries — each entry is <code>8</code> bytes — and write their addresses to <code>eax</code>. The last step in building the paging structure is to build the <code>2048</code> page table entries with <code>2-MByte</code> pages:</p>
<pre><code class="language-assembly">	leal	pgtable + 0x2000(%ebx), %edi
	movl	$0x00000183, %eax
	movl	$2048, %ecx
1:  movl	%eax, 0(%edi)
	addl	$0x00200000, %eax
	addl	$8, %edi
	decl	%ecx
	jnz	1b
</code></pre>
<p>Here we do almost the same things that we did in the previous example, all entries are associated with these flags - <code>$0x00000183</code> - <code>PRESENT + WRITE + MBZ</code>. In the end, we will have a page table with <code>2048</code> <code>2-MByte</code> pages, which represents a 4 Gigabyte block of memory:</p>
<pre><code class="language-python">&gt;&gt;&gt; 2048 * 0x00200000
4294967296
</code></pre>
<p>Since we've just finished building our early page table structure which maps <code>4</code> gigabytes of memory, we can put the address of the high-level page table - <code>PML4</code> - into the <code>cr3</code> control register:</p>
<pre><code class="language-assembly">	leal	pgtable(%ebx), %eax
	movl	%eax, %cr3
</code></pre>
<p>That's all. We are now prepared to transition to long mode.</p>
<h2 id="the-transition-to-64-bit-mode-1"><a class="header" href="#the-transition-to-64-bit-mode-1">The transition to 64-bit mode</a></h2>
<p>First of all we need to set the <code>EFER.LME</code> flag in the <a href="http://en.wikipedia.org/wiki/Model-specific_register">MSR</a> to <code>0xC0000080</code>:</p>
<pre><code class="language-assembly">	movl	$MSR_EFER, %ecx
	rdmsr
	btsl	$_EFER_LME, %eax
	wrmsr
</code></pre>
<p>Here we put the <code>MSR_EFER</code> flag (which is defined in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/include/asm/msr-index.h">arch/x86/include/asm/msr-index.h</a>) in the <code>ecx</code> register and execute the <code>rdmsr</code> instruction which reads the <a href="http://en.wikipedia.org/wiki/Model-specific_register">MSR</a> register. After <code>rdmsr</code> executes, the resulting data is stored in <code>edx:eax</code> according to the <code>MSR</code> register specified in <code>ecx</code>. We check the current <code>EFER_LME</code> bit, transfer it into the carry flag and update the bit, all with the <code>btsl</code> instruction. Then we write data from <code>edx:eax</code> back to the <code>MSR</code> register with the <code>wrmsr</code> instruction.</p>
<p>In the next step, we push the address of the kernel segment code to the stack (we defined it in the GDT) and put the address of the <code>startup_64</code> routine in <code>eax</code>.</p>
<pre><code class="language-assembly">	pushl	$__KERNEL_CS
	leal	startup_64(%ebp), %eax
</code></pre>
<p>After this we push <code>eax</code> to the stack and enable paging by setting the <code>PG</code> and <code>PE</code> bits in the <code>cr0</code> register:</p>
<pre><code class="language-assembly">	pushl	%eax
    movl	$(X86_CR0_PG | X86_CR0_PE), %eax
	movl	%eax, %cr0
</code></pre>
<p>We then execute the <code>lret</code> instruction:</p>
<pre><code class="language-assembly">lret
</code></pre>
<p>Remember that we pushed the address of the <code>startup_64</code> function to the stack in the previous step. The CPU extracts <code>startup_64</code>'s address from the stack and jumps there.</p>
<p>After all of these steps we're finally in 64-bit mode:</p>
<pre><code class="language-assembly">	.code64
	.org 0x200
ENTRY(startup_64)
....
....
....
</code></pre>
<p>That's all!</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>This is the end of the fourth part of the Linux kernel booting process. If you have any questions or suggestions, ping me on twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p>In the next part, we will learn about many things, including how kernel decompression works.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you find any mistakes please send a PR to <a href="https://github.com/0xAX/linux-internals">linux-insides</a>.</strong></p>
<h2 id="links-3"><a class="header" href="#links-3">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Protected_mode">Protected mode</a></li>
<li><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel® 64 and IA-32 Architectures Software Developer’s Manual 3A</a></li>
<li><a href="http://www.eecs.umich.edu/courses/eecs373/readings/Linker.pdf">GNU linker</a></li>
<li><a href="http://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a></li>
<li><a href="http://en.wikipedia.org/wiki/Paging">Paging</a></li>
<li><a href="http://en.wikipedia.org/wiki/Model-specific_register">Model specific register</a></li>
<li><a href="http://www.chemie.fu-berlin.de/chemnet/use/info/gas/gas_7.html">.fill instruction</a></li>
<li><a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-3.md">Previous part</a></li>
<li><a href="http://wiki.osdev.org/Paging">Paging on osdev.org</a></li>
<li><a href="https://www.cs.rutgers.edu/%7Epxk/416/notes/09a-paging.html">Paging Systems</a></li>
<li><a href="http://www.cirosantilli.com/x86-paging/">x86 Paging Tutorial</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-booting-process-part-5"><a class="header" href="#kernel-booting-process-part-5">Kernel booting process. Part 5.</a></h1>
<h2 id="kernel-decompression"><a class="header" href="#kernel-decompression">Kernel Decompression</a></h2>
<p>This is the fifth part of the <code>Kernel booting process</code> series. We went over the transition to 64-bit mode in the previous <a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-4.md#transition-to-the-long-mode">part</a> and we will continue where we left off in this part. We will study the steps taken to prepare for kernel decompression, relocation and the process of  kernel decompression itself. So... let's dive into the kernel code again.</p>
<h2 id="preparing-to-decompress-the-kernel"><a class="header" href="#preparing-to-decompress-the-kernel">Preparing to Decompress the Kernel</a></h2>
<p>We stopped right before the jump to the <code>64-bit</code> entry point - <code>startup_64</code> which is located in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> source code file. We already covered the jump to <code>startup_64</code> from <code>startup_32</code> in the previous part:</p>
<pre><code class="language-assembly">	pushl	$__KERNEL_CS
	leal	startup_64(%ebp), %eax
	...
	...
	...
	pushl	%eax
	...
	...
	...
	lret
</code></pre>
<p>Since we have loaded a new <code>Global Descriptor Table</code> and the CPU has transitioned to a new mode (<code>64-bit</code> mode in our case), we set up the segment registers again at the beginning of the <code>startup_64</code> function:</p>
<pre><code class="language-assembly">	.code64
	.org 0x200
ENTRY(startup_64)
	xorl	%eax, %eax
	movl	%eax, %ds
	movl	%eax, %es
	movl	%eax, %ss
	movl	%eax, %fs
	movl	%eax, %gs
</code></pre>
<p>All segment registers besides the <code>cs</code> register are now reset in <code>long mode</code>.</p>
<p>The next step is to compute the difference between the location the kernel was compiled to be loaded at and the location where it is actually loaded:</p>
<pre><code class="language-assembly">#ifdef CONFIG_RELOCATABLE
	leaq	startup_32(%rip), %rbp
	movl	BP_kernel_alignment(%rsi), %eax
	decl	%eax
	addq	%rax, %rbp
	notq	%rax
	andq	%rax, %rbp
	cmpq	$LOAD_PHYSICAL_ADDR, %rbp
	jge	1f
#endif
	movq	$LOAD_PHYSICAL_ADDR, %rbp
1:
	movl	BP_init_size(%rsi), %ebx
	subl	$_end, %ebx
	addq	%rbp, %rbx
</code></pre>
<p>The <code>rbp</code> register contains the decompressed kernel's start address. After this code executes, the <code>rbx</code> register will contain the address where the kernel code will be relocated to for decompression. We've already done this before in the <code>startup_32</code> function ( you can read about this in the previous part - <a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-4.md#calculate-relocation-address">Calculate relocation address</a>), but we need to do this calculation again because the bootloader can use the 64-bit boot protocol now and <code>startup_32</code> is no longer being executed.</p>
<p>In the next step we set up the stack pointer, reset the flags register and set up the <code>GDT</code> again to overwrite the <code>32-bit</code> specific values with those from the <code>64-bit</code> protocol:</p>
<pre><code class="language-assembly">    leaq	boot_stack_end(%rbx), %rsp

    leaq	gdt(%rip), %rax
    movq	%rax, gdt64+2(%rip)
    lgdt	gdt64(%rip)

    pushq	$0
    popfq
</code></pre>
<p>If you take a look at the code after the <code>lgdt gdt64(%rip)</code> instruction, you will see that there is some additional code. This code builds the trampoline to enable <a href="https://lwn.net/Articles/708526/">5-level paging</a> if needed. We will only consider 4-level paging in this book, so this code will be omitted.</p>
<p>As you can see above, the <code>rbx</code> register contains the start address of the kernel decompressor code and we just put this address with an offset of <code>boot_stack_end</code> in the <code>rsp</code> register which points to the top of the stack. After this step, the stack will be correct. You can find the definition of the <code>boot_stack_end</code> constant in the end of the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly source code file:</p>
<pre><code class="language-assembly">	.bss
	.balign 4
boot_heap:
	.fill BOOT_HEAP_SIZE, 1, 0
boot_stack:
	.fill BOOT_STACK_SIZE, 1, 0
boot_stack_end:
</code></pre>
<p>It located in the end of the <code>.bss</code> section, right before <code>.pgtable</code>. If you peek inside the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/vmlinux.lds.S">arch/x86/boot/compressed/vmlinux.lds.S</a> linker script, you will find the definitions of <code>.bss</code> and <code>.pgtable</code> there.</p>
<p>Since the stack is now correct, we can copy the compressed kernel to the address that we got above, when we calculated the relocation address of the decompressed kernel. Before we get into the details, let's take a look at this assembly code:</p>
<pre><code class="language-assembly">	pushq	%rsi
	leaq	(_bss-8)(%rip), %rsi
	leaq	(_bss-8)(%rbx), %rdi
	movq	$_bss, %rcx
	shrq	$3, %rcx
	std
	rep	movsq
	cld
	popq	%rsi
</code></pre>
<p>This set of instructions copies the compressed kernel over to where it will be decompressed.</p>
<p>First of all we push <code>rsi</code> to the stack. We need preserve the value of <code>rsi</code>, because this register now stores a pointer to <code>boot_params</code>  which is a real mode structure that contains booting related data (remember,  this structure was populated at the start of the kernel setup). We pop the pointer to <code>boot_params</code> back to <code>rsi</code> after we execute this code.</p>
<p>The next two <code>leaq</code> instructions calculate the effective addresses of the <code>rip</code> and <code>rbx</code> registers with an offset of <code>_bss - 8</code> and assign the results to <code>rsi</code> and <code>rdi</code> respectively. Why do we calculate these addresses? The compressed kernel image is located between this code (from <code>startup_32</code> to the current code) and the decompression code. You can verify this by looking at this linker script - <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/vmlinux.lds.S">arch/x86/boot/compressed/vmlinux.lds.S</a>:</p>
<pre><code>	. = 0;
	.head.text : {
		_head = . ;
		HEAD_TEXT
		_ehead = . ;
	}
	.rodata..compressed : {
		*(.rodata..compressed)
	}
	.text :	{
		_text = .; 	/* Text */
		*(.text)
		*(.text.*)
		_etext = . ;
	}
</code></pre>
<p>Note that the <code>.head.text</code> section contains <code>startup_32</code>. You may remember it from the previous part:</p>
<pre><code class="language-assembly">	__HEAD
	.code32
ENTRY(startup_32)
...
...
...
</code></pre>
<p>The <code>.text</code> section contains the decompression code:</p>
<pre><code class="language-assembly">	.text
relocated:
...
...
...
/*
 * Do the decompression, and jump to the new kernel..
 */
...
</code></pre>
<p>And <code>.rodata..compressed</code> contains the compressed kernel image. So <code>rsi</code> will contain the absolute address of <code>_bss - 8</code>, and <code>rdi</code> will contain the relocation relative address of <code>_bss - 8</code>. In the same way we store these addresses in registers, we put the address of <code>_bss</code> in the <code>rcx</code> register. As you can see in the <code>vmlinux.lds.S</code> linker script, it's located at the end of all sections with the setup/kernel code. Now we can start copying data from <code>rsi</code> to <code>rdi</code>, <code>8</code> bytes at a time, with the <code>movsq</code> instruction.</p>
<p>Note that we execute an <code>std</code> instruction before copying the data. This sets the <code>DF</code> flag, which means that <code>rsi</code> and <code>rdi</code> will be decremented. In other words, we will copy the bytes backwards. At the end, we clear the <code>DF</code> flag with the <code>cld</code> instruction, and restore the <code>boot_params</code> structure to <code>rsi</code>.</p>
<p>Now we have a pointer to the <code>.text</code> section's address after relocation, and we can jump to it:</p>
<pre><code class="language-assembly">	leaq	relocated(%rbx), %rax
	jmp	*%rax
</code></pre>
<h2 id="the-final-touches-before-kernel-decompression"><a class="header" href="#the-final-touches-before-kernel-decompression">The final touches before kernel decompression</a></h2>
<p>In the previous paragraph we saw that the <code>.text</code> section starts with the <code>relocated</code> label. The first thing we do is to clear the <code>bss</code> section with:</p>
<pre><code class="language-assembly">	xorl	%eax, %eax
	leaq    _bss(%rip), %rdi
	leaq    _ebss(%rip), %rcx
	subq	%rdi, %rcx
	shrq	$3, %rcx
	rep	stosq
</code></pre>
<p>We need to initialize the <code>.bss</code> section, because we'll soon jump to <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> code. Here we just clear <code>eax</code>, put the addresses of <code>_bss</code> in <code>rdi</code> and <code>_ebss</code> in <code>rcx</code>, and fill <code>.bss</code> with zeros with the <code>rep stosq</code> instruction.</p>
<p>At the end, we can see a call to the <code>extract_kernel</code> function:</p>
<pre><code class="language-assembly">	pushq	%rsi
	movq	%rsi, %rdi
	leaq	boot_heap(%rip), %rsi
	leaq	input_data(%rip), %rdx
	movl	$z_input_len, %ecx
	movq	%rbp, %r8
	movq	$z_output_len, %r9
	call	extract_kernel
	popq	%rsi
</code></pre>
<p>Like before, we push <code>rsi</code> onto the stack to preserve the pointer to <code>boot_params</code>. We also copy the contents of <code>rsi</code> to <code>rdi</code>. Then, we set <code>rsi</code> to point to the area where the kernel will be decompressed. The last step is to prepare the parameters for the  <code>extract_kernel</code> function and call it to decompress the kernel. The <code>extract_kernel</code> function is defined in the  <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/misc.c">arch/x86/boot/compressed/misc.c</a> source code file and takes six arguments:</p>
<ul>
<li><code>rmode</code> - a pointer to the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/include/uapi/asm/bootparam.h">boot_params</a> structure which is filled by either the bootloader or during early kernel initialization;</li>
<li><code>heap</code> - a pointer to <code>boot_heap</code> which represents the start address of the early boot heap;</li>
<li><code>input_data</code> - a pointer to the start of the compressed kernel or in other words, a pointer to the <code>arch/x86/boot/compressed/vmlinux.bin.bz2</code> file;</li>
<li><code>input_len</code> - the size of the compressed kernel;</li>
<li><code>output</code> - the start address of the decompressed kernel;</li>
<li><code>output_len</code> - the size of the decompressed kernel;</li>
</ul>
<p>All arguments will be passed through registers as per the <a href="https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf">System V Application Binary Interface</a>. We've finished all the preparations and can now decompress the kernel.</p>
<h2 id="kernel-decompression-1"><a class="header" href="#kernel-decompression-1">Kernel decompression</a></h2>
<p>As we saw in the previous paragraph, the <code>extract_kernel</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/misc.c">arch/x86/boot/compressed/misc.c</a> source code file and takes six arguments. This function starts with the video/console initialization that we already saw in the previous parts. We need to do this again because we don't know if we started in <a href="https://en.wikipedia.org/wiki/Real_mode">real mode</a> or if a bootloader was used, or whether the bootloader used the <code>32</code> or <code>64-bit</code> boot protocol.</p>
<p>After the first initialization steps, we store pointers to the start of the free memory and to the end of it:</p>
<pre><code class="language-C">free_mem_ptr     = heap;
free_mem_end_ptr = heap + BOOT_HEAP_SIZE;
</code></pre>
<p>Here, <code>heap</code> is the second parameter of the <code>extract_kernel</code> function as passed to it in <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a>:</p>
<pre><code class="language-assembly">leaq	boot_heap(%rip), %rsi
</code></pre>
<p>As you saw above, <code>boot_heap</code> is defined as:</p>
<pre><code class="language-assembly">boot_heap:
	.fill BOOT_HEAP_SIZE, 1, 0
</code></pre>
<p>where <code>BOOT_HEAP_SIZE</code> is a macro which expands to <code>0x10000</code> (<code>0x400000</code> in the case of a <code>bzip2</code> kernel) and represents the size of the heap.</p>
<p>After we initialize the heap pointers, the next step is to call the <code>choose_random_location</code> function from the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/kaslr.c">arch/x86/boot/compressed/kaslr.c</a> source code file. As we can guess from the function name, it chooses a memory location to write the decompressed kernel to. It may look weird that we need to find or even <code>choose</code> where to decompress the compressed kernel image, but the Linux kernel supports <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">kASLR</a> which allows decompression of the kernel into a random address, for security reasons.</p>
<p>We'll take a look at how the kernel's load address is randomized in the next part.</p>
<p>Now let's get back to <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/misc.c">misc.c</a>. After getting the address for the kernel image, we need to check that the random address we got is correctly aligned, and in general, not wrong:</p>
<pre><code class="language-C">if ((unsigned long)output &amp; (MIN_KERNEL_ALIGN - 1))
	error(&quot;Destination physical address inappropriately aligned&quot;);

if (virt_addr &amp; (MIN_KERNEL_ALIGN - 1))
	error(&quot;Destination virtual address inappropriately aligned&quot;);

if (heap &gt; 0x3fffffffffffUL)
	error(&quot;Destination address too large&quot;);

if (virt_addr + max(output_len, kernel_total_size) &gt; KERNEL_IMAGE_SIZE)
	error(&quot;Destination virtual address is beyond the kernel mapping area&quot;);

if ((unsigned long)output != LOAD_PHYSICAL_ADDR)
    error(&quot;Destination address does not match LOAD_PHYSICAL_ADDR&quot;);

if (virt_addr != LOAD_PHYSICAL_ADDR)
	error(&quot;Destination virtual address changed when not relocatable&quot;);
</code></pre>
<p>After all these checks we will see the familiar message:</p>
<pre><code>Decompressing Linux...
</code></pre>
<p>Now, we call the <code>__decompress</code> function to decompress the kernel:</p>
<pre><code class="language-C">__decompress(input_data, input_len, NULL, NULL, output, output_len, NULL, error);
</code></pre>
<p>The implementation of the <code>__decompress</code> function depends on what decompression algorithm was chosen during kernel compilation:</p>
<pre><code class="language-C">#ifdef CONFIG_KERNEL_GZIP
#include &quot;../../../../lib/decompress_inflate.c&quot;
#endif

#ifdef CONFIG_KERNEL_BZIP2
#include &quot;../../../../lib/decompress_bunzip2.c&quot;
#endif

#ifdef CONFIG_KERNEL_LZMA
#include &quot;../../../../lib/decompress_unlzma.c&quot;
#endif

#ifdef CONFIG_KERNEL_XZ
#include &quot;../../../../lib/decompress_unxz.c&quot;
#endif

#ifdef CONFIG_KERNEL_LZO
#include &quot;../../../../lib/decompress_unlzo.c&quot;
#endif

#ifdef CONFIG_KERNEL_LZ4
#include &quot;../../../../lib/decompress_unlz4.c&quot;
#endif
</code></pre>
<p>After the kernel is decompressed, two more functions are called: <code>parse_elf</code> and <code>handle_relocations</code>. The main point of these functions is to move the decompressed kernel image to its correct place in memory. This is because the decompression is done <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a>, and we still need to move the kernel to the correct address. As we already know, the kernel image is an <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> executable. The main goal of the <code>parse_elf</code> function is to move loadable segments to the correct address. We can see the kernel's loadable segments in the output of the <code>readelf</code> program:</p>
<pre><code>readelf -l vmlinux

Elf file type is EXEC (Executable file)
Entry point 0x1000000
There are 5 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000200000 0xffffffff81000000 0x0000000001000000
                 0x0000000000893000 0x0000000000893000  R E    200000
  LOAD           0x0000000000a93000 0xffffffff81893000 0x0000000001893000
                 0x000000000016d000 0x000000000016d000  RW     200000
  LOAD           0x0000000000c00000 0x0000000000000000 0x0000000001a00000
                 0x00000000000152d8 0x00000000000152d8  RW     200000
  LOAD           0x0000000000c16000 0xffffffff81a16000 0x0000000001a16000
                 0x0000000000138000 0x000000000029b000  RWE    200000
</code></pre>
<p>The goal of the <code>parse_elf</code> function is to load these segments to the <code>output</code> address we got from the <code>choose_random_location</code> function. This function starts by checking the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> signature:</p>
<pre><code class="language-C">Elf64_Ehdr ehdr;
Elf64_Phdr *phdrs, *phdr;

memcpy(&amp;ehdr, output, sizeof(ehdr));

if (ehdr.e_ident[EI_MAG0] != ELFMAG0 ||
    ehdr.e_ident[EI_MAG1] != ELFMAG1 ||
    ehdr.e_ident[EI_MAG2] != ELFMAG2 ||
    ehdr.e_ident[EI_MAG3] != ELFMAG3) {
        error(&quot;Kernel is not a valid ELF file&quot;);
        return;
}
</code></pre>
<p>If the ELF header is not valid, it prints an error message and halts. If we have a valid <code>ELF</code> file, we go through all the program headers from the given <code>ELF</code> file and copy all loadable segments with correct 2 megabyte aligned addresses to the output buffer:</p>
<pre><code class="language-C">	for (i = 0; i &lt; ehdr.e_phnum; i++) {
		phdr = &amp;phdrs[i];

		switch (phdr-&gt;p_type) {
		case PT_LOAD:
#ifdef CONFIG_X86_64
			if ((phdr-&gt;p_align % 0x200000) != 0)
				error(&quot;Alignment of LOAD segment isn't multiple of 2MB&quot;);
#endif
#ifdef CONFIG_RELOCATABLE
			dest = output;
			dest += (phdr-&gt;p_paddr - LOAD_PHYSICAL_ADDR);
#else
			dest = (void *)(phdr-&gt;p_paddr);
#endif
			memmove(dest, output + phdr-&gt;p_offset, phdr-&gt;p_filesz);
			break;
		default:
			break;
		}
	}
</code></pre>
<p>That's all.</p>
<p>From this moment, all loadable segments are in the correct place.</p>
<p>The next step after the <code>parse_elf</code> function is to call the <code>handle_relocations</code> function. The implementation of this function depends on the <code>CONFIG_X86_NEED_RELOCS</code> kernel configuration option and if it is enabled, this function adjusts addresses in the kernel image. This function is also only called if the <code>CONFIG_RANDOMIZE_BASE</code> configuration option was enabled during kernel configuration. The implementation of the <code>handle_relocations</code> function is easy enough. This function subtracts the value of <code>LOAD_PHYSICAL_ADDR</code> from the value of the base load address of the kernel and thus we obtain the difference between where the kernel was linked to load and where it was actually loaded. After this we can relocate the kernel since we know the actual address where the kernel was loaded, the address where it was linked to run and the relocation table which is at the end of the kernel image.</p>
<p>After the kernel is relocated, we return from the <code>extract_kernel</code> function to <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a>.</p>
<p>The address of the kernel will be in the <code>rax</code> register and we jump to it:</p>
<pre><code class="language-assembly">jmp	*%rax
</code></pre>
<p>That's all. Now we are in the kernel!</p>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>This is the end of the fifth part about the Linux kernel booting process. We will not see any more posts about the kernel booting process (there may be updates to this and previous posts though), but there will be many posts about other kernel internals.</p>
<p>The Next chapter will describe more advanced details about Linux kernel booting process, like load address randomization and etc.</p>
<p>If you have any questions or suggestions write me a comment or ping me in <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-internals">linux-insides</a>.</strong></p>
<h2 id="links-4"><a class="header" href="#links-4">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">address space layout randomization</a></li>
<li><a href="https://en.wikipedia.org/wiki/Initrd">initrd</a></li>
<li><a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a></li>
<li><a href="http://www.bzip.org/">bzip2</a></li>
<li><a href="https://en.wikipedia.org/wiki/RdRand">RdRand instruction</a></li>
<li><a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8253">Programmable Interval Timers</a></li>
<li><a href="https://github.com/0xAX/linux-insides/blob/v4.16/Booting/linux-bootstrap-4.md">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-booting-process-part-6"><a class="header" href="#kernel-booting-process-part-6">Kernel booting process. Part 6.</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This is the sixth part of the <code>Kernel booting process</code> series. In the <a href="Booting/linux-bootstrap-5.html">previous part</a> we took a look at the final stages of the Linux kernel boot process. But we have skipped some important, more advanced parts.</p>
<p>As you may remember, the entry point of the Linux kernel is the <code>start_kernel</code> function defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/init/main.c">main.c</a> source code file. This function is executed  at the address stored in <code>LOAD_PHYSICAL_ADDR</code>. and depends on the <code>CONFIG_PHYSICAL_START</code> kernel configuration option, which is <code>0x1000000</code> by default:</p>
<pre><code>config PHYSICAL_START
	hex &quot;Physical address where the kernel is loaded&quot; if (EXPERT || CRASH_DUMP)
	default &quot;0x1000000&quot;
	---help---
	  This gives the physical address where the kernel is loaded.
      ...
      ...
      ...
</code></pre>
<p>This value may be changed during kernel configuration, but the load address can also be configured to be a random value. For this purpose, the <code>CONFIG_RANDOMIZE_BASE</code> kernel configuration option should be enabled during kernel configuration.</p>
<p>Now, the physical address where the Linux kernel image will be decompressed and loaded will be randomized. This part considers the case when the <code>CONFIG_RANDOMIZE_BASE</code> option is enabled and the load address of the kernel image is randomized for <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">security reasons</a>.</p>
<h2 id="page-table-initialization"><a class="header" href="#page-table-initialization">Page Table Initialization</a></h2>
<p>Before the kernel decompressor can look for a random memory range to decompress and load the kernel to, the identity mapped page tables should be initialized. If the <a href="https://en.wikipedia.org/wiki/Booting">bootloader</a> used the <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/boot.txt">16-bit or 32-bit boot protocol</a>, we already have page tables. But, there may be problems if the kernel decompressor selects a memory range which is valid only in a 64-bit context. That's why we need to build new identity mapped page tables.</p>
<p>Indeed, the first step in randomizing the kernel load address is to build new identity mapped page tables. But first, let's reflect on how we got to this point.</p>
<p>In the <a href="Booting/linux-bootstrap-5.html">previous part</a>, we followed the transition to <a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a> and jumped to the kernel decompressor entry point - the <code>extract_kernel</code> function. The randomization stuff begins with a call to this function:</p>
<pre><code class="language-C">void choose_random_location(unsigned long input,
                            unsigned long input_size,
                            unsigned long *output,
                            unsigned long output_size,
                            unsigned long *virt_addr)
{}
</code></pre>
<p>This function takes five parameters:</p>
<ul>
<li><code>input</code>;</li>
<li><code>input_size</code>;</li>
<li><code>output</code>;</li>
<li><code>output_size</code>;</li>
<li><code>virt_addr</code>.</li>
</ul>
<p>Let's try to understand what these parameters are. The first parameter, <code>input</code> is just the <code>input_data</code> parameter of the <code>extract_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/misc.c">arch/x86/boot/compressed/misc.c</a> source code file, cast to <code>unsigned long</code>:</p>
<pre><code class="language-C">asmlinkage __visible void *extract_kernel(void *rmode, memptr heap,
				                          unsigned char *input_data,
				                          unsigned long input_len,
				                          unsigned char *output,
				                          unsigned long output_len)
{
  ...
  ...
  ...
  choose_random_location((unsigned long)input_data, input_len,
                         (unsigned long *)&amp;output,
				         max(output_len, kernel_total_size),
				         &amp;virt_addr);
  ...
  ...
  ...
}
</code></pre>
<p>This parameter is passed through assembly from the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> source code file:</p>
<pre><code class="language-C">leaq	input_data(%rip), %rdx
</code></pre>
<p><code>input_data</code> is generated by the little <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/mkpiggy.c">mkpiggy</a> program. If you've tried compiling the Linux kernel yourself, you may find the output generated by this program in the <code>linux/arch/x86/boot/compressed/piggy.S</code> source code file. In my case this file looks like this:</p>
<pre><code class="language-assembly">.section &quot;.rodata..compressed&quot;,&quot;a&quot;,@progbits
.globl z_input_len
z_input_len = 6988196
.globl z_output_len
z_output_len = 29207032
.globl input_data, input_data_end
input_data:
.incbin &quot;arch/x86/boot/compressed/vmlinux.bin.gz&quot;
input_data_end:
</code></pre>
<p>As you can see, it contains four global symbols. The first two, <code>z_input_len</code> and <code>z_output_len</code> are the sizes of the compressed and uncompressed <code>vmlinux.bin.gz</code> archive. The third is our <code>input_data</code> parameter which points to the Linux kernel image's raw binary (stripped of all debugging symbols, comments and relocation information). The last parameter,  <code>input_data_end</code>, points to the end of the compressed linux image.</p>
<p>So, the first parameter to the <code>choose_random_location</code> function is the pointer to the compressed kernel image that is embedded into the <code>piggy.o</code> object file.</p>
<p>The second parameter of the <code>choose_random_location</code> function is <code>z_input_len</code>.</p>
<p>The third and fourth parameters of the <code>choose_random_location</code> function are the address of the decompressed kernel image and its length respectively. The decompressed kernel's address came from the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> source code file and is the address of the <code>startup_32</code> function  aligned to a 2 megabyte boundary. The size of the decompressed kernel is given by <code>z_output_len</code> which, again, is found in <code>piggy.S</code>.</p>
<p>The last parameter of the <code>choose_random_location</code> function is the virtual address of the kernel load address. As can be seen, by default, it coincides with the default physical load address:</p>
<pre><code class="language-C">unsigned long virt_addr = LOAD_PHYSICAL_ADDR;
</code></pre>
<p>The physical load address is defined by the configuration options:</p>
<pre><code class="language-C">#define LOAD_PHYSICAL_ADDR ((CONFIG_PHYSICAL_START \
				+ (CONFIG_PHYSICAL_ALIGN - 1)) \
				&amp; ~(CONFIG_PHYSICAL_ALIGN - 1))
</code></pre>
<p>We've covered <code>choose_random_location</code>'s parameters, so let's look at its implementation. This function starts by checking the <code>nokaslr</code> option in the kernel command line:</p>
<pre><code class="language-C">if (cmdline_find_option_bool(&quot;nokaslr&quot;)) {
	warn(&quot;KASLR disabled: 'nokaslr' on cmdline.&quot;);
	return;
}
</code></pre>
<p>We exit <code>choose_random_location</code> if the option is specified, leaving the kernel load address unrandomized. Information related to this can be found in the <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/admin-guide/kernel-parameters.rst">kernel's documentation</a>:</p>
<pre><code>kaslr/nokaslr [X86]

Enable/disable kernel and module base offset ASLR
(Address Space Layout Randomization) if built into
the kernel. When CONFIG_HIBERNATION is selected,
kASLR is disabled by default. When kASLR is enabled,
hibernation will be disabled.
</code></pre>
<p>Let's assume that we didn't pass <code>nokaslr</code> to the kernel command line and the <code>CONFIG_RANDOMIZE_BASE</code> kernel configuration option is enabled. In this case we add <code>kASLR</code> flag to kernel load flags:</p>
<pre><code class="language-C">boot_params-&gt;hdr.loadflags |= KASLR_FLAG;
</code></pre>
<p>Now, we call another function:</p>
<pre><code class="language-C">initialize_identity_maps();
</code></pre>
<p>The <code>initialize_identity_maps</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/kaslr_64.c">arch/x86/boot/compressed/kaslr_64.c</a> source code file. This function starts by initializing an instance of the <code>x86_mapping_info</code> structure called <code>mapping_info</code>:</p>
<pre><code class="language-C">mapping_info.alloc_pgt_page = alloc_pgt_page;
mapping_info.context = &amp;pgt_data;
mapping_info.page_flag = __PAGE_KERNEL_LARGE_EXEC | sev_me_mask;
mapping_info.kernpg_flag = _KERNPG_TABLE;
</code></pre>
<p>The <code>x86_mapping_info</code> structure is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/include/asm/init.h">arch/x86/include/asm/init.h</a> header file and looks like this:</p>
<pre><code class="language-C">struct x86_mapping_info {
	void *(*alloc_pgt_page)(void *);
	void *context;
	unsigned long page_flag;
	unsigned long offset;
	bool direct_gbpages;
	unsigned long kernpg_flag;
};
</code></pre>
<p>This structure provides information about memory mappings. As you may remember from the previous part, we have already set up page tables to cover the range <code>0</code> to <code>4G</code>. This won't do since we might generate a randomized address outside of the 4 gigabyte range. So, the <code>initialize_identity_maps</code> function initializes the memory for a new page table entry. First, let's take a look at the definition of the <code>x86_mapping_info</code> structure.</p>
<p><code>alloc_pgt_page</code> is a callback function that is called to allocate space for a page table entry. The <code>context</code> field is an instance of the <code>alloc_pgt_data</code> structure. We use it to track allocated page tables. The <code>page_flag</code> and <code>kernpg_flag</code> fields are page flags. The first represents flags for <code>PMD</code> or <code>PUD</code> entries. The <code>kernpg_flag</code> field represents overridable flags for kernel pages. The <code>direct_gbpages</code> field is used to check if huge pages are supported and the last field,  <code>offset</code>, represents the offset between the kernel's virtual addresses and its physical addresses up to the <code>PMD</code> level.</p>
<p>The <code>alloc_pgt_page</code> callback just checks that there is space for a new page, allocates it in the <code>pgt_buf</code> field of the <code>alloc_pgt_data</code> structure and returns the address of the new page:</p>
<pre><code class="language-C">entry = pages-&gt;pgt_buf + pages-&gt;pgt_buf_offset;
pages-&gt;pgt_buf_offset += PAGE_SIZE;
</code></pre>
<p>Here's what the <code>alloc_pgt_data</code> structure looks like:</p>
<pre><code class="language-C">struct alloc_pgt_data {
	unsigned char *pgt_buf;
	unsigned long pgt_buf_size;
	unsigned long pgt_buf_offset;
};
</code></pre>
<p>The last goal of the <code>initialize_identity_maps</code> function is to initialize <code>pgdt_buf_size</code> and <code>pgt_buf_offset</code>. As we are only in the initialization phase, the <code>initialze_identity_maps</code> function sets <code>pgt_buf_offset</code> to zero:</p>
<pre><code class="language-C">pgt_data.pgt_buf_offset = 0;
</code></pre>
<p><code>pgt_data.pgt_buf_size</code> will be set to <code>77824</code> or <code>69632</code> depending on which boot protocol was used by the bootloader (64-bit or 32-bit). The same is done for <code>pgt_data.pgt_buf</code>. If a bootloader loaded the kernel at <code>startup_32</code>, <code>pgdt_data.pgdt_buf</code> will point to the end of the already initialized page table in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> source code file:</p>
<pre><code class="language-C">pgt_data.pgt_buf = _pgtable + BOOT_INIT_PGT_SIZE;
</code></pre>
<p>Here, <code>_pgtable</code> points to the beginning of <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/vmlinux.lds.S">_pgtable</a>. On the other hand, if the bootloader used the 64-bit boot protocol and loaded the kernel at <code>startup_64</code>, the early page tables should already be built by the bootloader itself and <code>_pgtable</code> will just point to those instead:</p>
<pre><code class="language-C">pgt_data.pgt_buf = _pgtable
</code></pre>
<p>As the buffer for new page tables is initialized, we may return to the <code>choose_random_location</code> function.</p>
<h2 id="avoiding-reserved-memory-ranges"><a class="header" href="#avoiding-reserved-memory-ranges">Avoiding Reserved Memory Ranges</a></h2>
<p>After the stuff related to identity page tables is initialized, we can choose a random memory location to extract the kernel image to. But as you may have guessed, we can't just choose any address. There are certain reserved memory regions which are occupied by important things like the <a href="https://en.wikipedia.org/wiki/Initial_ramdisk">initrd</a> and the kernel command line which must be avoided. The <code>mem_avoid_init</code> function will help us do this:</p>
<pre><code class="language-C">mem_avoid_init(input, input_size, *output);
</code></pre>
<p>All unsafe memory regions will be collected in an array called <code>mem_avoid</code>:</p>
<pre><code class="language-C">struct mem_vector {
	unsigned long long start;
	unsigned long long size;
};

static struct mem_vector mem_avoid[MEM_AVOID_MAX];
</code></pre>
<p>Here, <code>MEM_AVOID_MAX</code> is from the <code>mem_avoid_index</code> <a href="https://en.wikipedia.org/wiki/Enumerated_type#C">enum</a> which represents different types of reserved memory regions:</p>
<pre><code class="language-C">enum mem_avoid_index {
	MEM_AVOID_ZO_RANGE = 0,
	MEM_AVOID_INITRD,
	MEM_AVOID_CMDLINE,
	MEM_AVOID_BOOTPARAMS,
	MEM_AVOID_MEMMAP_BEGIN,
	MEM_AVOID_MEMMAP_END = MEM_AVOID_MEMMAP_BEGIN + MAX_MEMMAP_REGIONS - 1,
	MEM_AVOID_MAX,
};
</code></pre>
<p>Both are defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/kaslr.c">arch/x86/boot/compressed/kaslr.c</a> source code file.</p>
<p>Let's look at the implementation of the <code>mem_avoid_init</code> function. The main goal of this function is to store information about reserved memory regions with descriptions given by the <code>mem_avoid_index</code> enum in the <code>mem_avoid</code> array and to create new pages for such regions in our new identity mapped buffer. The <code>mem_avoid_index</code> function does the same thing for all elements in the <code>mem_avoid_index</code>enum, so let's look at a typical example of the process:</p>
<pre><code class="language-C">mem_avoid[MEM_AVOID_ZO_RANGE].start = input;
mem_avoid[MEM_AVOID_ZO_RANGE].size = (output + init_size) - input;
add_identity_map(mem_avoid[MEM_AVOID_ZO_RANGE].start,
		 mem_avoid[MEM_AVOID_ZO_RANGE].size);
</code></pre>
<p>The <code>mem_avoid_init</code> function first tries to avoid memory regions currently used to decompress the kernel. We fill an entry from the <code>mem_avoid</code> array with the start address and the size of the relevant region and call the <code>add_identity_map</code> function, which  builds the identity mapped pages for this region. The <code>add_identity_map</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/kaslr_64.c">arch/x86/boot/compressed/kaslr_64.c</a> source code file and looks like this:</p>
<pre><code class="language-C">void add_identity_map(unsigned long start, unsigned long size)
{
	unsigned long end = start + size;

	start = round_down(start, PMD_SIZE);
	end = round_up(end, PMD_SIZE);
	if (start &gt;= end)
		return;

	kernel_ident_mapping_init(&amp;mapping_info, (pgd_t *)top_level_pgt,
				  start, end);
}
</code></pre>
<p>The <code>round_up</code> and <code>round_down</code> functions are used to align the start and end addresses to a 2 megabyte boundary.</p>
<p>In the end this function calls the <code>kernel_ident_mapping_init</code> function from the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/mm/ident_map.c">arch/x86/mm/ident_map.c</a> source code file and passes the previously initialized <code>mapping_info</code> instance, the address of the top level page table and the start and end addresses of the memory region for which a new identity mapping should be built.</p>
<p>The <code>kernel_ident_mapping_init</code> function sets default flags for new pages if they were not already set:</p>
<pre><code class="language-C">if (!info-&gt;kernpg_flag)
	info-&gt;kernpg_flag = _KERNPG_TABLE;
</code></pre>
<p>It then starts to build new 2-megabyte (because of the <code>PSE</code> bit in <code>mapping_info.page_flag</code>) page entries (<code>PGD -&gt; P4D -&gt; PUD -&gt; PMD</code> if we're using <a href="https://lwn.net/Articles/717293/">five-level page tables</a> or <code>PGD -&gt; PUD -&gt; PMD</code> if <a href="https://lwn.net/Articles/117749/">four-level page tables</a> are used) associated with the given addresses.</p>
<pre><code class="language-C">for (; addr &lt; end; addr = next) {
	p4d_t *p4d;

	next = (addr &amp; PGDIR_MASK) + PGDIR_SIZE;
	if (next &gt; end)
		next = end;

    p4d = (p4d_t *)info-&gt;alloc_pgt_page(info-&gt;context);
	result = ident_p4d_init(info, p4d, addr, next);

    return result;
}
</code></pre>
<p>The first thing this for loop does is to find the next entry of the <code>Page Global Directory</code> for the given address. If the entry's address is greater than the <code>end</code> of the given memory region, we set its size to <code>end</code>. After this, we allocate a new page with the  <code>x86_mapping_info</code> callback that we looked at previously and call the <code>ident_p4d_init</code> function. The <code>ident_p4d_init</code> function will do the same thing, but for the lower level page directories (<code>p4d</code> -&gt; <code>pud</code> -&gt; <code>pmd</code>).</p>
<p>That's all.</p>
<p>We now have new page entries related to reserved addresses in our page tables. We haven't reached the end of the <code>mem_avoid_init</code> function, but the rest is similar. It builds pages for the <a href="https://en.wikipedia.org/wiki/Initial_ramdisk">initrd</a> and the kernel command line, among other things.</p>
<p>Now we may return to the <code>choose_random_location</code> function.</p>
<h2 id="physical-address-randomization"><a class="header" href="#physical-address-randomization">Physical address randomization</a></h2>
<p>After the reserved memory regions have been stored in the <code>mem_avoid</code> array and identity mapped pages are built for them, we select the region with the lowest available address to decompress the kernel to:</p>
<pre><code class="language-C">min_addr = min(*output, 512UL &lt;&lt; 20);
</code></pre>
<p>You will notice that the address should be within the first <code>512</code> megabytes. A limit of <code>512</code> megabytes was selected to avoid unknown things in lower memory.</p>
<p>The next step is to select random physical and virtual addresses to load the kernel to. The first is the physical addresses:</p>
<pre><code class="language-C">random_addr = find_random_phys_addr(min_addr, output_size);
</code></pre>
<p>The <code>find_random_phys_addr</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/boot/compressed/kaslr.c">same</a> source code file as <code>choose_random_location</code>:</p>
<pre><code>static unsigned long find_random_phys_addr(unsigned long minimum,
                                           unsigned long image_size)
{
	minimum = ALIGN(minimum, CONFIG_PHYSICAL_ALIGN);

	if (process_efi_entries(minimum, image_size))
		return slots_fetch_random();

	process_e820_entries(minimum, image_size);
	return slots_fetch_random();
}
</code></pre>
<p>The main goal of the <code>process_efi_entries</code> function is to find all suitable memory ranges in fully accessible memory to load kernel. If the kernel is compiled and run on a system without <a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">EFI</a> support, we continue to search for such memory regions in the <a href="https://en.wikipedia.org/wiki/E820">e820</a> region. All memory regions found will be stored in the <code>slot_areas</code> array:</p>
<pre><code class="language-C">struct slot_area {
	unsigned long addr;
	int num;
};

#define MAX_SLOT_AREA 100

static struct slot_area slot_areas[MAX_SLOT_AREA];
</code></pre>
<p>The kernel will select a random index from this array to decompress the kernel to. The selection process is conducted by the  <code>slots_fetch_random</code> function. The main goal of the <code>slots_fetch_random</code> function is to select a random memory range from the <code>slot_areas</code> array via the <code>kaslr_get_random_long</code> function:</p>
<pre><code class="language-C">slot = kaslr_get_random_long(&quot;Physical&quot;) % slot_max;
</code></pre>
<p>The <code>kaslr_get_random_long</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/v4.16/arch/x86/lib/kaslr.c">arch/x86/lib/kaslr.c</a> source code file and as its name suggests, returns a random number. Note that the random number can be generated in a number of ways depending on kernel configuration and features present in the system (For example, using the <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">time stamp counter</a>, or <a href="https://en.wikipedia.org/wiki/RdRand">rdrand</a> or some other method).</p>
<p>We now have a random physical address to decompress the kernel to.</p>
<h2 id="virtual-address-randomization"><a class="header" href="#virtual-address-randomization">Virtual address randomization</a></h2>
<p>After selecting a random physical address for the decompressed kernel, we generate identity mapped pages for the region:</p>
<pre><code class="language-C">random_addr = find_random_phys_addr(min_addr, output_size);

if (*output != random_addr) {
		add_identity_map(random_addr, output_size);
		*output = random_addr;
}
</code></pre>
<p>From now on, <code>output</code> will store the base address of the memory region where kernel will be decompressed. Currently, we have only randomized the physical address. We can randomize the virtual address as well on the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture:</p>
<pre><code class="language-C">if (IS_ENABLED(CONFIG_X86_64))
	random_addr = find_random_virt_addr(LOAD_PHYSICAL_ADDR, output_size);

*virt_addr = random_addr;
</code></pre>
<p>In architectures other than <code>x86_64</code>, the randomized physical and virtual addresses are the same. The <code>find_random_virt_addr</code> function calculates the number of virtual memory ranges needed to hold the kernel image. It calls the <code>kaslr_get_random_long</code> function, which we have already seen being used to generate a random <code>physical</code> address.</p>
<p>At this point we have randomized both the base physical (<code>*output</code>) and virtual (<code>*virt_addr</code>) addresses for the decompressed kernel.</p>
<p>That's all.</p>
<h2 id="conclusion-5"><a class="header" href="#conclusion-5">Conclusion</a></h2>
<p>This is the end of the sixth and last part concerning the Linux kernel's booting process. We will not see any more posts about kernel booting (though there may be updates to this and previous posts). We will now turn to other parts of the linux kernel instead.</p>
<p>The next chapter will be about kernel initialization and we will study the first steps take in the Linux kernel initialization code.</p>
<p>If you have any questions or suggestions write me a comment or ping me in <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-internals">linux-insides</a>.</strong></p>
<h2 id="links-5"><a class="header" href="#links-5">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address space layout randomization</a></li>
<li><a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/boot.txt">Linux kernel boot protocol</a></li>
<li><a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Initial_ramdisk">initrd</a></li>
<li><a href="https://en.wikipedia.org/wiki/Enumerated_type#C">Enumerated type</a></li>
<li><a href="https://lwn.net/Articles/117749/">four-level page tables</a></li>
<li><a href="https://lwn.net/Articles/717293/">five-level page tables</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">EFI</a></li>
<li><a href="https://en.wikipedia.org/wiki/E820">e820</a></li>
<li><a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">time stamp counter</a></li>
<li><a href="https://en.wikipedia.org/wiki/RdRand">rdrand</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="Booting/linux-bootstrap-5.html">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-initialization-process"><a class="header" href="#kernel-initialization-process">Kernel initialization process</a></h1>
<p>You will find here a couple of posts which describe the full cycle of kernel initialization from its first step after the kernel has been decompressed to the start of the first process run by the kernel itself.</p>
<p><em>Note</em> That there will not be a description of the all kernel initialization steps. Here will be only generic kernel part, without interrupts handling, ACPI, and many other parts. All parts which I have missed, will be described in other chapters.</p>
<ul>
<li><a href="Initialization/linux-initialization-1.html">First steps after kernel decompression</a> - describes first steps in the kernel.</li>
<li><a href="Initialization/linux-initialization-2.html">Early interrupt and exception handling</a> - describes early interrupts initialization and early page fault handler.</li>
<li><a href="Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a> - describes the last preparations before the call of the <code>start_kernel</code>.</li>
<li><a href="Initialization/linux-initialization-4.html">Kernel entry point</a> - describes first steps in the kernel generic code.</li>
<li><a href="Initialization/linux-initialization-5.html">Continue of architecture-specific initializations</a> - describes architecture-specific initialization.</li>
<li><a href="Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a> - describes continue of the architecture-specific initialization process.</li>
<li><a href="Initialization/linux-initialization-7.html">The End of the architecture-specific initializations, almost...</a> - describes the end of the <code>setup_arch</code> related stuff.</li>
<li><a href="Initialization/linux-initialization-8.html">Scheduler initialization</a> - describes preparation before scheduler initialization and initialization of it.</li>
<li><a href="Initialization/linux-initialization-9.html">RCU initialization</a> - describes the initialization of the <a href="http://en.wikipedia.org/wiki/Read-copy-update">RCU</a>.</li>
<li><a href="Initialization/linux-initialization-10.html">End of the initialization</a> - the last part about Linux kernel initialization.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-initialization-part-1"><a class="header" href="#kernel-initialization-part-1">Kernel initialization. Part 1.</a></h1>
<h2 id="first-steps-in-the-kernel-code"><a class="header" href="#first-steps-in-the-kernel-code">First steps in the kernel code</a></h2>
<p>The previous <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-6">post</a> was a last part of the Linux kernel <a href="https://0xax.gitbook.io/linux-insides/summary/booting">booting process</a> chapter and now we are starting to dive into initialization process of the Linux kernel. After the image of the Linux kernel is decompressed and placed in a correct place in memory, it starts to work. All previous parts describe the work of the Linux kernel setup code which does preparation before the first bytes of the Linux kernel code will be executed. From now we are in the kernel and all parts of this chapter will be devoted to the initialization process of the kernel before it will launch process with <a href="https://en.wikipedia.org/wiki/Process_identifier">pid</a> <code>1</code>. There are many things to do before the kernel will start first <code>init</code> process. Hope we will see all of the preparations before kernel will start in this big chapter. We will start from the kernel entry point, which is located in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/head_64.S">arch/x86/kernel/head_64.S</a> and will move further and further. We will see first preparations like early page tables initialization, switch to a new descriptor in kernel space and many many more, before we will see the <code>start_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/master/init/main.c">init/main.c</a> will be called.</p>
<p>In the last <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-6">part</a> of the previous <a href="https://0xax.gitbook.io/linux-insides/summary/booting">chapter</a> we stopped at the jmp instruction from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly source code file:</p>
<pre><code class="language-assembly">jmp	*%rax
</code></pre>
<p>At this moment the <code>rax</code> register contains address of the Linux kernel entry point which was obtained as a result of the call of the <code>decompress_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/boot/compressed/misc.c">arch/x86/boot/compressed/misc.c</a> source code file. So, our last instruction in the kernel setup code is a jump on the kernel entry point. We already know where the entry point of the Linux kernel is defined, so we are able to start to learn what Linux kernel does after the start.</p>
<h2 id="first-steps-in-the-kernel"><a class="header" href="#first-steps-in-the-kernel">First steps in the kernel</a></h2>
<p>Okay, we got the address of the decompressed kernel image from the <code>decompress_kernel</code> function into <code>rax</code> register and just jumped there. As we already know the entry point of the decompressed kernel image starts in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/head_64.S">arch/x86/kernel/head_64.S</a> assembly source code file and at the beginning of it, we can see following definitions:</p>
<pre><code class="language-assembly">    .text
	__HEAD
	.code64
	.globl startup_64
startup_64:
	...
	...
	...
</code></pre>
<p>We can see definition of the <code>startup_64</code> routine that is defined in the <code>__HEAD</code> section, which is just a macro which expands to the definition of executable <code>.head.text</code> section:</p>
<pre><code class="language-C">#define __HEAD		.section	&quot;.head.text&quot;,&quot;ax&quot;
</code></pre>
<p>We can see definition of this section in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/vmlinux.lds.S">arch/x86/kernel/vmlinux.lds.S</a> linker script:</p>
<pre><code>.text : AT(ADDR(.text) - LOAD_OFFSET) {
	_text = .;
	...
	...
	...
} :text = 0x9090
</code></pre>
<p>The ADDR keyword above returns the absolute address (here means virtual address) of the named section. The AT keyword above specifies the load address (here means physical address) of the section. The full syntax of section definition is defined in the <a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_21.html">Using ld The GNU linker</a>. </p>
<p>Besides the definition of the <code>.text</code> section, we can understand default virtual and physical addresses from the linker script. Note that address of the <code>_text</code> is location counter which is defined as:</p>
<pre><code>. = __START_KERNEL;
</code></pre>
<p>for <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a>. The definition of the <code>__START_KERNEL</code> macro is located in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/page_types.h">arch/x86/include/asm/page_types.h</a> header file and represented by the sum of the base virtual address of the kernel mapping and physical start:</p>
<pre><code class="language-C">#define __START_KERNEL	(__START_KERNEL_map + __PHYSICAL_START)

#define __PHYSICAL_START  ALIGN(CONFIG_PHYSICAL_START, CONFIG_PHYSICAL_ALIGN)
</code></pre>
<p>Or in other words:</p>
<ul>
<li>Base physical address of the Linux kernel - <code>0x1000000</code>;</li>
<li>Base virtual address of the Linux kernel - <code>0xffffffff81000000</code>.</li>
</ul>
<p>After we sanitized CPU configuration, we call <code>__startup_64</code> function which is defined in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/head64.c">arch/x86/kernel/head64.c</a>:</p>
<pre><code class="language-assembly">	leaq	_text(%rip), %rdi
	pushq	%rsi
	call	__startup_64
	popq	%rsi
</code></pre>
<pre><code class="language-C">unsigned long __head __startup_64(unsigned long physaddr,
				 struct boot_params *bp)
{
	unsigned long load_delta, *p;
	unsigned long pgtable_flags;
	pgdval_t *pgd;
	p4dval_t *p4d;
	pudval_t *pud;
	pmdval_t *pmd, pmd_entry;
	pteval_t *mask_ptr;
	bool la57;
	int i;
	unsigned int *next_pgt_ptr;
	...
	...
	...
}
</code></pre>
<p>Since <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization#Linux">kASLR</a> is enabled, the address <code>startup_64</code> routine was loaded may be different from the address compiled to run at, so we need to calculate the delta with the following code:</p>
<pre><code class="language-C">	load_delta = physaddr - (unsigned long)(_text - __START_KERNEL_map);
</code></pre>
<p>As a result, <code>load_delta</code> contains the delta between the address compiled to run at and the address actually loaded.</p>
<p>After we got the delta, we check if <code>_text</code> address is correctly aligned for <code>2</code> megabytes. We will do it with the following code:</p>
<pre><code class="language-C">	if (load_delta &amp; ~PMD_PAGE_MASK)
		for (;;);
</code></pre>
<p>If <code>_text</code> address is not aligned for <code>2</code> megabytes, we enter infinite loop. The <code>PMD_PAGE_MASK</code> indicates the mask for <code>Page middle directory</code> (read <a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-1">Paging</a> about it) and is defined as:</p>
<pre><code class="language-C">#define PMD_PAGE_MASK           (~(PMD_PAGE_SIZE-1))
</code></pre>
<p>where <code>PMD_PAGE_SIZE</code> macro is defined as:</p>
<pre><code class="language-C">#define PMD_PAGE_SIZE           (_AC(1, UL) &lt;&lt; PMD_SHIFT)
#define PMD_SHIFT		21
</code></pre>
<p>As we can easily calculate, <code>PMD_PAGE_SIZE</code> is <code>2</code> megabytes.</p>
<p>If <a href="https://en.wikipedia.org/wiki/Zen_%28microarchitecture%29#Enhanced_security_and_virtualization_support">SME</a> is supported and enabled, we activate it and include the SME encryption mask in <code>load_delta</code>:</p>
<pre><code class="language-C">	sme_enable(bp);
	load_delta += sme_get_me_mask();
</code></pre>
<p>Okay, we did some early checks and now we can move on.</p>
<h2 id="fix-base-addresses-of-page-tables"><a class="header" href="#fix-base-addresses-of-page-tables">Fix base addresses of page tables</a></h2>
<p>In the next step we fixup the physical addresses in the page table:</p>
<pre><code class="language-C">	pgd = fixup_pointer(&amp;early_top_pgt, physaddr);
	pud = fixup_pointer(&amp;level3_kernel_pgt, physaddr);
	pmd = fixup_pointer(level2_fixmap_pgt, physaddr);
</code></pre>
<p>So, let's look at the definition of <code>fixup_pointer</code> function which returns physical address of the passed argument:</p>
<pre><code class="language-C">static void __head *fixup_pointer(void *ptr, unsigned long physaddr)
{
	return ptr - (void *)_text + (void *)physaddr;
}
</code></pre>
<p>Next we'll focus on <code>early_top_pgt</code> and the other page table symbols which we saw above. Let's try to understand what these symbols mean. First of all let's look at their definition:</p>
<pre><code class="language-assembly">NEXT_PAGE(early_top_pgt)
	.fill	512,8,0
	.fill	PTI_USER_PGD_FILL,8,0

NEXT_PAGE(level3_kernel_pgt)
	.fill	L3_START_KERNEL,8,0
	.quad	level2_kernel_pgt - __START_KERNEL_map + _KERNPG_TABLE_NOENC
	.quad	level2_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE_NOENC

NEXT_PAGE(level2_kernel_pgt)
	PMDS(0, __PAGE_KERNEL_LARGE_EXEC,
		KERNEL_IMAGE_SIZE/PMD_SIZE)

NEXT_PAGE(level2_fixmap_pgt)
	.fill	506,8,0
	.quad	level1_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE_NOENC
	.fill	5,8,0

NEXT_PAGE(level1_fixmap_pgt)
	.fill	512,8,0
</code></pre>
<p>Looks hard, but it isn't. First of all let's look at the <code>early_top_pgt</code>. It starts with the <code>4096</code> bytes of zeros (or <code>8192</code> bytes if <code>CONFIG_PAGE_TABLE_ISOLATION</code> is enabled), it means that we don't use the first <code>512</code> entries. And after this we can see <code>level3_kernel_pgt</code> entry. At the start of its definition, we can see that it is filled with the <code>4080</code> bytes of zeros (<code>L3_START_KERNEL</code> equals <code>510</code>). Subsequently, it stores two entries which map kernel space. Note that we subtract <code>__START_KERNEL_map</code> from <code>level2_kernel_pgt</code> and <code>level2_fixmap_pgt</code>. As we know <code>__START_KERNEL_map</code> is a base virtual address of the kernel text, so if we subtract <code>__START_KERNEL_map</code>, we will get physical addresses of the <code>level2_kernel_pgt</code> and <code>level2_fixmap_pgt</code>.</p>
<p>Next let's look at <code>_KERNPG_TABLE_NOENC</code> and <code>_PAGE_TABLE_NOENC</code>, these are just page entry access rights:</p>
<pre><code class="language-C">#define _KERNPG_TABLE_NOENC   (_PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED | \
			       _PAGE_DIRTY)
#define _PAGE_TABLE_NOENC     (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | \
			       _PAGE_ACCESSED | _PAGE_DIRTY)
</code></pre>
<p>The <code>level2_kernel_pgt</code> is page table entry which contains pointer to the page middle directory which maps kernel space. It calls the <code>PDMS</code> macro which creates <code>512</code> megabytes from the <code>__START_KERNEL_map</code> for kernel <code>.text</code> (after these <code>512</code> megabytes will be module memory space).</p>
<p>The <code>level2_fixmap_pgt</code> is a virtual addresses which can refer to any physical addresses even under kernel space. They are represented by the <code>4048</code> bytes of zeros, the <code>level1_fixmap_pgt</code> entry, <code>8</code> megabytes reserved for <a href="https://lwn.net/Articles/446528/">vsyscalls</a> mapping and <code>2</code> megabytes of hole.</p>
<p>You can read more about it in the <a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-1">Paging</a> part.</p>
<p>Now, after we saw the definitions of these symbols, let's get back to the code. Next we initialize last entry of <code>pgd</code> with <code>level3_kernel_pgt</code>:</p>
<pre><code class="language-C">	pgd[pgd_index(__START_KERNEL_map)] = level3_kernel_pgt - __START_KERNEL_map + _PAGE_TABLE_NOENC;
</code></pre>
<p>All of <code>p*d</code> addresses may be wrong if the <code>startup_64</code> is not equal to default <code>0x1000000</code> address. Remember that the <code>load_delta</code> contains delta between the address of the <code>startup_64</code> symbol which was got during kernel <a href="https://en.wikipedia.org/wiki/Linker_%28computing%29">linking</a> and the actual address. So we add the delta to the certain entries of the <code>p*d</code>.</p>
<pre><code class="language-C">	pgd[pgd_index(__START_KERNEL_map)] += load_delta;
	pud[510] += load_delta;
	pud[511] += load_delta;
	pmd[506] += load_delta;
</code></pre>
<p>After all of this we will have:</p>
<pre><code>early_top_pgt[511] -&gt; level3_kernel_pgt[0]
level3_kernel_pgt[510] -&gt; level2_kernel_pgt[0]
level3_kernel_pgt[511] -&gt; level2_fixmap_pgt[0]
level2_kernel_pgt[0]   -&gt; 512 MB kernel mapping
level2_fixmap_pgt[506] -&gt; level1_fixmap_pgt
</code></pre>
<p>Note that we didn't fixup base address of the <code>early_top_pgt</code> and some of other page table directories, because we will see this when building/filling structures of these page tables. As we corrected base addresses of the page tables, we can start to build it.</p>
<h2 id="identity-mapping-setup"><a class="header" href="#identity-mapping-setup">Identity mapping setup</a></h2>
<p>Now we can see the set up of identity mapping of early page tables. In Identity Mapped Paging, virtual addresses are mapped to physical addresses identically. Let's look at it in detail. First of all we replace <code>pud</code> and <code>pmd</code> with the pointer to first and second entry of <code>early_dynamic_pgts</code>:</p>
<pre><code class="language-C">	next_pgt_ptr = fixup_pointer(&amp;next_early_pgt, physaddr);
	pud = fixup_pointer(early_dynamic_pgts[(*next_pgt_ptr)++], physaddr);
	pmd = fixup_pointer(early_dynamic_pgts[(*next_pgt_ptr)++], physaddr);
</code></pre>
<p>Let's look at the <code>early_dynamic_pgts</code> definition:</p>
<pre><code class="language-assembly">NEXT_PAGE(early_dynamic_pgts)
	.fill	512*EARLY_DYNAMIC_PAGE_TABLES,8,0
</code></pre>
<p>which will store temporary page tables for early kernel.</p>
<p>Next we initialize <code>pgtable_flags</code> which will be used when initializing <code>p*d</code> entries later:</p>
<pre><code class="language-C">	pgtable_flags = _KERNPG_TABLE_NOENC + sme_get_me_mask();
</code></pre>
<p><code>sme_get_me_mask</code> function returns <code>sme_me_mask</code> which was initialized in <code>sme_enable</code> function.</p>
<p>Next we fill two entries of <code>pgd</code> with <code>pud</code> plus <code>pgtable_flags</code> which we initialized above:</p>
<pre><code class="language-C">	i = (physaddr &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD;
	pgd[i + 0] = (pgdval_t)pud + pgtable_flags;
	pgd[i + 1] = (pgdval_t)pud + pgtable_flags;
</code></pre>
<p><code>PGDIR_SHFT</code> indicates the mask for page global directory bits in a virtual address. Here we calculate modulo with <code>PTRS_PER_PGD</code> (which expands to <code>512</code>) so as not to access the index greater than <code>512</code>. There are macro for all types of page directories:</p>
<pre><code class="language-C">#define PGDIR_SHIFT     39
#define PTRS_PER_PGD	512
#define PUD_SHIFT       30
#define PTRS_PER_PUD	512
#define PMD_SHIFT       21
#define PTRS_PER_PMD	512
</code></pre>
<p>We do the almost same thing above:</p>
<pre><code class="language-C">	i = (physaddr &gt;&gt; PUD_SHIFT) % PTRS_PER_PUD;
	pud[i + 0] = (pudval_t)pmd + pgtable_flags;
	pud[i + 1] = (pudval_t)pmd + pgtable_flags;
</code></pre>
<p>Next we initialize <code>pmd_entry</code> and filter out unsupported <code>__PAGE_KERNEL_*</code> bits:</p>
<pre><code class="language-C">	pmd_entry = __PAGE_KERNEL_LARGE_EXEC &amp; ~_PAGE_GLOBAL;
	mask_ptr = fixup_pointer(&amp;__supported_pte_mask, physaddr);
	pmd_entry &amp;= *mask_ptr;
	pmd_entry += sme_get_me_mask();
	pmd_entry += physaddr;
</code></pre>
<p>Next we fill all <code>pmd</code> entries to cover full size of the kernel:</p>
<pre><code class="language-C">	for (i = 0; i &lt; DIV_ROUND_UP(_end - _text, PMD_SIZE); i++) {
		int idx = i + (physaddr &gt;&gt; PMD_SHIFT) % PTRS_PER_PMD;
		pmd[idx] = pmd_entry + i * PMD_SIZE;
	}
</code></pre>
<p>Next we fixup the kernel text+data virtual addresses. Note that we might write invalid pmds, when the kernel is relocated (<code>cleanup_highmap</code> function fixes this up along with the mappings beyond <code>_end</code>).</p>
<pre><code class="language-C">	pmd = fixup_pointer(level2_kernel_pgt, physaddr);
	for (i = 0; i &lt; PTRS_PER_PMD; i++) {
		if (pmd[i] &amp; _PAGE_PRESENT)
			pmd[i] += load_delta;
	}
</code></pre>
<p>Next we remove the memory encryption mask to obtain the true physical address (remember that <code>load_delta</code> includes the mask):</p>
<pre><code class="language-C">	*fixup_long(&amp;phys_base, physaddr) += load_delta - sme_get_me_mask();
</code></pre>
<p><code>phys_base</code> must match the first entry in <code>level2_kernel_pgt</code>.</p>
<p>As final step of <code>__startup_64</code> function, we encrypt the kernel (if SME is active) and return the SME encryption mask to be used as a modifier for the initial page directory entry programmed into <code>cr3</code> register:</p>
<pre><code class="language-C">	sme_encrypt_kernel(bp);
	return sme_get_me_mask();
</code></pre>
<p>Now let's get back to assembly code. We prepare for next paragraph with following code:</p>
<pre><code class="language-assembly">	addq	$(early_top_pgt - __START_KERNEL_map), %rax
	jmp 1f
</code></pre>
<p>which adds physical address of <code>early_top_pgt</code> to <code>rax</code> register so that <code>rax</code> register contains sum of the address and the SME encryption mask.</p>
<p>That's all for now. Our early paging is prepared and we just need to finish last preparation before we will jump into kernel entry point.</p>
<h2 id="last-preparation-before-jump-at-the-kernel-entry-point"><a class="header" href="#last-preparation-before-jump-at-the-kernel-entry-point">Last preparation before jump at the kernel entry point</a></h2>
<p>After that we jump to the label <code>1</code> we enable <code>PAE</code>, <code>PGE</code> (Paging Global Extension) and put the content of the <code>phys_base</code> (see above) to the <code>rax</code> register and fill <code>cr3</code> register with it:</p>
<pre><code class="language-assembly">1:
	movl	$(X86_CR4_PAE | X86_CR4_PGE), %ecx
	movq	%rcx, %cr4

	addq	phys_base(%rip), %rax
	movq	%rax, %cr3
</code></pre>
<p>In the next step we check that CPU supports <a href="http://en.wikipedia.org/wiki/NX_bit">NX</a> bit with:</p>
<pre><code class="language-assembly">	movl	$0x80000001, %eax
	cpuid
	movl	%edx,%edi
</code></pre>
<p>We put <code>0x80000001</code> value to the <code>eax</code> and execute <code>cpuid</code> instruction for getting the extended processor info and feature bits. The result will be in the <code>edx</code> register which we put to the <code>edi</code>.</p>
<p>Now we put <code>0xc0000080</code> or <code>MSR_EFER</code> to the <code>ecx</code> and execute <code>rdmsr</code> instruction for the reading model specific register.</p>
<pre><code class="language-assembly">	movl	$MSR_EFER, %ecx
	rdmsr
</code></pre>
<p>The result will be in the <code>edx:eax</code>. General view of the <code>EFER</code> is following:</p>
<pre><code>63                                                                              32
 --------------------------------------------------------------------------------
|                                                                               |
|                                Reserved MBZ                                   |
|                                                                               |
 --------------------------------------------------------------------------------
31                            16  15      14      13   12  11   10  9  8 7  1   0
 --------------------------------------------------------------------------------
|                              | T |       |       |    |   |   |   |   |   |   |
| Reserved MBZ                 | C | FFXSR | LMSLE |SVME|NXE|LMA|MBZ|LME|RAZ|SCE|
|                              | E |       |       |    |   |   |   |   |   |   |
 --------------------------------------------------------------------------------
</code></pre>
<p>We will not see all fields in details here, but we will learn about this and other <code>MSRs</code> in a special part about it. As we read <code>EFER</code> to the <code>edx:eax</code>, we check <code>_EFER_SCE</code> or zero bit which is <code>System Call Extensions</code> with <code>btsl</code> instruction and set it to one. By the setting <code>SCE</code> bit we enable <code>SYSCALL</code> and <code>SYSRET</code> instructions. In the next step we check 20th bit in the <code>edi</code>, remember that this register stores result of the <code>cpuid</code> (see above). If <code>20</code> bit is set (<code>NX</code> bit) we just write <code>EFER_SCE</code> to the model specific register.</p>
<pre><code class="language-assembly">	btsl	$_EFER_SCE, %eax
	btl	$20,%edi
	jnc     1f
	btsl	$_EFER_NX, %eax
	btsq	$_PAGE_BIT_NX,early_pmd_flags(%rip)
1:	wrmsr
</code></pre>
<p>If the <a href="https://en.wikipedia.org/wiki/NX_bit">NX</a> bit is supported we enable <code>_EFER_NX</code>  and write it too, with the <code>wrmsr</code> instruction. After the <a href="https://en.wikipedia.org/wiki/NX_bit">NX</a> bit is set, we set some bits in the <code>cr0</code> <a href="https://en.wikipedia.org/wiki/Control_register">control register</a> with following assembly code:</p>
<pre><code class="language-assembly">	movl	$CR0_STATE, %eax
	movq	%rax, %cr0
</code></pre>
<p>specifically the following bits:</p>
<ul>
<li><code>X86_CR0_PE</code> - system is in protected mode;</li>
<li><code>X86_CR0_MP</code> - controls interaction of WAIT/FWAIT instructions with TS flag in CR0;</li>
<li><code>X86_CR0_ET</code> - on the 386, it allowed to specify whether the external math coprocessor was an 80287 or 80387;</li>
<li><code>X86_CR0_NE</code> - enable internal x87 floating point error reporting when set, else enables PC style x87 error detection;</li>
<li><code>X86_CR0_WP</code> - when set, the CPU can't write to read-only pages when privilege level is 0;</li>
<li><code>X86_CR0_AM</code> - alignment check enabled if AM set, AC flag (in EFLAGS register) set, and privilege level is 3;</li>
<li><code>X86_CR0_PG</code> - enable paging.</li>
</ul>
<p>We already know that to run any code, and even more <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> code from assembly, we need to setup a stack. As always, we are doing it by the setting of <a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a> to a correct place in memory and resetting <a href="https://en.wikipedia.org/wiki/FLAGS_register">flags</a> register after this:</p>
<pre><code class="language-assembly">	movq initial_stack(%rip), %rsp
	pushq $0
	popfq
</code></pre>
<p>The most interesting thing here is the <code>initial_stack</code>. This symbol is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/head_64.S">source</a> code file and looks like:</p>
<pre><code class="language-assembly">GLOBAL(initial_stack)
    .quad  init_thread_union + THREAD_SIZE - SIZEOF_PTREGS
</code></pre>
<p>The <code>THREAD_SIZE</code> macro is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/page_64_types.h">arch/x86/include/asm/page_64_types.h</a> header file and depends on value of the <code>KASAN_STACK_ORDER</code> macro:</p>
<pre><code class="language-C">#ifdef CONFIG_KASAN
#define KASAN_STACK_ORDER 1
#else
#define KASAN_STACK_ORDER 0
#endif

#define THREAD_SIZE_ORDER       (2 + KASAN_STACK_ORDER)
#define THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)
</code></pre>
<p>We consider when the <a href="https://github.com/torvalds/linux/blob/master/Documentation/dev-tools/kasan.rst">kasan</a> is disabled and the <code>PAGE_SIZE</code> is <code>4096</code> bytes. So the <code>THREAD_SIZE</code> will expands to <code>16</code> kilobytes and represents size of the stack of a thread. Why is <code>thread</code>? You may already know that each <a href="https://en.wikipedia.org/wiki/Process_%28computing%29">process</a> may have <a href="https://en.wikipedia.org/wiki/Parent_process">parent processes</a> and <a href="https://en.wikipedia.org/wiki/Child_process">child processes</a>. Actually, a parent process and child process differ in stack. A new kernel stack is allocated for a new process. In the Linux kernel this stack is represented by the <a href="https://en.wikipedia.org/wiki/Union_type#C.2FC.2B.2B">union</a> with the <code>thread_info</code> structure.</p>
<p>The <code>init_thread_union</code> is represented by the <code>thread_union</code>. And the <code>thread_union</code> is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h">include/linux/sched.h</a> file like the following:</p>
<pre><code class="language-C">union thread_union {
#ifndef CONFIG_ARCH_TASK_STRUCT_ON_STACK
	struct task_struct task;
#endif
#ifndef CONFIG_THREAD_INFO_IN_TASK
	struct thread_info thread_info;
#endif
	unsigned long stack[THREAD_SIZE/sizeof(long)];
};
</code></pre>
<p>The <code>CONFIG_ARCH_TASK_STRUCT_ON_STACK</code> kernel configuration option is only enabled for <code>ia64</code> architecture, and the <code>CONFIG_THREAD_INFO_IN_TASK</code> kernel configuration option is enabled for <code>x86_64</code> architecture. Thus the <code>thread_info</code> structure will be placed in <code>task_struct</code> structure instead of the <code>thread_union</code> union.</p>
<p>The <code>init_thread_union</code> is placed in the <a href="https://github.com/torvalds/blob/master/include/asm-generic/vmlinux.lds.h">include/asm-generic/vmlinux.lds.h</a> file as part of the <code>INIT_TASK_DATA</code> macro like the following:</p>
<pre><code class="language-C">#define INIT_TASK_DATA(align)  \
	. = ALIGN(align);      \
	...                    \
	init_thread_union = .; \
	...
</code></pre>
<p>This macro is used in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/vmlinux.lds.S">arch/x86/kernel/vmlinux.lds.S</a> file like the following:</p>
<pre><code>.data : AT(ADDR(.data) - LOAD_OFFSET) {
	...
	INIT_TASK_DATA(THREAD_SIZE)
	...
} :data
</code></pre>
<p>That is, <code>init_thread_union</code> is initialized with the address which is aligned to <code>THREAD_SIZE</code> which is <code>16</code> kilobytes.</p>
<p>Now we may understand this expression:</p>
<pre><code class="language-assembly">GLOBAL(initial_stack)
    .quad  init_thread_union + THREAD_SIZE - SIZEOF_PTREGS
</code></pre>
<p>that <code>initial_stack</code> symbol points to the start of the <code>thread_union.stack</code> array + <code>THREAD_SIZE</code> which is 16 killobytes and - <code>SIZEOF_PTREGS</code> which is convention which helps the in-kernel unwinder reliably detect the end of the stack.</p>
<p>After the early boot stack is set, to update the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a> with the <code>lgdt</code> instruction:</p>
<pre><code class="language-assembly">lgdt	early_gdt_descr(%rip)
</code></pre>
<p>where the <code>early_gdt_descr</code> is defined as:</p>
<pre><code class="language-assembly">early_gdt_descr:
	.word	GDT_ENTRIES*8-1
early_gdt_descr_base:
	.quad	INIT_PER_CPU_VAR(gdt_page)
</code></pre>
<p>We need to reload <code>Global Descriptor Table</code> because now kernel works in the low userspace addresses, but soon kernel will work in its own space.</p>
<p>Now let's look at the definition of <code>early_gdt_descr</code>. <code>GDT_ENTRIES</code> expands to <code>32</code> so that Global Descriptor Table contains <code>32</code> entries for kernel code, data, thread local storage segments and etc...</p>
<p>Now let's look at the definition of <code>early_gdt_descr_base</code>. The <code>gdt_page</code> structure is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/desc.h">arch/x86/include/asm/desc.h</a> as:</p>
<pre><code class="language-C">struct gdt_page {
	struct desc_struct gdt[GDT_ENTRIES];
} __attribute__((aligned(PAGE_SIZE)));
</code></pre>
<p>It contains one field <code>gdt</code> which is array of the <code>desc_struct</code> structure which is defined as:</p>
<pre><code class="language-C">struct desc_struct {
         union {
                 struct {
                         unsigned int a;
                         unsigned int b;
                 };
                 struct {
                         u16 limit0;
                         u16 base0;
                         unsigned base1: 8, type: 4, s: 1, dpl: 2, p: 1;
                         unsigned limit: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8;
                 };
         };
 } __attribute__((packed));
</code></pre>
<p>which looks familiar <code>GDT</code> descriptor. Note that <code>gdt_page</code> structure is aligned to <code>PAGE_SIZE</code> which is <code>4096</code> bytes. Which means that <code>gdt</code> will occupy one page.</p>
<p>Now let's try to understand what <code>INIT_PER_CPU_VAR</code> is. <code>INIT_PER_CPU_VAR</code> is a macro which is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/percpu.h">arch/x86/include/asm/percpu.h</a> and just concatenates <code>init_per_cpu__</code> with the given parameter:</p>
<pre><code class="language-C">#define INIT_PER_CPU_VAR(var) init_per_cpu__##var
</code></pre>
<p>After the <code>INIT_PER_CPU_VAR</code> macro will be expanded, we will have <code>init_per_cpu__gdt_page</code>. We can see the initialization of <code>init_per_cpu__gdt_page</code> in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/vmlinux.lds.S">linker script</a>:</p>
<pre><code>#define INIT_PER_CPU(x) init_per_cpu__##x = x + __per_cpu_load
INIT_PER_CPU(gdt_page);
</code></pre>
<p>As we got <code>init_per_cpu__gdt_page</code> in <code>INIT_PER_CPU_VAR</code> and <code>INIT_PER_CPU</code> macro from linker script will be expanded we will get offset from the <code>__per_cpu_load</code>. After this calculations, we will have correct base address of the new GDT.</p>
<p>Generally per-CPU variables is a 2.6 kernel feature. You can understand what it is from its name. When we create <code>per-CPU</code> variable, each CPU will have its own copy of this variable. Here we are creating <code>gdt_page</code> per-CPU variable. There are many advantages for variables of this type, like there are no locks, because each CPU works with its own copy of variable and etc... So every core on multiprocessor will have its own <code>GDT</code> table and every entry in the table will represent a memory segment which can be accessed from the thread which ran on the core. You can read in details about <code>per-CPU</code> variables in the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">Concepts/per-cpu</a> post.</p>
<p>As we loaded new Global Descriptor Table, we reload segments as we did it every time:</p>
<pre><code class="language-assembly">	xorl %eax,%eax
	movl %eax,%ds
	movl %eax,%ss
	movl %eax,%es
	movl %eax,%fs
	movl %eax,%gs
</code></pre>
<p>After all of these steps we set up <code>gs</code> register that it post to the <code>irqstack</code> which represents special stack where <a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a> will be handled on:</p>
<pre><code class="language-assembly">	movl	$MSR_GS_BASE,%ecx
	movl	initial_gs(%rip),%eax
	movl	initial_gs+4(%rip),%edx
	wrmsr
</code></pre>
<p>where <code>MSR_GS_BASE</code> is:</p>
<pre><code class="language-C">#define MSR_GS_BASE             0xc0000101
</code></pre>
<p>We need to put <code>MSR_GS_BASE</code> to the <code>ecx</code> register and load data from the <code>eax</code> and <code>edx</code> (which point to the <code>initial_gs</code>) with <code>wrmsr</code> instruction. We don't use <code>cs</code>, <code>fs</code>, <code>ds</code> and <code>ss</code> segment registers for addressing in the 64-bit mode, but <code>fs</code> and <code>gs</code> registers can be used. <code>fs</code> and <code>gs</code> have a hidden part (as we saw it in the real mode for <code>cs</code>) and this part contains a descriptor which is mapped to <a href="https://en.wikipedia.org/wiki/Model-specific_register">Model Specific Registers</a>. So we can see above <code>0xc0000101</code> is a <code>gs.base</code> MSR address. When a <a href="https://en.wikipedia.org/wiki/System_call">system call</a> or <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a> occurs, there is no kernel stack at the entry point, so the value of the <code>MSR_GS_BASE</code> will store address of the interrupt stack.</p>
<p>In the next step we put the address of the real mode bootparam structure to the <code>rdi</code> (remember <code>rsi</code> holds pointer to this structure from the start) and jump to the C code with:</p>
<pre><code class="language-assembly">	pushq	$.Lafter_lret	# put return address on stack for unwinder
	xorq	%rbp, %rbp	# clear frame pointer
	movq	initial_code(%rip), %rax
	pushq	$__KERNEL_CS	# set correct cs
	pushq	%rax		# target address in negative space
	lretq
.Lafter_lret:
</code></pre>
<p>Here we put the address of the <code>initial_code</code> to the <code>rax</code> and push the return address, <code>__KERNEL_CS</code> and the address of the <code>initial_code</code> to the stack. After this we can see <code>lretq</code> instruction which means that after it return address will be extracted from stack (now there is address of the <code>initial_code</code>) and jump there. <code>initial_code</code> is defined in the same source code file and looks:</p>
<pre><code class="language-assembly">	.balign	8
	GLOBAL(initial_code)
	.quad	x86_64_start_kernel
	...
	...
	...
</code></pre>
<p>As we can see <code>initial_code</code> contains address of the <code>x86_64_start_kernel</code>, which is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/head64.c">arch/x86/kerne/head64.c</a> and looks like this:</p>
<pre><code class="language-C">asmlinkage __visible void __init x86_64_start_kernel(char * real_mode_data)
{
	...
	...
	...
}
</code></pre>
<p>It has one argument is a <code>real_mode_data</code> (remember that we passed address of the real mode data to the <code>rdi</code> register previously).</p>
<h2 id="next-to-start_kernel"><a class="header" href="#next-to-start_kernel">Next to start_kernel</a></h2>
<p>We need to see last preparations before we can see &quot;kernel entry point&quot; - start_kernel function from the <a href="https://github.com/torvalds/linux/blob/master/init/main.c">init/main.c</a>.</p>
<p>First of all we can see some checks in the <code>x86_64_start_kernel</code> function:</p>
<pre><code class="language-C">BUILD_BUG_ON(MODULES_VADDR &lt; __START_KERNEL_map);
BUILD_BUG_ON(MODULES_VADDR - __START_KERNEL_map &lt; KERNEL_IMAGE_SIZE);
BUILD_BUG_ON(MODULES_LEN + KERNEL_IMAGE_SIZE &gt; 2*PUD_SIZE);
BUILD_BUG_ON((__START_KERNEL_map &amp; ~PMD_MASK) != 0);
BUILD_BUG_ON((MODULES_VADDR &amp; ~PMD_MASK) != 0);
BUILD_BUG_ON(!(MODULES_VADDR &gt; __START_KERNEL));
MAYBE_BUILD_BUG_ON(!(((MODULES_END - 1) &amp; PGDIR_MASK) == (__START_KERNEL &amp; PGDIR_MASK)));
BUILD_BUG_ON(__fix_to_virt(__end_of_fixed_addresses) &lt;= MODULES_END);
</code></pre>
<p>There are checks for different things like virtual address of module space is not fewer than base address of the kernel text - <code>__STAT_KERNEL_map</code>, that kernel text with modules is not less than image of the kernel and etc... <code>BUILD_BUG_ON</code> is a macro which looks as:</p>
<pre><code class="language-C">#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
</code></pre>
<p>Let's try to understand how this trick works. Let's take for example first condition: <code>MODULES_VADDR &lt; __START_KERNEL_map</code>. <code>!!conditions</code> is the same that <code>condition != 0</code>. So it means if <code>MODULES_VADDR &lt; __START_KERNEL_map</code> is true, we will get <code>1</code> in the <code>!!(condition)</code> or zero if not. After <code>2*!!(condition)</code> we will get or <code>2</code> or <code>0</code>. In the end of calculations we can get two different behaviors:</p>
<ul>
<li>We will have compilation error, because try to get size of the char array with negative index (as can be in our case, because <code>MODULES_VADDR</code> can't be less than <code>__START_KERNEL_map</code> will be in our case);</li>
<li>No compilation errors.</li>
</ul>
<p>That's all. So interesting C trick for getting compile error which depends on some constants.</p>
<p>In the next step we can see call of the <code>cr4_init_shadow</code> function which stores shadow copy of the <code>cr4</code> per cpu. Context switches can change bits in the <code>cr4</code> so we need to store <code>cr4</code> for each CPU. And after this we can see call of the <code>reset_early_page_tables</code> function where we resets all page global directory entries and write new pointer to the PGT in <code>cr3</code>:</p>
<pre><code class="language-C">	memset(early_top_pgt, 0, sizeof(pgd_t)*(PTRS_PER_PGD-1));
	next_early_pgt = 0;
	write_cr3(__sme_pa_nodebug(early_top_pgt));
</code></pre>
<p>Soon we will build new page tables. Here we can see that we zero all Page Global Directory entries. After this we set <code>next_early_pgt</code> to zero (we will see details about it in the next post) and write physical address of the <code>early_top_pgt</code> to the <code>cr3</code>.</p>
<p>After this we clear <code>_bss</code> from the <code>__bss_stop</code> to <code>__bss_start</code> and also clear <code>init_top_pgt</code>. <code>init_top_pgt</code> is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/head_64.S">arch/x86/kerne/head_64.S</a> like the following:</p>
<pre><code class="language-assembly">NEXT_PGD_PAGE(init_top_pgt)
	.fill	512,8,0
	.fill	PTI_USER_PGD_FILL,8,0
</code></pre>
<p>This is exactly the same definition as <code>early_top_pgt</code>.</p>
<p>The next step will be setup of the early <code>IDT</code> handlers, but it's big concept so we will see it in the next post.</p>
<h2 id="conclusion-6"><a class="header" href="#conclusion-6">Conclusion</a></h2>
<p>This is the end of the first part about Linux kernel initialization.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p>In the next part we will see initialization of the early interruption handlers, kernel space memory mapping and a lot more.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-6"><a class="header" href="#links-6">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Model-specific_register">Model Specific Register</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-1">Paging</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-6">Previous part - kernel load address randomization</a></li>
<li><a href="http://en.wikipedia.org/wiki/NX_bit">NX</a></li>
<li><a href="http://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-initialization-part-2"><a class="header" href="#kernel-initialization-part-2">Kernel initialization. Part 2.</a></h1>
<h2 id="early-interrupt-and-exception-handling"><a class="header" href="#early-interrupt-and-exception-handling">Early interrupt and exception handling</a></h2>
<p>In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">part</a> we stopped before setting of early interrupt handlers. At this moment we are in the decompressed Linux kernel, we have basic <a href="https://en.wikipedia.org/wiki/Page_table">paging</a> structure for early boot and our current goal is to finish early preparation before the main kernel code will start to work.</p>
<p>We already started to do this preparation in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">first</a> part of this <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">chapter</a>. We continue in this part and will know more about interrupt and exception handling.</p>
<p>Remember that we stopped before following function:</p>
<pre><code class="language-C">	idt_setup_early_handler();
</code></pre>
<p>from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/head64.c">arch/x86/kernel/head64.c</a> source code file. But before we start to sort out this function, we need to know about interrupts and handlers.</p>
<h2 id="some-theory"><a class="header" href="#some-theory">Some theory</a></h2>
<p>An interrupt is an event caused by software or hardware to the CPU. For example a user have pressed a key on keyboard. On interrupt, CPU stops the current task and transfer control to the special routine which is called - <a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt handler</a>. An interrupt handler handles and interrupt and transfer control back to the previously stopped task. We can split interrupts on three types:</p>
<ul>
<li>Software interrupts - when a software signals CPU that it needs kernel attention. These interrupts are generally used for system calls;</li>
<li>Hardware interrupts - when a hardware event happens, for example button is pressed on a keyboard;</li>
<li>Exceptions - interrupts generated by CPU, when the CPU detects error, for example division by zero or accessing a memory page which is not in RAM.</li>
</ul>
<p>Every interrupt and exception is assigned a unique number which is called - <code>vector number</code>. <code>Vector number</code> can be any number from <code>0</code> to <code>255</code>. There is common practice to use first <code>32</code> vector numbers for exceptions, and vector numbers from <code>32</code> to <code>255</code> are used for user-defined interrupts.</p>
<p>CPU uses vector number as an index in the <code>Interrupt Descriptor Table</code> (we will see description of it soon). CPU catches interrupts from the <a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a> or through its pins. Following table shows <code>0-31</code> exceptions:</p>
<pre><code>----------------------------------------------------------------------------------------------
|Vector|Mnemonic|Description         |Type |Error Code|Source                   |
----------------------------------------------------------------------------------------------
|0     | #DE    |Divide Error        |Fault|NO        |DIV and IDIV                          |
|---------------------------------------------------------------------------------------------
|1     | #DB    |Reserved            |F/T  |NO        |                                      |
|---------------------------------------------------------------------------------------------
|2     | ---    |NMI                 |INT  |NO        |external NMI                          |
|---------------------------------------------------------------------------------------------
|3     | #BP    |Breakpoint          |Trap |NO        |INT 3                                 |
|---------------------------------------------------------------------------------------------
|4     | #OF    |Overflow            |Trap |NO        |INTO  instruction                     |
|---------------------------------------------------------------------------------------------
|5     | #BR    |Bound Range Exceeded|Fault|NO        |BOUND instruction                     |
|---------------------------------------------------------------------------------------------
|6     | #UD    |Invalid Opcode      |Fault|NO        |UD2 instruction                       |
|---------------------------------------------------------------------------------------------
|7     | #NM    |Device Not Available|Fault|NO        |Floating point or [F]WAIT             |
|---------------------------------------------------------------------------------------------
|8     | #DF    |Double Fault        |Abort|YES       |An instruction which can generate NMI |
|---------------------------------------------------------------------------------------------
|9     | ---    |Reserved            |Fault|NO        |                                      |
|---------------------------------------------------------------------------------------------
|10    | #TS    |Invalid TSS         |Fault|YES       |Task switch or TSS access             |
|---------------------------------------------------------------------------------------------
|11    | #NP    |Segment Not Present |Fault|NO        |Accessing segment register            |
|---------------------------------------------------------------------------------------------
|12    | #SS    |Stack-Segment Fault |Fault|YES       |Stack operations                      |
|---------------------------------------------------------------------------------------------
|13    | #GP    |General Protection  |Fault|YES       |Memory reference                      |
|---------------------------------------------------------------------------------------------
|14    | #PF    |Page fault          |Fault|YES       |Memory reference                      |
|---------------------------------------------------------------------------------------------
|15    | ---    |Reserved            |     |NO        |                                      |
|---------------------------------------------------------------------------------------------
|16    | #MF    |x87 FPU fp error    |Fault|NO        |Floating point or [F]Wait             |
|---------------------------------------------------------------------------------------------
|17    | #AC    |Alignment Check     |Fault|YES       |Data reference                        |
|---------------------------------------------------------------------------------------------
|18    | #MC    |Machine Check       |Abort|NO        |                                      |
|---------------------------------------------------------------------------------------------
|19    | #XM    |SIMD fp exception   |Fault|NO        |SSE[2,3] instructions                 |
|---------------------------------------------------------------------------------------------
|20    | #VE    |Virtualization exc. |Fault|NO        |EPT violations                        |
|---------------------------------------------------------------------------------------------
|21-31 | ---    |Reserved            |INT  |NO        |External interrupts                   |
----------------------------------------------------------------------------------------------
</code></pre>
<p>To react on interrupt CPU uses special structure - Interrupt Descriptor Table or IDT. IDT is an array of 8-byte descriptors like Global Descriptor Table, but IDT entries are called <code>gates</code>. CPU multiplies vector number by 8 to find the IDT entry. But in 64-bit mode IDT is an array of 16-byte descriptors and CPU multiplies vector number by 16 to find the entry in the IDT. We remember from the previous part that CPU uses special <code>GDTR</code> register to locate Global Descriptor Table, so CPU uses special register <code>IDTR</code> for Interrupt Descriptor Table and <code>lidt</code> instruction for loading base address of the table into this register.</p>
<p>64-bit mode IDT entry has following structure:</p>
<pre><code>127                                                                             96
 --------------------------------------------------------------------------------
|                                                                               |
|                                Reserved                                       |
|                                                                               |
 --------------------------------------------------------------------------------
95                                                                              64
 --------------------------------------------------------------------------------
|                                                                               |
|                               Offset 63..32                                   |
|                                                                               |
 --------------------------------------------------------------------------------
63                               48 47      46  44   42    39             34    32
 --------------------------------------------------------------------------------
|                                  |       |  D  |   |     |      |   |   |     |
|       Offset 31..16              |   P   |  P  | 0 |Type |0 0 0 | 0 | 0 | IST |
|                                  |       |  L  |   |     |      |   |   |     |
 --------------------------------------------------------------------------------
31                                   16 15                                      0
 --------------------------------------------------------------------------------
|                                      |                                        |
|          Segment Selector            |                 Offset 15..0           |
|                                      |                                        |
 --------------------------------------------------------------------------------
</code></pre>
<p>Where:</p>
<ul>
<li><code>Offset</code> - is offset to entry point of an interrupt handler;</li>
<li><code>DPL</code> -    Descriptor Privilege Level;</li>
<li><code>P</code> -      Segment Present flag;</li>
<li><code>Segment selector</code> - a code segment selector in GDT or LDT (actually in linux, it must point to a valid descriptor in your GDT.)</li>
</ul>
<pre><code class="language-C">#define __KERNEL_CS	(GDT_ENTRY_KERNEL_CS*8) // 0000 0000 0001 0000
#define GDT_ENTRY_KERNEL_CS 2
</code></pre>
<ul>
<li><code>IST</code> -    provides ability to switch to a new stack for interrupts handling.</li>
</ul>
<p>And the last <code>Type</code> field describes type of the <code>IDT</code> entry. There are three different kinds of gates for interrupts:</p>
<ul>
<li>Task gate</li>
<li>Interrupt gate</li>
<li>Trap gate</li>
</ul>
<p>Interrupt and trap gates contain a far pointer to the entry point of the interrupt handler. Only one difference between these types is how CPU handles <code>IF</code> flag. If interrupt handler was accessed through interrupt gate, CPU clear the <code>IF</code> flag to prevent other interrupts while current interrupt handler executes. After that current interrupt handler executes, CPU sets the <code>IF</code> flag again with <code>iret</code> instruction.</p>
<p>Other bits in the interrupt descriptor is reserved and must be 0. Now let's look how CPU handles interrupts:</p>
<ul>
<li>CPU save flags register, <code>CS</code>, and instruction pointer on the stack.</li>
<li>If interrupt causes an error code (like <code>#PF</code> for example), CPU saves an error on the stack after instruction pointer;</li>
<li>After interrupt handler executes, <code>iret</code> instruction will be used to return from it.</li>
</ul>
<p>Now let's back to code.</p>
<h2 id="fill-and-load-idt"><a class="header" href="#fill-and-load-idt">Fill and load IDT</a></h2>
<p>We stopped at the following function:</p>
<pre><code class="language-C">	idt_setup_early_handler();
</code></pre>
<p><code>idt_setup_early_handler</code> is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/idt.c">arch/x86/kernel/idt.c</a> like the following:</p>
<pre><code class="language-C">void __init idt_setup_early_handler(void)
{
	int i;

	for (i = 0; i &lt; NUM_EXCEPTION_VECTORS; i++)
		set_intr_gate(i, early_idt_handler_array[i]);

	load_idt(&amp;idt_descr);
}
</code></pre>
<p>where <code>NUM_EXCEPTION_VECTORS</code> expands to <code>32</code>. As we can see, We're filling only first 32 <code>IDT</code> entries in the loop, because all of the early setup runs with interrupts disabled, so there is no need to set up interrupt handlers for vectors greater than <code>32</code>. Here we call <code>set_intr_gate</code> in the loop, which takes two parameters:</p>
<ul>
<li>Number of an interrupt or <code>vector number</code>;</li>
<li>Address of the idt handler.</li>
</ul>
<p>and inserts an interrupt gate to the <code>IDT</code> table which is represented by the <code>&amp;idt_descr</code> array. </p>
<p>The <code>early_idt_handler_array</code> array is declared in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/segment.h">arch/x86/include/asm/segment.h</a> header file and contains addresses of the first <code>32</code> exception handlers:</p>
<pre><code class="language-C">#define EARLY_IDT_HANDLER_SIZE   9
#define NUM_EXCEPTION_VECTORS	32

extern const char early_idt_handler_array[NUM_EXCEPTION_VECTORS][EARLY_IDT_HANDLER_SIZE];
</code></pre>
<p>The <code>early_idt_handler_array</code> is <code>288</code> bytes array which contains address of exception entry points every nine bytes. Every nine bytes of this array consist of two bytes optional instruction for pushing dummy error code if an exception does not provide it, two bytes instruction for pushing vector number to the stack and five bytes of <code>jump</code> to the common exception handler code. You will see more detail in the next paragraph.</p>
<p>The <code>set_intr_gate</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/idt.c">arch/x86/kernel/idt.c</a> source file and looks:</p>
<pre><code class="language-C">static void set_intr_gate(unsigned int n, const void *addr)
{
	struct idt_data data;

	BUG_ON(n &gt; 0xFF);

	memset(&amp;data, 0, sizeof(data));
	data.vector	= n;
	data.addr	= addr;
	data.segment	= __KERNEL_CS;
	data.bits.type	= GATE_INTERRUPT;
	data.bits.p	= 1;

        idt_setup_from_table(idt_table, &amp;data, 1, false);
}
</code></pre>
<p>First of all it checks that passed vector number is not greater than <code>255</code> with <code>BUG_ON</code> macro. We need to do this because we are limited to have up to <code>256</code> interrupts. After this, we fill the idt data with the given arguments and others, which will be passed to <code>idt_setup_from_table</code>. The <code>idt_setup_from_table</code> function is defined in the same file as the <code>set_intr_gate</code> function like the following:</p>
<pre><code class="language-C">static void
idt_setup_from_table(gate_desc *idt, const struct idt_data *t, int size, bool sys)
{
	gate_desc desc;

	for (; size &gt; 0; t++, size--) {
		desc.offset_low    = (u16) t-&gt;addr;
		desc.segment	   = (u16) t-&gt;segment
		desc.bits	   = t-&gt;bits;
		desc.offset_middle = (u16) (t-&gt;addr &gt;&gt; 16);
		desc.offset_high   = (u32) (t-&gt;addr &gt;&gt; 32);
		desc.reserved	   = 0;
		memcpy(&amp;idt[t-&gt;vector], &amp;desc, sizeof(desc));
		if (sys)
			set_bit(t-&gt;vector, system_vectors);
	}
}
</code></pre>
<p>which fill temporary idt descriptor with the given arguments and others. And then we just copy it to the certain element of the <code>idt_table</code> array. <code>idt_table</code> is an array of idt entries:</p>
<pre><code class="language-C">gate_desc idt_table[IDT_ENTRIES] __page_aligned_bss;
</code></pre>
<p>Now we are moving back to main loop code. After main loop finishes, we can load <code>Interrupt Descriptor table</code> with the call of the:</p>
<pre><code class="language-C">	load_idt((const struct desc_ptr *)&amp;idt_descr);
</code></pre>
<p>where <code>idt_descr</code> is:</p>
<pre><code class="language-C">struct desc_ptr idt_descr __ro_after_init = {
	.size		= (IDT_ENTRIES * 2 * sizeof(unsigned long)) - 1,
	.address	= (unsigned long) idt_table,
};
</code></pre>
<p>and <code>load_idt</code> just executes <code>lidt</code> instruction:</p>
<pre><code class="language-C">	asm volatile(&quot;lidt %0&quot;::&quot;m&quot; (idt_descr));
</code></pre>
<p>Okay, now we have filled and loaded <code>Interrupt Descriptor Table</code>, we know how the CPU acts during an interrupt. So now time to deal with interrupts handlers.</p>
<h2 id="early-interrupts-handlers"><a class="header" href="#early-interrupts-handlers">Early interrupts handlers</a></h2>
<p>As you can read above, we filled <code>IDT</code> with the address of the <code>early_idt_handler_array</code>. In this section, we are going to look into it in detail. We can find it in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/head_64.S">arch/x86/kernel/head_64.S</a> assembly file:</p>
<pre><code class="language-assembly">ENTRY(early_idt_handler_array)
	i = 0
	.rept NUM_EXCEPTION_VECTORS
	.if ((EXCEPTION_ERRCODE_MASK &gt;&gt; i) &amp; 1) == 0
		UNWIND_HINT_IRET_REGS
		pushq $0	# Dummy error code, to make stack frame uniform
	.else
		UNWIND_HINT_IRET_REGS offset=8
	.endif
	pushq $i		# 72(%rsp) Vector number
	jmp early_idt_handler_common
	UNWIND_HINT_IRET_REGS
	i = i + 1
	.fill early_idt_handler_array + i*EARLY_IDT_HANDLER_SIZE - ., 1, 0xcc
	.endr
	UNWIND_HINT_IRET_REGS offset=16
END(early_idt_handler_array)
</code></pre>
<p>We can see here, interrupt handlers generation for the first <code>32</code> exceptions. We check here, if exception has an error code then we do nothing, if exception does not return error code, we push zero to the stack. We do it for that stack was uniform. After that we push <code>vector number</code> on the stack and jump on the <code>early_idt_handler_common</code> which is generic interrupt handler for now. After all, every nine bytes of the <code>early_idt_handler_array</code> array consists of optional push of an error code, push of <code>vector number</code> and jump instruction to <code>early_idt_handler_common</code>. We can see it in the output of the <code>objdump</code> util:</p>
<pre><code>$ objdump -D vmlinux
...
...
...
ffffffff81fe5000 &lt;early_idt_handler_array&gt;:
ffffffff81fe5000:       6a 00                   pushq  $0x0
ffffffff81fe5002:       6a 00                   pushq  $0x0
ffffffff81fe5004:       e9 17 01 00 00          jmpq   ffffffff81fe5120 &lt;early_idt_handler_common&gt;
ffffffff81fe5009:       6a 00                   pushq  $0x0
ffffffff81fe500b:       6a 01                   pushq  $0x1
ffffffff81fe500d:       e9 0e 01 00 00          jmpq   ffffffff81fe5120 &lt;early_idt_handler_common&gt;
ffffffff81fe5012:       6a 00                   pushq  $0x0
ffffffff81fe5014:       6a 02                   pushq  $0x2
...
...
...
</code></pre>
<p>As we may know, CPU pushes flag register, <code>CS</code> and <code>RIP</code> on the stack before calling interrupt handler. So before <code>early_idt_handler_common</code> will be executed, stack will contain following data:</p>
<pre><code>|--------------------|
| %rflags            |
| %cs                |
| %rip               |
| error code         |
| vector number      |&lt;-- %rsp
|--------------------|
</code></pre>
<p>Now let's look on the <code>early_idt_handler_common</code> implementation. It locates in the same <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/head_64.S">arch/x86/kernel/head_64.S</a> assembly file. First of all we increment <code>early_recursion_flag</code> to prevent recursion in the <code>early_idt_handler_common</code>:</p>
<pre><code class="language-assembly">	incl early_recursion_flag(%rip)
</code></pre>
<p>The <code>early_recursion_flag</code> is defined in the same assembly file as the <code>early_idt_handler_common</code> symbol as follows:</p>
<pre><code class="language-assembly">	early_recursion_flag:
		.long 0
</code></pre>
<p>Next we save general registers on the stack:</p>
<pre><code class="language-assembly">	pushq %rsi
	movq 8(%rsp), %rsi
	movq %rdi, 8(%rsp)
	pushq %rdx
	pushq %rcx
	pushq %rax
	pushq %r8
	pushq %r9
	pushq %r10
	pushq %r11
	pushq %rbx
	pushq %rbp
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	UNWIND_HINT_REGS
</code></pre>
<p>Okay, now the stack contains following data:</p>
<pre><code>High |-------------------------|
     | %rflags                 |
     | %cs                     |
     | %rip                    |
     | error code              |
     | %rdi                    |
     | %rsi                    |
     | %rdx                    |
     | %rax                    |
     | %r8                     |
     | %r9                     |
     | %r10                    |
     | %r11                    |
     | %rbx                    |
     | %rbp                    |
     | %r12                    |
     | %r13                    |
     | %r14                    |
     | %r15                    |&lt;-- %rsp
Low  |-------------------------|
</code></pre>
<p>We need to do it to prevent wrong values of registers when we return from the interrupt handler. After this we check the vector number, and if it is <code>#PF</code> or <a href="https://en.wikipedia.org/wiki/Page_fault">Page Fault</a>, we put value from the <code>cr2</code> to the <code>rdi</code> register and call <code>early_make_pgtable</code> (we'll see it soon):</p>
<pre><code class="language-assembly">	cmpq $14,%rsi            /* Page fault? */
	jnz 10f
	GET_CR2_INTO(%rdi)
	call early_make_pgtable
	andl %eax,%eax           /* It is more efficient, the opcode is shorter than movl 1, %eax, only 2 bytes. */
	jz 20f                   /* All good */
</code></pre>
<p>otherwise we call <code>early_fixup_exception</code> function by passing kernel stack pointer:</p>
<pre><code class="language-assembly">10:
	movq %rsp,%rdi
	call early_fixup_exception
</code></pre>
<p>We'll see the implementation of the <code>early_fixup_exception</code> function later.</p>
<pre><code class="language-assembly">20:
	decl early_recursion_flag(%rip)
	jmp restore_regs_and_return_to_kernel
</code></pre>
<p>After we decrement the <code>early_recursion_flag</code>, we restore registers which we saved before from the stack and return from the handler with <code>iretq</code>.</p>
<p>It is the end of the interrupt handler. We will examine the page fault handling and the other exception handling in order.</p>
<h2 id="page-fault-handling"><a class="header" href="#page-fault-handling">Page fault handling</a></h2>
<p>In the previous paragraph we saw the early interrupt handler which checks if the vector number is page fault and calls <code>early_make_pgtable</code> for building new page tables if it is. We need to have <code>#PF</code> handler in this step because there are plans to add ability to load kernel above <code>4G</code> and make access to <code>boot_params</code> structure above the 4G.</p>
<p>You can find the implementation of <code>early_make_pgtable</code> in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/head64.c">arch/x86/kernel/head64.c</a> and takes one parameter - the value of <code>cr2</code> register, which contains the address caused page fault. Let's look on it:</p>
<pre><code class="language-C">int __init early_make_pgtable(unsigned long address)
{
	unsigned long physaddr = address - __PAGE_OFFSET;
	pmdval_t pmd;

	pmd = (physaddr &amp; PMD_MASK) + early_pmd_flags;

	return __early_make_pgtable(address, pmd);
}
</code></pre>
<p><code>__PAGE_OFFSET</code> is defined in the <a href="https://elixir.bootlin.com/linux/v3.10-rc1/source/arch/x86/include/asm/page_64_types.h#L33">arch/x86/include/asm/page_64_types.h</a> header file, and the suffix <code>UL</code> forces the page offset to be a unsigned long data type.</p>
<pre><code class="language-C">#define __PAGE_OFFSET           _AC(0xffff880000000000, UL) 
</code></pre>
<p>And the <code>_AC</code> macro is defined in the <a href="https://elixir.bootlin.com/linux/v3.10-rc1/source/include/uapi/linux/const.h#L16">include/uapi/linux/const.h</a> header file: </p>
<pre><code class="language-C">/* Some constant macros are used in both assembler and
 * C code.  Therefore we cannot annotate them always with
 * 'UL' and other type specifiers unilaterally.  We
 * use the following macros to deal with this.
 *
 * Similarly, _AT() will cast an expression with a type in C, but
 * leave it unchanged in asm.
 */

#ifdef __ASSEMBLY__
#define _AC(X,Y)	X
#else
#define __AC(X,Y)	(X##Y)
#define _AC(X,Y)	__AC(X,Y)
#endif
</code></pre>
<p>Where <code>__PAGE_OFFSET</code> expands to <code>0xffff888000000000</code>. But, why is it possible to translate a virtual address to a physical address by subtracting <code>__PAGE_OFFSET</code>?  The answer is in the <a href="https://elixir.bootlin.com/linux/v5.10-rc5/source/Documentation/x86/x86_64/mm.rst#L45">Documentation/x86/x86_64/mm.rst</a> documentation: </p>
<pre><code>...
ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | direct mapping of all physical memory (page_offset_base)
...
</code></pre>
<p>As explained above, the virtual address space <code>ffff888000000000-ffffc87fffffffff</code> is direct mapping of all physical memory. When the kernel wants to access all physical memory, it uses direct mapping.</p>
<p>Okay, let's get back to discussing <code>early_make_pgtable</code>. We initialize <code>pmd</code> and pass it to the <code>__early_make_pgtable</code> function along with <code>address</code>. The <code>__early_make_pgtable</code> function is defined in the same file as the <code>early_make_pgtable</code> function as follows:</p>
<pre><code class="language-C">int __init __early_make_pgtable(unsigned long address, pmdval_t pmd)
{
	unsigned long physaddr = address - __PAGE_OFFSET;
	pgdval_t pgd, *pgd_p;
	p4dval_t p4d, *p4d_p;
	pudval_t pud, *pud_p;
	pmdval_t *pmd_p;
	...
	...
	...
}
</code></pre>
<p>It starts from the definition of some variables which have <code>*val_t</code> types. All of these types are declared as alias of <code>unsigned long</code> using <code>typedef</code>.</p>
<p>After we made the check that we have no invalid address, we're getting the address of the Page Global Directory entry which contains base address of Page Upper Directory and put its value to the <code>pgd</code> variable:</p>
<pre><code class="language-C">again:
	pgd_p = &amp;early_top_pgt[pgd_index(address)].pgd;
	pgd = *pgd_p;
</code></pre>
<p>And we check if <code>pgd</code> is presented. If it is, we assign the base address of the page upper directory table to <code>pud_p</code>:</p>
<pre><code class="language-C">	pud_p = (pudval_t *)((pgd &amp; PTE_PFN_MASK) + __START_KERNEL_map - phys_base);
</code></pre>
<p>where <code>PTE_PFN_MASK</code> is a macro which mask lower <code>12</code> bits of <code>(pte|pmd|pud|pgd)val_t</code>.</p>
<p>If <code>pgd</code> is not presented, we check if <code>next_early_pgt</code> is not greater than <code>EARLY_DYNAMIC_PAGE_TABLES</code> which is <code>64</code> and present a fixed number of buffers to set up new page tables on demand. If <code>next_early_pgt</code> is greater than <code>EARLY_DYNAMIC_PAGE_TABLES</code> we reset page tables and start again from <code>again</code> label. If <code>next_early_pgt</code> is less than <code>EARLY_DYNAMIC_PAGE_TABLES</code>, we assign the next entry of <code>early_dynamic_pgts</code> to <code>pud_p</code> and fill whole entry of the page upper directory with <code>0</code>, then fill the page global directory entry with the base address and some access rights:</p>
<pre><code class="language-C">	if (next_early_pgt &gt;= EARLY_DYNAMIC_PAGE_TABLES) {
		reset_early_page_tables();
		goto again;
	}
		
	pud_p = (pudval_t *)early_dynamic_pgts[next_early_pgt++];
	memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);
	*pgd_p = (pgdval_t)pud_p - __START_KERNEL_map + phys_base + _KERNPG_TABLE;
</code></pre>
<p>And we fix <code>pud_p</code> to point to correct entry and assign its value to <code>pud</code> with the following:</p>
<pre><code class="language-C">	pud_p += pud_index(address);
	pud = *pud_p;
</code></pre>
<p>And then we do the same routine as above, but to the page middle directory.</p>
<p>In the end we assign the given <code>pmd</code> which is passed by the <code>early_make_pgtable</code> function to the certain entry of page middle directory which maps kernel text+data virtual addresses:</p>
<pre><code class="language-C">	pmd_p[pmd_index(address)] = pmd;
</code></pre>
<p>After page fault handler finished its work, as a result, <code>early_top_pgt</code> contains entries which point to the valid addresses.</p>
<h2 id="other-exception-handling"><a class="header" href="#other-exception-handling">Other exception handling</a></h2>
<p>In early interrupt phase, exceptions other than page fault are handled by <code>early_fixup_exception</code> function which is defined in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/mm/extable.c">arch/x86/mm/extable.c</a> and takes two parameters - pointer to kernel stack which consists of saved registers and vector number:</p>
<pre><code class="language-C">void __init early_fixup_exception(struct pt_regs *regs, int trapnr)
{
	...
	...
	...
}
</code></pre>
<p>First of all we need to make some checks as the following:</p>
<pre><code class="language-C">	if (trapnr == X86_TRAP_NMI)
		return;

	if (early_recursion_flag &gt; 2)
		goto halt_loop;

	if (!xen_pv_domain() &amp;&amp; regs-&gt;cs != __KERNEL_CS)
		goto fail;
</code></pre>
<p>Here we just ignore <a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">NMI</a> and make sure that we are not in recursive situation.</p>
<p>After that, we get into:</p>
<pre><code class="language-C">	if (fixup_exception(regs, trapnr))
		return;
</code></pre>
<p>The <code>fixup_exception</code> function finds the actual handler and call it. It is defined in the same file as <code>early_fixup_exception</code> function as the following:</p>
<pre><code class="language-C">int fixup_exception(struct pt_regs *regs, int trapnr)
{
	const struct exception_table_entry *e;
	ex_handler_t handler;

	e = search_exception_tables(regs-&gt;ip);
	if (!e)
		return 0;

	handler = ex_fixup_handler(e);
	return handler(e, regs, trapnr);
}
</code></pre>
<p>The <code>ex_handler_t</code> is a type of function pointer, which is defined like:</p>
<pre><code class="language-C">typedef bool (*ex_handler_t)(const struct exception_table_entry *,
                            struct pt_regs *, int)
</code></pre>
<p>The <code>search_exception_tables</code> function looks up the given address in the exception table (i.e. the contents of the ELF section, <code>__ex_table</code>). After that, we get the actual address by <code>ex_fixup_handler</code> function. At last we call actual handler. For more information about exception table, you can refer to <a href="https://github.com/torvalds/linux/blob/master/Documentation/x86/exception-tables.txt">Documentation/x86/exception-tables.txt</a>.</p>
<p>Let's get back to the <code>early_fixup_exception</code> function, the next step is:</p>
<pre><code class="language-C">	if (fixup_bug(regs, trapnr))
		return;
</code></pre>
<p>The <code>fixup_bug</code> function is defined in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a>. Let's have a look on the function implementation:</p>
<pre><code class="language-C">int fixup_bug(struct pt_regs *regs, int trapnr)
{
	if (trapnr != X86_TRAP_UD)
		return 0;

	switch (report_bug(regs-&gt;ip, regs)) {
	case BUG_TRAP_TYPE_NONE:
	case BUG_TRAP_TYPE_BUG:
		break;

	case BUG_TRAP_TYPE_WARN:
		regs-&gt;ip += LEN_UD2;
		return 1;
	}

	return 0;
}
</code></pre>
<p>All what this function does is just returns <code>1</code> if the exception is generated because <code>#UD</code> (or <a href="https://wiki.osdev.org/Exceptions#Invalid_Opcode">Invalid Opcode</a>) occurred and the <code>report_bug</code> function returns <code>BUG_TRAP_TYPE_WARN</code>, otherwise returns <code>0</code>.</p>
<h2 id="conclusion-7"><a class="header" href="#conclusion-7">Conclusion</a></h2>
<p>This is the end of the second part about Linux kernel insides. If you have questions or suggestions, ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>. In the next part we will see all steps before kernel entry point - <code>start_kernel</code> function.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-7"><a class="header" href="#links-7">Links</a></h2>
<ul>
<li><a href="https://sourceware.org/binutils/docs-2.23/as/Rept.html">GNU assembly .rept</a></li>
<li><a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a></li>
<li><a href="http://en.wikipedia.org/wiki/Non-maskable_interrupt">NMI</a></li>
<li><a href="https://en.wikipedia.org/wiki/Page_table">Page table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_handler">Interrupt handler</a></li>
<li><a href="https://en.wikipedia.org/wiki/Page_fault">Page Fault</a>,</li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-initialization-part-3"><a class="header" href="#kernel-initialization-part-3">Kernel initialization. Part 3.</a></h1>
<h2 id="last-preparations-before-the-kernel-entry-point"><a class="header" href="#last-preparations-before-the-kernel-entry-point">Last preparations before the kernel entry point</a></h2>
<p>This is the third part of the Linux kernel initialization process series. In the previous <a href="https://github.com/0xAX/linux-insides/blob/master/Initialization/linux-initialization-2.md">part</a> we saw early interrupt and exception handling and will continue to dive into the Linux kernel initialization process in the current part. Our next point is 'kernel entry point' - <code>start_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> source code file. Yes, technically it is not kernel's entry point but the start of the generic kernel code which does not depend on certain architecture. But before we call the <code>start_kernel</code> function, we must do some preparations. So let's continue.</p>
<h2 id="boot_params-again"><a class="header" href="#boot_params-again">boot_params again</a></h2>
<p>In the previous part we stopped at setting Interrupt Descriptor Table and loading it in the <code>IDTR</code> register. At the next step after this we can see a call of the <code>copy_bootdata</code> function:</p>
<pre><code class="language-C">copy_bootdata(__va(real_mode_data));
</code></pre>
<p>This function takes one argument - virtual address of the <code>real_mode_data</code>. Remember that we passed the address of the <code>boot_params</code> structure from <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/uapi/asm/bootparam.h#L114">arch/x86/include/uapi/asm/bootparam.h</a>  to the <code>x86_64_start_kernel</code> function as first argument in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/head_64.S">arch/x86/kernel/head_64.S</a>:</p>
<pre><code>	/* rsi is pointer to real mode structure with interesting info.
	   pass it to C */
	movq	%rsi, %rdi
</code></pre>
<p>Now let's look at <code>__va</code> macro. This macro defined in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>:</p>
<pre><code class="language-C">#define __va(x)                 ((void *)((unsigned long)(x)+PAGE_OFFSET))
</code></pre>
<p>where <code>PAGE_OFFSET</code> is <code>__PAGE_OFFSET</code> which is <code>0xffff880000000000</code> and the base virtual address of the direct mapping of all physical memory. So we're getting virtual address of variable <code>boot_params</code> which come along from real mode, and pass it to the <code>copy_bootdata</code> function, where we copy <code>real_mode_data</code> to the <code>boot_params</code> which is defined in the <a href="https://github.com/torvalds/linux/blob/d9919d43cbf6790d2bc0c0a2743c51fc25f26919/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a></p>
<pre><code class="language-C">struct boot_params boot_params;
</code></pre>
<p>Let's look at the <code>copy_boot_data</code> implementation:</p>
<pre><code class="language-C">static void __init copy_bootdata(char *real_mode_data)
{
	char * command_line;
	unsigned long cmd_line_ptr;

	memcpy(&amp;boot_params, real_mode_data, sizeof boot_params);
	sanitize_boot_params(&amp;boot_params);
	cmd_line_ptr = get_cmd_line_ptr();
	if (cmd_line_ptr) {
		command_line = __va(cmd_line_ptr);
		memcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);
	}
}
</code></pre>
<p>First of all, note that this function is declared with <code>__init</code> prefix. It means that this function will be used only during the initialization and used memory will be freed.</p>
<p>We can see declaration of two variables for the kernel command line and copying <code>real_mode_data</code> to the <code>boot_params</code> with the <code>memcpy</code> function. The next call of the <code>sanitize_boot_params</code> function which fills some fields of the <code>boot_params</code> structure like <code>ext_ramdisk_image</code> and etc... if bootloaders which fail to initialize unknown fields in <code>boot_params</code> to zero. After this we're getting address of the command line with the call of the <code>get_cmd_line_ptr</code> function:</p>
<pre><code class="language-C">unsigned long cmd_line_ptr = boot_params.hdr.cmd_line_ptr;
cmd_line_ptr |= (u64)boot_params.ext_cmd_line_ptr &lt;&lt; 32;
return cmd_line_ptr;
</code></pre>
<p>which gets the 64-bit address of the command line from the kernel boot header and returns it. In the last step we check <code>cmd_line_ptr</code>, getting its virtual address and copy it to the <code>boot_command_line</code> which is just an array of bytes:</p>
<pre><code class="language-C">extern char __initdata boot_command_line[];
</code></pre>
<p>After this we will have copied kernel command line and <code>boot_params</code> structure. In the next step we can see call of the <code>load_ucode_bsp</code> function which loads processor microcode, but we will not see it here.</p>
<p>After microcode was loaded we can see the check of the <code>console_loglevel</code> and the <code>early_printk</code> function which prints <code>Kernel Alive</code> string. But you'll never see this output because <code>early_printk</code> is not initialized yet. It is a minor bug in the kernel and i sent the patch - <a href="http://git.kernel.org/cgit/linux/kernel/git/tip/tip.git/commit/?id=91d8f0416f3989e248d3a3d3efb821eda10a85d2">commit</a> and you will see it in the mainline soon. So you can skip this code.</p>
<h2 id="move-on-init-pages"><a class="header" href="#move-on-init-pages">Move on init pages</a></h2>
<p>In the next step, as we have copied <code>boot_params</code> structure, we need to move from the early page tables to the page tables for initialization process. We already set early page tables for switchover, you can read about it in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">part</a> and dropped all it in the <code>reset_early_page_tables</code> function (you can read about it in the previous part too) and kept only kernel high mapping. After this we call:</p>
<pre><code class="language-C">	clear_page(init_level4_pgt);
</code></pre>
<p>function and pass <code>init_level4_pgt</code> which also defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/head_64.S">arch/x86/kernel/head_64.S</a> and looks:</p>
<pre><code class="language-assembly">NEXT_PAGE(init_level4_pgt)
	.quad   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE
	.org    init_level4_pgt + L4_PAGE_OFFSET*8, 0
	.quad   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE
	.org    init_level4_pgt + L4_START_KERNEL*8, 0
	.quad   level3_kernel_pgt - __START_KERNEL_map + _PAGE_TABLE
</code></pre>
<p>which maps first 2 gigabytes and 512 megabytes for the kernel code, data and bss. <code>clear_page</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/lib/clear_page_64.S">arch/x86/lib/clear_page_64.S</a> let's look on this function:</p>
<pre><code class="language-assembly">ENTRY(clear_page)
	CFI_STARTPROC
	xorl %eax,%eax
	movl $4096/64,%ecx
	.p2align 4
	.Lloop:
    decl	%ecx
#define PUT(x) movq %rax,x*8(%rdi)
	movq %rax,(%rdi)
	PUT(1)
	PUT(2)
	PUT(3)
	PUT(4)
	PUT(5)
	PUT(6)
	PUT(7)
	leaq 64(%rdi),%rdi
	jnz	.Lloop
	nop
	ret
	CFI_ENDPROC
	.Lclear_page_end:
	ENDPROC(clear_page)
</code></pre>
<p>As you can understand from the function name it clears or fills with zeros page tables. First of all note that this function starts with the <code>CFI_STARTPROC</code> and <code>CFI_ENDPROC</code> which are expands to GNU assembly directives:</p>
<pre><code class="language-C">#define CFI_STARTPROC           .cfi_startproc
#define CFI_ENDPROC             .cfi_endproc
</code></pre>
<p>and used for debugging. After <code>CFI_STARTPROC</code> macro we zero out <code>eax</code> register and put 64 to the <code>ecx</code> (it will be a counter). Next we can see loop which starts with the <code>.Lloop</code> label and it starts from the <code>ecx</code> decrement. After it we put zero from the <code>rax</code> register to the <code>rdi</code> which contains the base address of the <code>init_level4_pgt</code> now and do the same procedure seven times but every time move <code>rdi</code> offset on 8. After this we will have first 64 bytes of the <code>init_level4_pgt</code> filled with zeros. In the next step we put the address of the <code>init_level4_pgt</code> with 64-bytes offset to the <code>rdi</code> again and repeat all operations until <code>ecx</code> reaches zero. In the end we will have <code>init_level4_pgt</code> filled with zeros.</p>
<p>As we have <code>init_level4_pgt</code> filled with zeros, we set the last <code>init_level4_pgt</code> entry to kernel high mapping with the:</p>
<pre><code class="language-C">init_level4_pgt[511] = early_top_pgt[511];
</code></pre>
<p>Remember that we dropped all <code>early_top_pgt</code> entries in the <code>reset_early_page_table</code> function and kept only kernel high mapping there.</p>
<p>The last step in the <code>x86_64_start_kernel</code> function is the call of the:</p>
<pre><code class="language-C">x86_64_start_reservations(real_mode_data);
</code></pre>
<p>function with the <code>real_mode_data</code> as argument. The <code>x86_64_start_reservations</code> function defined in the same source code file as the <code>x86_64_start_kernel</code> function and looks:</p>
<pre><code class="language-C">void __init x86_64_start_reservations(char *real_mode_data)
{
	if (!boot_params.hdr.version)
		copy_bootdata(__va(real_mode_data));

	reserve_ebda_region();

	start_kernel();
}
</code></pre>
<p>You can see that it is the last function before we are in the kernel entry point - <code>start_kernel</code> function. Let's look what it does and how it works.</p>
<h2 id="last-step-before-kernel-entry-point"><a class="header" href="#last-step-before-kernel-entry-point">Last step before kernel entry point</a></h2>
<p>First of all we can see in the <code>x86_64_start_reservations</code> function the check for <code>boot_params.hdr.version</code>:</p>
<pre><code class="language-C">if (!boot_params.hdr.version)
	copy_bootdata(__va(real_mode_data));
</code></pre>
<p>and if it is zero we call <code>copy_bootdata</code> function again with the virtual address of the <code>real_mode_data</code> (read about its implementation).</p>
<p>In the next step we can see the call of the <code>reserve_ebda_region</code> function which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/head.c">arch/x86/kernel/head.c</a>. This function reserves memory block for the <code>EBDA</code> or Extended BIOS Data Area. The Extended BIOS Data Area located in the top of conventional memory and contains data about ports, disk parameters and etc...</p>
<p>Let's look on the <code>reserve_ebda_region</code> function. It starts from the checking is paravirtualization enabled or not:</p>
<pre><code class="language-C">if (paravirt_enabled())
	return;
</code></pre>
<p>we exit from the <code>reserve_ebda_region</code> function if paravirtualization is enabled because if it enabled the extended BIOS data area is absent. In the next step we need to get the end of the low memory:</p>
<pre><code class="language-C">lowmem = *(unsigned short *)__va(BIOS_LOWMEM_KILOBYTES);
lowmem &lt;&lt;= 10;
</code></pre>
<p>We're getting the virtual address of the BIOS low memory in kilobytes and convert it to bytes with shifting it on 10 (multiply on 1024 in other words). After this we need to get the address of the extended BIOS data are with the:</p>
<pre><code class="language-C">ebda_addr = get_bios_ebda();
</code></pre>
<p>where <code>get_bios_ebda</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bios_ebda.h">arch/x86/include/asm/bios_ebda.h</a> and looks like:</p>
<pre><code class="language-C">static inline unsigned int get_bios_ebda(void)
{
	unsigned int address = *(unsigned short *)phys_to_virt(0x40E);
	address &lt;&lt;= 4;
	return address;
}
</code></pre>
<p>Let's try to understand how it works. Here we can see that we are converting physical address <code>0x40E</code> to the virtual, where <code>0x0040:0x000e</code> is the segment which contains base address of the extended BIOS data area. Don't worry that we are using <code>phys_to_virt</code> function for converting a physical address to virtual address. You can note that previously we have used <code>__va</code> macro for the same point, but <code>phys_to_virt</code> is the same:</p>
<pre><code class="language-C">static inline void *phys_to_virt(phys_addr_t address)
{
         return __va(address);
}
</code></pre>
<p>only with one difference: we pass argument with the <code>phys_addr_t</code> which depends on <code>CONFIG_PHYS_ADDR_T_64BIT</code>:</p>
<pre><code class="language-C">#ifdef CONFIG_PHYS_ADDR_T_64BIT
	typedef u64 phys_addr_t;
#else
	typedef u32 phys_addr_t;
#endif
</code></pre>
<p>This configuration option is enabled by <code>CONFIG_PHYS_ADDR_T_64BIT</code>. After that we got virtual address of the segment which stores the base address of the extended BIOS data area, we shift it on 4 and return. After this <code>ebda_addr</code> variables contains the base address of the extended BIOS data area.</p>
<p>In the next step we check that address of the extended BIOS data area and low memory is not less than <code>INSANE_CUTOFF</code> macro</p>
<pre><code class="language-C">if (ebda_addr &lt; INSANE_CUTOFF)
	ebda_addr = LOWMEM_CAP;

if (lowmem &lt; INSANE_CUTOFF)
	lowmem = LOWMEM_CAP;
</code></pre>
<p>which is:</p>
<pre><code class="language-C">#define INSANE_CUTOFF		0x20000U
</code></pre>
<p>or 128 kilobytes. In the last step we get lower part in the low memory and extended BIOS data area and call <code>memblock_reserve</code> function which will reserve memory region for extended BIOS data between low memory and one megabyte mark:</p>
<pre><code class="language-C">lowmem = min(lowmem, ebda_addr);
lowmem = min(lowmem, LOWMEM_CAP);
memblock_reserve(lowmem, 0x100000 - lowmem);
</code></pre>
<p><code>memblock_reserve</code> function is defined at <a href="https://github.com/torvalds/linux/blob/master/mm/memblock.c">mm/memblock.c</a> and takes two parameters:</p>
<ul>
<li>base physical address;</li>
<li>region size.</li>
</ul>
<p>and reserves memory region for the given base address and size. <code>memblock_reserve</code> is the first function in this book from Linux kernel memory manager framework. We will take a closer look on memory manager soon, but now let's look at its implementation.</p>
<h2 id="first-touch-of-the-linux-kernel-memory-manager-framework"><a class="header" href="#first-touch-of-the-linux-kernel-memory-manager-framework">First touch of the Linux kernel memory manager framework</a></h2>
<p>In the previous paragraph we stopped at the call of the <code>memblock_reserve</code> function and as I said before it is the first function from the memory manager framework. Let's try to understand how it works. <code>memblock_reserve</code> function just calls:</p>
<pre><code class="language-C">memblock_reserve_region(base, size, MAX_NUMNODES, 0);
</code></pre>
<p>function and passes 4 parameters there:</p>
<ul>
<li>physical base address of the memory region;</li>
<li>size of the memory region;</li>
<li>maximum number of numa nodes;</li>
<li>flags.</li>
</ul>
<p>At the start of the <code>memblock_reserve_region</code> body we can see definition of the <code>memblock_type</code> structure:</p>
<pre><code class="language-C">struct memblock_type *_rgn = &amp;memblock.reserved;
</code></pre>
<p>which presents the type of the memory block and looks:</p>
<pre><code class="language-C">struct memblock_type {
         unsigned long cnt;
         unsigned long max;
         phys_addr_t total_size;
         struct memblock_region *regions;
};
</code></pre>
<p>As we need to reserve memory block for extended BIOS data area, the type of the current memory region is reserved where <code>memblock</code> structure is:</p>
<pre><code class="language-C">struct memblock {
         bool bottom_up;
         phys_addr_t current_limit;
         struct memblock_type memory;
         struct memblock_type reserved;
#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP
         struct memblock_type physmem;
#endif
};
</code></pre>
<p>and describes generic memory block. You can see that we initialize <code>_rgn</code> by assigning it to the address of the <code>memblock.reserved</code>. <code>memblock</code> is the global variable which looks:</p>
<pre><code class="language-C">struct memblock memblock __initdata_memblock = {
	.memory.regions		= memblock_memory_init_regions,
	.memory.cnt		= 1,
	.memory.max		= INIT_MEMBLOCK_REGIONS,
	.reserved.regions	= memblock_reserved_init_regions,
	.reserved.cnt		= 1,
	.reserved.max		= INIT_MEMBLOCK_REGIONS,
#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP
	.physmem.regions	= memblock_physmem_init_regions,
	.physmem.cnt		= 1,
	.physmem.max		= INIT_PHYSMEM_REGIONS,
#endif
	.bottom_up		= false,
	.current_limit		= MEMBLOCK_ALLOC_ANYWHERE,
};
</code></pre>
<p>We will not dive into detail of this variable, but we will see all details about it in the parts about memory manager. Just note that <code>memblock</code> variable defined with the <code>__initdata_memblock</code> which is:</p>
<pre><code class="language-C">#define __initdata_memblock __meminitdata
</code></pre>
<p>and <code>__meminit_data</code> is:</p>
<pre><code class="language-C">#define __meminitdata    __section(.meminit.data)
</code></pre>
<p>From this we can conclude that all memory blocks will be in the <code>.meminit.data</code> section. After we defined <code>_rgn</code> we print information about it with <code>memblock_dbg</code> macros. You can enable it by passing <code>memblock=debug</code> to the kernel command line.</p>
<p>After debugging lines were printed next is the call of the following function:</p>
<pre><code class="language-C">memblock_add_range(_rgn, base, size, nid, flags);
</code></pre>
<p>which adds new memory block region into the <code>.meminit.data</code> section. As we do not initialize <code>_rgn</code> but it just contains <code>&amp;memblock.reserved</code>, we just fill passed <code>_rgn</code> with the base address of the extended BIOS data area region, size of this region and flags:</p>
<pre><code class="language-C">if (type-&gt;regions[0].size == 0) {
    WARN_ON(type-&gt;cnt != 1 || type-&gt;total_size);
    type-&gt;regions[0].base = base;
    type-&gt;regions[0].size = size;
    type-&gt;regions[0].flags = flags;
    memblock_set_region_node(&amp;type-&gt;regions[0], nid);
    type-&gt;total_size = size;
    return 0;
}
</code></pre>
<p>After we filled our region we can see the call of the <code>memblock_set_region_node</code> function with two parameters:</p>
<ul>
<li>address of the filled memory region;</li>
<li>NUMA node id.</li>
</ul>
<p>where our regions represented by the <code>memblock_region</code> structure:</p>
<pre><code class="language-C">struct memblock_region {
    phys_addr_t base;
	phys_addr_t size;
	unsigned long flags;
#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP
    int nid;
#endif
};
</code></pre>
<p>NUMA node id depends on <code>MAX_NUMNODES</code> macro which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/numa.h">include/linux/numa.h</a>:</p>
<pre><code class="language-C">#define MAX_NUMNODES    (1 &lt;&lt; NODES_SHIFT)
</code></pre>
<p>where <code>NODES_SHIFT</code> depends on <code>CONFIG_NODES_SHIFT</code> configuration parameter and defined as:</p>
<pre><code class="language-C">#ifdef CONFIG_NODES_SHIFT
  #define NODES_SHIFT     CONFIG_NODES_SHIFT
#else
  #define NODES_SHIFT     0
#endif
</code></pre>
<p><code>memblock_set_region_node</code> function just fills <code>nid</code> field from <code>memblock_region</code> with the given value:</p>
<pre><code class="language-C">static inline void memblock_set_region_node(struct memblock_region *r, int nid)
{
         r-&gt;nid = nid;
}
</code></pre>
<p>After this we will have first reserved <code>memblock</code> for the extended BIOS data area in the <code>.meminit.data</code> section. <code>reserve_ebda_region</code> function finished its work on this step and we can go back to the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/head64.c">arch/x86/kernel/head64.c</a>.</p>
<p>We finished all preparations before the kernel entry point! The last step in the <code>x86_64_start_reservations</code> function is the call of the:</p>
<pre><code class="language-C">start_kernel()
</code></pre>
<p>function from <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> file.</p>
<p>That's all for this part.</p>
<h2 id="conclusion-8"><a class="header" href="#conclusion-8">Conclusion</a></h2>
<p>It is the end of the third part about Linux kernel insides. In next part we will see the first initialization steps in the kernel entry point - <code>start_kernel</code> function. It will be the first step before we will see launch of the first <code>init</code> process.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-8"><a class="header" href="#links-8">Links</a></h2>
<ul>
<li><a href="http://stanislavs.org/helppc/bios_data_area.html">BIOS data area</a></li>
<li><a href="http://www.kryslix.com/nsfaq/Q.6.html">What is in the extended BIOS data area on a PC?</a></li>
<li><a href="https://github.com/0xAX/linux-insides/blob/master/Initialization/linux-initialization-2.md">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-initialization-part-4"><a class="header" href="#kernel-initialization-part-4">Kernel initialization. Part 4.</a></h1>
<h1 id="kernel-entry-point"><a class="header" href="#kernel-entry-point">Kernel entry point</a></h1>
<p>If you have read the previous part - <a href="https://github.com/0xAX/linux-insides/blob/master/Initialization/linux-initialization-3.md">Last preparations before the kernel entry point</a>, you can remember that we finished all pre-initialization stuff and stopped right before the call to the <code>start_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>. The <code>start_kernel</code> is the entry of the generic and architecture independent kernel code, although we will return to the <code>arch/</code> folder many times. If you look inside of the <code>start_kernel</code> function, you will see that this function is very big. For this moment it contains about <code>86</code> function calls. Yes, it's very big and of course this part will not cover all the processes that occur in this function. In the current part we will only start to do it. This part and all the next which will be in the <a href="https://github.com/0xAX/linux-insides/blob/master/Initialization/README.md">Kernel initialization process</a> chapter will cover it.</p>
<p>The main purpose of the <code>start_kernel</code> to finish kernel initialization process and launch the first <code>init</code> process. Before the first process will be started, the <code>start_kernel</code> must do many things such as: to enable <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a>, to initialize processor id, to enable early <a href="http://en.wikipedia.org/wiki/Cgroups">cgroups</a> subsystem, to setup per-cpu areas, to initialize different caches in <a href="http://en.wikipedia.org/wiki/Virtual_file_system">vfs</a>, to initialize memory manager, rcu, vmalloc, scheduler, IRQs, ACPI and many many more. Only after these steps will we see the launch of the first <code>init</code> process in the last part of this chapter. So much kernel code awaits us, let's start.</p>
<p><strong>NOTE: All parts from this big chapter <code>Linux Kernel initialization process</code> will not cover anything about debugging. There will be a separate chapter about kernel debugging tips.</strong></p>
<h2 id="a-little-about-function-attributes"><a class="header" href="#a-little-about-function-attributes">A little about function attributes</a></h2>
<p>As I wrote above, the <code>start_kernel</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>. This function defined with the <code>__init</code> attribute and as you already may know from other parts, all functions which are defined with this attribute are necessary during kernel initialization.</p>
<pre><code class="language-C">#define __init      __section(.init.text) __cold notrace
</code></pre>
<p>After the initialization process have finished, the kernel will release these sections with a call to the <code>free_initmem</code> function. Note also that <code>__init</code> is defined with two attributes: <code>__cold</code> and <code>notrace</code>. The purpose of the first <code>cold</code> attribute is to mark that the function is rarely used and the compiler must optimize this function for size. The second <code>notrace</code> is defined as:</p>
<pre><code class="language-C">#define notrace __attribute__((no_instrument_function))
</code></pre>
<p>where <code>no_instrument_function</code> says to the compiler not to generate profiling function calls.</p>
<p>In the definition of the <code>start_kernel</code> function, you can also see the <code>__visible</code> attribute which expands to the:</p>
<pre><code>#define __visible __attribute__((externally_visible))
</code></pre>
<p>where <code>externally_visible</code> tells to the compiler that something uses this function or variable, to prevent marking this function/variable as <code>unusable</code>. You can find the definition of this and other macro attributes in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init.h">include/linux/init.h</a>.</p>
<h2 id="first-steps-in-the-start_kernel"><a class="header" href="#first-steps-in-the-start_kernel">First steps in the start_kernel</a></h2>
<p>At the beginning of the <code>start_kernel</code> you can see the definition of these two variables:</p>
<pre><code class="language-C">char *command_line;
char *after_dashes;
</code></pre>
<p>The first represents a pointer to the kernel command line and the second will contain the result of the <code>parse_args</code> function which parses an input string with parameters in the form <code>name=value</code>, looking for specific keywords and invoking the right handlers. We will not go into the details related with these two variables at this time, but will see it in the next parts. In the next step we can see a call to the <code>set_task_stack_end_magic</code> function. This function takes address of the <code>init_task</code> and sets <code>STACK_END_MAGIC</code> (<code>0x57AC6E9D</code>) as canary for it. <code>init_task</code> represents the initial task structure:</p>
<pre><code class="language-C">struct task_struct init_task = INIT_TASK(init_task);
</code></pre>
<p>where <code>task_struct</code> stores all the information about a process. I will not explain this structure in this book because it's very big. You can find its definition in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/sched.h#L1278">include/linux/sched.h</a>. At this moment <code>task_struct</code> contains more than <code>100</code> fields! Although you will not see the explanation of the <code>task_struct</code> in this book, we will use it very often since it is the fundamental structure which describes the <code>process</code> in the Linux kernel. I will describe the meaning of the fields of this structure as we meet them in practice.</p>
<p>You can see the definition of the <code>init_task</code> and it is initialized by the <code>INIT_TASK</code> macro. This macro is from <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init_task.h">include/linux/init_task.h</a> and it just fills the <code>init_task</code> with the values for the first process. For example it sets:</p>
<ul>
<li>init process state to zero or <code>runnable</code>. A runnable process is one which is waiting only for a CPU to run on;</li>
<li>init process flags - <code>PF_KTHREAD</code> which means - kernel thread;</li>
<li>a list of runnable task;</li>
<li>process address space;</li>
<li>init process stack to the <code>&amp;init_thread_info</code> which is <code>init_thread_union.thread_info</code> and <code>initthread_union</code> has type - <code>thread_union</code> which contains <code>thread_info</code> and process stack:</li>
</ul>
<pre><code class="language-C">union thread_union {
    struct thread_info thread_info;
    unsigned long stack[THREAD_SIZE/sizeof(long)];
};
</code></pre>
<p>Every process has its own stack and it is 16 kilobytes or 4 page frames in <code>x86_64</code>. We can note that it is defined as array of <code>unsigned long</code>. The next field of the <code>thread_union</code> is - <code>thread_info</code> defined as:</p>
<pre><code class="language-C">struct thread_info {
        struct task_struct      *task;
        struct exec_domain      *exec_domain;
        __u32                   flags;
        __u32                   status;
        __u32                   cpu;
        int                     saved_preempt_count;
        mm_segment_t            addr_limit;
        struct restart_block    restart_block;
        void __user             *sysenter_return;
        unsigned int            sig_on_uaccess_error:1;
        unsigned int            uaccess_err:1;
};
</code></pre>
<p>and occupies 52 bytes. The <code>thread_info</code> structure contains architecture-specific information on the thread. We know that on <code>x86_64</code> the stack grows down and <code>thread_union.thread_info</code> is stored at the bottom of the stack in our case. So the process stack is 16 kilobytes and <code>thread_info</code> is at the bottom. The remaining thread size will be <code>16 kilobytes - 62 bytes = 16332 bytes</code>. Note that <code>thread_union</code> represented as the <a href="http://en.wikipedia.org/wiki/Union_type">union</a> and not structure, it means that <code>thread_info</code> and stack share the memory space.</p>
<p>Schematically it can be represented as follows:</p>
<pre><code class="language-C">+-----------------------+
|                       |
|                       |
|        stack          |
|                       |
|_______________________|
|          |            |
|          |            |
|          |            |
|__________↓____________|             +--------------------+
|                       |             |                    |
|      thread_info      |&lt;-----------&gt;|     task_struct    |
|                       |             |                    |
+-----------------------+             +--------------------+
</code></pre>
<p>http://www.quora.com/In-Linux-kernel-Why-thread_info-structure-and-the-kernel-stack-of-a-process-binds-in-union-construct</p>
<p>So the <code>INIT_TASK</code> macro fills these <code>task_struct's</code> fields and many many more. As I already wrote above, I will not describe all the fields and values in the <code>INIT_TASK</code> macro but we will see them soon.</p>
<p>Now let's go back to the <code>set_task_stack_end_magic</code> function. This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/fork.c#L297">kernel/fork.c</a> and sets a <a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow">canary</a> to the <code>init</code> process stack to prevent stack overflow.</p>
<pre><code class="language-C">void set_task_stack_end_magic(struct task_struct *tsk)
{
	unsigned long *stackend;
	stackend = end_of_stack(tsk);
	*stackend = STACK_END_MAGIC; /* for overflow detection */
}
</code></pre>
<p>Its implementation is simple. <code>set_task_stack_end_magic</code> gets the end of the stack for the given <code>task_struct</code> with the <code>end_of_stack</code> function. Earlier (and now for all architectures besides <code>x86_64</code>) stack was located in the <code>thread_info</code> structure. So the end of a process stack depends on the <code>CONFIG_STACK_GROWSUP</code> configuration option. As we learn in <code>x86_64</code> architecture, the stack grows down. So the end of the process stack will be:</p>
<pre><code class="language-C">(unsigned long *)(task_thread_info(p) + 1);
</code></pre>
<p>where <code>task_thread_info</code> just returns the stack which we filled with the <code>INIT_TASK</code> macro:</p>
<pre><code class="language-C">#define task_thread_info(task)  ((struct thread_info *)(task)-&gt;stack)
</code></pre>
<p>From the Linux kernel <code>v4.9-rc1</code> release, <code>thread_info</code> structure may contains only flags and stack pointer resides in <code>task_struct</code> structure which represents a thread in the Linux kernel. This depends on <code>CONFIG_THREAD_INFO_IN_TASK</code> kernel configuration option which is enabled by default for <code>x86_64</code>. You can be sure in this if you will look in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> configuration build file:</p>
<pre><code>config THREAD_INFO_IN_TASK
	bool
	help
	  Select this to move thread_info off the stack into task_struct.  To
	  make this work, an arch will need to remove all thread_info fields
	  except flags and fix any runtime bugs.

	  One subtle change that will be needed is to use try_get_task_stack()
	  and put_task_stack() in save_thread_stack_tsk() and get_wchan().
</code></pre>
<p>and <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/Kconfig">arch/x86/Kconfig</a>:</p>
<pre><code>config X86
	def_bool y
        ...
        ...
        ...
        select THREAD_INFO_IN_TASK
        ...
        ...
        ...
</code></pre>
<p>So, in this way we may just get end of a thread stack from the given <code>task_struct</code> structure:</p>
<pre><code class="language-C">#ifdef CONFIG_THREAD_INFO_IN_TASK
static inline unsigned long *end_of_stack(const struct task_struct *task)
{
	return task-&gt;stack;
}
#endif
</code></pre>
<p>As we got the end of the <code>init</code> process stack, we write <code>STACK_END_MAGIC</code> there. After <code>canary</code> is set, we can check it like this:</p>
<pre><code class="language-C">if (*end_of_stack(task) != STACK_END_MAGIC) {
        //
        // handle stack overflow here
        //
}
</code></pre>
<p>The next function after the <code>set_task_stack_end_magic</code> is <code>smp_setup_processor_id</code>. This function has an empty body for <code>x86_64</code>:</p>
<pre><code class="language-C">void __init __weak smp_setup_processor_id(void)
{
}
</code></pre>
<p>as it not implemented for all architectures, but some such as <a href="http://en.wikipedia.org/wiki/IBM_ESA/390">s390</a> and <a href="http://en.wikipedia.org/wiki/ARM_architecture#64.2F32-bit_architecture">arm64</a>.</p>
<p>The next function in <code>start_kernel</code> is <code>debug_objects_early_init</code>. Implementation of this function is almost the same as <code>lockdep_init</code>, but fills hashes for object debugging. As I wrote above, we will not see the explanation of this and other functions which are for debugging purposes in this chapter.</p>
<p>After the <code>debug_object_early_init</code> function we can see the call of the <code>boot_init_stack_canary</code> function which fills <code>task_struct-&gt;canary</code> with the <code>canary</code> value for the <code>-fstack-protector</code> gcc feature. This function depends on the <code>CONFIG_CC_STACKPROTECTOR</code> configuration option and if this option is disabled, <code>boot_init_stack_canary</code> does nothing, otherwise it generates random numbers based on random pool and the <a href="http://en.wikipedia.org/wiki/Time_Stamp_Counter">TSC</a>:</p>
<pre><code class="language-C">get_random_bytes(&amp;canary, sizeof(canary));
tsc = __native_read_tsc();
canary += tsc + (tsc &lt;&lt; 32UL);
</code></pre>
<p>After we got a random number, we fill the <code>stack_canary</code> field of <code>task_struct</code> with it:</p>
<pre><code class="language-C">current-&gt;stack_canary = canary;
</code></pre>
<p>and write this value to the top of the IRQ stack with the:</p>
<pre><code class="language-C">this_cpu_write(irq_stack_union.stack_canary, canary); // read below about this_cpu_write
</code></pre>
<p>Again, we will not dive into details here, we will cover it in the part about <a href="http://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQs</a>. As <code>canary</code> is set, we disable local and early boot IRQs and register the bootstrap CPU in the CPU maps. We disable local IRQs (interrupts for current CPU) with the <code>local_irq_disable</code> macro which expands to the call of the <code>arch_local_irq_disable</code> function from <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/percpu-defs.h">include/linux/percpu-defs.h</a>:</p>
<pre><code class="language-C">static inline notrace void arch_local_irq_disable(void)
{
        native_irq_disable();
}
</code></pre>
<p>Where <code>native_irq_disable</code> is <code>cli</code> instruction for <code>x86_64</code>. As interrupts are disabled we can register the current CPU with the given ID in the CPU bitmap.</p>
<h2 id="the-first-processor-activation"><a class="header" href="#the-first-processor-activation">The first processor activation</a></h2>
<p>The current function from the <code>start_kernel</code> is <code>boot_cpu_init</code>. This function initializes various CPU masks for the bootstrap processor. First of all it gets the bootstrap processor id with a call to:</p>
<pre><code class="language-C">int cpu = smp_processor_id();
</code></pre>
<p>For now it is just zero. If the <code>CONFIG_DEBUG_PREEMPT</code> configuration option is disabled, <code>smp_processor_id</code> just expands to the call of <code>raw_smp_processor_id</code> which expands to the:</p>
<pre><code class="language-C">#define raw_smp_processor_id() (this_cpu_read(cpu_number))
</code></pre>
<p><code>this_cpu_read</code> as many other function like this (<code>this_cpu_write</code>, <code>this_cpu_add</code> and etc...) defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/percpu-defs.h">include/linux/percpu-defs.h</a> and presents <code>this_cpu</code> operation. These operations provide a way of optimizing access to the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> variables which are associated with the current processor. In our case it is <code>this_cpu_read</code>:</p>
<pre><code>__pcpu_size_call_return(this_cpu_read_, pcp)
</code></pre>
<p>Remember that we have passed <code>cpu_number</code> as <code>pcp</code> to the <code>this_cpu_read</code> from the <code>raw_smp_processor_id</code>. Now let's look at the <code>__pcpu_size_call_return</code> implementation:</p>
<pre><code class="language-C">#define __pcpu_size_call_return(stem, variable)                         \
({                                                                      \
        typeof(variable) pscr_ret__;                                    \
        __verify_pcpu_ptr(&amp;(variable));                                 \
        switch(sizeof(variable)) {                                      \
        case 1: pscr_ret__ = stem##1(variable); break;                  \
        case 2: pscr_ret__ = stem##2(variable); break;                  \
        case 4: pscr_ret__ = stem##4(variable); break;                  \
        case 8: pscr_ret__ = stem##8(variable); break;                  \
        default:                                                        \
                __bad_size_call_parameter(); break;                     \
        }                                                               \
        pscr_ret__;                                                     \
})
</code></pre>
<p>Yes, it looks a little strange but it's easy. First of all we can see the definition of the <code>pscr_ret__</code> variable with the <code>int</code> type. Why int? Ok, <code>variable</code> is <code>cpu_number</code> and it was declared as per-cpu int variable:</p>
<pre><code class="language-C">DECLARE_PER_CPU_READ_MOSTLY(int, cpu_number);
</code></pre>
<p>In the next step we call <code>__verify_pcpu_ptr</code> with the address of <code>cpu_number</code>. <code>__veryf_pcpu_ptr</code> used to verify that the given parameter is a per-cpu pointer. After that we set <code>pscr_ret__</code> value which depends on the size of the variable. Our <code>cpu_number</code> variable is <code>int</code>, so it's 4 bytes in size. It means that we will get <code>this_cpu_read_4(cpu_number)</code> in <code>pscr_ret__</code>. In the end of the <code>__pcpu_size_call_return</code> we just call it. <code>this_cpu_read_4</code> is a macro:</p>
<pre><code class="language-C">#define this_cpu_read_4(pcp)       percpu_from_op(&quot;mov&quot;, pcp)
</code></pre>
<p>which calls <code>percpu_from_op</code> and pass <code>mov</code> instruction and per-cpu variable there. <code>percpu_from_op</code> will expand to the inline assembly call:</p>
<pre><code class="language-C">asm(&quot;movl %%gs:%1,%0&quot; : &quot;=r&quot; (pfo_ret__) : &quot;m&quot; (cpu_number))
</code></pre>
<p>Let's try to understand how it works and what it does. The <code>gs</code> segment register contains the base of per-cpu area. Here we just copy <code>cpu_number</code> which is in memory to the <code>pfo_ret__</code> with the <code>movl</code> instruction. Or with another words:</p>
<pre><code class="language-C">this_cpu_read(cpu_number)
</code></pre>
<p>is the same as:</p>
<pre><code class="language-C">movl %gs:$cpu_number, $pfo_ret__
</code></pre>
<p>As we didn't setup per-cpu area, we have only one - for the current running CPU, we will get <code>zero</code> as a result of the <code>smp_processor_id</code>.</p>
<p>As we got the current processor id, <code>boot_cpu_init</code> sets the given CPU online, active, present and possible with the:</p>
<pre><code class="language-C">set_cpu_online(cpu, true);
set_cpu_active(cpu, true);
set_cpu_present(cpu, true);
set_cpu_possible(cpu, true);
</code></pre>
<p>All of these functions use the concept - <code>cpumask</code>. <code>cpu_possible</code> is a set of CPU ID's which can be plugged in at any time during the life of that system boot. <code>cpu_present</code> represents which CPUs are currently plugged in. <code>cpu_online</code> represents subset of the <code>cpu_present</code> and indicates CPUs which are available for scheduling. These masks depend on the <code>CONFIG_HOTPLUG_CPU</code> configuration option and if this option is disabled <code>possible == present</code> and <code>active == online</code>. Implementation of the all of these functions are very similar. Every function checks the second parameter. If it is <code>true</code>, it calls <code>cpumask_set_cpu</code> or <code>cpumask_clear_cpu</code> otherwise.</p>
<p>For example let's look at <code>set_cpu_possible</code>. As we passed <code>true</code> as the second parameter, the:</p>
<pre><code class="language-C">cpumask_set_cpu(cpu, to_cpumask(cpu_possible_bits));
</code></pre>
<p>will be called. First of all let's try to understand the <code>to_cpumask</code> macro. This macro casts a bitmap to a <code>struct cpumask *</code>. CPU masks provide a bitmap suitable for representing the set of CPU's in a system, one bit position per CPU number. CPU mask presented by the <code>cpumask</code> structure:</p>
<pre><code class="language-C">typedef struct cpumask { DECLARE_BITMAP(bits, NR_CPUS); } cpumask_t;
</code></pre>
<p>which is just bitmap declared with the <code>DECLARE_BITMAP</code> macro:</p>
<pre><code class="language-C">#define DECLARE_BITMAP(name, bits) unsigned long name[BITS_TO_LONGS(bits)]
</code></pre>
<p>As we can see from its definition, the <code>DECLARE_BITMAP</code> macro expands to the array of <code>unsigned long</code>. Now let's look at how the <code>to_cpumask</code> macro is implemented:</p>
<pre><code class="language-C">#define to_cpumask(bitmap)                                              \
        ((struct cpumask *)(1 ? (bitmap)                                \
                            : (void *)sizeof(__check_is_bitmap(bitmap))))
</code></pre>
<p>I don't know about you, but it looked really weird for me at the first time. We can see a ternary operator here which is <code>true</code> every time, but why the <code>__check_is_bitmap</code> here? It's simple, let's look at it:</p>
<pre><code class="language-C">static inline int __check_is_bitmap(const unsigned long *bitmap)
{
        return 1;
}
</code></pre>
<p>Yeah, it just returns <code>1</code> every time. Actually we need in it here only for one purpose: at compile time it checks that the given <code>bitmap</code> is a bitmap, or in other words it checks that the given <code>bitmap</code> has a type of <code>unsigned long *</code>. So we just pass <code>cpu_possible_bits</code> to the <code>to_cpumask</code> macro for converting the array of <code>unsigned long</code> to the <code>struct cpumask *</code>. Now we can call <code>cpumask_set_cpu</code> function with the <code>cpu</code> - 0 and <code>struct cpumask *cpu_possible_bits</code>. This function makes only one call of the <code>set_bit</code> function which sets the given <code>cpu</code> in the cpumask. All of these <code>set_cpu_*</code> functions work on the same principle.</p>
<p>If you're not sure that this <code>set_cpu_*</code> operations and <code>cpumask</code> are not clear for you, don't worry about it. You can get more info by reading the special part about it - <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumask</a> or <a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">documentation</a>.</p>
<p>As we activated the bootstrap processor, it's time to go to the next function in the <code>start_kernel.</code> Now it is <code>page_address_init</code>, but this function does nothing in our case, because it executes only when all <code>RAM</code> can't be mapped directly.</p>
<h2 id="print-linux-banner"><a class="header" href="#print-linux-banner">Print Linux banner</a></h2>
<p>The next call is <code>pr_notice</code>:</p>
<pre><code class="language-C">#define pr_notice(fmt, ...) \
    printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)
</code></pre>
<p>as you can see it just expands to the <code>printk</code> call. At this moment we use <code>pr_notice</code> to print the Linux banner:</p>
<pre><code class="language-C">pr_notice(&quot;%s&quot;, linux_banner);
</code></pre>
<p>which is just the kernel version with some additional parameters:</p>
<pre><code>Linux version 4.0.0-rc6+ (alex@localhost) (gcc version 4.9.1 (Ubuntu 4.9.1-16ubuntu6) ) #319 SMP
</code></pre>
<h2 id="architecture-dependent-parts-of-initialization"><a class="header" href="#architecture-dependent-parts-of-initialization">Architecture-dependent parts of initialization</a></h2>
<p>The next step is architecture-specific initialization. The Linux kernel does it with the call of the <code>setup_arch</code> function. This is a very big function like <code>start_kernel</code> and we do not have time to consider all of its implementation in this part. Here we'll only start to do it and continue in the next part. As it is <code>architecture-specific</code>, we need to go again to the <code>arch/</code> directory. The <code>setup_arch</code> function defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> source code file and takes only one argument - address of the kernel command line.</p>
<p>This function starts from the reserving memory block for the kernel <code>_text</code> and <code>_data</code> which starts from the <code>_text</code> symbol (you can remember it from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/head_64.S#L46">arch/x86/kernel/head_64.S</a>) and ends before <code>__bss_stop</code>. We are using <code>memblock</code> for the reserving of memory block:</p>
<pre><code class="language-C">memblock_reserve(__pa_symbol(_text), (unsigned long)__bss_stop - (unsigned long)_text);
</code></pre>
<p>You can read about <code>memblock</code> in the <a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-1">Linux kernel memory management Part 1.</a>. As you can remember <code>memblock_reserve</code> function takes two parameters:</p>
<ul>
<li>base physical address of a memory block;</li>
<li>size of a memory block.</li>
</ul>
<p>We can get the base physical address of the <code>_text</code> symbol with the <code>__pa_symbol</code> macro:</p>
<pre><code class="language-C">#define __pa_symbol(x) \
	__phys_addr_symbol(__phys_reloc_hide((unsigned long)(x)))
</code></pre>
<p>First of all it calls <code>__phys_reloc_hide</code> macro on the given parameter. The <code>__phys_reloc_hide</code> macro does nothing for <code>x86_64</code> and just returns the given parameter. Implementation of the <code>__phys_addr_symbol</code> macro is easy. It just subtracts the symbol address from the base address of the kernel text mapping base virtual address (you can remember that it is <code>__START_KERNEL_map</code>) and adds <code>phys_base</code> which is the base address of <code>_text</code>:</p>
<pre><code class="language-C">#define __phys_addr_symbol(x) \
 ((unsigned long)(x) - __START_KERNEL_map + phys_base)
</code></pre>
<p>After we got the physical address of the <code>_text</code> symbol, <code>memblock_reserve</code> can reserve a memory block from the <code>_text</code> to the <code>__bss_stop - _text</code>.</p>
<h2 id="reserve-memory-for-initrd"><a class="header" href="#reserve-memory-for-initrd">Reserve memory for initrd</a></h2>
<p>In the next step after we reserved place for the kernel text and data is reserving place for the <a href="http://en.wikipedia.org/wiki/Initrd">initrd</a>. We will not see details about <code>initrd</code> in this post, you just may know that it is temporary root file system stored in memory and used by the kernel during its startup. The <code>early_reserve_initrd</code> function does all work. First of all this function gets the base address of the ram disk, its size and the end address with:</p>
<pre><code class="language-C">u64 ramdisk_image = get_ramdisk_image();
u64 ramdisk_size  = get_ramdisk_size();
u64 ramdisk_end   = PAGE_ALIGN(ramdisk_image + ramdisk_size);
</code></pre>
<p>All of these parameters are taken from <code>boot_params</code>. If you have read the chapter about <a href="https://0xax.gitbook.io/linux-insides/summary/booting">Linux Kernel Booting Process</a>, you must remember that we filled the <code>boot_params</code> structure during boot time. The kernel setup header contains a couple of fields which describes ramdisk, for example:</p>
<pre><code>Field name:	ramdisk_image
Type:		write (obligatory)
Offset/size:	0x218/4
Protocol:	2.00+

  The 32-bit linear address of the initial ramdisk or ramfs.  Leave at
  zero if there is no initial ramdisk/ramfs.
</code></pre>
<p>So we can get all the information that interests us from <code>boot_params</code>. For example let's look at <code>get_ramdisk_image</code>:</p>
<pre><code class="language-C">static u64 __init get_ramdisk_image(void)
{
        u64 ramdisk_image = boot_params.hdr.ramdisk_image;

        ramdisk_image |= (u64)boot_params.ext_ramdisk_image &lt;&lt; 32;

        return ramdisk_image;
}
</code></pre>
<p>Here we get the address of the ramdisk from the <code>boot_params</code> and shift left it on <code>32</code>. We need to do it because as you can read in the <a href="https://github.com/0xAX/linux/blob/0a07b238e5f488b459b6113a62e06b6aab017f71/Documentation/x86/zero-page.txt">Documentation/x86/zero-page.txt</a>:</p>
<pre><code>0C0/004	ALL	ext_ramdisk_image ramdisk_image high 32bits
</code></pre>
<p>So after shifting it on 32, we're getting a 64-bit address in <code>ramdisk_image</code> and we return it. <code>get_ramdisk_size</code> works on the same principle as <code>get_ramdisk_image</code>, but it used <code>ext_ramdisk_size</code> instead of <code>ext_ramdisk_image</code>. After we got ramdisk's size, base address and end address, we check that bootloader provided ramdisk with the:</p>
<pre><code class="language-C">if (!boot_params.hdr.type_of_loader ||
    !ramdisk_image || !ramdisk_size)
	return;
</code></pre>
<p>and reserve memory block with the calculated addresses for the initial ramdisk in the end:</p>
<pre><code class="language-C">memblock_reserve(ramdisk_image, ramdisk_end - ramdisk_image);
</code></pre>
<h2 id="conclusion-9"><a class="header" href="#conclusion-9">Conclusion</a></h2>
<p>It is the end of the fourth part about the Linux kernel initialization process. We started to dive in the kernel generic code from the <code>start_kernel</code> function in this part and stopped on the architecture-specific initialization in the <code>setup_arch</code>. In the next part we will continue with architecture-dependent initialization steps.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-9"><a class="header" href="#links-9">Links</a></h2>
<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">GCC function attributes</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/this_cpu_ops.txt">this_cpu operations</a></li>
<li><a href="http://www.crashcourse.ca/wiki/index.php/Cpumask">cpumask</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a></li>
<li><a href="http://en.wikipedia.org/wiki/Cgroups">cgroups</a></li>
<li><a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow">stack buffer overflow</a></li>
<li><a href="http://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQs</a></li>
<li><a href="http://en.wikipedia.org/wiki/Initrd">initrd</a></li>
<li><a href="https://github.com/0xAX/linux-insides/blob/master/Initialization/linux-initialization-3.md">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-initialization-part-5"><a class="header" href="#kernel-initialization-part-5">Kernel initialization. Part 5.</a></h1>
<h1 id="continue-of-architecture-specific-initialization"><a class="header" href="#continue-of-architecture-specific-initialization">Continue of architecture-specific initialization</a></h1>
<p>In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">part</a>, we stopped at the initialization of an architecture-specific stuff from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/setup.c#L856">setup_arch</a> function and now we will continue with it. As we reserved memory for the <a href="http://en.wikipedia.org/wiki/Initrd">initrd</a>, next step is the <code>olpc_ofw_detect</code> which detects <a href="http://wiki.laptop.org/go/OFW_FAQ">One Laptop Per Child support</a>. We will not consider platform related stuff in this book and will skip functions related with it. So let's go ahead. The next step is the <code>early_trap_init</code> function. This function initializes debug (<code>#DB</code> - raised when the <code>TF</code> flag of rflags is set) and <code>int3</code> (<code>#BP</code>) interrupts gate. If you don't know anything about interrupts, you can read about it in the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-2">Early interrupt and exception handling</a>. In <code>x86</code> architecture <code>INT</code>, <code>INTO</code> and <code>INT3</code> are special instructions which allow a task to explicitly call an interrupt handler. The <code>INT3</code> instruction calls the breakpoint (<code>#BP</code>) handler. You may remember, we already saw it in the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-2">part</a> about interrupts: and exceptions:</p>
<pre><code>----------------------------------------------------------------------------------------------
|Vector|Mnemonic|Description         |Type |Error Code|Source                   |
----------------------------------------------------------------------------------------------
|3     | #BP    |Breakpoint          |Trap |NO        |INT 3                    |
----------------------------------------------------------------------------------------------
</code></pre>
<p>Debug interrupt <code>#DB</code> is the primary method of invoking debuggers. <code>early_trap_init</code> defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a>. This functions sets <code>#DB</code> and <code>#BP</code> handlers and reloads <a href="http://en.wikipedia.org/wiki/Interrupt_descriptor_table">IDT</a>:</p>
<pre><code class="language-C">void __init early_trap_init(void)
{
        set_intr_gate_ist(X86_TRAP_DB, &amp;debug, DEBUG_STACK);
        set_system_intr_gate_ist(X86_TRAP_BP, &amp;int3, DEBUG_STACK);
        load_idt(&amp;idt_descr);
}
</code></pre>
<p>We already saw implementation of the <code>set_intr_gate</code> in the previous part about interrupts. Here are two similar functions <code>set_intr_gate_ist</code> and <code>set_system_intr_gate_ist</code>. Both of these two functions take three parameters:</p>
<ul>
<li>number of the interrupt;</li>
<li>base address of the interrupt/exception handler;</li>
<li>third parameter is - <code>Interrupt Stack Table</code>. <code>IST</code> is a new mechanism in the <code>x86_64</code> and part of the <a href="http://en.wikipedia.org/wiki/Task_state_segment">TSS</a>. Every active thread in kernel mode has own kernel stack which is <code>16</code> kilobytes. While a thread in user space, this kernel stack is empty.</li>
</ul>
<p>In addition to per-thread stacks, there are a couple of specialized stacks associated with each CPU. All about these stack you can read in the Linux kernel documentation - <a href="https://www.kernel.org/doc/Documentation/x86/kernel-stacks">Kernel stacks</a>. <code>x86_64</code> provides feature which allows to switch to a new <code>special</code> stack for during any events as non-maskable interrupt and etc... And the name of this feature is - <code>Interrupt Stack Table</code>. There can be up to 7 <code>IST</code> entries per CPU and every entry points to the dedicated stack. In our case this is <code>DEBUG_STACK</code>.</p>
<p><code>set_intr_gate_ist</code> and <code>set_system_intr_gate_ist</code> work by the same principle as <code>set_intr_gate</code> with only one difference. Both of these functions checks
interrupt number and call <code>_set_gate</code> inside:</p>
<pre><code class="language-C">BUG_ON((unsigned)n &gt; 0xFF);
_set_gate(n, GATE_INTERRUPT, addr, 0, ist, __KERNEL_CS);
</code></pre>
<p>as <code>set_intr_gate</code> does this. But <code>set_intr_gate</code> calls <code>_set_gate</code> with <a href="http://en.wikipedia.org/wiki/Privilege_level">dpl</a> - 0, and ist - 0, but <code>set_intr_gate_ist</code> and <code>set_system_intr_gate_ist</code> sets <code>ist</code> as <code>DEBUG_STACK</code> and <code>set_system_intr_gate_ist</code> sets <code>dpl</code> as <code>0x3</code> which is the lowest privilege. When an interrupt occurs and the hardware loads such a descriptor, then hardware automatically sets the new stack pointer based on the IST value, then invokes the interrupt handler. All of the special kernel stacks will be set in the <code>cpu_init</code> function (we will see it later).</p>
<p>As <code>#DB</code> and <code>#BP</code> gates written to the <code>idt_descr</code>, we reload <code>IDT</code> table with <code>load_idt</code> which just call <code>ldtr</code> instruction. Now let's look on interrupt handlers and will try to understand how they works. Of course, I can't cover all interrupt handlers in this book and I do not see the point in this. It is very interesting to delve in the Linux kernel source code, so we will see how <code>debug</code> handler implemented in this part, and understand how other interrupt handlers are implemented will be your task.</p>
<h2 id="db-handler"><a class="header" href="#db-handler">#DB handler</a></h2>
<p>As you can read above, we passed address of the <code>#DB</code> handler as <code>&amp;debug</code> in the <code>set_intr_gate_ist</code>. <a href="http://lxr.free-electrons.com/ident">lxr.free-electrons.com</a> is a great resource for searching identifiers in the Linux kernel source code, but unfortunately you will not find <code>debug</code> handler with it. All of you can find, it is <code>debug</code> definition in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/traps.h">arch/x86/include/asm/traps.h</a>:</p>
<pre><code class="language-C">asmlinkage void debug(void);
</code></pre>
<p>We can see <code>asmlinkage</code> attribute which tells to us that <code>debug</code> is function written with <a href="http://en.wikipedia.org/wiki/Assembly_language">assembly</a>. Yeah, again and again assembly :). Implementation of the <code>#DB</code> handler as other handlers is in this <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> and defined with the <code>idtentry</code> assembly macro:</p>
<pre><code class="language-assembly">idtentry debug do_debug has_error_code=0 paranoid=1 shift_ist=DEBUG_STACK
</code></pre>
<p><code>idtentry</code> is a macro which defines an interrupt/exception entry point. As you can see it takes five arguments:</p>
<ul>
<li>name of the interrupt entry point;</li>
<li>name of the interrupt handler;</li>
<li>has interrupt error code or not;</li>
<li>paranoid  - if this parameter = 1, switch to special stack (read above);</li>
<li>shift_ist - stack to switch during interrupt.</li>
</ul>
<p>Now let's look on <code>idtentry</code> macro implementation. This macro defined in the same assembly file and defines <code>debug</code> function with the <code>ENTRY</code> macro. For the start <code>idtentry</code> macro checks that given parameters are correct in case if need to switch to the special stack. In the next step it checks that give interrupt returns error code. If interrupt does not return error code (in our case <code>#DB</code> does not return error code), it calls <code>INTR_FRAME</code> or <code>XCPT_FRAME</code> if interrupt has error code. Both of these macros <code>XCPT_FRAME</code> and <code>INTR_FRAME</code> do nothing and need only for the building initial frame state for interrupts. They uses <code>CFI</code> directives and used for debugging. More info you can find in the <a href="https://sourceware.org/binutils/docs/as/CFI-directives.html">CFI directives</a>. As comment from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S">arch/x86/kernel/entry/entry_64.S</a> says: <code>CFI macros are used to generate dwarf2 unwind information for better backtraces. They don't change any code.</code> so we will ignore them.</p>
<pre><code class="language-assembly">.macro idtentry sym do_sym has_error_code:req paranoid=0 shift_ist=-1
ENTRY(\sym)
	/* Sanity check */
	.if \shift_ist != -1 &amp;&amp; \paranoid == 0
	.error &quot;using shift_ist requires paranoid=1&quot;
	.endif

	.if \has_error_code
	XCPT_FRAME
	.else
	INTR_FRAME
	.endif
	...
	...
	...
</code></pre>
<p>You can remember from the previous part about early interrupts/exceptions handling that after interrupt occurs, current stack will have following format:</p>
<pre><code>    +-----------------------+
    |                       |
+40 |         SS            |
+32 |         RSP           |
+24 |        RFLAGS         |
+16 |         CS            |
+8  |         RIP           |
 0  |       Error Code      | &lt;---- rsp
    |                       |
    +-----------------------+
</code></pre>
<p>The next two macro from the <code>idtentry</code> implementation are:</p>
<pre><code class="language-assembly">	ASM_CLAC
	PARAVIRT_ADJUST_EXCEPTION_FRAME
</code></pre>
<p>First <code>ASM_CLAC</code> macro depends on <code>CONFIG_X86_SMAP</code> configuration option and need for security reason, more about it you can read <a href="https://lwn.net/Articles/517475/">here</a>. The second <code>PARAVIRT_ADJUST_EXCEPTION_FRAME</code> macro is for handling handle Xen-type-exceptions (this chapter about kernel initialization and we will not consider virtualization stuff here).</p>
<p>The next piece of code checks if interrupt has error code or not and pushes <code>$-1</code> which is <code>0xffffffffffffffff</code> on <code>x86_64</code> on the stack if not:</p>
<pre><code class="language-assembly">	.ifeq \has_error_code
	pushq_cfi $-1
	.endif
</code></pre>
<p>We need to do it as <code>dummy</code> error code for stack consistency for all interrupts. In the next step we subtract from the stack pointer <code>$ORIG_RAX-R15</code>:</p>
<pre><code class="language-assembly">	subq $ORIG_RAX-R15, %rsp
</code></pre>
<p>where <code>ORIRG_RAX</code>, <code>R15</code> and other macros defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/calling.h">arch/x86/entry/calling.h</a> and <code>ORIG_RAX-R15</code> is 120 bytes. General purpose registers will occupy these 120 bytes because we need to store all registers on the stack during interrupt handling. After we set stack for general purpose registers, the next step is checking that interrupt came from userspace with:</p>
<pre><code class="language-assembly">testl $3, CS(%rsp)
jnz 1f
</code></pre>
<p>Here we checks first and second bits in the <code>CS</code>. You can remember that <code>CS</code> register contains segment selector where first two bits are <code>RPL</code>. All privilege levels are integers in the range 0–3, where the lowest number corresponds to the highest privilege. So if interrupt came from the kernel mode we call <code>save_paranoid</code>	or jump on label <code>1</code> if not. In the <code>save_paranoid</code> we store all general purpose registers on the stack and switch user <code>gs</code> on kernel <code>gs</code> if need:</p>
<pre><code class="language-assembly">	movl $1,%ebx
	movl $MSR_GS_BASE,%ecx
	rdmsr
	testl %edx,%edx
	js 1f
	SWAPGS
	xorl %ebx,%ebx
1:	ret
</code></pre>
<p>In the next steps we put <code>pt_regs</code> pointer to the <code>rdi</code>, save error code in the <code>rsi</code> if it has and call interrupt handler which is - <code>do_debug</code> in our case from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a>. <code>do_debug</code> like other handlers takes two parameters:</p>
<ul>
<li>pt_regs - is a structure which presents set of CPU registers which are saved in the process' memory region;</li>
<li>error code - error code of interrupt.</li>
</ul>
<p>After interrupt handler finished its work, calls <code>paranoid_exit</code> which restores stack, switch on userspace if interrupt came from there and calls <code>iret</code>. That's all. Of course it is not all :), but we will see more deeply in the separate chapter about interrupts.</p>
<p>This is general view of the <code>idtentry</code> macro for <code>#DB</code> interrupt. All interrupts are similar to this implementation and defined with idtentry too. After <code>early_trap_init</code> finished its work, the next function is <code>early_cpu_init</code>. This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/cpu/common.c">arch/x86/kernel/cpu/common.c</a> and collects information about CPU and its vendor.</p>
<h2 id="early-ioremap-initialization"><a class="header" href="#early-ioremap-initialization">Early ioremap initialization</a></h2>
<p>The next step is initialization of early <code>ioremap</code>. In general there are two ways to communicate with devices:</p>
<ul>
<li>I/O Ports;</li>
<li>Device memory.</li>
</ul>
<p>We already saw first method (<code>outb/inb</code> instructions) in the part about Linux kernel booting <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-3">process</a>. The second method is to map I/O physical addresses to virtual addresses. When a physical address is accessed by the CPU, it may refer to a portion of physical RAM which can be mapped on memory of the I/O device. So <code>ioremap</code> used to map device memory into kernel address space.</p>
<p>As I wrote above next function is the <code>early_ioremap_init</code> which re-maps I/O memory to kernel address space so it can access it. We need to initialize early ioremap for early initialization code which needs to temporarily map I/O or memory regions before the normal mapping functions like <code>ioremap</code> are available. Implementation of this function is in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/ioremap.c">arch/x86/mm/ioremap.c</a>. At the start of the <code>early_ioremap_init</code> we can see definition of the <code>pmd</code> pointer with <code>pmd_t</code> type (which presents page middle directory entry <code>typedef struct { pmdval_t pmd; } pmd_t;</code> where <code>pmdval_t</code> is <code>unsigned long</code>) and make a check that <code>fixmap</code> aligned in a correct way:</p>
<pre><code class="language-C">pmd_t *pmd;
BUILD_BUG_ON((fix_to_virt(0) + PAGE_SIZE) &amp; ((1 &lt;&lt; PMD_SHIFT) - 1));
</code></pre>
<p><code>fixmap</code> - is fixed virtual address mappings which extends from <code>FIXADDR_START</code> to <code>FIXADDR_TOP</code>. Fixed virtual addresses are needed for subsystems that need to know the virtual address at compile time. After the check <code>early_ioremap_init</code> makes a call of the <code>early_ioremap_setup</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/early_ioremap.c">mm/early_ioremap.c</a>. <code>early_ioremap_setup</code> fills <code>slot_virt</code> array of the <code>unsigned long</code> with virtual addresses with 512 temporary boot-time fix-mappings:</p>
<pre><code class="language-C">for (i = 0; i &lt; FIX_BTMAPS_SLOTS; i++)
    slot_virt[i] = __fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i);
</code></pre>
<p>After this we get page middle directory entry for the <code>FIX_BTMAP_BEGIN</code> and put to the <code>pmd</code> variable, fills <code>bm_pte</code> with zeros which is boot time page tables and call <code>pmd_populate_kernel</code> function for setting given page table entry in the given page middle directory:</p>
<pre><code class="language-C">pmd = early_ioremap_pmd(fix_to_virt(FIX_BTMAP_BEGIN));
memset(bm_pte, 0, sizeof(bm_pte));
pmd_populate_kernel(&amp;init_mm, pmd, bm_pte);
</code></pre>
<p>That's all for this. If you feeling puzzled, don't worry. There is special part about <code>ioremap</code> and <code>fixmaps</code> in the <a href="https://github.com/0xAX/linux-insides/blob/master/MM/linux-mm-2.md">Linux Kernel Memory Management. Part 2</a> chapter.</p>
<h2 id="obtaining-major-and-minor-numbers-for-the-root-device"><a class="header" href="#obtaining-major-and-minor-numbers-for-the-root-device">Obtaining major and minor numbers for the root device</a></h2>
<p>After early <code>ioremap</code> was initialized, you can see the following code:</p>
<pre><code class="language-C">ROOT_DEV = old_decode_dev(boot_params.hdr.root_dev);
</code></pre>
<p>This code obtains major and minor numbers for the root device where <code>initrd</code> will be mounted later in the <code>do_mount_root</code> function. Major number of the device identifies a driver associated with the device. Minor number referred on the device controlled by driver. Note that <code>old_decode_dev</code> takes one parameter from the <code>boot_params_structure</code>. As we can read from the x86 Linux kernel boot protocol:</p>
<pre><code>Field name:	root_dev
Type:		modify (optional)
Offset/size:	0x1fc/2
Protocol:	ALL

  The default root device device number.  The use of this field is
  deprecated, use the &quot;root=&quot; option on the command line instead.
</code></pre>
<p>Now let's try to understand what <code>old_decode_dev</code> does. Actually it just calls <code>MKDEV</code> inside which generates <code>dev_t</code> from the give major and minor numbers. It's implementation is pretty simple:</p>
<pre><code class="language-C">static inline dev_t old_decode_dev(u16 val)
{
         return MKDEV((val &gt;&gt; 8) &amp; 255, val &amp; 255);
}
</code></pre>
<p>where <code>dev_t</code> is a kernel data type to present major/minor number pair.  But what's the strange <code>old_</code> prefix? For historical reasons, there are two ways of managing the major and minor numbers of a device. In the first way major and minor numbers occupied 2 bytes. You can see it in the previous code: 8 bit for major number and 8 bit for minor number. But there is a problem: only 256 major numbers and 256 minor numbers are possible. So 16-bit integer was replaced by 32-bit integer where 12 bits reserved for major number and 20 bits for minor. You can see this in the <code>new_decode_dev</code> implementation:</p>
<pre><code class="language-C">static inline dev_t new_decode_dev(u32 dev)
{
         unsigned major = (dev &amp; 0xfff00) &gt;&gt; 8;
         unsigned minor = (dev &amp; 0xff) | ((dev &gt;&gt; 12) &amp; 0xfff00);
         return MKDEV(major, minor);
}
</code></pre>
<p>After calculation we will get <code>0xfff</code> or 12 bits for <code>major</code> if it is <code>0xffffffff</code> and <code>0xfffff</code> or 20 bits for <code>minor</code>. So in the end of execution of the <code>old_decode_dev</code> we will get major and minor numbers for the root device in <code>ROOT_DEV</code>.</p>
<h2 id="memory-map-setup"><a class="header" href="#memory-map-setup">Memory map setup</a></h2>
<p>The next point is the setup of the memory map with the call of the <code>setup_memory_map</code> function. But before this we setup different parameters as information about a screen (current row and column, video page and etc... (you can read about it in the <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-3">Video mode initialization and transition to protected mode</a>)), Extended display identification data, video mode, bootloader_type and etc...:</p>
<pre><code class="language-C">	screen_info = boot_params.screen_info;
	edid_info = boot_params.edid_info;
	saved_video_mode = boot_params.hdr.vid_mode;
	bootloader_type = boot_params.hdr.type_of_loader;
	if ((bootloader_type &gt;&gt; 4) == 0xe) {
		bootloader_type &amp;= 0xf;
		bootloader_type |= (boot_params.hdr.ext_loader_type+0x10) &lt;&lt; 4;
	}
	bootloader_version  = bootloader_type &amp; 0xf;
	bootloader_version |= boot_params.hdr.ext_loader_ver &lt;&lt; 4;
</code></pre>
<p>All of these parameters we got during boot time and stored in the <code>boot_params</code> structure. After this we need to setup the end of the I/O memory. As you know one of the main purposes of the kernel is resource management. And one of the resource is memory. As we already know there are two ways to communicate with devices are I/O ports and device memory. All information about registered resources are available through:</p>
<ul>
<li>/proc/ioports - provides a list of currently registered port regions used for input or output communication with a device;</li>
<li>/proc/iomem   - provides current map of the system's memory for each physical device.</li>
</ul>
<p>At the moment we are interested in <code>/proc/iomem</code>:</p>
<pre><code>cat /proc/iomem
00000000-00000fff : reserved
00001000-0009d7ff : System RAM
0009d800-0009ffff : reserved
000a0000-000bffff : PCI Bus 0000:00
000c0000-000cffff : Video ROM
000d0000-000d3fff : PCI Bus 0000:00
000d4000-000d7fff : PCI Bus 0000:00
000d8000-000dbfff : PCI Bus 0000:00
000dc000-000dffff : PCI Bus 0000:00
000e0000-000fffff : reserved
  000e0000-000e3fff : PCI Bus 0000:00
  000e4000-000e7fff : PCI Bus 0000:00
  000f0000-000fffff : System ROM
</code></pre>
<p>As you can see range of addresses are shown in hexadecimal notation with its owner. Linux kernel provides API for managing any resources in a general way. Global resources (for example PICs or I/O ports) can be divided into subsets - relating to any hardware bus slot. The main structure <code>resource</code>:</p>
<pre><code class="language-C">struct resource {
        resource_size_t start;
        resource_size_t end;
        const char *name;
        unsigned long flags;
        struct resource *parent, *sibling, *child;
};
</code></pre>
<p>presents abstraction for a tree-like subset of system resources. This structure provides range of addresses from <code>start</code> to <code>end</code> (<code>resource_size_t</code> is <code>phys_addr_t</code> or <code>u64</code> for <code>x86_64</code>) which a resource covers, <code>name</code> of a resource (you see these names in the <code>/proc/iomem</code> output) and <code>flags</code> of a resource (All resources flags defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/ioport.h">include/linux/ioport.h</a>). The last are three pointers to the <code>resource</code> structure. These pointers enable a tree-like structure:</p>
<pre><code>+-------------+      +-------------+
|             |      |             |
|    parent   |------|    sibling  |
|             |      |             |
+-------------+      +-------------+
       |
       |
+-------------+
|             |
|    child    |
|             |
+-------------+
</code></pre>
<p>Every subset of resources has root range resources. For <code>iomem</code> it is <code>iomem_resource</code> which defined as:</p>
<pre><code class="language-C">struct resource iomem_resource = {
        .name   = &quot;PCI mem&quot;,
        .start  = 0,
        .end    = -1,
        .flags  = IORESOURCE_MEM,
};
EXPORT_SYMBOL(iomem_resource);
</code></pre>
<p>TODO EXPORT_SYMBOL</p>
<p><code>iomem_resource</code> defines root addresses range for io memory with <code>PCI mem</code> name and <code>IORESOURCE_MEM</code> (<code>0x00000200</code>) as flags. As i wrote above our current point is setup the end address of the <code>iomem</code>. We will do it with:</p>
<pre><code class="language-C">iomem_resource.end = (1ULL &lt;&lt; boot_cpu_data.x86_phys_bits) - 1;
</code></pre>
<p>Here we shift <code>1</code> on <code>boot_cpu_data.x86_phys_bits</code>. <code>boot_cpu_data</code> is <code>cpuinfo_x86</code> structure which we filled during execution of the <code>early_cpu_init</code>. As you can understand from the name of the <code>x86_phys_bits</code> field, it presents maximum bits amount of the maximum physical address in the system. Note also that <code>iomem_resource</code> is passed to the <code>EXPORT_SYMBOL</code> macro. This macro exports the given symbol (<code>iomem_resource</code> in our case) for dynamic linking or in other words it makes a symbol accessible to dynamically loaded modules.</p>
<p>After we set the end address of the root <code>iomem</code> resource address range, as I wrote above the next step will be setup of the memory map. It will be produced with the call of the <code>setup_ memory_map</code> function:</p>
<pre><code class="language-C">void __init setup_memory_map(void)
{
        char *who;

        who = x86_init.resources.memory_setup();
        memcpy(&amp;e820_saved, &amp;e820, sizeof(struct e820map));
        printk(KERN_INFO &quot;e820: BIOS-provided physical RAM map:\n&quot;);
        e820_print_map(who);
}
</code></pre>
<p>First of all we call look here the call of the <code>x86_init.resources.memory_setup</code>. <code>x86_init</code> is a <code>x86_init_ops</code> structure which presents platform specific setup functions as resources initialization, pci initialization and etc... initialization of the <code>x86_init</code> is in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/x86_init.c">arch/x86/kernel/x86_init.c</a>. I will not give here the full description because it is very long, but only one part which interests us for now:</p>
<pre><code class="language-C">struct x86_init_ops x86_init __initdata = {
	.resources = {
            .probe_roms             = probe_roms,
            .reserve_resources      = reserve_standard_io_resources,
            .memory_setup           = default_machine_specific_memory_setup,
    },
    ...
    ...
    ...
}
</code></pre>
<p>As we can see here <code>memory_setup</code> field is <code>default_machine_specific_memory_setup</code> where we get the number of the <a href="http://en.wikipedia.org/wiki/E820">e820</a> entries which we collected in the <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-2">boot time</a>, sanitize the BIOS e820 map and fill <code>e820map</code> structure with the memory regions. As all regions are collected, print of all regions with printk. You can find this print if you execute <code>dmesg</code> command and you can see something like this:</p>
<pre><code>[    0.000000] e820: BIOS-provided physical RAM map:
[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009d7ff] usable
[    0.000000] BIOS-e820: [mem 0x000000000009d800-0x000000000009ffff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000000e0000-0x00000000000fffff] reserved
[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x00000000be825fff] usable
[    0.000000] BIOS-e820: [mem 0x00000000be826000-0x00000000be82cfff] ACPI NVS
[    0.000000] BIOS-e820: [mem 0x00000000be82d000-0x00000000bf744fff] usable
[    0.000000] BIOS-e820: [mem 0x00000000bf745000-0x00000000bfff4fff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000bfff5000-0x00000000dc041fff] usable
[    0.000000] BIOS-e820: [mem 0x00000000dc042000-0x00000000dc0d2fff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000dc0d3000-0x00000000dc138fff] usable
[    0.000000] BIOS-e820: [mem 0x00000000dc139000-0x00000000dc27dfff] ACPI NVS
[    0.000000] BIOS-e820: [mem 0x00000000dc27e000-0x00000000deffefff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000defff000-0x00000000deffffff] usable
...
...
...
</code></pre>
<h2 id="copying-of-the-bios-enhanced-disk-device-information"><a class="header" href="#copying-of-the-bios-enhanced-disk-device-information">Copying of the BIOS Enhanced Disk Device information</a></h2>
<p>The next two steps is parsing of the <code>setup_data</code> with <code>parse_setup_data</code> function and copying BIOS EDD to the safe place. <code>setup_data</code> is a field from the kernel boot header and as we can read from the <code>x86</code> boot protocol:</p>
<pre><code>Field name:	setup_data
Type:		write (special)
Offset/size:	0x250/8
Protocol:	2.09+

  The 64-bit physical pointer to NULL terminated single linked list of
  struct setup_data. This is used to define a more extensible boot
  parameters passing mechanism.
</code></pre>
<p>It used for storing setup information for different types as device tree blob, EFI setup data and etc... In the second step we copy BIOS EDD information from the <code>boot_params</code> structure that we collected in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/edd.c">arch/x86/boot/edd.c</a> to the <code>edd</code> structure:</p>
<pre><code class="language-C">static inline void __init copy_edd(void)
{
     memcpy(edd.mbr_signature, boot_params.edd_mbr_sig_buffer,
            sizeof(edd.mbr_signature));
     memcpy(edd.edd_info, boot_params.eddbuf, sizeof(edd.edd_info));
     edd.mbr_signature_nr = boot_params.edd_mbr_sig_buf_entries;
     edd.edd_info_nr = boot_params.eddbuf_entries;
}
</code></pre>
<h2 id="memory-descriptor-initialization"><a class="header" href="#memory-descriptor-initialization">Memory descriptor initialization</a></h2>
<p>The next step is initialization of the memory descriptor of the init process. As you already can know every process has its own address space. This address space presented with special data structure which called <code>memory descriptor</code>. Directly in the Linux kernel source code memory descriptor presented with <code>mm_struct</code> structure. <code>mm_struct</code> contains many different fields related with the process address space as start/end address of the kernel code/data, start/end of the brk, number of memory areas, list of memory areas and etc... This structure defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/mm_types.h">include/linux/mm_types.h</a>. As every process has its own memory descriptor, <code>task_struct</code> structure contains it in the <code>mm</code> and <code>active_mm</code> field. And our first <code>init</code> process has it too. You can remember that we saw the part of initialization of the init <code>task_struct</code> with <code>INIT_TASK</code> macro in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">part</a>:</p>
<pre><code class="language-C">#define INIT_TASK(tsk)  \
{
    ...
	...
	...
	.mm = NULL,         \
    .active_mm  = &amp;init_mm, \
	...
}
</code></pre>
<p><code>mm</code> points to the process address space and <code>active_mm</code> points to the active address space if process has no address space such as kernel threads (more about it you can read in the <a href="https://www.kernel.org/doc/Documentation/vm/active_mm.txt">documentation</a>). Now we fill memory descriptor of the initial process:</p>
<pre><code class="language-C">	init_mm.start_code = (unsigned long) _text;
	init_mm.end_code = (unsigned long) _etext;
	init_mm.end_data = (unsigned long) _edata;
	init_mm.brk = _brk_end;
</code></pre>
<p>with the kernel's text, data and brk. <code>init_mm</code> is the memory descriptor of the initial process and defined as:</p>
<pre><code class="language-C">struct mm_struct init_mm = {
    .mm_rb          = RB_ROOT,
    .pgd            = swapper_pg_dir,
    .mm_users       = ATOMIC_INIT(2),
    .mm_count       = ATOMIC_INIT(1),
    .mmap_sem       = __RWSEM_INITIALIZER(init_mm.mmap_sem),
    .page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),
    .mmlist         = LIST_HEAD_INIT(init_mm.mmlist),
    INIT_MM_CONTEXT(init_mm)
};
</code></pre>
<p>where <code>mm_rb</code> is a red-black tree of the virtual memory areas, <code>pgd</code> is a pointer to the page global directory, <code>mm_users</code> is address space users, <code>mm_count</code> is primary usage counter and <code>mmap_sem</code> is memory area semaphore. After we setup memory descriptor of the initial process, next step is initialization of the Intel Memory Protection Extensions with <code>mpx_mm_init</code>. The next step is initialization of the code/data/bss resources with:</p>
<pre><code class="language-C">	code_resource.start = __pa_symbol(_text);
	code_resource.end = __pa_symbol(_etext)-1;
	data_resource.start = __pa_symbol(_etext);
	data_resource.end = __pa_symbol(_edata)-1;
	bss_resource.start = __pa_symbol(__bss_start);
	bss_resource.end = __pa_symbol(__bss_stop)-1;
</code></pre>
<p>We already know a little about <code>resource</code> structure (read above). Here we fill code/data/bss resources with their physical addresses. You can see it in the <code>/proc/iomem</code>:</p>
<pre><code class="language-C">00100000-be825fff : System RAM
  01000000-015bb392 : Kernel code
  015bb393-01930c3f : Kernel data
  01a11000-01ac3fff : Kernel bss
</code></pre>
<p>All of these structures are defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> and look like typical resource initialization:</p>
<pre><code class="language-C">static struct resource code_resource = {
	.name	= &quot;Kernel code&quot;,
	.start	= 0,
	.end	= 0,
	.flags	= IORESOURCE_BUSY | IORESOURCE_MEM
};
</code></pre>
<p>The last step which we will cover in this part will be <code>NX</code> configuration. <code>NX-bit</code> or no execute bit is 63-bit in the page directory entry which controls the ability to execute code from all physical pages mapped by the table entry. This bit can only be used/set when the <code>no-execute</code> page-protection mechanism is enabled by the setting <code>EFER.NXE</code> to 1. In the <code>x86_configure_nx</code> function we check that CPU has support of <code>NX-bit</code> and it does not disabled. After the check we fill <code>__supported_pte_mask</code> depend on it:</p>
<pre><code class="language-C">void x86_configure_nx(void)
{
        if (cpu_has_nx &amp;&amp; !disable_nx)
                __supported_pte_mask |= _PAGE_NX;
        else
                __supported_pte_mask &amp;= ~_PAGE_NX;
}
</code></pre>
<h2 id="conclusion-10"><a class="header" href="#conclusion-10">Conclusion</a></h2>
<p>It is the end of the fifth part about Linux kernel initialization process. In this part we continued to dive in the <code>setup_arch</code> function which makes initialization of architecture-specific stuff. It was long part, but we are not finished with it. As I already wrote, the <code>setup_arch</code> is big function, and I am really not sure that we will cover all of it even in the next part. There were some new interesting concepts in this part like <code>Fix-mapped</code> addresses, ioremap and etc... Don't worry if they are unclear for you. There is a special part about these concepts - <a href="https://github.com/0xAX/linux-insides/blob/master/MM/linux-mm-2.md">Linux kernel memory management Part 2.</a>. In the next part we will continue with the initialization of the architecture-specific stuff and will see parsing of the early kernel parameters, early dump of the pci devices, <code>Desktop Management Interface</code> scanning and many many more.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-10"><a class="header" href="#links-10">Links</a></h2>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/vm/active_mm.txt">mm vs active_mm</a></li>
<li><a href="http://en.wikipedia.org/wiki/E820">e820</a></li>
<li><a href="https://lwn.net/Articles/517475/">Supervisor mode access prevention</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/x86/x86_64/kernel-stacks">Kernel stacks</a></li>
<li><a href="http://en.wikipedia.org/wiki/Task_state_segment">TSS</a></li>
<li><a href="http://en.wikipedia.org/wiki/Interrupt_descriptor_table">IDT</a></li>
<li><a href="http://en.wikipedia.org/wiki/Memory-mapped_I/O">Memory mapped I/O</a></li>
<li><a href="https://sourceware.org/binutils/docs/as/CFI-directives.html">CFI directives</a></li>
<li><a href="http://dwarfstd.org/doc/DWARF4.pdf">PDF. dwarf4 specification</a></li>
<li><a href="http://en.wikipedia.org/wiki/Call_stack">Call stack</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-initialization-part-6"><a class="header" href="#kernel-initialization-part-6">Kernel initialization. Part 6.</a></h1>
<h1 id="architecture-specific-initialization-again"><a class="header" href="#architecture-specific-initialization-again">Architecture-specific initialization, again...</a></h1>
<p>In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">part</a> we saw architecture-specific (<code>x86_64</code> in our case) initialization stuff from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> and finished on <code>x86_configure_nx</code> function which sets the <code>_PAGE_NX</code> flag depends on support of <a href="http://en.wikipedia.org/wiki/NX_bit">NX bit</a>. As I wrote before <code>setup_arch</code> function and <code>start_kernel</code> are very big, so in this and in the next part we will continue to learn about architecture-specific initialization process. The next function after <code>x86_configure_nx</code> is <code>parse_early_param</code>. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> and as you can understand from its name, this function parses kernel command line and setups different services depends on the given parameters (all kernel command line parameters you can find are in the <a href="https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.rst">Documentation/kernel-parameters.txt</a>). You may remember how we setup <code>earlyprintk</code> in the earliest <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-2">part</a>. On the early stage we looked for kernel parameters and their value with the <code>cmdline_find_option</code> function and <code>__cmdline_find_option</code>, <code>__cmdline_find_option_bool</code> helpers from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/cmdline.c">arch/x86/boot/cmdline.c</a>. There we're in the generic kernel part which does not depend on architecture and here we use another approach. If you are reading Linux kernel source code, you already note calls like this:</p>
<pre><code class="language-C">early_param(&quot;gbpages&quot;, parse_direct_gbpages_on);
</code></pre>
<p><code>early_param</code> macro takes two parameters:</p>
<ul>
<li>command line parameter name;</li>
<li>function which will be called if given parameter is passed.</li>
</ul>
<p>and defined as:</p>
<pre><code class="language-C">#define early_param(str, fn) \
        __setup_param(str, fn, fn, 1)
</code></pre>
<p>in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init.h">include/linux/init.h</a>. As you can see <code>early_param</code> macro just makes call of the <code>__setup_param</code> macro:</p>
<pre><code class="language-C">#define __setup_param(str, unique_id, fn, early)                \
        static const char __setup_str_##unique_id[] __initconst \
                __aligned(1) = str; \
        static struct obs_kernel_param __setup_##unique_id      \
                __used __section(.init.setup)                   \
                __attribute__((aligned((sizeof(long)))))        \
                = { __setup_str_##unique_id, fn, early }
</code></pre>
<p>This macro defines <code>__setup_str_*_id</code> variable (where <code>*</code> depends on given function name) and assigns it to the given command line parameter name. In the next line we can see definition of the <code>__setup_*</code> variable which type is <code>obs_kernel_param</code> and its initialization. <code>obs_kernel_param</code> structure defined as:</p>
<pre><code class="language-C">struct obs_kernel_param {
        const char *str;
        int (*setup_func)(char *);
        int early;
};
</code></pre>
<p>and contains three fields:</p>
<ul>
<li>name of the kernel parameter;</li>
<li>function which setups something depend on parameter;</li>
<li>field determines is parameter early (1) or not (0).</li>
</ul>
<p>Note that <code>__set_param</code> macro defines with <code>__section(.init.setup)</code> attribute. It means that all <code>__setup_str_*</code> will be placed in the <code>.init.setup</code> section, moreover, as we can see in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/asm-generic/vmlinux.lds.h">include/asm-generic/vmlinux.lds.h</a>, they will be placed between <code>__setup_start</code> and <code>__setup_end</code>:</p>
<pre><code>#define INIT_SETUP(initsetup_align)                \
                . = ALIGN(initsetup_align);        \
                VMLINUX_SYMBOL(__setup_start) = .; \
                *(.init.setup)                     \
                VMLINUX_SYMBOL(__setup_end) = .;
</code></pre>
<p>Now we know how parameters are defined, let's back to the <code>parse_early_param</code> implementation:</p>
<pre><code class="language-C">void __init parse_early_param(void)
{
        static int done __initdata;
        static char tmp_cmdline[COMMAND_LINE_SIZE] __initdata;

        if (done)
                return;

        /* All fall through to do_early_param. */
        strlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);
        parse_early_options(tmp_cmdline);
        done = 1;
}
</code></pre>
<p>The <code>parse_early_param</code> function defines two static variables. First <code>done</code> check that <code>parse_early_param</code> already called and the second is temporary storage for kernel command line. After this we copy <code>boot_command_line</code> to the temporary command line which we just defined and call the <code>parse_early_options</code> function from the same source code <code>main.c</code> file. <code>parse_early_options</code> calls the <code>parse_args</code> function from the <a href="https://github.com/torvalds/linux">kernel/params.c</a> where <code>parse_args</code> parses given command line and calls <code>do_early_param</code> function. This <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c#L413">function</a> goes from the <code> __setup_start</code> to <code>__setup_end</code>, and calls the function from the <code>obs_kernel_param</code> if a parameter is early. After this all services which are depend on early command line parameters were setup and the next call after the <code>parse_early_param</code> is <code>x86_report_nx</code>. As I wrote in the beginning of this part, we already set <code>NX-bit</code> with the <code>x86_configure_nx</code>. The next <code>x86_report_nx</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/setup_nx.c">arch/x86/mm/setup_nx.c</a> just prints information about the <code>NX</code>. Note that we call <code>x86_report_nx</code> not right after the <code>x86_configure_nx</code>, but after the call of the <code>parse_early_param</code>. The answer is simple: we call it after the <code>parse_early_param</code> because the kernel support <code>noexec</code> parameter:</p>
<pre><code>noexec		[X86]
			On X86-32 available only on PAE configured kernels.
			noexec=on: enable non-executable mappings (default)
			noexec=off: disable non-executable mappings
</code></pre>
<p>We can see it in the booting time:</p>
<p><img src="Initialization/images/NX.png" alt="NX" /></p>
<p>After this we can see call of the:</p>
<pre><code class="language-C">	memblock_x86_reserve_range_setup_data();
</code></pre>
<p>function. This function is defined in the same <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> source code file and remaps memory for the <code>setup_data</code> and reserved memory block for the <code>setup_data</code> (more about <code>setup_data</code> you can read in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">part</a> and about <code>ioremap</code> and <code>memblock</code> you can read in the <a href="https://0xax.gitbook.io/linux-insides/summary/mm">Linux kernel memory management</a>).</p>
<p>In the next step we can see following conditional statement:</p>
<pre><code class="language-C">	if (acpi_mps_check()) {
#ifdef CONFIG_X86_LOCAL_APIC
		disable_apic = 1;
#endif
		setup_clear_cpu_cap(X86_FEATURE_APIC);
	}
</code></pre>
<p>The first <code>acpi_mps_check</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/acpi/boot.c">arch/x86/kernel/acpi/boot.c</a> depends on <code>CONFIG_X86_LOCAL_APIC</code> and <code>CONFIG_x86_MPPARSE</code> configuration options:</p>
<pre><code class="language-C">int __init acpi_mps_check(void)
{
#if defined(CONFIG_X86_LOCAL_APIC) &amp;&amp; !defined(CONFIG_X86_MPPARSE)
        /* mptable code is not built-in*/
        if (acpi_disabled || acpi_noirq) {
                printk(KERN_WARNING &quot;MPS support code is not built-in.\n&quot;
                       &quot;Using acpi=off or acpi=noirq or pci=noacpi &quot;
                       &quot;may have problem\n&quot;);
                 return 1;
        }
#endif
        return 0;
}
</code></pre>
<p>It checks the built-in <code>MPS</code> or <a href="http://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Specification</a> table. If <code>CONFIG_X86_LOCAL_APIC</code> is set and <code>CONFIG_x86_MPPARSE</code> is not set, <code>acpi_mps_check</code> prints warning message if the one of the command line options: <code>acpi=off</code>, <code>acpi=noirq</code> or <code>pci=noacpi</code> passed to the kernel. If <code>acpi_mps_check</code> returns <code>1</code> it means that we disable local <a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a> and clear <code>X86_FEATURE_APIC</code> bit in the of the current CPU with the <code>setup_clear_cpu_cap</code> macro. (more about CPU mask you can read in the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">CPU masks</a>).</p>
<h2 id="early-pci-dump"><a class="header" href="#early-pci-dump">Early PCI dump</a></h2>
<p>In the next step we make a dump of the <a href="http://en.wikipedia.org/wiki/Conventional_PCI">PCI</a> devices with the following code:</p>
<pre><code class="language-C">#ifdef CONFIG_PCI
	if (pci_early_dump_regs)
		early_dump_pci_devices();
#endif
</code></pre>
<p><code>pci_early_dump_regs</code> variable defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/pci/common.c">arch/x86/pci/common.c</a> and its value depends on the kernel command line parameter: <code>pci=earlydump</code>. We can find definition of this parameter in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch">drivers/pci/pci.c</a>:</p>
<pre><code class="language-C">early_param(&quot;pci&quot;, pci_setup);
</code></pre>
<p><code>pci_setup</code> function gets the string after the <code>pci=</code> and analyzes it. This function calls <code>pcibios_setup</code> which defined as <code>__weak</code> in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch">drivers/pci/pci.c</a> and every architecture defines the same function which overrides <code>__weak</code> analog. For example <code>x86_64</code> architecture-dependent version is in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/pci/common.c">arch/x86/pci/common.c</a>:</p>
<pre><code class="language-C">char *__init pcibios_setup(char *str) {
        ...
		...
		...
		} else if (!strcmp(str, &quot;earlydump&quot;)) {
                pci_early_dump_regs = 1;
                return NULL;
        }
		...
		...
		...
}
</code></pre>
<p>So, if <code>CONFIG_PCI</code> option is set and we passed <code>pci=earlydump</code> option to the kernel command line, next function which will be called - <code>early_dump_pci_devices</code> from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/pci/early.c">arch/x86/pci/early.c</a>. This function checks <code>noearly</code> PCI parameter with:</p>
<pre><code class="language-C">if (!early_pci_allowed())
        return;
</code></pre>
<p>and returns if it was passed. Each PCI domain can host up to <code>256</code> buses and each bus hosts up to 32 devices. So, we goes in a loop:</p>
<pre><code class="language-C">for (bus = 0; bus &lt; 256; bus++) {
                for (slot = 0; slot &lt; 32; slot++) {
                        for (func = 0; func &lt; 8; func++) {
						...
						...
						...
                        }
                }
}
</code></pre>
<p>and read the <code>pci</code> config with the <code>read_pci_config</code> function.</p>
<p>That's all. We will not go deep in the <code>pci</code> details, but will see more details in the special <code>Drivers/PCI</code> part.</p>
<h2 id="finish-with-memory-parsing"><a class="header" href="#finish-with-memory-parsing">Finish with memory parsing</a></h2>
<p>After the <code>early_dump_pci_devices</code>, there are a couple of function related with available memory and <a href="http://en.wikipedia.org/wiki/E820">e820</a> which we collected in the <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-2">First steps in the kernel setup</a> part:</p>
<pre><code class="language-C">	/* update the e820_saved too */
	e820_reserve_setup_data();
	finish_e820_parsing();
	...
	...
	...
	e820_add_kernel_range();
	trim_bios_range(void);
	max_pfn = e820_end_of_ram_pfn();
	early_reserve_e820_mpc_new();
</code></pre>
<p>Let's look at it. As you can see the first function is <code>e820_reserve_setup_data</code>. This function does almost the same as <code>memblock_x86_reserve_range_setup_data</code> which we saw above, but it also calls <code>e820_update_range</code> which adds new regions to the <code>e820map</code> with the given type which is <code>E820_RESERVED_KERN</code> in our case. The next function is <code>finish_e820_parsing</code> which sanitizes <code>e820map</code> with the <code>sanitize_e820_map</code> function. Besides this two functions we can see a couple of functions related to the <a href="http://en.wikipedia.org/wiki/E820">e820</a>. You can see it in the listing above. <code>e820_add_kernel_range</code> function takes the physical address of the kernel start and end:</p>
<pre><code class="language-C">u64 start = __pa_symbol(_text);
u64 size = __pa_symbol(_end) - start;
</code></pre>
<p>checks that <code>.text</code> <code>.data</code> and <code>.bss</code> marked as <code>E820RAM</code> in the <code>e820map</code> and prints the warning message if not. The next function <code>trm_bios_range</code> update first 4096 bytes in <code>e820Map</code> as <code>E820_RESERVED</code> and sanitizes it again with the call of the <code>sanitize_e820_map</code>. After this we get the last page frame number with the call of the <code>e820_end_of_ram_pfn</code> function. Every memory page has a unique number - <code>Page frame number</code>  and <code>e820_end_of_ram_pfn</code> function returns the maximum with the call of the <code>e820_end_pfn</code>:</p>
<pre><code class="language-C">unsigned long __init e820_end_of_ram_pfn(void)
{
	return e820_end_pfn(MAX_ARCH_PFN);
}
</code></pre>
<p>where <code>e820_end_pfn</code> takes maximum page frame number on the certain architecture (<code>MAX_ARCH_PFN</code> is <code>0x400000000</code> for <code>x86_64</code>). In the <code>e820_end_pfn</code> we go through the all <code>e820</code> slots and check that <code>e820</code> entry has <code>E820_RAM</code> or <code>E820_PRAM</code> type because we calculate page frame numbers only for these types, gets the base address and end address of the page frame number for the current <code>e820</code> entry and makes some checks for these addresses:</p>
<pre><code class="language-C">for (i = 0; i &lt; e820.nr_map; i++) {
		struct e820entry *ei = &amp;e820.map[i];
		unsigned long start_pfn;
		unsigned long end_pfn;

		if (ei-&gt;type != E820_RAM &amp;&amp; ei-&gt;type != E820_PRAM)
			continue;

		start_pfn = ei-&gt;addr &gt;&gt; PAGE_SHIFT;
		end_pfn = (ei-&gt;addr + ei-&gt;size) &gt;&gt; PAGE_SHIFT;

        if (start_pfn &gt;= limit_pfn)
			continue;
		if (end_pfn &gt; limit_pfn) {
			last_pfn = limit_pfn;
			break;
		}
		if (end_pfn &gt; last_pfn)
			last_pfn = end_pfn;
}
</code></pre>
<pre><code class="language-C">	if (last_pfn &gt; max_arch_pfn)
		last_pfn = max_arch_pfn;

	printk(KERN_INFO &quot;e820: last_pfn = %#lx max_arch_pfn = %#lx\n&quot;,
			 last_pfn, max_arch_pfn);
	return last_pfn;
</code></pre>
<p>After this we check that <code>last_pfn</code> which we got in the loop is not greater that maximum page frame number for the certain architecture (<code>x86_64</code> in our case), print information about last page frame number and return it. We can see the <code>last_pfn</code> in the <code>dmesg</code> output:</p>
<pre><code>...
[    0.000000] e820: last_pfn = 0x41f000 max_arch_pfn = 0x400000000
...
</code></pre>
<p>After this, as we have calculated the biggest page frame number, we calculate <code>max_low_pfn</code> which is the biggest page frame number in the <code>low memory</code> or below first <code>4</code> gigabytes. If installed more than 4 gigabytes of RAM, <code>max_low_pfn</code> will be result of the <code>e820_end_of_low_ram_pfn</code> function which does the same <code>e820_end_of_ram_pfn</code> but with 4 gigabytes limit, in other way <code>max_low_pfn</code> will be the same as <code>max_pfn</code>:</p>
<pre><code class="language-C">if (max_pfn &gt; (1UL&lt;&lt;(32 - PAGE_SHIFT)))
	max_low_pfn = e820_end_of_low_ram_pfn();
else
	max_low_pfn = max_pfn;

high_memory = (void *)__va(max_pfn * PAGE_SIZE - 1) + 1;
</code></pre>
<p>Next we calculate <code>high_memory</code> (defines the upper bound on direct map memory) with <code>__va</code> macro which returns a virtual address by the given physical memory.</p>
<h2 id="dmi-scanning"><a class="header" href="#dmi-scanning">DMI scanning</a></h2>
<p>The next step after manipulations with different memory regions and <code>e820</code> slots is collecting information about computer. We will get all information with the <a href="http://en.wikipedia.org/wiki/Desktop_Management_Interface">Desktop Management Interface</a> and following functions:</p>
<pre><code class="language-C">dmi_scan_machine();
dmi_memdev_walk();
</code></pre>
<p>First is <code>dmi_scan_machine</code> defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/drivers/firmware/dmi_scan.c">drivers/firmware/dmi_scan.c</a>. This function goes through the <a href="http://en.wikipedia.org/wiki/System_Management_BIOS">System Management BIOS</a> structures and extracts information. There are two ways specified to gain access to the <code>SMBIOS</code> table: get the pointer to the <code>SMBIOS</code> table from the <a href="http://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">EFI</a>'s configuration table and scanning the physical memory between <code>0xF0000</code> and <code>0xFFFFF</code> addresses, <code>0x10000</code> bytes totally. Let's look on the second approach. <code>dmi_scan_machine</code> function remaps memory addresses start from <code>0xF0000</code> to <code>0xFFFFF</code> with size of <code>0x10000</code> bytes with the <code>dmi_early_remap</code> which just expands to the <code>early_ioremap</code>:</p>
<pre><code class="language-C">void __init dmi_scan_machine(void)
{
	char __iomem *p, *q;
	char buf[32];
	...
	...
	...
	p = dmi_early_remap(0xF0000, 0x10000);
	if (p == NULL)
			goto error;
</code></pre>
<p>and iterates over all <code>DMI</code> header address and find search <code>_SM_</code> string:</p>
<pre><code class="language-C">memset(buf, 0, 16);
for (q = p; q &lt; p + 0x10000; q += 16) {
		memcpy_fromio(buf + 16, q, 16);
		if (!dmi_smbios3_present(buf) || !dmi_present(buf)) {
			dmi_available = 1;
			dmi_early_unmap(p, 0x10000);
			goto out;
		}
		memcpy(buf, buf + 16, 16);
}
</code></pre>
<p><code>_SM_</code> string must be between <code>000F0000h</code> and <code>0x000FFFFF</code>. Here we copy 16 bytes to the <code>buf</code> with <code>memcpy_fromio</code> which is the same <code>memcpy</code> and execute <code>dmi_smbios3_present</code> and <code>dmi_present</code> on the buffer. These functions check that first 4 bytes is <code>_SM_</code> string, get <code>SMBIOS</code> version and gets <code>_DMI_</code> attributes as <code>DMI</code> structure table length, table address and etc... After one of these functions finish, you will see the result of it in the <code>dmesg</code> output:</p>
<pre><code>[    0.000000] SMBIOS 2.7 present.
[    0.000000] DMI: Gigabyte Technology Co., Ltd. Z97X-UD5H-BK/Z97X-UD5H-BK, BIOS F6 06/17/2014
</code></pre>
<p>In the end of the <code>dmi_scan_machine</code>, we unmap the previously remapped memory:</p>
<pre><code class="language-C">dmi_early_unmap(p, 0x10000);
</code></pre>
<p>The second function is - <code>dmi_memdev_walk</code>. As you can understand it goes over memory devices. Let's look on it:</p>
<pre><code class="language-C">void __init dmi_memdev_walk(void)
{
	if (!dmi_available)
		return;

	if (dmi_walk_early(count_mem_devices) == 0 &amp;&amp; dmi_memdev_nr) {
		dmi_memdev = dmi_alloc(sizeof(*dmi_memdev) * dmi_memdev_nr);
		if (dmi_memdev)
			dmi_walk_early(save_mem_devices);
	}
}
</code></pre>
<p>It checks that <code>DMI</code> available (we got it in the previous function - <code>dmi_scan_machine</code>) and collects information about memory devices with <code>dmi_walk_early</code> and <code>dmi_alloc</code> which defined as:</p>
<pre><code>#ifdef CONFIG_DMI
RESERVE_BRK(dmi_alloc, 65536);
#endif
</code></pre>
<p><code>RESERVE_BRK</code> defined in the <a href="http://github.com/torvalds/linux/blob/master/arch/x86/include/asm/setup.h">arch/x86/include/asm/setup.h</a> and reserves space with given size in the <code>brk</code> section.</p>
<hr />
<pre><code>init_hypervisor_platform();
x86_init.resources.probe_roms();
insert_resource(&amp;iomem_resource, &amp;code_resource);
insert_resource(&amp;iomem_resource, &amp;data_resource);
insert_resource(&amp;iomem_resource, &amp;bss_resource);
early_gart_iommu_check();
</code></pre>
<h2 id="smp-config"><a class="header" href="#smp-config">SMP config</a></h2>
<p>The next step is parsing of the <a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a> configuration. We do it with the call of the <code>find_smp_config</code> function which just calls function:</p>
<pre><code class="language-C">static inline void find_smp_config(void)
{
        x86_init.mpparse.find_smp_config();
}
</code></pre>
<p>inside. <code>x86_init.mpparse.find_smp_config</code> is the <code>default_find_smp_config</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/mpparse.c">arch/x86/kernel/mpparse.c</a>. In the <code>default_find_smp_config</code> function we are scanning a couple of memory regions for <code>SMP</code> config and return if they are found:</p>
<pre><code class="language-C">if (smp_scan_config(0x0, 0x400) ||
            smp_scan_config(639 * 0x400, 0x400) ||
            smp_scan_config(0xF0000, 0x10000))
            return;
</code></pre>
<p>First of all <code>smp_scan_config</code> function defines a couple of variables:</p>
<pre><code class="language-C">unsigned int *bp = phys_to_virt(base);
struct mpf_intel *mpf;
</code></pre>
<p>First is virtual address of the memory region where we will scan <code>SMP</code> config, second is the pointer to the <code>mpf_intel</code> structure. Let's try to understand what is it <code>mpf_intel</code>. All information stores in the multiprocessor configuration data structure. <code>mpf_intel</code> presents this structure and looks:</p>
<pre><code class="language-C">struct mpf_intel {
        char signature[4];
        unsigned int physptr;
        unsigned char length;
        unsigned char specification;
        unsigned char checksum;
        unsigned char feature1;
        unsigned char feature2;
        unsigned char feature3;
        unsigned char feature4;
        unsigned char feature5;
};
</code></pre>
<p>As we can read in the documentation - one of the main functions of the system BIOS is to construct the MP floating pointer structure and the MP configuration table. And operating system must have access to this information about the multiprocessor configuration and <code>mpf_intel</code> stores the physical address (look at second parameter) of the multiprocessor configuration table. So, <code>smp_scan_config</code> going in a loop through the given memory range and tries to find <code>MP floating pointer structure</code> there. It checks that current byte points to the <code>SMP</code> signature, checks checksum, checks if <code>mpf-&gt;specification</code> is 1 or 4(it must be <code>1</code> or <code>4</code> by specification) in the loop:</p>
<pre><code class="language-C">while (length &gt; 0) {
if ((*bp == SMP_MAGIC_IDENT) &amp;&amp;
    (mpf-&gt;length == 1) &amp;&amp;
    !mpf_checksum((unsigned char *)bp, 16) &amp;&amp;
    ((mpf-&gt;specification == 1)
    || (mpf-&gt;specification == 4))) {

        mem = virt_to_phys(mpf);
        memblock_reserve(mem, sizeof(*mpf));
        if (mpf-&gt;physptr)
            smp_reserve_memory(mpf);
	}
}
</code></pre>
<p>reserves given memory block if search is successful with <code>memblock_reserve</code> and reserves physical address of the multiprocessor configuration table. You can find documentation about this in the - <a href="http://www.intel.com/design/pentium/datashts/24201606.pdf">MultiProcessor Specification</a>. You can read More details in the special part about <code>SMP</code>.</p>
<h2 id="additional-early-memory-initialization-routines"><a class="header" href="#additional-early-memory-initialization-routines">Additional early memory initialization routines</a></h2>
<p>In the next step of the <code>setup_arch</code> we can see the call of the <code>early_alloc_pgt_buf</code> function which allocates the page table buffer for early stage. The page table buffer will be placed in the <code>brk</code> area. Let's look on its implementation:</p>
<pre><code class="language-C">void  __init early_alloc_pgt_buf(void)
{
        unsigned long tables = INIT_PGT_BUF_SIZE;
        phys_addr_t base;

        base = __pa(extend_brk(tables, PAGE_SIZE));

        pgt_buf_start = base &gt;&gt; PAGE_SHIFT;
        pgt_buf_end = pgt_buf_start;
        pgt_buf_top = pgt_buf_start + (tables &gt;&gt; PAGE_SHIFT);
}
</code></pre>
<p>First of all it get the size of the page table buffer, it will be <code>INIT_PGT_BUF_SIZE</code> which is <code>(6 * PAGE_SIZE)</code> in the current Linux kernel 4.0. As we got the size of the page table buffer, we call <code>extend_brk</code> function with two parameters: size and align. As you can understand from its name, this function extends the <code>brk</code> area. As we can see in the linux kernel linker script <code>brk</code> is in memory right after the <a href="http://en.wikipedia.org/wiki/.bss">BSS</a>:</p>
<pre><code class="language-C">	. = ALIGN(PAGE_SIZE);
	.brk : AT(ADDR(.brk) - LOAD_OFFSET) {
		__brk_base = .;
		. += 64 * 1024;		/* 64k alignment slop space */
		*(.brk_reservation)	/* areas brk users have reserved */
		__brk_limit = .;
	}
</code></pre>
<p>Or we can find it with <code>readelf</code> util:</p>
<p><img src="Initialization/images/brk_area.png" alt="brk area" /></p>
<p>After that we got physical address of the new <code>brk</code> with the <code>__pa</code> macro, we calculate the base address and the end of the page table buffer. In the next step as we got page table buffer, we reserve memory block for the brk area with the <code>reserve_brk</code> function:</p>
<pre><code class="language-C">static void __init reserve_brk(void)
{
	if (_brk_end &gt; _brk_start)
		memblock_reserve(__pa_symbol(_brk_start),
				 _brk_end - _brk_start);

	_brk_start = 0;
}
</code></pre>
<p>Note that in the end of the <code>reserve_brk</code>, we set <code>brk_start</code> to zero, because after this we will not allocate it anymore. The next step after reserving memory block for the <code>brk</code>, we need to unmap out-of-range memory areas in the kernel mapping with the <code>cleanup_highmap</code> function. Remember that kernel mapping is <code>__START_KERNEL_map</code> and <code>_end - _text</code> or <code>level2_kernel_pgt</code> maps the kernel <code>_text</code>, <code>data</code> and <code>bss</code>. In the start of the <code>clean_high_map</code> we define these parameters:</p>
<pre><code class="language-C">unsigned long vaddr = __START_KERNEL_map;
unsigned long end = roundup((unsigned long)_end, PMD_SIZE) - 1;
pmd_t *pmd = level2_kernel_pgt;
pmd_t *last_pmd = pmd + PTRS_PER_PMD;
</code></pre>
<p>Now, as we defined start and end of the kernel mapping, we go in the loop through the all kernel page middle directory entries and clean entries which are not between <code>_text</code> and <code>end</code>:</p>
<pre><code class="language-C">for (; pmd &lt; last_pmd; pmd++, vaddr += PMD_SIZE) {
        if (pmd_none(*pmd))
            continue;
        if (vaddr &lt; (unsigned long) _text || vaddr &gt; end)
            set_pmd(pmd, __pmd(0));
}
</code></pre>
<p>After this we set the limit for the <code>memblock</code> allocation with the <code>memblock_set_current_limit</code> function (read more about <code>memblock</code> you can in the <a href="https://github.com/0xAX/linux-insides/blob/master/MM/linux-mm-2.md">Linux kernel memory management Part 2</a>), it will be <code>ISA_END_ADDRESS</code> or <code>0x100000</code> and fill the <code>memblock</code> information according to <code>e820</code> with the call of the <code>memblock_x86_fill</code> function. You can see the result of this function in the kernel initialization time:</p>
<pre><code>MEMBLOCK configuration:
 memory size = 0x1fff7ec00 reserved size = 0x1e30000
 memory.cnt  = 0x3
 memory[0x0]	[0x00000000001000-0x0000000009efff], 0x9e000 bytes flags: 0x0
 memory[0x1]	[0x00000000100000-0x000000bffdffff], 0xbfee0000 bytes flags: 0x0
 memory[0x2]	[0x00000100000000-0x0000023fffffff], 0x140000000 bytes flags: 0x0
 reserved.cnt  = 0x3
 reserved[0x0]	[0x0000000009f000-0x000000000fffff], 0x61000 bytes flags: 0x0
 reserved[0x1]	[0x00000001000000-0x00000001a57fff], 0xa58000 bytes flags: 0x0
 reserved[0x2]	[0x0000007ec89000-0x0000007fffffff], 0x1377000 bytes flags: 0x0
</code></pre>
<p>The rest functions after the <code>memblock_x86_fill</code> are: <code>early_reserve_e820_mpc_new</code> allocates additional slots in the <code>e820map</code> for MultiProcessor Specification table, <code>reserve_real_mode</code> - reserves low memory from <code>0x0</code> to 1 megabyte for the trampoline to the real mode (for rebooting, etc.), <code>trim_platform_memory_ranges</code> - trims certain memory regions started from <code>0x20050000</code>, <code>0x20110000</code>, etc. these regions must be excluded because <a href="http://en.wikipedia.org/wiki/Sandy_Bridge">Sandy Bridge</a> has problems with these regions, <code>trim_low_memory_range</code> reserves the first 4 kilobyte page in <code>memblock</code>, <code>init_mem_mapping</code> function reconstructs direct memory mapping and setups the direct mapping of the physical memory at <code>PAGE_OFFSET</code>, <code>early_trap_pf_init</code> setups <code>#PF</code> handler (we will look on it in the chapter about interrupts) and <code>setup_real_mode</code> function setups trampoline to the <a href="http://en.wikipedia.org/wiki/Real_mode">real mode</a> code.</p>
<p>That's all. You can note that this part will not cover all functions which are in the <code>setup_arch</code> (like <code>early_gart_iommu_check</code>, <a href="http://en.wikipedia.org/wiki/Memory_type_range_register">mtrr</a> initialization, etc.). As I already wrote many times, <code>setup_arch</code> is big, and Linux kernel is big. That's why I can't cover every line in the linux kernel. I don't think that we missed something important, but you can say something like: each line of code is important. Yes, it's true, but I missed them anyway, because I think that it is not realistic to cover full linux kernel. Anyway we will often return to the idea that we have already seen, and if something is unfamiliar, we will cover this theme.</p>
<h2 id="conclusion-11"><a class="header" href="#conclusion-11">Conclusion</a></h2>
<p>It is the end of the sixth part about Linux kernel initialization process. In this part we continued to dive in the <code>setup_arch</code> function again and it was long part, but we are not finished with it. Yes, <code>setup_arch</code> is big, hope that next part will be the last part about this function.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-11"><a class="header" href="#links-11">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Specification</a></li>
<li><a href="http://en.wikipedia.org/wiki/NX_bit">NX bit</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.rst">Documentation/kernel-parameters.txt</a></li>
<li><a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">CPU masks</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm">Linux kernel memory management</a></li>
<li><a href="http://en.wikipedia.org/wiki/Conventional_PCI">PCI</a></li>
<li><a href="http://en.wikipedia.org/wiki/E820">e820</a></li>
<li><a href="http://en.wikipedia.org/wiki/System_Management_BIOS">System Management BIOS</a></li>
<li><a href="http://en.wikipedia.org/wiki/System_Management_BIOS">System Management BIOS</a></li>
<li><a href="http://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">EFI</a></li>
<li><a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a></li>
<li><a href="http://www.intel.com/design/pentium/datashts/24201606.pdf">MultiProcessor Specification</a></li>
<li><a href="http://en.wikipedia.org/wiki/.bss">BSS</a></li>
<li><a href="http://www.dmtf.org/sites/default/files/standards/documents/DSP0134v2.5Final.pdf">SMBIOS specification</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-initialization-part-7"><a class="header" href="#kernel-initialization-part-7">Kernel initialization. Part 7.</a></h1>
<h1 id="the-end-of-the-architecture-specific-initialization-almost"><a class="header" href="#the-end-of-the-architecture-specific-initialization-almost">The End of the architecture-specific initialization, almost...</a></h1>
<p>This is the seventh part of the Linux Kernel initialization process which covers insides of the <code>setup_arch</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/setup.c#L861">arch/x86/kernel/setup.c</a>. As you can know from the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">parts</a>, the <code>setup_arch</code> function does some architecture-specific (in our case it is <a href="http://en.wikipedia.org/wiki/X86-64">x86_64</a>) initialization stuff like reserving memory for kernel code/data/bss, early scanning of the <a href="http://en.wikipedia.org/wiki/Desktop_Management_Interface">Desktop Management Interface</a>, early dump of the <a href="http://en.wikipedia.org/wiki/PCI">PCI</a> device and many many more. If you have read the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-6">part</a>, you can remember that we've finished it at the <code>setup_real_mode</code> function. In the next step, as we set limit of the <a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-1">memblock</a> to the all mapped pages, we can see the call of the <code>setup_log_buf</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/printk/printk.c">kernel/printk/printk.c</a>.</p>
<p>The <code>setup_log_buf</code> function setups kernel cyclic buffer and its length depends on the <code>CONFIG_LOG_BUF_SHIFT</code> configuration option. As we can read from the documentation of the <code>CONFIG_LOG_BUF_SHIFT</code> it can be between <code>12</code> and <code>21</code>. In the insides, buffer defined as array of chars:</p>
<pre><code class="language-C">#define __LOG_BUF_LEN (1 &lt;&lt; CONFIG_LOG_BUF_SHIFT)
static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
static char *log_buf = __log_buf;
</code></pre>
<p>Now let's look on the implementation of the <code>setup_log_buf</code> function. It starts with check that current buffer is empty (It must be empty, because we just setup it) and another check that it is early setup. If setup of the kernel log buffer is not early, we call the <code>log_buf_add_cpu</code> function which increase size of the buffer for every CPU:</p>
<pre><code class="language-C">if (log_buf != __log_buf)
    return;

if (!early &amp;&amp; !new_log_buf_len)
    log_buf_add_cpu();
</code></pre>
<p>We will not research <code>log_buf_add_cpu</code> function, because as you can see in the <code>setup_arch</code>, we call <code>setup_log_buf</code> as:</p>
<pre><code class="language-C">setup_log_buf(1);
</code></pre>
<p>where <code>1</code> means that it is early setup. In the next step we check <code>new_log_buf_len</code> variable which is updated length of the kernel log buffer and allocate new space for the buffer with the <code>memblock_virt_alloc</code> function for it, or just return.</p>
<p>As kernel log buffer is ready, the next function is <code>reserve_initrd</code>. You can remember that we already called the <code>early_reserve_initrd</code> function in the fourth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">Kernel initialization</a>. Now, as we reconstructed direct memory mapping in the <code>init_mem_mapping</code> function, we need to move <a href="http://en.wikipedia.org/wiki/Initrd">initrd</a> into directly mapped memory. The <code>reserve_initrd</code> function starts from the definition of the base address and end address of the <code>initrd</code> and check that <code>initrd</code> is provided by a bootloader. All the same as what we saw in the <code>early_reserve_initrd</code>. But instead of the reserving place in the <code>memblock</code> area with the call of the <code>memblock_reserve</code> function, we get the mapped size of the direct memory area and check that the size of the <code>initrd</code> is not greater than this area with:</p>
<pre><code class="language-C">mapped_size = memblock_mem_size(max_pfn_mapped);
if (ramdisk_size &gt;= (mapped_size&gt;&gt;1))
    panic(&quot;initrd too large to handle, &quot;
	      &quot;disabling initrd (%lld needed, %lld available)\n&quot;,
	      ramdisk_size, mapped_size&gt;&gt;1);
</code></pre>
<p>You can see here that we call <code>memblock_mem_size</code> function and pass the <code>max_pfn_mapped</code> to it, where <code>max_pfn_mapped</code> contains the highest direct mapped page frame number. If you do not remember what is <code>page frame number</code>, explanation is simple: First <code>12</code> bits of the virtual address represent offset in the physical page or page frame. If we right-shift out <code>12</code> bits of the virtual address, we'll discard offset part and will get <code>Page Frame Number</code>. In the <code>memblock_mem_size</code> we go through the all memblock <code>mem</code> (not reserved) regions and calculates size of the mapped pages and return it to the <code>mapped_size</code> variable (see code above). As we got amount of the direct mapped memory, we check that size of the <code>initrd</code> is not greater than mapped pages. If it is greater we just call <code>panic</code> which halts the system and prints famous <a href="http://en.wikipedia.org/wiki/Kernel_panic">Kernel panic</a> message. In the next step we print information about the <code>initrd</code> size. We can see the result of this in the <code>dmesg</code> output:</p>
<pre><code class="language-C">[0.000000] RAMDISK: [mem 0x36d20000-0x37687fff]
</code></pre>
<p>and relocate <code>initrd</code> to the direct mapping area with the <code>relocate_initrd</code> function. In the start of the <code>relocate_initrd</code> function we try to find a free area with the <code>memblock_find_in_range</code> function:</p>
<pre><code class="language-C">relocated_ramdisk = memblock_find_in_range(0, PFN_PHYS(max_pfn_mapped), area_size, PAGE_SIZE);

if (!relocated_ramdisk)
    panic(&quot;Cannot find place for new RAMDISK of size %lld\n&quot;,
	       ramdisk_size);
</code></pre>
<p>The <code>memblock_find_in_range</code> function tries to find a free area in a given range, in our case from <code>0</code> to the maximum mapped physical address and size must equal to the aligned size of the <code>initrd</code>. If we didn't find a area with the given size, we call <code>panic</code> again. If all is good, we start to relocated RAM disk to the down of the directly mapped memory in the next step.</p>
<p>In the end of the <code>reserve_initrd</code> function, we free memblock memory which occupied by the ramdisk with the call of the:</p>
<pre><code class="language-C">memblock_free(ramdisk_image, ramdisk_end - ramdisk_image);
</code></pre>
<p>After we relocated <code>initrd</code> ramdisk image, the next function is <code>vsmp_init</code> from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/vsmp_64.c">arch/x86/kernel/vsmp_64.c</a>. This function initializes support of the <code>ScaleMP vSMP</code>. As I already wrote in the previous parts, this chapter will not cover non-related <code>x86_64</code> initialization parts (for example as the current or <code>ACPI</code>, etc.). So we will skip implementation of this for now and will back to it in the part which cover techniques of parallel computing.</p>
<p>The next function is <code>io_delay_init</code> from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/io_delay.c">arch/x86/kernel/io_delay.c</a>. This function allows to override default I/O delay <code>0x80</code> port. We already saw I/O delay in the <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-3">Last preparation before transition into protected mode</a>, now let's look on the <code>io_delay_init</code> implementation:</p>
<pre><code class="language-C">void __init io_delay_init(void)
{
    if (!io_delay_override)
        dmi_check_system(io_delay_0xed_port_dmi_table);
}
</code></pre>
<p>This function check <code>io_delay_override</code> variable and overrides I/O delay port if <code>io_delay_override</code> is set. We can set <code>io_delay_override</code> variably by passing <code>io_delay</code> option to the kernel command line. As we can read from the <a href="https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.rst">Documentation/kernel-parameters.txt</a>, <code>io_delay</code> option is:</p>
<pre><code>io_delay=	[X86] I/O delay method
    0x80
        Standard port 0x80 based delay
    0xed
        Alternate port 0xed based delay (needed on some systems)
    udelay
        Simple two microseconds delay
    none
        No delay
</code></pre>
<p>We can see <code>io_delay</code> command line parameter setup with the <code>early_param</code> macro in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/io_delay.c">arch/x86/kernel/io_delay.c</a></p>
<pre><code class="language-C">early_param(&quot;io_delay&quot;, io_delay_param);
</code></pre>
<p>More about <code>early_param</code> you can read in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-6">part</a>. So the <code>io_delay_param</code> function which setups <code>io_delay_override</code> variable will be called in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c#L413">do_early_param</a> function. <code>io_delay_param</code> function gets the argument of the <code>io_delay</code> kernel command line parameter and sets <code>io_delay_type</code> depends on it:</p>
<pre><code class="language-C">static int __init io_delay_param(char *s)
{
        if (!s)
                return -EINVAL;

        if (!strcmp(s, &quot;0x80&quot;))
                io_delay_type = CONFIG_IO_DELAY_TYPE_0X80;
        else if (!strcmp(s, &quot;0xed&quot;))
                io_delay_type = CONFIG_IO_DELAY_TYPE_0XED;
        else if (!strcmp(s, &quot;udelay&quot;))
                io_delay_type = CONFIG_IO_DELAY_TYPE_UDELAY;
        else if (!strcmp(s, &quot;none&quot;))
                io_delay_type = CONFIG_IO_DELAY_TYPE_NONE;
        else
                return -EINVAL;

        io_delay_override = 1;
        return 0;
}
</code></pre>
<p>The next functions are <code>acpi_boot_table_init</code>, <code>early_acpi_boot_init</code> and <code>initmem_init</code> after the <code>io_delay_init</code>, but as I wrote above we will not cover <a href="http://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI</a> related stuff in this <code>Linux Kernel initialization process</code> chapter.</p>
<h2 id="allocate-area-for-dma"><a class="header" href="#allocate-area-for-dma">Allocate area for DMA</a></h2>
<p>In the next step we need to allocate area for the <a href="http://en.wikipedia.org/wiki/Direct_memory_access">Direct memory access</a> with the <code>dma_contiguous_reserve</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/drivers/base/dma-contiguous.c">drivers/base/dma-contiguous.c</a>. <code>DMA</code> is a special mode when devices communicate with memory without CPU. Note that we pass one parameter - <code>max_pfn_mapped &lt;&lt; PAGE_SHIFT</code>, to the <code>dma_contiguous_reserve</code> function and as you can understand from this expression, this is limit of the reserved memory. Let's look on the implementation of this function. It starts from the definition of the following variables:</p>
<pre><code class="language-C">phys_addr_t selected_size = 0;
phys_addr_t selected_base = 0;
phys_addr_t selected_limit = limit;
bool fixed = false;
</code></pre>
<p>where first represents size in bytes of the reserved area, second is base address of the reserved area, third is end address of the reserved area and the last <code>fixed</code> parameter shows where to place reserved area. If <code>fixed</code> is <code>1</code> we just reserve area with the <code>memblock_reserve</code>, if it is <code>0</code> we allocate space with the <code>kmemleak_alloc</code>. In the next step we check <code>size_cmdline</code> variable and if it is not equal to <code>-1</code> we fill all variables which you can see above with the values from the <code>cma</code> kernel command line parameter:</p>
<pre><code class="language-C">if (size_cmdline != -1) {
   ...
   ...
   ...
}
</code></pre>
<p>You can find in this source code file definition of the early parameter:</p>
<pre><code class="language-C">early_param(&quot;cma&quot;, early_cma);
</code></pre>
<p>where <code>cma</code> is:</p>
<pre><code>cma=nn[MG]@[start[MG][-end[MG]]]
		[ARM,X86,KNL]
		Sets the size of kernel global memory area for
		contiguous memory allocations and optionally the
		placement constraint by the physical address range of
		memory allocations. A value of 0 disables CMA
		altogether. For more information, see
		include/linux/dma-contiguous.h
</code></pre>
<p>If we will not pass <code>cma</code> option to the kernel command line, <code>size_cmdline</code> will be equal to <code>-1</code>. In this way we need to calculate size of the reserved area which depends on the following kernel configuration options:</p>
<ul>
<li><code>CONFIG_CMA_SIZE_SEL_MBYTES</code> - size in megabytes, default global <code>CMA</code> area, which is equal to <code>CMA_SIZE_MBYTES * SZ_1M</code> or <code>CONFIG_CMA_SIZE_MBYTES * 1M</code>;</li>
<li><code>CONFIG_CMA_SIZE_SEL_PERCENTAGE</code> - percentage of total memory;</li>
<li><code>CONFIG_CMA_SIZE_SEL_MIN</code> - use lower value;</li>
<li><code>CONFIG_CMA_SIZE_SEL_MAX</code> - use higher value.</li>
</ul>
<p>As we calculated the size of the reserved area, we reserve area with the call of the <code>dma_contiguous_reserve_area</code> function which first of all calls:</p>
<pre><code>ret = cma_declare_contiguous(base, size, limit, 0, 0, fixed, res_cma);
</code></pre>
<p>function. The <code>cma_declare_contiguous</code> reserves contiguous area from the given base address with given size. After we reserved area for the <code>DMA</code>, next function is the <code>memblock_find_dma_reserve</code>. As you can understand from its name, this function counts the reserved pages in the <code>DMA</code> area. This part will not cover all details of the <code>CMA</code> and <code>DMA</code>, because they are big. We will see much more details in the special part in the Linux Kernel Memory management which covers contiguous memory allocators and areas.</p>
<h2 id="initialization-of-the-sparse-memory"><a class="header" href="#initialization-of-the-sparse-memory">Initialization of the sparse memory</a></h2>
<p>The next step is the call of the function - <code>x86_init.paging.pagetable_init</code>. If you try to find this function in the Linux kernel source code, in the end of your search, you will see the following macro:</p>
<pre><code class="language-C">#define native_pagetable_init        paging_init
</code></pre>
<p>which expands as you can see to the call of the <code>paging_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/init_64.c">arch/x86/mm/init_64.c</a>. The <code>paging_init</code> function initializes sparse memory and zone sizes. First of all what's zones and what is it <code>Sparsemem</code>. The <code>Sparsemem</code> is a special foundation in the Linux kernel memory manager which used to split memory area into different memory banks in the <a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a> systems. Let's look on the implementation of the <code>paging_init</code> function:</p>
<pre><code class="language-C">void __init paging_init(void)
{
        sparse_memory_present_with_active_regions(MAX_NUMNODES);
        sparse_init();

        node_clear_state(0, N_MEMORY);
        if (N_MEMORY != N_NORMAL_MEMORY)
                node_clear_state(0, N_NORMAL_MEMORY);

        zone_sizes_init();
}
</code></pre>
<p>As you can see there is call of the <code>sparse_memory_present_with_active_regions</code> function which records a memory area for every <code>NUMA</code> node to the array of the <code>mem_section</code> structure which contains a pointer to the structure of the array of <code>struct page</code>. The next <code>sparse_init</code> function allocates non-linear <code>mem_section</code> and <code>mem_map</code>. In the next step we clear state of the movable memory nodes and initialize sizes of zones. Every <code>NUMA</code> node is divided into a number of pieces which are called - <code>zones</code>. So, <code>zone_sizes_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/init.c">arch/x86/mm/init.c</a> initializes size of zones.</p>
<p>Again, this part and next parts do not cover this theme in full details. There will be special part about <code>NUMA</code>.</p>
<h2 id="vsyscall-mapping"><a class="header" href="#vsyscall-mapping">vsyscall mapping</a></h2>
<p>The next step after <code>SparseMem</code> initialization is setting of the <code>trampoline_cr4_features</code> which must contain content of the <code>cr4</code> <a href="http://en.wikipedia.org/wiki/Control_register">Control register</a>. First of all we need to check that current CPU has support of the <code>cr4</code> register and if it has, we save its content to the <code>trampoline_cr4_features</code> which is storage for <code>cr4</code> in the real mode:</p>
<pre><code class="language-C">if (boot_cpu_data.cpuid_level &gt;= 0) {
    mmu_cr4_features = __read_cr4();
	if (trampoline_cr4_features)
	    *trampoline_cr4_features = mmu_cr4_features;
}
</code></pre>
<p>The next function which you can see is <code>map_vsyscal</code> from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/vsyscall/vsyscall_64.c">arch/x86/entry/vsyscall/vsyscall_64.c</a>. This function maps memory space for <a href="https://lwn.net/Articles/446528/">vsyscalls</a> and depends on <code>CONFIG_X86_VSYSCALL_EMULATION</code> kernel configuration option. Actually <code>vsyscall</code> is a special segment which provides fast access to the certain system calls like <code>getcpu</code>, etc. Let's look on implementation of this function:</p>
<pre><code class="language-C">void __init map_vsyscall(void)
{
        extern char __vsyscall_page;
        unsigned long physaddr_vsyscall = __pa_symbol(&amp;__vsyscall_page);

        if (vsyscall_mode != NONE)
                __set_fixmap(VSYSCALL_PAGE, physaddr_vsyscall,
                             vsyscall_mode == NATIVE
                             ? PAGE_KERNEL_VSYSCALL
                             : PAGE_KERNEL_VVAR);

        BUILD_BUG_ON((unsigned long)__fix_to_virt(VSYSCALL_PAGE) !=
                     (unsigned long)VSYSCALL_ADDR);
}
</code></pre>
<p>In the beginning of the <code>map_vsyscall</code> we can see definition of two variables. The first is extern variable <code>__vsyscall_page</code>. As a extern variable, it defined somewhere in other source code file. Actually we can see definition of the <code>__vsyscall_page</code> in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/vsyscall/vsyscall_emu_64.S">arch/x86/entry/vsyscall/vsyscall_emu_64.S</a>. The <code>__vsyscall_page</code> symbol points to the aligned calls of the <code>vsyscalls</code> as <code>gettimeofday</code>, etc.:</p>
<pre><code class="language-assembly">	.globl __vsyscall_page
	.balign PAGE_SIZE, 0xcc
	.type __vsyscall_page, @object
__vsyscall_page:

	mov $__NR_gettimeofday, %rax
	syscall
	ret

	.balign 1024, 0xcc
	mov $__NR_time, %rax
	syscall
	ret
    ...
    ...
    ...
</code></pre>
<p>The second variable is <code>physaddr_vsyscall</code> which just stores physical address of the <code>__vsyscall_page</code> symbol. In the next step we check the <code>vsyscall_mode</code> variable, and if it is not equal to <code>NONE</code>, it is <code>EMULATE</code> by default:</p>
<pre><code class="language-C">static enum { EMULATE, NATIVE, NONE } vsyscall_mode = EMULATE;
</code></pre>
<p>And after this check we can see the call of the <code>__set_fixmap</code> function which calls <code>native_set_fixmap</code> with the same parameters:</p>
<pre><code class="language-C">void native_set_fixmap(enum fixed_addresses idx, unsigned long phys, pgprot_t flags)
{
        __native_set_fixmap(idx, pfn_pte(phys &gt;&gt; PAGE_SHIFT, flags));
}

void __native_set_fixmap(enum fixed_addresses idx, pte_t pte)
{
        unsigned long address = __fix_to_virt(idx);

        if (idx &gt;= __end_of_fixed_addresses) {
                BUG();
                return;
        }
        set_pte_vaddr(address, pte);
        fixmaps_set++;
}
</code></pre>
<p>Here we can see that <code>native_set_fixmap</code> makes value of <code>Page Table Entry</code> from the given physical address (physical address of the <code>__vsyscall_page</code> symbol in our case) and calls internal function - <code>__native_set_fixmap</code>. Internal function gets the virtual address of the given <code>fixed_addresses</code> index (<code>VSYSCALL_PAGE</code> in our case) and checks that given index is not greater than end of the fix-mapped addresses. After this we set page table entry with the call of the <code>set_pte_vaddr</code> function and increase count of the fix-mapped addresses. And in the end of the <code>map_vsyscall</code> we check that virtual address of the <code>VSYSCALL_PAGE</code> (which is first index in the <code>fixed_addresses</code>) is not greater than <code>VSYSCALL_ADDR</code> which is <code>-10UL &lt;&lt; 20</code> or <code>ffffffffff600000</code> with the <code>BUILD_BUG_ON</code> macro:</p>
<pre><code class="language-C">BUILD_BUG_ON((unsigned long)__fix_to_virt(VSYSCALL_PAGE) !=
                     (unsigned long)VSYSCALL_ADDR);
</code></pre>
<p>Now <code>vsyscall</code> area is in the <code>fix-mapped</code> area. That's all about <code>map_vsyscall</code>, if you do not know anything about fix-mapped addresses, you can read <a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-2">Fix-Mapped Addresses and ioremap</a>. We will see more about <code>vsyscalls</code> in the <code>vsyscalls and vdso</code> part.</p>
<h2 id="getting-the-smp-configuration"><a class="header" href="#getting-the-smp-configuration">Getting the SMP configuration</a></h2>
<p>You may remember how we made a search of the <a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a> configuration in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-6">part</a>. Now we need to get the <code>SMP</code> configuration if we found it. For this we check <code>smp_found_config</code> variable which we set in the <code>smp_scan_config</code> function (read about it the previous part) and call the <code>get_smp_config</code> function:</p>
<pre><code class="language-C">if (smp_found_config)
	get_smp_config();
</code></pre>
<p>The <code>get_smp_config</code> expands to the <code>x86_init.mpparse.default_get_smp_config</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/mpparse.c">arch/x86/kernel/mpparse.c</a>. This function defines a pointer to the multiprocessor floating pointer structure - <code>mpf_intel</code> (you can read about it in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-6">part</a>) and does some checks:</p>
<pre><code class="language-C">struct mpf_intel *mpf = mpf_found;

if (!mpf)
    return;

if (acpi_lapic &amp;&amp; early)
   return;
</code></pre>
<p>Here we can see that multiprocessor configuration was found in the <code>smp_scan_config</code> function or just return from the function if not. The next check is <code>acpi_lapic</code> and <code>early</code>. And as we did this checks, we start to read the <code>SMP</code> configuration. As we finished reading it, the next step is - <code>prefill_possible_map</code> function which makes preliminary filling of the possible CPU's <code>cpumask</code> (more about it you can read in the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">Introduction to the cpumasks</a>).</p>
<h2 id="the-rest-of-the-setup_arch"><a class="header" href="#the-rest-of-the-setup_arch">The rest of the setup_arch</a></h2>
<p>Here we are getting to the end of the <code>setup_arch</code> function. The rest of function of course is important, but details about these stuff will not will not be included in this part. We will just take a short look on these functions, because although they are important as I wrote above, they cover non-generic kernel features related with the <code>NUMA</code>, <code>SMP</code>, <code>ACPI</code> and <code>APICs</code>, etc. First of all, the next call of the <code>init_apic_mappings</code> function. As we can understand this function sets the address of the local <a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a>. The next is <code>x86_io_apic_ops.init</code> and this function initializes I/O APIC. Please note that we will see all details related with <code>APIC</code> in the chapter about interrupts and exceptions handling. In the next step we reserve standard I/O resources like <code>DMA</code>, <code>TIMER</code>, <code>FPU</code>, etc., with the call of the <code>x86_init.resources.reserve_resources</code> function. Following is <code>mcheck_init</code> function initializes <code>Machine check Exception</code> and the last is <code>register_refined_jiffies</code> which registers <a href="http://en.wikipedia.org/wiki/Jiffy_%28time%29">jiffy</a> (There will be separate chapter about timers in the kernel).</p>
<p>So that's all. Finally we have finished with the big <code>setup_arch</code> function in this part. Of course as I already wrote many times, we did not see full details about this function, but do not worry about it. We will be back more than once to this function from different chapters for understanding how different platform-dependent parts are initialized.</p>
<p>That's all, and now we can back to the <code>start_kernel</code> from the <code>setup_arch</code>.</p>
<h1 id="back-to-the-mainc"><a class="header" href="#back-to-the-mainc">Back to the main.c</a></h1>
<p>As I wrote above, we have finished with the <code>setup_arch</code> function and now we can back to the <code>start_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>. As you may remember or saw yourself, <code>start_kernel</code> function as big as the <code>setup_arch</code>. So the couple of the next part will be dedicated to learning of this function. So, let's continue with it. After the <code>setup_arch</code> we can see the call of the <code>mm_init_cpumask</code> function. This function sets the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumask</a> pointer to the memory descriptor <code>cpumask</code>. We can look on its implementation:</p>
<pre><code class="language-C">static inline void mm_init_cpumask(struct mm_struct *mm)
{
#ifdef CONFIG_CPUMASK_OFFSTACK
        mm-&gt;cpu_vm_mask_var = &amp;mm-&gt;cpumask_allocation;
#endif
        cpumask_clear(mm-&gt;cpu_vm_mask_var);
}
</code></pre>
<p>As you can see in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>, we pass memory descriptor of the init process to the <code>mm_init_cpumask</code> and depends on <code>CONFIG_CPUMASK_OFFSTACK</code> configuration option we clear <a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a> switch <code>cpumask</code>.</p>
<p>In the next step we can see the call of the following function:</p>
<pre><code class="language-C">setup_command_line(command_line);
</code></pre>
<p>This function takes pointer to the kernel command line allocates a couple of buffers to store command line. We need a couple of buffers, because one buffer used for future reference and accessing to command line and one for parameter parsing. We will allocate space for the following buffers:</p>
<ul>
<li><code>saved_command_line</code> - will contain boot command line;</li>
<li><code>initcall_command_line</code> - will contain boot command line. will be used in the <code>do_initcall_level</code>;</li>
<li><code>static_command_line</code> - will contain command line for parameters parsing.</li>
</ul>
<p>We will allocate space with the <code>memblock_virt_alloc</code> function. This function calls <code>memblock_virt_alloc_try_nid</code> which allocates boot memory block with <code>memblock_reserve</code> if <a href="http://en.wikipedia.org/wiki/Slab_allocation">slab</a> is not available or uses <code>kzalloc_node</code> (more about it will be in the Linux memory management chapter). The <code>memblock_virt_alloc</code> uses <code>BOOTMEM_LOW_LIMIT</code> (physical address of the <code>(PAGE_OFFSET + 0x1000000)</code> value) and <code>BOOTMEM_ALLOC_ACCESSIBLE</code> (equal to the current value of the <code>memblock.current_limit</code>) as minimum address of the memory region and maximum address of the memory region.</p>
<p>Let's look on the implementation of the <code>setup_command_line</code>:</p>
<pre><code class="language-C">static void __init setup_command_line(char *command_line)
{
        saved_command_line =
                memblock_virt_alloc(strlen(boot_command_line) + 1, 0);
        initcall_command_line =
                memblock_virt_alloc(strlen(boot_command_line) + 1, 0);
        static_command_line = memblock_virt_alloc(strlen(command_line) + 1, 0);
        strcpy(saved_command_line, boot_command_line);
        strcpy(static_command_line, command_line);
 }
</code></pre>
<p>Here we can see that we allocate space for the three buffers which will contain kernel command line for the different purposes (read above). And as we allocated space, we store <code>boot_command_line</code> in the <code>saved_command_line</code> and <code>command_line</code> (kernel command line from the <code>setup_arch</code>) to the <code>static_command_line</code>.</p>
<p>The next function after the <code>setup_command_line</code> is the <code>setup_nr_cpu_ids</code>. This function setting <code>nr_cpu_ids</code> (number of CPUs) according to the last bit in the <code>cpu_possible_mask</code> (more about it you can read in the chapter describes <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumasks</a> concept). Let's look on its implementation:</p>
<pre><code class="language-C">void __init setup_nr_cpu_ids(void)
{
        nr_cpu_ids = find_last_bit(cpumask_bits(cpu_possible_mask),NR_CPUS) + 1;
}
</code></pre>
<p>Here <code>nr_cpu_ids</code> represents number of CPUs, <code>NR_CPUS</code> represents the maximum number of CPUs which we can set in configuration time:</p>
<p><img src="Initialization/images/CONFIG_NR_CPUS.png" alt="CONFIG_NR_CPUS" /></p>
<p>Actually we need to call this function, because <code>NR_CPUS</code> can be greater than actual amount of the CPUs in the your computer. Here we can see that we call <code>find_last_bit</code> function and pass two parameters to it:</p>
<ul>
<li><code>cpu_possible_mask</code> bits;</li>
<li>maximum number of CPUS.</li>
</ul>
<p>In the <code>setup_arch</code> we can find the call of the <code>prefill_possible_map</code> function which calculates and writes to the <code>cpu_possible_mask</code> actual number of the CPUs. We call the <code>find_last_bit</code> function which takes the address and maximum size to search and returns bit number of the first set bit. We passed <code>cpu_possible_mask</code> bits and maximum number of the CPUs. First of all the <code>find_last_bit</code> function splits given <code>unsigned long</code> address to the <a href="http://en.wikipedia.org/wiki/Word_%28computer_architecture%29">words</a>:</p>
<pre><code class="language-C">words = size / BITS_PER_LONG;
</code></pre>
<p>where <code>BITS_PER_LONG</code> is <code>64</code> on the <code>x86_64</code>. As we got amount of words in the given size of the search data, we need to check is given size does not contain partial words with the following check:</p>
<pre><code class="language-C">if (size &amp; (BITS_PER_LONG-1)) {
         tmp = (addr[words] &amp; (~0UL &gt;&gt; (BITS_PER_LONG
                                 - (size &amp; (BITS_PER_LONG-1)))));
         if (tmp)
                 goto found;
}
</code></pre>
<p>if it contains partial word, we mask the last word and check it. If the last word is not zero, it means that current word contains at least one set bit. We go to the <code>found</code> label:</p>
<pre><code class="language-C">found:
    return words * BITS_PER_LONG + __fls(tmp);
</code></pre>
<p>Here you can see <code>__fls</code> function which returns last set bit in a given word with help of the <code>bsr</code> instruction:</p>
<pre><code class="language-C">static inline unsigned long __fls(unsigned long word)
{
        asm(&quot;bsr %1,%0&quot;
            : &quot;=r&quot; (word)
            : &quot;rm&quot; (word));
        return word;
}
</code></pre>
<p>The <code>bsr</code> instruction which scans the given operand for first bit set. If the last word is not partial we going through the all words in the given address and trying to find first set bit:</p>
<pre><code class="language-C">while (words) {
    tmp = addr[--words];
    if (tmp) {
found:
        return words * BITS_PER_LONG + __fls(tmp);
    }
}
</code></pre>
<p>Here we put the last word to the <code>tmp</code> variable and check that <code>tmp</code> contains at least one set bit. If a set bit found, we return the number of this bit. If no one words do not contains set bit we just return given size:</p>
<pre><code class="language-C">return size;
</code></pre>
<p>After this <code>nr_cpu_ids</code> will contain the correct amount of the available CPUs.</p>
<p>That's all.</p>
<h1 id="conclusion-12"><a class="header" href="#conclusion-12">Conclusion</a></h1>
<p>It is the end of the seventh part about the Linux kernel initialization process. In this part, finally we have finished with the <code>setup_arch</code> function and returned to the <code>start_kernel</code> function. In the next part we will continue to learn generic kernel code from the <code>start_kernel</code> and will continue our way to the first <code>init</code> process.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h1 id="links-12"><a class="header" href="#links-12">Links</a></h1>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Desktop_Management_Interface">Desktop Management Interface</a></li>
<li><a href="http://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="http://en.wikipedia.org/wiki/Initrd">initrd</a></li>
<li><a href="http://en.wikipedia.org/wiki/Kernel_panic">Kernel panic</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.rst">Documentation/kernel-parameters.txt</a></li>
<li><a href="http://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI</a></li>
<li><a href="http://en.wikipedia.org/wiki/Direct_memory_access">Direct memory access</a></li>
<li><a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a></li>
<li><a href="http://en.wikipedia.org/wiki/Control_register">Control register</a></li>
<li><a href="https://lwn.net/Articles/446528/">vsyscalls</a></li>
<li><a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a></li>
<li><a href="http://en.wikipedia.org/wiki/Jiffy_%28time%29">jiffy</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-6">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-initialization-part-8"><a class="header" href="#kernel-initialization-part-8">Kernel initialization. Part 8.</a></h1>
<h1 id="scheduler-initialization"><a class="header" href="#scheduler-initialization">Scheduler initialization</a></h1>
<p>This is the eighth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">part</a> of the Linux kernel initialization process chapter and we stopped on the <code>setup_nr_cpu_ids</code> function in the <a href="https://github.com/0xAX/linux-insides/blob/master/Initialization/linux-initialization-7.md">previous part</a>.</p>
<p>The main point of this part is <a href="http://en.wikipedia.org/wiki/Scheduling_%28computing%29">scheduler</a> initialization. But before we will start to learn initialization process of the scheduler, we need to do some stuff. The next step in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> is the <code>setup_per_cpu_areas</code> function. This function setups memory areas for the <code>percpu</code> variables, more about it you can read in the special part about the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">Per-CPU variables</a>. After <code>percpu</code> areas is up and running, the next step is the <code>smp_prepare_boot_cpu</code> function.</p>
<p>This function does some preparations for <a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing">symmetric multiprocessing</a>. Since this function is architecture specific, it is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/smp.h#L78">arch/x86/include/asm/smp.h</a> Linux kernel header file. Let's look at the definition of this function:</p>
<pre><code class="language-C">static inline void smp_prepare_boot_cpu(void)
{
         smp_ops.smp_prepare_boot_cpu();
}
</code></pre>
<p>We may see here that it just calls the <code>smp_prepare_boot_cpu</code> callback of the <code>smp_ops</code> structure. If we look at the definition of instance of this structure from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/smp.c">arch/x86/kernel/smp.c</a> source code file, we will see that the <code>smp_prepare_boot_cpu</code> expands to the call of the <code>native_smp_prepare_boot_cpu</code> function:</p>
<pre><code class="language-C">struct smp_ops smp_ops = {
    ...
    ...
    ...
    smp_prepare_boot_cpu = native_smp_prepare_boot_cpu,
    ...
    ...
    ...
}
EXPORT_SYMBOL_GPL(smp_ops);
</code></pre>
<p>The <code>native_smp_prepare_boot_cpu</code> function looks:</p>
<pre><code class="language-C">void __init native_smp_prepare_boot_cpu(void)
{
        int me = smp_processor_id();
        switch_to_new_gdt(me);
        cpumask_set_cpu(me, cpu_callout_mask);
        per_cpu(cpu_state, me) = CPU_ONLINE;
}
</code></pre>
<p>and executes following things: first of all it gets the <code>id</code> of the current CPU (which is Bootstrap processor and its <code>id</code> is zero for this moment) with the <code>smp_processor_id</code> function. I will not explain how the <code>smp_processor_id</code> works, because we already saw it in the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">Kernel entry point</a> part. After we've got processor <code>id</code> number we reload <a href="http://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a> for the given CPU with the <code>switch_to_new_gdt</code> function:</p>
<pre><code class="language-C">void switch_to_new_gdt(int cpu)
{
        struct desc_ptr gdt_descr;

        gdt_descr.address = (long)get_cpu_gdt_table(cpu);
        gdt_descr.size = GDT_SIZE - 1;
        load_gdt(&amp;gdt_descr);
        load_percpu_segment(cpu);
}
</code></pre>
<p>The <code>gdt_descr</code> variable represents pointer to the <code>GDT</code> descriptor here (we already saw definition of a <code>desc_ptr</code> structure in the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-2">Early interrupt and exception handling</a> part). We get the address and the size of the <code>GDT</code> descriptor for the <code>CPU</code> with the given <code>id</code>. The <code>GDT_SIZE</code> is <code>256</code> or:</p>
<pre><code class="language-C">#define GDT_SIZE (GDT_ENTRIES * 8)
</code></pre>
<p>and the address of the descriptor we will get with the <code>get_cpu_gdt_table</code>:</p>
<pre><code class="language-C">static inline struct desc_struct *get_cpu_gdt_table(unsigned int cpu)
{
        return per_cpu(gdt_page, cpu).gdt;
}
</code></pre>
<p>The <code>get_cpu_gdt_table</code> uses <code>per_cpu</code> macro for getting value of a <code>gdt_page</code> percpu variable for the given CPU number (bootstrap processor with <code>id</code> - 0 in our case).</p>
<p>You may ask the following question: so, if we can access <code>gdt_page</code> percpu variable, where was it defined? Actually we already saw it in this book. If you have read the first <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">part</a> of this chapter, you can remember that we saw definition of the <code>gdt_page</code> in the <a href="https://github.com/0xAX/linux/blob/0a07b238e5f488b459b6113a62e06b6aab017f71/arch/x86/kernel/head_64.S">arch/x86/kernel/head_64.S</a>:</p>
<pre><code class="language-assembly">early_gdt_descr:
	.word	GDT_ENTRIES*8-1
early_gdt_descr_base:
	.quad	INIT_PER_CPU_VAR(gdt_page)
</code></pre>
<p>and if we will look on the <a href="https://github.com/0xAX/linux/blob/0a07b238e5f488b459b6113a62e06b6aab017f71/arch/x86/kernel/vmlinux.lds.S">linker</a> file we can see that it locates after the <code>__per_cpu_load</code> symbol:</p>
<pre><code class="language-C">#define INIT_PER_CPU(x) init_per_cpu__##x = x + __per_cpu_load
INIT_PER_CPU(gdt_page);
</code></pre>
<p>and filled <code>gdt_page</code> in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/cpu/common.c#L94">arch/x86/kernel/cpu/common.c</a>:</p>
<pre><code class="language-C">DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = { .gdt = {
#ifdef CONFIG_X86_64
	[GDT_ENTRY_KERNEL32_CS]		= GDT_ENTRY_INIT(0xc09b, 0, 0xfffff),
	[GDT_ENTRY_KERNEL_CS]		= GDT_ENTRY_INIT(0xa09b, 0, 0xfffff),
	[GDT_ENTRY_KERNEL_DS]		= GDT_ENTRY_INIT(0xc093, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER32_CS]	= GDT_ENTRY_INIT(0xc0fb, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER_DS]	= GDT_ENTRY_INIT(0xc0f3, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER_CS]	= GDT_ENTRY_INIT(0xa0fb, 0, 0xfffff),
    ...
    ...
    ...
</code></pre>
<p>more about <code>percpu</code> variables you can read in the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">Per-CPU variables</a> part. As we got address and size of the <code>GDT</code> descriptor we reload <code>GDT</code> with the <code>load_gdt</code> which just execute <code>lgdt</code> instruct and load <code>percpu_segment</code> with the following function:</p>
<pre><code class="language-C">void load_percpu_segment(int cpu) {
    loadsegment(gs, 0);
    wrmsrl(MSR_GS_BASE, (unsigned long)per_cpu(irq_stack_union.gs_base, cpu));
    load_stack_canary_segment();
}
</code></pre>
<p>The base address of the <code>percpu</code> area must contain <code>gs</code> register (or <code>fs</code> register for <code>x86</code>), so we are using <code>loadsegment</code> macro and pass <code>gs</code>. In the next step we write the base address if the <a href="http://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> stack and setup stack <a href="http://en.wikipedia.org/wiki/Buffer_overflow_protection">canary</a> (this is only for <code>x86_32</code>). After we load new <code>GDT</code>, we fill <code>cpu_callout_mask</code> bitmap with the current cpu and set cpu state as online with the setting <code>cpu_state</code> percpu variable for the current processor - <code>CPU_ONLINE</code>:</p>
<pre><code class="language-C">cpumask_set_cpu(me, cpu_callout_mask);
per_cpu(cpu_state, me) = CPU_ONLINE;
</code></pre>
<p>So, what is <code>cpu_callout_mask</code> bitmap? As we initialized bootstrap processor (processor which is booted the first on <code>x86</code>) the other processors in a multiprocessor system are known as <code>secondary processors</code>. Linux kernel uses following two bitmasks:</p>
<ul>
<li><code>cpu_callout_mask</code></li>
<li><code>cpu_callin_mask</code></li>
</ul>
<p>After bootstrap processor initialized, it updates the <code>cpu_callout_mask</code> to indicate which secondary processor can be initialized next. All other or secondary processors can do some initialization stuff before and check the <code>cpu_callout_mask</code> on the bootstrap processor bit. Only after the bootstrap processor filled the <code>cpu_callout_mask</code> with this secondary processor, it will continue the rest of its initialization. After that the certain processor finish its initialization process, the processor sets bit in the <code>cpu_callin_mask</code>. Once the bootstrap processor finds the bit in the <code>cpu_callin_mask</code> for the current secondary processor, this processor repeats the same procedure for initialization of one of the remaining secondary processors. In a short words it works as I described, but we will see more details in the chapter about <code>SMP</code>.</p>
<p>That's all. We did all <code>SMP</code> boot preparation.</p>
<h2 id="build-zonelists"><a class="header" href="#build-zonelists">Build zonelists</a></h2>
<p>In the next step we can see the call of the <code>build_all_zonelists</code> function. This function sets up the order of zones that allocations are preferred from. What are zones and what's order we will understand soon. For the start let's see how Linux kernel considers physical memory. Physical memory is split into banks which are called - <code>nodes</code>. If you have no hardware support for <code>NUMA</code>, you will see only one node:</p>
<pre><code>$ cat /sys/devices/system/node/node0/numastat
numa_hit 72452442
numa_miss 0
numa_foreign 0
interleave_hit 12925
local_node 72452442
other_node 0
</code></pre>
<p>Every <code>node</code> is presented by the <code>struct pglist_data</code> in the Linux kernel. Each node is divided into a number of special blocks which are called - <code>zones</code>. Every zone is presented by the <code>zone struct</code> in the linux kernel and has one of the type:</p>
<ul>
<li><code>ZONE_DMA</code> - 0-16M;</li>
<li><code>ZONE_DMA32</code> - used for 32 bit devices that can only do DMA areas below 4G;</li>
<li><code>ZONE_NORMAL</code> - all RAM from the 4GB on the <code>x86_64</code>;</li>
<li><code>ZONE_HIGHMEM</code> - absent on the <code>x86_64</code>;</li>
<li><code>ZONE_MOVABLE</code> - zone which contains movable pages.</li>
</ul>
<p>which are presented by the <code>zone_type</code> enum. We can get information about zones with the:</p>
<pre><code>$ cat /proc/zoneinfo
Node 0, zone      DMA
  pages free     3975
        min      3
        low      3
        ...
        ...
Node 0, zone    DMA32
  pages free     694163
        min      875
        low      1093
        ...
        ...
Node 0, zone   Normal
  pages free     2529995
        min      3146
        low      3932
        ...
        ...
</code></pre>
<p>As I wrote above all nodes are described with the <code>pglist_data</code> or <code>pg_data_t</code> structure in memory. This structure is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/mmzone.h">include/linux/mmzone.h</a>. The <code>build_all_zonelists</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/page_alloc.c">mm/page_alloc.c</a> constructs an ordered <code>zonelist</code> (of different zones <code>DMA</code>, <code>DMA32</code>, <code>NORMAL</code>, <code>HIGH_MEMORY</code>, <code>MOVABLE</code>) which specifies the zones/nodes to visit when a selected <code>zone</code> or <code>node</code> cannot satisfy the allocation request. That's all. More about <code>NUMA</code> and multiprocessor systems will be in the special part.</p>
<h2 id="the-rest-of-the-stuff-before-scheduler-initialization"><a class="header" href="#the-rest-of-the-stuff-before-scheduler-initialization">The rest of the stuff before scheduler initialization</a></h2>
<p>Before we start to dive into Linux kernel scheduler initialization process we must do a couple of things. The first thing is the <code>page_alloc_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/page_alloc.c">mm/page_alloc.c</a>. This function looks pretty easy:</p>
<pre><code class="language-C">void __init page_alloc_init(void)
{
    int ret;

    ret = cpuhp_setup_state_nocalls(CPUHP_PAGE_ALLOC_DEAD,
                                    &quot;mm/page_alloc:dead&quot;, NULL,
                                    page_alloc_cpu_dead);
    WARN_ON(ret &lt; 0);
}
</code></pre>
<p>It setups setup the <code>startup</code> and <code>teardown</code> callbacks (second and third parameters) for the <code>CPUHP_PAGE_ALLOC_DEAD</code> cpu <a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">hotplug</a> state. Of course the implementation of this function depends on the <code>CONFIG_HOTPLUG_CPU</code> kernel configuration option and if this option is set, such callbacks will be set for all cpu(s) in the system depends on their <code>hotplug</code> states. <a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">hotplug</a> mechanism is a big theme and it will not be described in this book.</p>
<p>After this function we can see the kernel command line in the initialization output:</p>
<p><img src="Initialization/images/kernel_command_line.png" alt="kernel command line" /></p>
<p>And a couple of functions such as <code>parse_early_param</code> and <code>parse_args</code> which handles Linux kernel command line. You may remember that we already saw the call of the <code>parse_early_param</code> function in the sixth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-6">part</a> of the kernel initialization chapter, so why we call it again? Answer is simple: we call this function in the architecture-specific code (<code>x86_64</code> in our case), but not all architecture calls this function. And we need to call the second function <code>parse_args</code> to parse and handle non-early command line arguments.</p>
<p>In the next step we can see the call of the <code>jump_label_init</code> from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/jump_label.c">kernel/jump_label.c</a>. and initializes <a href="https://lwn.net/Articles/412072/">jump label</a>.</p>
<p>After this we can see the call of the <code>setup_log_buf</code> function which setups the <a href="http://www.makelinux.net/books/lkd2/ch18lev1sec3">printk</a> log buffer. We already saw this function in the seventh <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-7">part</a> of the Linux kernel initialization process chapter.</p>
<h2 id="pid-hash-initialization"><a class="header" href="#pid-hash-initialization">PID hash initialization</a></h2>
<p>The next is <code>pidhash_init</code> function. As you know each process has assigned a unique number which called - <code>process identification number</code> or <code>PID</code>. Each process generated with fork or clone is automatically assigned a new unique <code>PID</code> value by the kernel. The management of <code>PIDs</code> centered around the two special data structures: <code>struct pid</code> and <code>struct upid</code>. First structure represents information about a <code>PID</code> in the kernel. The second structure represents the information that is visible in a specific namespace. All <code>PID</code> instances stored in the special hash table:</p>
<pre><code class="language-C">static struct hlist_head *pid_hash;
</code></pre>
<p>This hash table is used to find the pid instance that belongs to a numeric <code>PID</code> value. So, <code>pidhash_init</code> initializes this hash table. In the start of the <code>pidhash_init</code> function we can see the call of the <code>alloc_large_system_hash</code>:</p>
<pre><code class="language-C">pid_hash = alloc_large_system_hash(&quot;PID&quot;, sizeof(*pid_hash), 0, 18,
                                   HASH_EARLY | HASH_SMALL,
                                   &amp;pidhash_shift, NULL,
                                   0, 4096);
</code></pre>
<p>The number of elements of the <code>pid_hash</code> depends on the <code>RAM</code> configuration, but it can be between <code>2^4</code> and <code>2^12</code>. The <code>pidhash_init</code> computes the size
and allocates the required storage (which is <code>hlist</code> in our case - the same as <a href="https://0xax.gitbook.io/linux-insides/summary/datastructures/linux-datastructures-1">doubly linked list</a>, but contains one pointer instead on the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/types.h">struct hlist_head</a>. The <code>alloc_large_system_hash</code> function allocates a large system hash table with <code>memblock_virt_alloc_nopanic</code> if we pass <code>HASH_EARLY</code> flag (as it in our case) or with <code>__vmalloc</code> if we did no pass this flag.</p>
<p>The result we can see in the <code>dmesg</code> output:</p>
<pre><code>$ dmesg | grep hash
[    0.000000] PID hash table entries: 4096 (order: 3, 32768 bytes)
...
...
...
</code></pre>
<p>That's all. The rest of the stuff before scheduler initialization is the following functions: <code>vfs_caches_init_early</code> does early initialization of the <a href="http://en.wikipedia.org/wiki/Virtual_file_system">virtual file system</a> (more about it will be in the chapter which will describe virtual file system), <code>sort_main_extable</code> sorts the kernel's built-in exception table entries which are between <code>__start___ex_table</code> and <code>__stop___ex_table</code>, and <code>trap_init</code> initializes trap handlers (more about last two function we will know in the separate chapter about interrupts).</p>
<p>The last step before the scheduler initialization is initialization of the memory manager with the <code>mm_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>. As we can see, the <code>mm_init</code> function initializes different parts of the Linux kernel memory manager:</p>
<pre><code class="language-C">page_ext_init_flatmem();
mem_init();
kmem_cache_init();
percpu_init_late();
pgtable_init();
vmalloc_init();
</code></pre>
<p>The first is <code>page_ext_init_flatmem</code> which depends on the <code>CONFIG_SPARSEMEM</code> kernel configuration option and initializes extended data per page handling. The <code>mem_init</code> releases all <code>bootmem</code>, the <code>kmem_cache_init</code> initializes kernel cache, the <code>percpu_init_late</code> - replaces <code>percpu</code> chunks with those allocated by <a href="http://en.wikipedia.org/wiki/SLUB_%28software%29">slub</a>, the <code>pgtable_init</code> - initializes the <code>page-&gt;ptl</code> kernel cache, the <code>vmalloc_init</code> - initializes <code>vmalloc</code>. Please, <strong>NOTE</strong> that we will not dive into details about all of these functions and concepts, but we will see all of them it in the <a href="https://0xax.gitbook.io/linux-insides/summary/mm">Linux kernel memory manager</a> chapter.</p>
<p>That's all. Now we can look on the <code>scheduler</code>.</p>
<h2 id="scheduler-initialization-1"><a class="header" href="#scheduler-initialization-1">Scheduler initialization</a></h2>
<p>And now we come to the main purpose of this part - initialization of the task scheduler. I want to say again as I already did it many times, you will not see the full explanation of the scheduler here, there will be special separate chapter about this. Here will be described first initial scheduler mechanisms which are initialized first of all. So let's start.</p>
<p>Our current point is the <code>sched_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/sched/core.c">kernel/sched/core.c</a> kernel source code file and as we can understand from the function's name, it initializes scheduler. Let's start to dive into this function and try to understand how the scheduler is initialized. At the start of the <code>sched_init</code> function we can see the following call:</p>
<pre><code class="language-C">sched_clock_init();
</code></pre>
<p>The <code>sched_clock_init</code> is pretty easy function and as we may see it just sets <code>sched_clock_init</code> variable:</p>
<pre><code class="language-C">void sched_clock_init(void)
{
	sched_clock_running = 1;
}
</code></pre>
<p>that will be used later. At the next step is initialization of the array of <code>waitqueues</code>:</p>
<pre><code class="language-C">for (i = 0; i &lt; WAIT_TABLE_SIZE; i++)
	init_waitqueue_head(bit_wait_table + i);
</code></pre>
<p>where <code>bit_wait_table</code> is defined as:</p>
<pre><code class="language-C">#define WAIT_TABLE_BITS 8
#define WAIT_TABLE_SIZE (1 &lt;&lt; WAIT_TABLE_BITS)
static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE] __cacheline_aligned;
</code></pre>
<p>The <code>bit_wait_table</code> is array of wait queues that will be used for wait/wake up of processes depends on the value of a designated bit. The next step after initialization of <code>waitqueues</code> array is calculating size of memory to allocate for the <code>root_task_group</code>. As we may see this size depends on two following kernel configuration options:</p>
<pre><code class="language-C">#ifdef CONFIG_FAIR_GROUP_SCHED
         alloc_size += 2 * nr_cpu_ids * sizeof(void **);
#endif
#ifdef CONFIG_RT_GROUP_SCHED
         alloc_size += 2 * nr_cpu_ids * sizeof(void **);
#endif
</code></pre>
<ul>
<li><code>CONFIG_FAIR_GROUP_SCHED</code>;</li>
<li><code>CONFIG_RT_GROUP_SCHED</code>.</li>
</ul>
<p>Both of these options provide two different planning models. As we can read from the <a href="https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt">documentation</a>, the current scheduler - <code>CFS</code> or <code>Completely Fair Scheduler</code> use a simple concept. It models process scheduling as if the system has an ideal multitasking processor where each process would receive <code>1/n</code> processor time, where <code>n</code> is the number of the runnable processes. The scheduler uses the special set of rules. These rules determine when and how to select a new process to run and they are called <code>scheduling policy</code>.</p>
<p>The <code>Completely Fair Scheduler</code> supports following <code>normal</code> or in other words <code>non-real-time</code> scheduling policies:</p>
<ul>
<li><code>SCHED_NORMAL</code>;</li>
<li><code>SCHED_BATCH</code>;</li>
<li><code>SCHED_IDLE</code>.</li>
</ul>
<p>The <code>SCHED_NORMAL</code> is used for the most normal applications, the amount of cpu each process consumes is mostly determined by the <a href="http://en.wikipedia.org/wiki/Nice_%28Unix%29">nice</a> value, the <code>SCHED_BATCH</code> used for the 100% non-interactive tasks and the <code>SCHED_IDLE</code> runs tasks only when the processor has no task to run besides this task.</p>
<p>The <code>real-time</code> policies are also supported for the time-critical applications: <code>SCHED_FIFO</code> and <code>SCHED_RR</code>. If you've read something about the Linux kernel scheduler, you can know that it is modular. That means it supports different algorithms to schedule different types of processes. Usually this modularity is called <code>scheduler classes</code>. These modules encapsulate scheduling policy details and are handled by the scheduler core without knowing too much about them.</p>
<p>Now let's get back to the our code and look on the two configuration options: <code>CONFIG_FAIR_GROUP_SCHED</code> and <code>CONFIG_RT_GROUP_SCHED</code>. The smallest unit that the scheduler works with is an individual task or thread. However, a process is not the only type of entity that the scheduler can operate with. Both of these options provide support for group scheduling. The first option provides support for group scheduling with the <code>completely fair scheduler</code> policies and the second with the <code>real-time</code> policies respectively.</p>
<p>In simple words, group scheduling is a feature that allows us to schedule a set of tasks as if they were a single task. For example, if you create a group with two tasks on the group, then this group is just like one normal task, from the kernel perspective. After a group is scheduled, the scheduler will pick a task from this group and it will be scheduled inside the group. So, such mechanism allows us to build hierarchies and manage their resources. Although a minimal unit of scheduling is a process, the Linux kernel scheduler does not use <code>task_struct</code> structure under the hood. There is special <code>sched_entity</code> structure that is used by the Linux kernel scheduler as scheduling unit.</p>
<p>So, the current goal is to calculate a space to allocate for a <code>sched_entity(ies)</code> of the root task group and we do it two times with:</p>
<pre><code class="language-C">#ifdef CONFIG_FAIR_GROUP_SCHED
         alloc_size += 2 * nr_cpu_ids * sizeof(void **);
#endif
#ifdef CONFIG_RT_GROUP_SCHED
         alloc_size += 2 * nr_cpu_ids * sizeof(void **);
#endif
</code></pre>
<p>The first is for case when scheduling of task groups is enabled with <code>completely fair</code> scheduler and the second is for the same purpose by in a case of <code>real-time</code> scheduler. So here we calculate size which is equal to size of a pointer multiplied on amount of CPUs in the system and multiplied to <code>2</code>. We need to multiply this on <code>2</code> as we will need to allocate a space for two things:</p>
<ul>
<li>scheduler entity structure;</li>
<li><code>runqueue</code>.</li>
</ul>
<p>After we have calculated size, we allocate a space with the <code>kzalloc</code> function and set pointers of <code>sched_entity</code> and <code>runqueues</code> there:</p>
<pre><code class="language-C">ptr = (unsigned long)kzalloc(alloc_size, GFP_NOWAIT);

#ifdef CONFIG_FAIR_GROUP_SCHED
        root_task_group.se = (struct sched_entity **)ptr;
        ptr += nr_cpu_ids * sizeof(void **);

        root_task_group.cfs_rq = (struct cfs_rq **)ptr;
        ptr += nr_cpu_ids * sizeof(void **);
#endif
#ifdef CONFIG_RT_GROUP_SCHED
		root_task_group.rt_se = (struct sched_rt_entity **)ptr;
		ptr += nr_cpu_ids * sizeof(void **);

		root_task_group.rt_rq = (struct rt_rq **)ptr;
		ptr += nr_cpu_ids * sizeof(void **);

#endif
</code></pre>
<p>As I already mentioned, the Linux group scheduling mechanism allows to specify a hierarchy. The root of such hierarchies is the <code>root_runqueuetask_group</code> task group structure. This structure contains many fields, but we are interested in <code>se</code>, <code>rt_se</code>, <code>cfs_rq</code> and <code>rt_rq</code> for this moment:</p>
<p>The first two are instances of <code>sched_entity</code> structure. It is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/sched.h">include/linux/sched.h</a> kernel header filed and used by the scheduler as a unit of scheduling.</p>
<pre><code class="language-C">struct task_group {
    ...
    ...
    struct sched_entity **se;
    struct cfs_rq **cfs_rq;
    ...
    ...
}
</code></pre>
<p>The <code>cfs_rq</code> and <code>rt_rq</code> present <code>run queues</code>. A <code>run queue</code> is a special <code>per-cpu</code> structure that is used by the Linux kernel scheduler to store <code>active</code> threads or in other words set of threads which potentially will be picked up by the scheduler to run.</p>
<p>The space is allocated and the next step is to initialize a <code>bandwidth</code> of CPU for <code>real-time</code> and <code>deadline</code> tasks:</p>
<pre><code class="language-C">init_rt_bandwidth(&amp;def_rt_bandwidth,
                  global_rt_period(), global_rt_runtime());
init_dl_bandwidth(&amp;def_dl_bandwidth,
                  global_rt_period(), global_rt_runtime());
</code></pre>
<p>All groups have to be able to rely on the amount of CPU time. The two following structures: <code>def_rt_bandwidth</code> and <code>def_dl_bandwidth</code> represent default values of bandwidths for <code>real-time</code> and <code>deadline</code> tasks. We will not look at definition of these structures as it is not so important for now, but we are interested in two following values:</p>
<ul>
<li><code>sched_rt_period_us</code>;</li>
<li><code>sched_rt_runtime_us</code>.</li>
</ul>
<p>The first represents a period and the second represents quantum that is allocated for <code>real-time</code> tasks during <code>sched_rt_period_us</code>. You may see global values of these parameters in the:</p>
<pre><code>$ cat /proc/sys/kernel/sched_rt_period_us
1000000

$ cat /proc/sys/kernel/sched_rt_runtime_us
950000
</code></pre>
<p>The values related to a group can be configured in <code>&lt;cgroup&gt;/cpu.rt_period_us</code> and <code>&lt;cgroup&gt;/cpu.rt_runtime_us</code>. Due no one filesystem is not mounted yet, the <code>def_rt_bandwidth</code> and the <code>def_dl_bandwidth</code> will be initialized with default values which will be returned by the <code>global_rt_period</code> and <code>global_rt_runtime</code> functions.</p>
<p>That's all with the bandwiths of <code>real-time</code> and <code>deadline</code> tasks and in the next step, depends on enable of <a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a>, we make initialization of the <code>root domain</code>:</p>
<pre><code class="language-C">#ifdef CONFIG_SMP
	init_defrootdomain();
#endif
</code></pre>
<p>The real-time scheduler requires global resources to make scheduling decision. But unfortunately scalability bottlenecks appear as the number of CPUs increase. The concept of <code>root domains</code> was introduced for improving scalability and avoid such bottlenecks. Instead of bypassing over all <code>run queues</code>, the scheduler gets information about a CPU where/from to push/pull a <code>real-time</code> task from the <code>root_domain</code> structure. This structure is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/sched/sched.h">kernel/sched/sched.h</a> kernel header file and just keeps track of CPUs that can be used to push or pull a process.</p>
<p>After <code>root domain</code> initialization, we make initialization of the <code>bandwidth</code> for the <code>real-time</code> tasks of the <code>root task group</code> as we did the same above:</p>
<pre><code class="language-C">#ifdef CONFIG_RT_GROUP_SCHED
	init_rt_bandwidth(&amp;root_task_group.rt_bandwidth,
			global_rt_period(), global_rt_runtime());
#endif
</code></pre>
<p>with the same default values.</p>
<p>In the next step, depends on the <code>CONFIG_CGROUP_SCHED</code> kernel configuration option we allocate <code>slab</code> cache for <code>task_group(s)</code> and initialize the <code>siblings</code> and <code>children</code> lists of the root task group. As we can read from the documentation, the <code>CONFIG_CGROUP_SCHED</code> is:</p>
<pre><code>This option allows you to create arbitrary task groups using the &quot;cgroup&quot; pseudo
filesystem and control the cpu bandwidth allocated to each such task group.
</code></pre>
<p>As we finished with the lists initialization, we can see the call of the <code>autogroup_init</code> function:</p>
<pre><code class="language-C">#ifdef CONFIG_CGROUP_SCHED
         list_add(&amp;root_task_group.list, &amp;task_groups);
         INIT_LIST_HEAD(&amp;root_task_group.children);
         INIT_LIST_HEAD(&amp;root_task_group.siblings);
         autogroup_init(&amp;init_task);
#endif
</code></pre>
<p>which initializes automatic process group scheduling. The <code>autogroup</code> feature is about automatic creation and population of a new task group during creation of a new session via <a href="https://linux.die.net/man/2/setsid">setsid</a> call.</p>
<p>After this we are going through the all <code>possible</code> CPUs (you can remember that <code>possible</code> CPUs are stored in the <code>cpu_possible_mask</code> bitmap that can ever be available in the system) and initialize a <code>runqueue</code> for each <code>possible</code> cpu:</p>
<pre><code class="language-C">for_each_possible_cpu(i) {
    struct rq *rq;
    ...
    ...
    ...
</code></pre>
<p>The <code>rq</code> structure in the Linux kernel is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/sched/sched.h#L625">kernel/sched/sched.h</a>. As I already mentioned this above, a <code>run queue</code> is a fundamental data structure in a scheduling process. The scheduler uses it to determine who will be ran next. As you may see, this structure has many different fields and we will not cover all of them here, but we will look on them when they will be directly used.</p>
<p>After initialization of <code>per-cpu</code> run queues with default values, we need to setup <code>load weight</code> of the first task in the system:</p>
<pre><code class="language-C">set_load_weight(&amp;init_task);
</code></pre>
<p>First of all let's try to understand what is it <code>load weight</code> of a process. If you will look at the definition of the <code>sched_entity</code> structure, you will see that it starts from the <code>load</code> field:</p>
<pre><code class="language-C">struct sched_entity {
	struct load_weight		load;
    ...
    ...
    ...
}
</code></pre>
<p>represented by the <code>load_weight</code> structure which just contains two fields that represent actual load weight of a scheduler entity and its invariant value:</p>
<pre><code class="language-C">struct load_weight {
	unsigned long	weight;
	u32				inv_weight;
};
</code></pre>
<p>You already may know that each process in the system has <code>priority</code>. The higher priority allows to get more time to run. A <code>load weight</code> of a process is a relation between priority of this process and timeslices of this process. Each process has three following fields related to priority:</p>
<pre><code class="language-C">struct task_struct {
...
...
...
	int				prio;
	int				static_prio;
	int				normal_prio;
...
...
...
}
</code></pre>
<p>The first one is <code>dynamic priority</code> which can't be changed during lifetime of a process based on its static priority and interactivity of the process. The <code>static_prio</code> contains initial priority most likely well-known to you <code>nice value</code>. This value is not changed by the kernel if a user does not change it. The last one is <code>normal_priority</code> based on the value of the <code>static_prio</code> too, but also it depends on the scheduling policy of a process.</p>
<p>So the main goal of the <code>set_load_weight</code> function is to initialize <code>load_weight</code> fields for the <code>init</code> task:</p>
<pre><code class="language-C">static void set_load_weight(struct task_struct *p)
{
	int prio = p-&gt;static_prio - MAX_RT_PRIO;
	struct load_weight *load = &amp;p-&gt;se.load;

	if (idle_policy(p-&gt;policy)) {
		load-&gt;weight = scale_load(WEIGHT_IDLEPRIO);
		load-&gt;inv_weight = WMULT_IDLEPRIO;
		return;
	}

	load-&gt;weight = scale_load(sched_prio_to_weight[prio]);
	load-&gt;inv_weight = sched_prio_to_wmult[prio];
}
</code></pre>
<p>As you may see we calculate initial <code>prio</code> from the initial value of the <code>static_prio</code> of the <code>init</code> task and use it as index of <code>sched_prio_to_weight</code> and <code>sched_prio_to_wmult</code> arrays to set <code>weight</code> and <code>inv_weight</code> values. These two arrays contain a <code>load weight</code> depends on priority value. In a case of when a process is <code>idle</code> process, we set minimal load weight.</p>
<p>For this moment we came to the end of initialization process of the Linux kernel scheduler. The last steps are: to make current process (it will be the first <code>init</code> process) <code>idle</code> that will be ran when a cpu has no other process to run. Calculating next time period of the next calculation of CPU load and initialization of the <code>fair</code> class:</p>
<pre><code class="language-C">__init void init_sched_fair_class(void)
{
#ifdef CONFIG_SMP
	open_softirq(SCHED_SOFTIRQ, run_rebalance_domains);
#endif
}
</code></pre>
<p>Here we register a <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-9">soft irq</a> that will call the <code>run_rebalance_domains</code> handler. After the <code>SCHED_SOFTIRQ</code> will be triggered, the <code>run_rebalance</code> will be called to rebalance a run queue on the current CPU.</p>
<p>The last two steps of the <code>sched_init</code> function is to initialization of scheduler statistics and setting <code>scheeduler_running</code> variable:</p>
<pre><code class="language-C">scheduler_running = 1;
</code></pre>
<p>That's all. Linux kernel scheduler is initialized. Of course, we have skipped many different details and explanations here, because we need to know and understand how different concepts (like process and process groups, runqueue, rcu, etc.) works in the Linux kernel , but we took a short look on the scheduler initialization process. We will look all other details in the separate part which will be fully dedicated to the scheduler.</p>
<h2 id="conclusion-13"><a class="header" href="#conclusion-13">Conclusion</a></h2>
<p>It is the end of the eighth part about the Linux kernel initialization process. In this part, we looked on the initialization process of the scheduler and we will continue in the next part to dive in the linux kernel initialization process and will see initialization of the <a href="http://en.wikipedia.org/wiki/Read-copy-update">RCU</a> and many other initialization stuff in the next part.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-13"><a class="header" href="#links-13">Links</a></h2>
<ul>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">CPU masks</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/timers/hrtimers.txt">high-resolution kernel timer</a></li>
<li><a href="http://en.wikipedia.org/wiki/Spinlock">spinlock</a></li>
<li><a href="http://en.wikipedia.org/wiki/Run_queue">Run queue</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm">Linux kernel memory manager</a></li>
<li><a href="http://en.wikipedia.org/wiki/SLUB_%28software%29">slub</a></li>
<li><a href="http://en.wikipedia.org/wiki/Virtual_file_system">virtual file system</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">Linux kernel hotplug documentation</a></li>
<li><a href="http://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a></li>
<li><a href="http://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">Per-CPU variables</a></li>
<li><a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a></li>
<li><a href="http://en.wikipedia.org/wiki/Read-copy-update">RCU</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt">CFS Scheduler documentation</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/scheduler/sched-rt-group.txt">Real-Time group scheduling</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-7">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-initialization-part-9"><a class="header" href="#kernel-initialization-part-9">Kernel initialization. Part 9.</a></h1>
<h1 id="rcu-initialization"><a class="header" href="#rcu-initialization">RCU initialization</a></h1>
<p>This is ninth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">Linux Kernel initialization process</a> and in the previous part we stopped at the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-8">scheduler initialization</a>. In this part we will continue to dive to the Linux kernel initialization process and the main purpose of this part will be to learn about initialization of the <a href="http://en.wikipedia.org/wiki/Read-copy-update">RCU</a>. We can see that the next step in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> after the <code>sched_init</code> is the call of the <code>preempt_disable</code>. There are two macros:</p>
<ul>
<li><code>preempt_disable</code></li>
<li><code>preempt_enable</code></li>
</ul>
<p>for preemption disabling and enabling. First of all let's try to understand what is <code>preempt</code> in the context of an operating system kernel. In simple words, preemption is ability of the operating system kernel to preempt current task to run task with higher priority. Here we need to disable preemption because we will have only one <code>init</code> process for the early boot time and we don't need to stop it before we call <code>cpu_idle</code> function. The <code>preempt_disable</code> macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/preempt.h">include/linux/preempt.h</a> and depends on the <code>CONFIG_PREEMPT_COUNT</code> kernel configuration option. This macro is implemented as:</p>
<pre><code class="language-C">#define preempt_disable() \
do { \
        preempt_count_inc(); \
        barrier(); \
} while (0)
</code></pre>
<p>and if <code>CONFIG_PREEMPT_COUNT</code> is not set just:</p>
<pre><code class="language-C">#define preempt_disable()                       barrier()
</code></pre>
<p>Let's look on it. First of all we can see one difference between these macro implementations. The <code>preempt_disable</code> with <code>CONFIG_PREEMPT_COUNT</code> set contains the call of the <code>preempt_count_inc</code>. There is special <code>percpu</code> variable which stores the number of held locks and <code>preempt_disable</code> calls:</p>
<pre><code class="language-C">DECLARE_PER_CPU(int, __preempt_count);
</code></pre>
<p>In the first implementation of the <code>preempt_disable</code> we increment this <code>__preempt_count</code>. There is API for returning value of the <code>__preempt_count</code>, it is the <code>preempt_count</code> function. As we called <code>preempt_disable</code>, first of all we increment preemption counter with the <code>preempt_count_inc</code> macro which expands to the:</p>
<pre><code>#define preempt_count_inc() preempt_count_add(1)
#define preempt_count_add(val)  __preempt_count_add(val)
</code></pre>
<p>where <code>preempt_count_add</code> calls the <code>raw_cpu_add_4</code> macro which adds <code>1</code> to the given <code>percpu</code> variable (<code>__preempt_count</code>) in our case (more about <code>precpu</code> variables you can read in the part about <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">Per-CPU variables</a>). Ok, we increased <code>__preempt_count</code> and the next step we can see the call of the <code>barrier</code> macro in the both macros. The <code>barrier</code> macro inserts an optimization barrier. In the processors with <code>x86_64</code> architecture independent memory access operations can be performed in any order. That's why we need the opportunity to point compiler and processor on compliance of order. This mechanism is memory barrier. Let's consider a simple example:</p>
<pre><code class="language-C">preempt_disable();
foo();
preempt_enable();
</code></pre>
<p>Compiler can rearrange it as:</p>
<pre><code class="language-C">preempt_disable();
preempt_enable();
foo();
</code></pre>
<p>In this case non-preemptible function <code>foo</code> can be preempted. As we put <code>barrier</code> macro in the <code>preempt_disable</code> and <code>preempt_enable</code> macros, it prevents the compiler from swapping <code>preempt_count_inc</code> with other statements. More about barriers you can read <a href="http://en.wikipedia.org/wiki/Memory_barrier">here</a> and <a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt">here</a>.</p>
<p>In the next step we can see following statement:</p>
<pre><code class="language-C">if (WARN(!irqs_disabled(),
	 &quot;Interrupts were enabled *very* early, fixing it\n&quot;))
	local_irq_disable();
</code></pre>
<p>which check <a href="http://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQs</a> state, and disabling (with <code>cli</code> instruction for <code>x86_64</code>) if they are enabled.</p>
<p>That's all. Preemption is disabled and we can go ahead.</p>
<h2 id="initialization-of-the-integer-id-management"><a class="header" href="#initialization-of-the-integer-id-management">Initialization of the integer ID management</a></h2>
<p>In the next step we can see the call of the <code>idr_init_cache</code> function which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/lib/idr.c">lib/idr.c</a>. The <code>idr</code> library is used in a various <a href="http://lxr.free-electrons.com/ident?i=idr_find">places</a> in the Linux kernel to manage assigning integer <code>IDs</code> to objects and looking up objects by id.</p>
<p>Let's look on the implementation of the <code>idr_init_cache</code> function:</p>
<pre><code class="language-C">void __init idr_init_cache(void)
{
        idr_layer_cache = kmem_cache_create(&quot;idr_layer_cache&quot;,
                                sizeof(struct idr_layer), 0, SLAB_PANIC, NULL);
}
</code></pre>
<p>Here we can see the call of the <code>kmem_cache_create</code>. We already called the <code>kmem_cache_init</code> in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c#L485">init/main.c</a>. This function create generalized caches again using the <code>kmem_cache_alloc</code> (more about caches we will see in the <a href="https://0xax.gitbook.io/linux-insides/summary/mm">Linux kernel memory management</a> chapter). In our case, as we are using <code>kmem_cache_t</code> which will be used by the <a href="http://en.wikipedia.org/wiki/Slab_allocation">slab</a> allocator and <code>kmem_cache_create</code> creates it. As you can see we pass five parameters to the <code>kmem_cache_create</code>:</p>
<ul>
<li>name of the cache;</li>
<li>size of the object to store in cache;</li>
<li>offset of the first object in the page;</li>
<li>flags;</li>
<li>constructor for the objects.</li>
</ul>
<p>and it will create <code>kmem_cache</code> for the integer IDs. Integer <code>IDs</code> is commonly used pattern to map set of integer IDs to the set of pointers. We can see usage of the integer IDs in the <a href="http://en.wikipedia.org/wiki/I%C2%B2C">i2c</a> drivers subsystem. For example <a href="https://github.com/torvalds/linux/blob/master/drivers/i2c/i2c-core-base.c">drivers/i2c/i2c-core-base.c</a> which represents the core of the <code>i2c</code> subsystem defines <code>ID</code> for the <code>i2c</code> adapter with the <code>DEFINE_IDR</code> macro:</p>
<pre><code class="language-C">static DEFINE_IDR(i2c_adapter_idr);
</code></pre>
<p>and then uses it for the declaration of the <code>i2c</code> adapter:</p>
<pre><code class="language-C">static int __i2c_add_numbered_adapter(struct i2c_adapter *adap)
{
  int     id;
  ...
  ...
  ...
  id = idr_alloc(&amp;i2c_adapter_idr, adap, adap-&gt;nr, adap-&gt;nr + 1, GFP_KERNEL);
  ...
  ...
  ...
}
</code></pre>
<p>and <code>id2_adapter_idr</code> presents dynamically calculated bus number.</p>
<p>More about integer ID management you can read <a href="https://lwn.net/Articles/103209/">here</a>.</p>
<h2 id="rcu-initialization-1"><a class="header" href="#rcu-initialization-1">RCU initialization</a></h2>
<p>The next step is <a href="http://en.wikipedia.org/wiki/Read-copy-update">RCU</a> initialization with the <code>rcu_init</code> function and its implementation depends on two kernel configuration options:</p>
<ul>
<li><code>CONFIG_TINY_RCU</code></li>
<li><code>CONFIG_TREE_RCU</code></li>
</ul>
<p>In the first case <code>rcu_init</code> will be in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/rcu/tiny.c">kernel/rcu/tiny.c</a> and in the second case it will be defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/rcu/tree.c">kernel/rcu/tree.c</a>. We will see the implementation of the <code>tree rcu</code>, but first of all about the <code>RCU</code> in general.</p>
<p><code>RCU</code> or read-copy update is a scalable high-performance synchronization mechanism implemented in the Linux kernel. On the early stage the Linux kernel provided support and environment for the concurrently running applications, but all execution was serialized in the kernel using a single global lock. In our days linux kernel has no single global lock, but provides different mechanisms including <a href="http://en.wikipedia.org/wiki/Concurrent_data_structure">lock-free data structures</a>, <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a> data structures and other. One of these mechanisms is - the <code>read-copy update</code>. The <code>RCU</code> technique is designed for rarely-modified data structures. The idea of the <code>RCU</code> is simple. For example we have a rarely-modified data structure. If somebody wants to change this data structure, we make a copy of this data structure and make all changes in the copy. In the same time all other users of the data structure use old version of it. Next, we need to choose safe moment when original version of the data structure will have no users and update it with the modified copy.</p>
<p>Of course this description of the <code>RCU</code> is very simplified. To understand some details about <code>RCU</code>, first of all we need to learn some terminology. Data readers in the <code>RCU</code> executed in the <a href="http://en.wikipedia.org/wiki/Critical_section">critical section</a>. Every time when data reader get to the critical section, it calls the <code>rcu_read_lock</code>, and <code>rcu_read_unlock</code> on exit from the critical section. If the thread is not in the critical section, it will be in state which called - <code>quiescent state</code>. The moment when every thread is in the <code>quiescent state</code> called - <code>grace period</code>. If a thread wants to remove an element from the data structure, this occurs in two steps. First step is <code>removal</code> - atomically removes element from the data structure, but does not release the physical memory. After this thread-writer announces and waits until it is finished. From this moment, the removed element is available to the thread-readers. After the <code>grace period</code> finished, the second step of the element removal will be started, it just removes the element from the physical memory.</p>
<p>There a couple of implementations of the <code>RCU</code>. Old <code>RCU</code> called classic, the new implementation called <code>tree</code> RCU. As you may already understand, the <code>CONFIG_TREE_RCU</code> kernel configuration option enables tree <code>RCU</code>. Another is the <code>tiny</code> RCU which depends on <code>CONFIG_TINY_RCU</code> and <code>CONFIG_SMP=n</code>. We will see more details about the <code>RCU</code> in general in the separate chapter about synchronization primitives, but now let's look on the <code>rcu_init</code> implementation from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/rcu/tree.c">kernel/rcu/tree.c</a>:</p>
<pre><code class="language-C">void __init rcu_init(void)
{
         int cpu;

         rcu_bootup_announce();
         rcu_init_geometry();
         rcu_init_one(&amp;rcu_bh_state, &amp;rcu_bh_data);
         rcu_init_one(&amp;rcu_sched_state, &amp;rcu_sched_data);
         __rcu_init_preempt();
         open_softirq(RCU_SOFTIRQ, rcu_process_callbacks);

         /*
          * We don't need protection against CPU-hotplug here because
          * this is called early in boot, before either interrupts
          * or the scheduler are operational.
          */
         cpu_notifier(rcu_cpu_notify, 0);
         pm_notifier(rcu_pm_notify, 0);
         for_each_online_cpu(cpu)
                 rcu_cpu_notify(NULL, CPU_UP_PREPARE, (void *)(long)cpu);

         rcu_early_boot_tests();
}
</code></pre>
<p>In the beginning of the <code>rcu_init</code> function we define <code>cpu</code> variable and call <code>rcu_bootup_announce</code>. The <code>rcu_bootup_announce</code> function is pretty simple:</p>
<pre><code class="language-C">static void __init rcu_bootup_announce(void)
{
        pr_info(&quot;Hierarchical RCU implementation.\n&quot;);
        rcu_bootup_announce_oddness();
}
</code></pre>
<p>It just prints information about the <code>RCU</code> with the <code>pr_info</code> function and <code>rcu_bootup_announce_oddness</code> which uses <code>pr_info</code> too, for printing different information about the current <code>RCU</code> configuration which depends on different kernel configuration options like <code>CONFIG_RCU_TRACE</code>, <code>CONFIG_PROVE_RCU</code>, <code>CONFIG_RCU_FANOUT_EXACT</code>, etc. In the next step, we can see the call of the <code>rcu_init_geometry</code> function. This function is defined in the same source code file and computes the node tree geometry depends on the amount of CPUs. Actually <code>RCU</code> provides scalability with extremely low internal RCU lock contention. What if a data structure will be read from the different CPUs? <code>RCU</code> API provides the <code>rcu_state</code> structure which presents RCU global state including node hierarchy. Hierarchy is presented by the:</p>
<pre><code>struct rcu_node node[NUM_RCU_NODES];
</code></pre>
<p>array of structures. As we can read in the comment of above definition:</p>
<pre><code>The root (first level) of the hierarchy is in -&gt;node[0] (referenced by -&gt;level[0]), the second
level in -&gt;node[1] through -&gt;node[m] (-&gt;node[1] referenced by -&gt;level[1]), and the third level
in -&gt;node[m+1] and following (-&gt;node[m+1] referenced by -&gt;level[2]).  The number of levels is
determined by the number of CPUs and by CONFIG_RCU_FANOUT.

Small systems will have a &quot;hierarchy&quot; consisting of a single rcu_node.
</code></pre>
<p>The <code>rcu_node</code> structure is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/rcu/tree.h">kernel/rcu/tree.h</a> and contains information about current grace period, is grace period completed or not, CPUs or groups that need to switch in order for current grace period to proceed, etc. Every <code>rcu_node</code> contains a lock for a couple of CPUs. These <code>rcu_node</code> structures are embedded into a linear array in the <code>rcu_state</code> structure and represented as a tree with the root as the first element and covers all CPUs. As you can see the number of the rcu nodes determined by the <code>NUM_RCU_NODES</code> which depends on number of available CPUs:</p>
<pre><code class="language-C">#define NUM_RCU_NODES (RCU_SUM - NR_CPUS)
#define RCU_SUM (NUM_RCU_LVL_0 + NUM_RCU_LVL_1 + NUM_RCU_LVL_2 + NUM_RCU_LVL_3 + NUM_RCU_LVL_4)
</code></pre>
<p>where levels values depend on the <code>CONFIG_RCU_FANOUT_LEAF</code> configuration option. For example for the simplest case, one <code>rcu_node</code> will cover two CPU on machine with the eight CPUs:</p>
<pre><code>+-----------------------------------------------------------------+
|  rcu_state                                                      |
|                 +----------------------+                        |
|                 |         root         |                        |
|                 |       rcu_node       |                        |
|                 +----------------------+                        |
|                    |                |                           |
|               +----v-----+       +--v-------+                   |
|               |          |       |          |                   |
|               | rcu_node |       | rcu_node |                   |
|               |          |       |          |                   |
|         +------------------+     +----------------+             |
|         |                  |        |             |             |
|         |                  |        |             |             |
|    +----v-----+    +-------v--+   +-v--------+  +-v--------+    |
|    |          |    |          |   |          |  |          |    |
|    | rcu_node |    | rcu_node |   | rcu_node |  | rcu_node |    |
|    |          |    |          |   |          |  |          |    |
|    +----------+    +----------+   +----------+  +----------+    |
|         |                 |             |               |       |
|         |                 |             |               |       |
|         |                 |             |               |       |
|         |                 |             |               |       |
+---------|-----------------|-------------|---------------|-------+
          |                 |             |               |
+---------v-----------------v-------------v---------------v--------+
|                 |                |               |               |
|     CPU1        |      CPU3      |      CPU5     |     CPU7      |
|                 |                |               |               |
|     CPU2        |      CPU4      |      CPU6     |     CPU8      |
|                 |                |               |               |
+------------------------------------------------------------------+
</code></pre>
<p>So, in the <code>rcu_init_geometry</code> function we just need to calculate the total number of <code>rcu_node</code> structures. We start to do it with the calculation of the <code>jiffies</code> till to the first and next <code>fqs</code> which is <code>force-quiescent-state</code> (read above about it):</p>
<pre><code class="language-C">d = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;
if (jiffies_till_first_fqs == ULONG_MAX)
        jiffies_till_first_fqs = d;
if (jiffies_till_next_fqs == ULONG_MAX)
        jiffies_till_next_fqs = d;
</code></pre>
<p>where:</p>
<pre><code class="language-C">#define RCU_JIFFIES_TILL_FORCE_QS (1 + (HZ &gt; 250) + (HZ &gt; 500))
#define RCU_JIFFIES_FQS_DIV     256
</code></pre>
<p>As we calculated these <a href="http://en.wikipedia.org/wiki/Jiffy_%28time%29">jiffies</a>, we check that previous defined <code>jiffies_till_first_fqs</code> and <code>jiffies_till_next_fqs</code> variables are equal to the <a href="http://www.rowleydownload.co.uk/avr/documentation/index.htm?http://www.rowleydownload.co.uk/avr/documentation/ULONG_MAX.htm">ULONG_MAX</a> (their default values) and set they equal to the calculated value. As we did not touch these variables before, they are equal to the <code>ULONG_MAX</code>:</p>
<pre><code class="language-C">static ulong jiffies_till_first_fqs = ULONG_MAX;
static ulong jiffies_till_next_fqs = ULONG_MAX;
</code></pre>
<p>In the next step of the <code>rcu_init_geometry</code>, we check that <code>rcu_fanout_leaf</code> didn't change (it has the same value as <code>CONFIG_RCU_FANOUT_LEAF</code> in compile-time) and equal to the value of the <code>CONFIG_RCU_FANOUT_LEAF</code> configuration option, we just return:</p>
<pre><code class="language-C">if (rcu_fanout_leaf == CONFIG_RCU_FANOUT_LEAF &amp;&amp;
    nr_cpu_ids == NR_CPUS)
    return;
</code></pre>
<p>After this we need to compute the number of nodes that an <code>rcu_node</code> tree can handle with the given number of levels:</p>
<pre><code class="language-C">rcu_capacity[0] = 1;
rcu_capacity[1] = rcu_fanout_leaf;
for (i = 2; i &lt;= MAX_RCU_LVLS; i++)
    rcu_capacity[i] = rcu_capacity[i - 1] * CONFIG_RCU_FANOUT;
</code></pre>
<p>And in the last step we calculate the number of rcu_nodes at each level of the tree in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/rcu/tree.c#L4094">loop</a>.</p>
<p>As we calculated geometry of the <code>rcu_node</code> tree, we need to go back to the <code>rcu_init</code> function and next step we need to initialize two <code>rcu_state</code> structures with the <code>rcu_init_one</code> function:</p>
<pre><code class="language-C">rcu_init_one(&amp;rcu_bh_state, &amp;rcu_bh_data);
rcu_init_one(&amp;rcu_sched_state, &amp;rcu_sched_data);
</code></pre>
<p>The <code>rcu_init_one</code> function takes two arguments:</p>
<ul>
<li>Global <code>RCU</code> state;</li>
<li>Per-CPU data for <code>RCU</code>.</li>
</ul>
<p>Both variables defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/rcu/tree.h">kernel/rcu/tree.h</a> with its <code>percpu</code> data:</p>
<pre><code>extern struct rcu_state rcu_bh_state;
DECLARE_PER_CPU(struct rcu_data, rcu_bh_data);
</code></pre>
<p>About these states you can read <a href="http://lwn.net/Articles/264090/">here</a>. As I wrote above we need to initialize <code>rcu_state</code> structures and <code>rcu_init_one</code> function will help us with it. After the <code>rcu_state</code> initialization, we can see the call of the <code> __rcu_init_preempt</code> which depends on the <code>CONFIG_PREEMPT_RCU</code> kernel configuration option. It does the same as previous functions - initialization of the <code>rcu_preempt_state</code> structure with the <code>rcu_init_one</code> function which has <code>rcu_state</code> type. After this, in the <code>rcu_init</code>, we can see the call of the:</p>
<pre><code class="language-C">open_softirq(RCU_SOFTIRQ, rcu_process_callbacks);
</code></pre>
<p>function. This function registers a handler of the <code>pending interrupt</code>. Pending interrupt or <code>softirq</code> supposes that part of actions can be delayed for later execution when the system is less loaded. Pending interrupts is represented by the following structure:</p>
<pre><code class="language-C">struct softirq_action
{
        void    (*action)(struct softirq_action *);
};
</code></pre>
<p>which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/interrupt.h">include/linux/interrupt.h</a> and contains only one field - handler of an interrupt. You can check about <code>softirqs</code> in the your system with the:</p>
<pre><code>$ cat /proc/softirqs
                    CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7
          HI:          2          0          0          1          0          2          0          0
       TIMER:     137779     108110     139573     107647     107408     114972      99653      98665
      NET_TX:       1127          0          4          0          1          1          0          0
      NET_RX:        334        221     132939       3076        451        361        292        303
       BLOCK:       5253       5596          8        779       2016      37442         28       2855
BLOCK_IOPOLL:          0          0          0          0          0          0          0          0
     TASKLET:         66          0       2916        113          0         24      26708          0
       SCHED:     102350      75950      91705      75356      75323      82627      69279      69914
     HRTIMER:        510        302        368        260        219        255        248        246
         RCU:      81290      68062      82979      69015      68390      69385      63304      63473
</code></pre>
<p>The <code>open_softirq</code> function takes two parameters:</p>
<ul>
<li>index of the interrupt;</li>
<li>interrupt handler.</li>
</ul>
<p>and adds interrupt handler to the array of the pending interrupts:</p>
<pre><code class="language-C">void open_softirq(int nr, void (*action)(struct softirq_action *))
{
        softirq_vec[nr].action = action;
}
</code></pre>
<p>In our case the interrupt handler is - <code>rcu_process_callbacks</code> which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/rcu/tree.c">kernel/rcu/tree.c</a> and does the <code>RCU</code> core processing for the current CPU. After we registered <code>softirq</code> interrupt for the <code>RCU</code>, we can see the following code:</p>
<pre><code class="language-C">cpu_notifier(rcu_cpu_notify, 0);
pm_notifier(rcu_pm_notify, 0);
for_each_online_cpu(cpu)
    rcu_cpu_notify(NULL, CPU_UP_PREPARE, (void *)(long)cpu);
</code></pre>
<p>Here we can see registration of the <code>cpu</code> notifier which needs in systems which supports <a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">CPU hotplug</a> and we will not dive into details about this theme. The last function in the <code>rcu_init</code> is the <code>rcu_early_boot_tests</code>:</p>
<pre><code class="language-C">void rcu_early_boot_tests(void)
{
        pr_info(&quot;Running RCU self tests\n&quot;);

        if (rcu_self_test)
                 early_boot_test_call_rcu();
         if (rcu_self_test_bh)
                 early_boot_test_call_rcu_bh();
         if (rcu_self_test_sched)
                early_boot_test_call_rcu_sched();
}
</code></pre>
<p>which runs self tests for the <code>RCU</code>.</p>
<p>That's all. We saw initialization process of the <code>RCU</code> subsystem. As I wrote above, more about the <code>RCU</code> will be in the separate chapter about synchronization primitives.</p>
<h2 id="rest-of-the-initialization-process"><a class="header" href="#rest-of-the-initialization-process">Rest of the initialization process</a></h2>
<p>Ok, we already passed the main theme of this part which is <code>RCU</code> initialization, but it is not the end of the Linux kernel initialization process. In the last paragraph of this theme we will see a couple of functions which work in the initialization time, but we will not dive into deep details around this function for different reasons. Some reasons not to dive into details are following:</p>
<ul>
<li>They are not very important for the generic kernel initialization process and depend on the different kernel configuration;</li>
<li>They have the character of debugging and not important for now;</li>
<li>We will see many of this stuff in the separate parts/chapters.</li>
</ul>
<p>After we initialized <code>RCU</code>, the next step which you can see in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> is the - <code>trace_init</code> function. As you can understand from its name, this function initialize <a href="http://en.wikipedia.org/wiki/Tracing_%28software%29">tracing</a> subsystem. You can read more about Linux kernel trace system - <a href="http://elinux.org/Kernel_Trace_Systems">here</a>.</p>
<p>After the <code>trace_init</code>, we can see the call of the <code>radix_tree_init</code>. If you are familiar with the different data structures, you can understand from the name of this function that it initializes kernel implementation of the <a href="http://en.wikipedia.org/wiki/Radix_tree">Radix tree</a>. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/lib/radix-tree.c">lib/radix-tree.c</a> and you can read more about it in the part about <a href="https://0xax.gitbook.io/linux-insides/summary/datastructures/linux-datastructures-2">Radix tree</a>.</p>
<p>In the next step we can see the functions which are related to the <code>interrupts handling</code> subsystem, they are:</p>
<ul>
<li><code>early_irq_init</code></li>
<li><code>init_IRQ</code></li>
<li><code>softirq_init</code></li>
</ul>
<p>We will see explanation about this functions and their implementation in the special part about interrupts and exceptions handling. After this many different functions (like <code>init_timers</code>, <code>hrtimers_init</code>, <code>time_init</code>, etc.) which are related to different timing and timers stuff. We will see more about these function in the chapter about timers.</p>
<p>The next couple of functions are related with the <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> events - <code>perf_event-init</code> (there will be separate chapter about perf), initialization of the <code>profiling</code> with the <code>profile_init</code>. After this we enable <code>irq</code> with the call of the:</p>
<pre><code class="language-C">local_irq_enable();
</code></pre>
<p>which expands to the <code>sti</code> instruction and making post initialization of the <a href="http://en.wikipedia.org/wiki/Slab_allocation">SLAB</a> with the call of the <code>kmem_cache_init_late</code> function (As I wrote above we will know about the <code>SLAB</code> in the <a href="https://0xax.gitbook.io/linux-insides/summary/mm">Linux memory management</a> chapter).</p>
<p>After the post initialization of the <code>SLAB</code>, next point is initialization of the console with the <code>console_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/drivers/tty/tty_io.c">drivers/tty/tty_io.c</a>.</p>
<p>After the console initialization, we can see the <code>lockdep_info</code> function which prints information about the <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">Lock dependency validator</a>. After this, we can see the initialization of the dynamic allocation of the <code>debug objects</code> with the <code>debug_objects_mem_init</code>, kernel memory leak <a href="https://www.kernel.org/doc/Documentation/kmemleak.txt">detector</a> initialization with the <code>kmemleak_init</code>, <code>percpu</code> pageset setup with the <code>setup_per_cpu_pageset</code>, setup of the <a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a> policy with the <code>numa_policy_init</code>, setting time for the scheduler with the <code>sched_clock_init</code>, <code>pidmap</code> initialization with the call of the <code>pidmap_init</code> function for the initial <code>PID</code> namespace, cache creation with the <code>anon_vma_init</code> for the private virtual memory areas and early initialization of the <a href="http://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI</a> with the <code>acpi_early_init</code>.</p>
<p>This is the end of the ninth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">linux kernel initialization process</a> and here we saw initialization of the <a href="http://en.wikipedia.org/wiki/Read-copy-update">RCU</a>. In the last paragraph of this part (<code>Rest of the initialization process</code>) we will go through many functions but did not dive into details about their implementations. Do not worry if you do not know anything about these stuff or you know and do not understand anything about this. As I already wrote many times, we will see details of implementations in other parts or other chapters.</p>
<h2 id="conclusion-14"><a class="header" href="#conclusion-14">Conclusion</a></h2>
<p>It is the end of the ninth part about the Linux kernel <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">initialization process</a>. In this part, we looked on the initialization process of the <code>RCU</code> subsystem. In the next part we will continue to dive into linux kernel initialization process and I hope that we will finish with the <code>start_kernel</code> function and will go to the <code>rest_init</code> function from the same <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> source code file and will see the start of the first process.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-14"><a class="header" href="#links-14">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Concurrent_data_structure">lock-free data structures</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/kmemleak.txt">kmemleak</a></li>
<li><a href="http://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI</a></li>
<li><a href="http://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQs</a></li>
<li><a href="http://en.wikipedia.org/wiki/Read-copy-update">RCU</a></li>
<li><a href="https://github.com/torvalds/linux/tree/master/Documentation/RCU">RCU documentation</a></li>
<li><a href="https://lwn.net/Articles/103209/">integer ID management</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt">Documentation/memory-barriers.txt</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">Runtime locking correctness validator</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">Per-CPU variables</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm">Linux kernel memory management</a></li>
<li><a href="http://en.wikipedia.org/wiki/Slab_allocation">slab</a></li>
<li><a href="http://en.wikipedia.org/wiki/I%C2%B2C">i2c</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-8">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kernel-initialization-part-10"><a class="header" href="#kernel-initialization-part-10">Kernel initialization. Part 10.</a></h1>
<h1 id="end-of-the-linux-kernel-initialization-process"><a class="header" href="#end-of-the-linux-kernel-initialization-process">End of the Linux kernel initialization process</a></h1>
<p>This is tenth part of the chapter about Linux kernel <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">initialization process</a> and in the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-9">previous part</a> we saw the initialization of the <a href="http://en.wikipedia.org/wiki/Read-copy-update">RCU</a> and stopped on the call of the <code>acpi_early_init</code> function. This part will be the last part of the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">Kernel initialization process</a> chapter, so let's finish it.</p>
<p>After the call of the <code>acpi_early_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>, we can see the following code:</p>
<pre><code class="language-C">#ifdef CONFIG_X86_ESPFIX64
	init_espfix_bsp();
#endif
</code></pre>
<p>Here we can see the call of the <code>init_espfix_bsp</code> function which depends on the <code>CONFIG_X86_ESPFIX64</code> kernel configuration option. As we can understand from the function name, it does something with the stack. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/espfix_64.c">arch/x86/kernel/espfix_64.c</a> and prevents leaking of <code>31:16</code> bits of the <code>esp</code> register during returning to 16-bit stack. First of all we install <code>espfix</code> page upper directory into the kernel page directory in the <code>init_espfix_bs</code>:</p>
<pre><code class="language-C">pgd_p = &amp;init_level4_pgt[pgd_index(ESPFIX_BASE_ADDR)];
pgd_populate(&amp;init_mm, pgd_p, (pud_t *)espfix_pud_page);
</code></pre>
<p>Where <code>ESPFIX_BASE_ADDR</code> is:</p>
<pre><code class="language-C">#define PGDIR_SHIFT     39
#define ESPFIX_PGD_ENTRY _AC(-2, UL)
#define ESPFIX_BASE_ADDR (ESPFIX_PGD_ENTRY &lt;&lt; PGDIR_SHIFT)
</code></pre>
<p>Also we can find it in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/x86_64/mm.txt">Documentation/x86/x86_64/mm</a>:</p>
<pre><code>... unused hole ...
ffffff0000000000 - ffffff7fffffffff (=39 bits) %esp fixup stacks
... unused hole ...
</code></pre>
<p>After we've filled page global directory with the <code>espfix</code> pud, the next step is call of the <code>init_espfix_random</code> and <code>init_espfix_ap</code> functions. The first function returns random locations for the <code>espfix</code> page and the second enables the <code>espfix</code> for the current CPU. After the <code>init_espfix_bsp</code> finished the work, we can see the call of the <code>thread_info_cache_init</code> function which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/fork.c">kernel/fork.c</a> and allocates cache for the <code>thread_info</code> if <code>THREAD_SIZE</code> is less than <code>PAGE_SIZE</code>:</p>
<pre><code class="language-C"># if THREAD_SIZE &gt;= PAGE_SIZE
...
...
...
void thread_info_cache_init(void)
{
        thread_info_cache = kmem_cache_create(&quot;thread_info&quot;, THREAD_SIZE,
                                              THREAD_SIZE, 0, NULL);
        BUG_ON(thread_info_cache == NULL);
}
...
...
...
#endif
</code></pre>
<p>As we already know the <code>PAGE_SIZE</code> is <code>(_AC(1,UL) &lt;&lt; PAGE_SHIFT)</code> or <code>4096</code> bytes and <code>THREAD_SIZE</code> is <code>(PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</code> or <code>16384</code> bytes for the <code>x86_64</code>. The next function after the <code>thread_info_cache_init</code> is the <code>cred_init</code> from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/cred.c">kernel/cred.c</a>. This function just allocates cache for the credentials (like <code>uid</code>, <code>gid</code>, etc.):</p>
<pre><code class="language-C">void __init cred_init(void)
{
         cred_jar = kmem_cache_create(&quot;cred_jar&quot;, sizeof(struct cred),
                                     0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
}
</code></pre>
<p>more about credentials you can read in the <a href="https://github.com/torvalds/linux/blob/master/Documentation/security/credentials.rst">Documentation/security/credentials.txt</a>. Next step is the <code>fork_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/fork.c">kernel/fork.c</a>. The <code>fork_init</code> function allocates cache for the <code>task_struct</code>. Let's look on the implementation of the <code>fork_init</code>. First of all we can see definitions of the <code>ARCH_MIN_TASKALIGN</code> macro and creation of a slab where task_structs will be allocated:</p>
<pre><code class="language-C">#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR
#ifndef ARCH_MIN_TASKALIGN
#define ARCH_MIN_TASKALIGN      L1_CACHE_BYTES
#endif
        task_struct_cachep =
                kmem_cache_create(&quot;task_struct&quot;, sizeof(struct task_struct),
                        ARCH_MIN_TASKALIGN, SLAB_PANIC | SLAB_NOTRACK, NULL);
#endif
</code></pre>
<p>As we can see this code depends on the <code>CONFIG_ARCH_TASK_STRUCT_ACLLOCATOR</code> kernel configuration option. This configuration option shows the presence of the <code>alloc_task_struct</code> for the given architecture. As <code>x86_64</code> has no <code>alloc_task_struct</code> function, this code will not work and even will not be compiled on the <code>x86_64</code>.</p>
<h2 id="allocating-cache-for-init-task"><a class="header" href="#allocating-cache-for-init-task">Allocating cache for init task</a></h2>
<p>After this we can see the call of the <code>arch_task_cache_init</code> function in the <code>fork_init</code>:</p>
<pre><code class="language-C">void arch_task_cache_init(void)
{
        task_xstate_cachep =
                kmem_cache_create(&quot;task_xstate&quot;, xstate_size,
                                  __alignof__(union thread_xstate),
                                  SLAB_PANIC | SLAB_NOTRACK, NULL);
        setup_xstate_comp();
}
</code></pre>
<p>The <code>arch_task_cache_init</code> does initialization of the architecture-specific caches. In our case it is <code>x86_64</code>, so as we can see, the <code>arch_task_cache_init</code> allocates cache for the <code>task_xstate</code> which represents <a href="http://en.wikipedia.org/wiki/Floating-point_unit">FPU</a> state and sets up offsets and sizes of all extended states in <a href="http://www.felixcloutier.com/x86/XSAVES.html">xsave</a> area with the call of the <code>setup_xstate_comp</code> function. After the <code>arch_task_cache_init</code> we calculate default maximum number of threads with the:</p>
<pre><code class="language-C">set_max_threads(MAX_THREADS);
</code></pre>
<p>where default maximum number of threads is:</p>
<pre><code class="language-C">#define FUTEX_TID_MASK  0x3fffffff
#define MAX_THREADS     FUTEX_TID_MASK
</code></pre>
<p>In the end of the <code>fork_init</code> function we initialize <a href="http://www.win.tue.nl/%7Eaeb/linux/lk/lk-5.html">signal</a> handler:</p>
<pre><code class="language-C">init_task.signal-&gt;rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;
init_task.signal-&gt;rlim[RLIMIT_NPROC].rlim_max = max_threads/2;
init_task.signal-&gt;rlim[RLIMIT_SIGPENDING] =
		init_task.signal-&gt;rlim[RLIMIT_NPROC];
</code></pre>
<p>As we know the <code>init_task</code> is an instance of the <code>task_struct</code> structure, so it contains <code>signal</code> field which represents signal handler. It has following type <code>struct signal_struct</code>. On the first two lines we can see setting of the current and maximum limit of the <code>resource limits</code>. Every process has an associated set of resource limits. These limits specify amount of resources which current process can use. Here <code>rlim</code> is resource control limit and presented by the:</p>
<pre><code class="language-C">struct rlimit {
        __kernel_ulong_t        rlim_cur;
        __kernel_ulong_t        rlim_max;
};
</code></pre>
<p>structure from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/uapi/linux/resource.h">include/uapi/linux/resource.h</a>. In our case the resource is the <code>RLIMIT_NPROC</code> which is the maximum number of processes that user can own and <code>RLIMIT_SIGPENDING</code> - the maximum number of pending signals. We can see it in the:</p>
<pre><code class="language-C">cat /proc/self/limits
Limit                     Soft Limit           Hard Limit           Units
...
...
...
Max processes             63815                63815                processes
Max pending signals       63815                63815                signals
...
...
...
</code></pre>
<h2 id="initialization-of-the-caches"><a class="header" href="#initialization-of-the-caches">Initialization of the caches</a></h2>
<p>The next function after the <code>fork_init</code> is the <code>proc_caches_init</code> from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/fork.c">kernel/fork.c</a>. This function allocates caches for the memory descriptors (or <code>mm_struct</code> structure). At the beginning of the <code>proc_caches_init</code> we can see allocation of the different <a href="http://en.wikipedia.org/wiki/Slab_allocation">SLAB</a> caches with the call of the <code>kmem_cache_create</code>:</p>
<ul>
<li><code>sighand_cachep</code> - manage information about installed signal handlers;</li>
<li><code>signal_cachep</code> - manage information about process signal descriptor;</li>
<li><code>files_cachep</code> - manage information about opened files;</li>
<li><code>fs_cachep</code> - manage filesystem information.</li>
</ul>
<p>After this we allocate <code>SLAB</code> cache for the <code>mm_struct</code> structures:</p>
<pre><code class="language-C">mm_cachep = kmem_cache_create(&quot;mm_struct&quot;,
                         sizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,
                         SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);
</code></pre>
<p>After this we allocate <code>SLAB</code> cache for the important <code>vm_area_struct</code> which used by the kernel to manage virtual memory space:</p>
<pre><code class="language-C">vm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);
</code></pre>
<p>Note, that we use <code>KMEM_CACHE</code> macro here instead of the <code>kmem_cache_create</code>. This macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/slab.h">include/linux/slab.h</a> and just expands to the <code>kmem_cache_create</code> call:</p>
<pre><code class="language-C">#define KMEM_CACHE(__struct, __flags) kmem_cache_create(#__struct,\
                sizeof(struct __struct), __alignof__(struct __struct),\
                (__flags), NULL)
</code></pre>
<p>The <code>KMEM_CACHE</code> has one difference from <code>kmem_cache_create</code>. Take a look on <code>__alignof__</code> operator. The <code>KMEM_CACHE</code> macro aligns <code>SLAB</code> to the size of the given structure, but <code>kmem_cache_create</code> uses given value to align space. After this we can see the call of the <code>mmap_init</code> and <code>nsproxy_cache_init</code> functions. The first function initializes virtual memory area <code>SLAB</code> and the second function initializes <code>SLAB</code> for namespaces.</p>
<p>The next function after the <code>proc_caches_init</code> is <code>buffer_init</code>. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/buffer.c">fs/buffer.c</a> source code file and allocate cache for the <code>buffer_head</code>. The <code>buffer_head</code> is a special structure which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/buffer_head.h">include/linux/buffer_head.h</a> and used for managing buffers. In the start of the <code>buffer_init</code> function we allocate cache for the <code>struct buffer_head</code> structures with the call of the <code>kmem_cache_create</code> function as we did in the previous functions. And calculate the maximum size of the buffers in memory with:</p>
<pre><code class="language-C">nrpages = (nr_free_buffer_pages() * 10) / 100;
max_buffer_heads = nrpages * (PAGE_SIZE / sizeof(struct buffer_head));
</code></pre>
<p>which will be equal to the <code>10%</code> of the <code>ZONE_NORMAL</code> (all RAM from the 4GB on the <code>x86_64</code>). The next function after the <code>buffer_init</code> is - <code>vfs_caches_init</code>. This function allocates <code>SLAB</code> caches and hashtable for different <a href="http://en.wikipedia.org/wiki/Virtual_file_system">VFS</a> caches. We already saw the <code>vfs_caches_init_early</code> function in the eighth part of the Linux kernel <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-8">initialization process</a> which initialized caches for <code>dcache</code> (or directory-cache) and <a href="http://en.wikipedia.org/wiki/Inode">inode</a> cache. The <code>vfs_caches_init</code> function makes post-early initialization of the <code>dcache</code> and <code>inode</code> caches, private data cache, hash tables for the mount points, etc. More details about <a href="http://en.wikipedia.org/wiki/Virtual_file_system">VFS</a> will be described in the separate part. After this we can see <code>signals_init</code> function. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/signal.c">kernel/signal.c</a> and allocates a cache for the <code>sigqueue</code> structures which represents queue of the real time signals. The next function is <code>page_writeback_init</code>. This function initializes the ratio for the dirty pages. Every low-level page entry contains the <code>dirty</code> bit which indicates whether a page has been written to after been loaded into memory.</p>
<h2 id="creation-of-the-root-for-the-procfs"><a class="header" href="#creation-of-the-root-for-the-procfs">Creation of the root for the procfs</a></h2>
<p>After all of this preparations we need to create the root for the <a href="http://en.wikipedia.org/wiki/Procfs">proc</a> filesystem. We will do it with the call of the <code>proc_root_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/proc/root.c">fs/proc/root.c</a>. At the start of the <code>proc_root_init</code> function we allocate the cache for the inodes and register a new filesystem in the system with the:</p>
<pre><code class="language-C">err = register_filesystem(&amp;proc_fs_type);
      if (err)
                return;
</code></pre>
<p>As I wrote above we will not dive into details about <a href="http://en.wikipedia.org/wiki/Virtual_file_system">VFS</a> and different filesystems in this chapter, but will see it in the chapter about the <code>VFS</code>. After we've registered a new filesystem in our system, we call the <code>proc_self_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/proc/self.c">fs/proc/self.c</a> and this function allocates <code>inode</code> number for the <code>self</code> (<code>/proc/self</code> directory refers to the process accessing the <code>/proc</code> filesystem). The next step after the <code>proc_self_init</code> is <code>proc_setup_thread_self</code> which setups the <code>/proc/thread-self</code> directory which contains information about current thread. After this we create <code>/proc/self/mounts</code> symlink which will contains mount points with the call of the</p>
<pre><code class="language-C">proc_symlink(&quot;mounts&quot;, NULL, &quot;self/mounts&quot;);
</code></pre>
<p>and a couple of directories depends on the different configuration options:</p>
<pre><code class="language-C">#ifdef CONFIG_SYSVIPC
        proc_mkdir(&quot;sysvipc&quot;, NULL);
#endif
        proc_mkdir(&quot;fs&quot;, NULL);
        proc_mkdir(&quot;driver&quot;, NULL);
        proc_mkdir(&quot;fs/nfsd&quot;, NULL);
#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)
        proc_mkdir(&quot;openprom&quot;, NULL);
#endif
        proc_mkdir(&quot;bus&quot;, NULL);
        ...
        ...
        ...
        if (!proc_mkdir(&quot;tty&quot;, NULL))
                 return;
        proc_mkdir(&quot;tty/ldisc&quot;, NULL);
        ...
        ...
        ...
</code></pre>
<p>In the end of the <code>proc_root_init</code> we call the <code>proc_sys_init</code> function which creates <code>/proc/sys</code> directory and initializes the <a href="http://en.wikipedia.org/wiki/Sysctl">Sysctl</a>.</p>
<p>It is the end of <code>start_kernel</code> function. I did not describe all functions which are called in the <code>start_kernel</code>. I skipped them, because they are not important for the generic kernel initialization stuff and depend on only different kernel configurations. They are <code>taskstats_init_early</code> which exports per-task statistic to the user-space, <code>delayacct_init</code> - initializes per-task delay accounting, <code>key_init</code> and <code>security_init</code> initialize different security stuff, <code>check_bugs</code> - fix some architecture-dependent bugs, <code>ftrace_init</code> function executes initialization of the <a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt">ftrace</a>, <code>cgroup_init</code> makes initialization of the rest of the <a href="http://en.wikipedia.org/wiki/Cgroups">cgroup</a> subsystem, etc. Many of these parts and subsystems will be described in the other chapters.</p>
<p>That's all. Finally we have passed through the long-long <code>start_kernel</code> function. But it is not the end of the Linux kernel initialization process. We haven't run the first process yet. In the end of the <code>start_kernel</code> we can see the last call of the - <code>rest_init</code> function. Let's go ahead.</p>
<h2 id="first-steps-after-the-start_kernel"><a class="header" href="#first-steps-after-the-start_kernel">First steps after the start_kernel</a></h2>
<p>The <code>rest_init</code> function is defined in the same source code file as <code>start_kernel</code> function, and this file is <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>. In the beginning of the <code>rest_init</code> we can see call of the two following functions:</p>
<pre><code class="language-C">	rcu_scheduler_starting();
	smpboot_thread_init();
</code></pre>
<p>The first <code>rcu_scheduler_starting</code> makes <a href="http://en.wikipedia.org/wiki/Read-copy-update">RCU</a> scheduler active and the second <code>smpboot_thread_init</code> registers the <code>smpboot_thread_notifier</code> CPU notifier (more about it you can read in the <a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">CPU hotplug documentation</a>. After this we can see the following calls:</p>
<pre><code class="language-C">kernel_thread(kernel_init, NULL, CLONE_FS);
pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);
</code></pre>
<p>Here the <code>kernel_thread</code> function (defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/fork.c">kernel/fork.c</a>) creates new kernel thread. As we can see the <code>kernel_thread</code> function takes three arguments:</p>
<ul>
<li>Function which will be executed in a new thread;</li>
<li>Parameter for the <code>kernel_init</code> function;</li>
<li>Flags.</li>
</ul>
<p>We will not dive into details about <code>kernel_thread</code> implementation (we will see it in the chapter which describe scheduler, just need to say that <code>kernel_thread</code> invokes <a href="http://www.tutorialspoint.com/unix_system_calls/clone.htm">clone</a>). Now we only need to know that we create new kernel thread with <code>kernel_thread</code> function, parent and child of the thread will use shared information about filesystem and it will start to execute <code>kernel_init</code> function. A kernel thread differs from a user thread that it runs in kernel mode. So with these two <code>kernel_thread</code> calls we create two new kernel threads with the <code>PID = 1</code> for <code>init</code> process and <code>PID = 2</code> for <code>kthreadd</code>. We already know what is <code>init</code> process. Let's look on the <code>kthreadd</code>. It is a special kernel thread which manages and helps different parts of the kernel to create another kernel thread. We can see it in the output of the <code>ps</code> util:</p>
<pre><code class="language-C">$ ps -ef | grep kthreadd
root         2     0  0 Jan11 ?        00:00:00 [kthreadd]
</code></pre>
<p>Let's postpone <code>kernel_init</code> and <code>kthreadd</code> for now and go ahead in the <code>rest_init</code>. In the next step after we have created two new kernel threads we can see the following code:</p>
<pre><code class="language-C">	rcu_read_lock();
	kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);
	rcu_read_unlock();
</code></pre>
<p>The first <code>rcu_read_lock</code> function marks the beginning of an <a href="http://en.wikipedia.org/wiki/Read-copy-update">RCU</a> read-side critical section and the <code>rcu_read_unlock</code> marks the end of an RCU read-side critical section. We call these functions because we need to protect the <code>find_task_by_pid_ns</code>. The <code>find_task_by_pid_ns</code> returns pointer to the <code>task_struct</code> by the given pid. So, here we are getting the pointer to the <code>task_struct</code> for <code>PID = 2</code> (we got it after <code>kthreadd</code> creation with the <code>kernel_thread</code>). In the next step we call <code>complete</code> function</p>
<pre><code class="language-C">complete(&amp;kthreadd_done);
</code></pre>
<p>and pass address of the <code>kthreadd_done</code>. The <code>kthreadd_done</code> defined as</p>
<pre><code class="language-C">static __initdata DECLARE_COMPLETION(kthreadd_done);
</code></pre>
<p>where <code>DECLARE_COMPLETION</code> macro defined as:</p>
<pre><code class="language-C">#define DECLARE_COMPLETION(work) \
         struct completion work = COMPLETION_INITIALIZER(work)
</code></pre>
<p>and expands to the definition of the <code>completion</code> structure. This structure is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/completion.h">include/linux/completion.h</a> and presents <code>completions</code> concept. Completions is a code synchronization mechanism which provides race-free solution for the threads that must wait for some process to have reached a point or a specific state. Using completions consists of three parts: The first is definition of the <code>complete</code> structure and we did it with the <code>DECLARE_COMPLETION</code>. The second is call of the <code>wait_for_completion</code>. After the call of this function, a thread which called it will not continue to execute and will wait while other thread did not call <code>complete</code> function. Note that we call <code>wait_for_completion</code> with the <code>kthreadd_done</code> in the beginning of the <code>kernel_init_freeable</code>:</p>
<pre><code class="language-C">wait_for_completion(&amp;kthreadd_done);
</code></pre>
<p>And the last step is to call <code>complete</code> function as we saw it above. After this the <code>kernel_init_freeable</code> function will not be executed while <code>kthreadd</code> thread will not be set. After the <code>kthreadd</code> was set, we can see three following functions in the <code>rest_init</code>:</p>
<pre><code class="language-C">	init_idle_bootup_task(current);
	schedule_preempt_disabled();
    cpu_startup_entry(CPUHP_ONLINE);
</code></pre>
<p>The first <code>init_idle_bootup_task</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/sched/core.c">kernel/sched/core.c</a> sets the Scheduling class for the current process (<code>idle</code> class in our case):</p>
<pre><code class="language-C">void init_idle_bootup_task(struct task_struct *idle)
{
         idle-&gt;sched_class = &amp;idle_sched_class;
}
</code></pre>
<p>where <code>idle</code> class is a low task priority and tasks can be run only when the processor doesn't have anything to run besides this tasks. The second function <code>schedule_preempt_disabled</code> disables preempt in <code>idle</code> tasks. And the third function <code>cpu_startup_entry</code> is defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/sched/idle.c">kernel/sched/idle.c</a> and calls <code>cpu_idle_loop</code> from the <a href="https://github.com/torvalds/linux/blob/master/kernel/sched/idle.c">kernel/sched/idle.c</a>. The <code>cpu_idle_loop</code> function works as process with <code>PID = 0</code> and works in the background. Main purpose of the <code>cpu_idle_loop</code> is to consume the idle CPU cycles. When there is no process to run, this process starts to work. We have one process with <code>idle</code> scheduling class (we just set the <code>current</code> task to the <code>idle</code> with the call of the <code>init_idle_bootup_task</code> function), so the <code>idle</code> thread does not do useful work but just checks if there is an active task to switch to:</p>
<pre><code class="language-C">static void cpu_idle_loop(void)
{
        ...
        ...
        ...
        while (1) {
                while (!need_resched()) {
                ...
                ...
                ...
                }
        ...
        }
</code></pre>
<p>More about it will be in the chapter about scheduler. So for this moment the <code>start_kernel</code> calls the <code>rest_init</code> function which spawns an <code>init</code> (<code>kernel_init</code> function) process and become <code>idle</code> process itself. Now is time to look on the <code>kernel_init</code>. Execution of the <code>kernel_init</code> function starts from the call of the <code>kernel_init_freeable</code> function. The <code>kernel_init_freeable</code> function first of all waits for the completion of the <code>kthreadd</code> setup. I already wrote about it above:</p>
<pre><code class="language-C">wait_for_completion(&amp;kthreadd_done);
</code></pre>
<p>After this we set <code>gfp_allowed_mask</code> to <code>__GFP_BITS_MASK</code> which means that system is already running, set allowed <a href="https://www.kernel.org/doc/Documentation/cgroups/cpusets.txt">cpus/mems</a> to all CPUs and <a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a> nodes with the <code>set_mems_allowed</code> function, allow <code>init</code> process to run on any CPU with the <code>set_cpus_allowed_ptr</code>, set pid for the <code>cad</code> or <code>Ctrl-Alt-Delete</code>, do preparation for booting of the other CPUs with the call of the <code>smp_prepare_cpus</code>, call early <a href="http://kernelnewbies.org/Documents/InitcallMechanism">initcalls</a> with the <code>do_pre_smp_initcalls</code>, initialize <code>SMP</code> with the <code>smp_init</code> and initialize <a href="https://www.kernel.org/doc/Documentation/lockup-watchdogs.txt">lockup_detector</a> with the call of the <code>lockup_detector_init</code> and initialize scheduler with the <code>sched_init_smp</code>.</p>
<p>After this we can see the call of the following functions - <code>do_basic_setup</code>. Before we will call the <code>do_basic_setup</code> function, our kernel already initialized for this moment. As comment says:</p>
<pre><code>Now we can finally start doing some real work..
</code></pre>
<p>The <code>do_basic_setup</code> will reinitialize <a href="https://www.kernel.org/doc/Documentation/cgroups/cpusets.txt">cpuset</a> to the active CPUs, initialize the <code>khelper</code> - which is a kernel thread which used for making calls out to userspace from within the kernel, initialize <a href="http://en.wikipedia.org/wiki/Tmpfs">tmpfs</a>, initialize <code>drivers</code> subsystem, enable the user-mode helper <code>workqueue</code>  and make post-early call of the <code>initcalls</code>. We can see opening of the <code>dev/console</code> and dup twice file descriptors from <code>0</code> to <code>2</code> after the <code>do_basic_setup</code>:</p>
<pre><code class="language-C">if (sys_open((const char __user *) &quot;/dev/console&quot;, O_RDWR, 0) &lt; 0)
	pr_err(&quot;Warning: unable to open an initial console.\n&quot;);

(void) sys_dup(0);
(void) sys_dup(0);
</code></pre>
<p>We are using two system calls here <code>sys_open</code> and <code>sys_dup</code>. In the next chapters we will see explanation and implementation of the different system calls. After we opened initial console, we check that <code>rdinit=</code> option was passed to the kernel command line or set default path of the ramdisk:</p>
<pre><code class="language-C">if (!ramdisk_execute_command)
	ramdisk_execute_command = &quot;/init&quot;;
</code></pre>
<p>Check user's permissions for the <code>ramdisk</code> and call the <code>prepare_namespace</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/do_mounts.c">init/do_mounts.c</a> which checks and mounts the <a href="http://en.wikipedia.org/wiki/Initrd">initrd</a>:</p>
<pre><code class="language-C">if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {
	ramdisk_execute_command = NULL;
	prepare_namespace();
}
</code></pre>
<p>This is the end of the <code>kernel_init_freeable</code> function and we need return to the <code>kernel_init</code>. The next step after the <code>kernel_init_freeable</code> finished its execution is the <code>async_synchronize_full</code>. This function waits until all asynchronous function calls have been done and after it we will call the <code>free_initmem</code> which will release all memory occupied by the initialization stuff which located between <code>__init_begin</code> and <code>__init_end</code>. After this we protect <code>.rodata</code> with the <code>mark_rodata_ro</code> and update state of the system from the <code>SYSTEM_BOOTING</code> to the</p>
<pre><code class="language-C">system_state = SYSTEM_RUNNING;
</code></pre>
<p>And tries to run the <code>init</code> process:</p>
<pre><code class="language-C">if (ramdisk_execute_command) {
	ret = run_init_process(ramdisk_execute_command);
	if (!ret)
		return 0;
	pr_err(&quot;Failed to execute %s (error %d)\n&quot;,
	       ramdisk_execute_command, ret);
}
</code></pre>
<p>First of all it checks the <code>ramdisk_execute_command</code> which we set in the <code>kernel_init_freeable</code> function and it will be equal to the value of the <code>rdinit=</code> kernel command line parameters or <code>/init</code> by default. The <code>run_init_process</code> function fills the first element of the <code>argv_init</code> array:</p>
<pre><code class="language-C">static const char *argv_init[MAX_INIT_ARGS+2] = { &quot;init&quot;, NULL, };
</code></pre>
<p>which represents arguments of the <code>init</code> program and call <code>do_execve</code> function:</p>
<pre><code class="language-C">argv_init[0] = init_filename;
return do_execve(getname_kernel(init_filename),
	(const char __user *const __user *)argv_init,
	(const char __user *const __user *)envp_init);
</code></pre>
<p>The <code>do_execve</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/sched.h">include/linux/sched.h</a> and runs program with the given file name and arguments. If we did not pass <code>rdinit=</code> option to the kernel command line, kernel starts to check the <code>execute_command</code> which is equal to value of the <code>init=</code> kernel command line parameter:</p>
<pre><code class="language-C">	if (execute_command) {
		ret = run_init_process(execute_command);
		if (!ret)
			return 0;
		panic(&quot;Requested init %s failed (error %d).&quot;,
		      execute_command, ret);
	}
</code></pre>
<p>If we did not pass <code>init=</code> kernel command line parameter either, kernel tries to run one of the following executable files:</p>
<pre><code class="language-C">if (!try_to_run_init_process(&quot;/sbin/init&quot;) ||
    !try_to_run_init_process(&quot;/etc/init&quot;) ||
    !try_to_run_init_process(&quot;/bin/init&quot;) ||
    !try_to_run_init_process(&quot;/bin/sh&quot;))
	return 0;
</code></pre>
<p>Otherwise we finish with <a href="http://en.wikipedia.org/wiki/Kernel_panic">panic</a>:</p>
<pre><code class="language-C">panic(&quot;No working init found.  Try passing init= option to kernel. &quot;
      &quot;See Linux Documentation/init.txt for guidance.&quot;);
</code></pre>
<p>That's all! Linux kernel initialization process is finished!</p>
<h2 id="conclusion-15"><a class="header" href="#conclusion-15">Conclusion</a></h2>
<p>It is the end of the tenth part about the Linux kernel <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">initialization process</a>. It is not only the <code>tenth</code> part, but also is the last part which describes initialization of the linux kernel. As I wrote in the first <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">part</a> of this chapter, we will go through all steps of the kernel initialization and we did it. We started at the first architecture-independent function - <code>start_kernel</code> and finished with the launch of the first <code>init</code> process in the our system. I skipped details about different subsystem of the kernel, for example I almost did not cover scheduler, interrupts, exception handling, etc. From the next part we will start to dive to the different kernel subsystems. Hope it will be interesting.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-15"><a class="header" href="#links-15">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Slab_allocation">SLAB</a></li>
<li><a href="http://www.felixcloutier.com/x86/XSAVES.html">xsave</a></li>
<li><a href="http://en.wikipedia.org/wiki/Floating-point_unit">FPU</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/Documentation/security/credentials.rst">Documentation/security/credentials.txt</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/x86_64/mm.txt">Documentation/x86/x86_64/mm</a></li>
<li><a href="http://en.wikipedia.org/wiki/Read-copy-update">RCU</a></li>
<li><a href="http://en.wikipedia.org/wiki/Virtual_file_system">VFS</a></li>
<li><a href="http://en.wikipedia.org/wiki/Inode">inode</a></li>
<li><a href="http://en.wikipedia.org/wiki/Procfs">proc</a></li>
<li><a href="http://linux.die.net/man/5/proc">man proc</a></li>
<li><a href="http://en.wikipedia.org/wiki/Sysctl">Sysctl</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/trace/ftrace.txt">ftrace</a></li>
<li><a href="http://en.wikipedia.org/wiki/Cgroups">cgroup</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">CPU hotplug documentation</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/scheduler/completion.txt">completions - wait for completion handling</a></li>
<li><a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cgroups/cpusets.txt">cpus/mems</a></li>
<li><a href="http://kernelnewbies.org/Documents/InitcallMechanism">initcalls</a></li>
<li><a href="http://en.wikipedia.org/wiki/Tmpfs">Tmpfs</a></li>
<li><a href="http://en.wikipedia.org/wiki/Initrd">initrd</a></li>
<li><a href="http://en.wikipedia.org/wiki/Kernel_panic">panic</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-9">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts-and-interrupt-handling"><a class="header" href="#interrupts-and-interrupt-handling">Interrupts and Interrupt Handling</a></h1>
<p>In the following posts, we will cover interrupts and exceptions handling in the Linux kernel.</p>
<ul>
<li><a href="Interrupts/linux-interrupts-1.html">Interrupts and Interrupt Handling. Part 1.</a> - describes interrupts and interrupt handling theory.</li>
<li><a href="Interrupts/linux-interrupts-2.html">Interrupts in the Linux Kernel</a> - describes stuffs related to interrupts and exceptions handling from the early stage.</li>
<li><a href="Interrupts/linux-interrupts-3.html">Early interrupt handlers</a> - describes early interrupt handlers.</li>
<li><a href="Interrupts/linux-interrupts-4.html">Interrupt handlers</a> - describes first non-early interrupt handlers.</li>
<li><a href="Interrupts/linux-interrupts-5.html">Implementation of exception handlers</a> - describes implementation of some exception handlers such as double fault, divide by zero etc.</li>
<li><a href="Interrupts/linux-interrupts-6.html">Handling non-maskable interrupts</a> - describes handling of non-maskable interrupts and remaining interrupt handlers from the architecture-specific part.</li>
<li><a href="Interrupts/linux-interrupts-7.html">External hardware interrupts</a> - describes early initialization of code which is related to handling external hardware interrupts.</li>
<li><a href="Interrupts/linux-interrupts-8.html">Non-early initialization of the IRQs</a> - describes non-early initialization of code which is related to handling external hardware interrupts.</li>
<li><a href="Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a> - describes softirqs, tasklets and workqueues concepts.</li>
<li><a href="Interrupts/linux-interrupts-10.html">Last part</a> - this is the last part of the <code>Interrupts and Interrupt Handling</code> chapter and here we will see a real hardware driver and some interrupts related stuff.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts-and-interrupt-handling-part-1"><a class="header" href="#interrupts-and-interrupt-handling-part-1">Interrupts and Interrupt Handling. Part 1.</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>This is the first part of the new chapter of the <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">linux insides</a> book. We have come a long way in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">chapter</a> of this book. We started from the earliest <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">steps</a> of kernel initialization and finished with the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-10">launch</a> of the first <code>init</code> process. Yes, we saw several initialization steps which are related to the various kernel subsystems. But we did not dig deep into the details of these subsystems. With this chapter, we will try to understand how the various kernel subsystems work and how they are implemented. As you can already understand from the chapter's title, the first subsystem will be <a href="http://en.wikipedia.org/wiki/Interrupt">interrupts</a>.</p>
<h2 id="what-is-an-interrupt"><a class="header" href="#what-is-an-interrupt">What is an Interrupt?</a></h2>
<p>We have already heard of the word <code>interrupt</code> in several parts of this book. We even saw a couple of examples of interrupt handlers. In the current chapter we will start from the theory, i.e.</p>
<ul>
<li>What are <code>interrupts</code> ?</li>
<li>What are <code>interrupt handlers</code>?</li>
</ul>
<p>We will then continue to dig deeper into the details of <code>interrupts</code> and how the Linux kernel handles them.</p>
<p>The first question that arises in our mind when we come across word <code>interrupt</code> is <code>What is an interrupt?</code> An interrupt is an <code>event</code> raised by software or hardware when it needs the CPU's attention. For example, we press a button on the keyboard and what do we expect next? What should the operating system and computer do after this? To simplify matters, assume that each peripheral device has an interrupt line to the CPU. A device can use it to signal an interrupt to the CPU. However, interrupts are not signaled directly to the CPU. In the old machines there was a <a href="http://en.wikipedia.org/wiki/Programmable_Interrupt_Controller">PIC</a> which is a chip responsible for sequentially processing multiple interrupt requests from multiple devices. In the new machines there is an <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">Advanced Programmable Interrupt Controller</a> commonly known as - <code>APIC</code>. An <code>APIC</code> consists of two separate devices:</p>
<ul>
<li><code>Local APIC</code></li>
<li><code>I/O APIC</code></li>
</ul>
<p>The first - <code>Local APIC</code> is located on each CPU core. The local APIC is responsible for handling the CPU-specific interrupt configuration. The local APIC is usually used to manage interrupts from the APIC-timer, thermal sensor and any other such locally connected I/O devices.</p>
<p>The second - <code>I/O APIC</code> provides multi-processor interrupt management. It is used to distribute external interrupts among the CPU cores. More about the local and I/O APICs will be covered later in this chapter. As you can understand, interrupts can occur at any time. When an interrupt occurs, the operating system must handle it immediately. But what does it mean <code>to handle an interrupt</code>? When an interrupt occurs, the  operating system must ensure the following steps:</p>
<ul>
<li>The kernel must pause execution of the current process; (preempt current task);</li>
<li>The kernel must search for the handler of the interrupt and transfer control (execute interrupt handler);</li>
<li>After the interrupt handler completes execution, the interrupted process can resume execution.</li>
</ul>
<p>Of course there are numerous intricacies involved in this procedure of handling interrupts. But the above 3 steps form the basic skeleton of the procedure.</p>
<p>Addresses of each of the interrupt handlers are maintained in a special location referred to as the - <code>Interrupt Descriptor Table</code> or <code>IDT</code>. The processor uses a unique number for recognizing the type of interruption or exception. This number is called - <code>vector number</code>. A vector number is an index in the <code>IDT</code>. There is a limited amount of the vector numbers and it can be from <code>0</code> to <code>255</code>. You can note the following range-check upon the vector number within the Linux kernel source-code:</p>
<pre><code class="language-C">BUG_ON((unsigned)n &gt; 0xFF);
</code></pre>
<p>You can find this check within the Linux kernel source code related to interrupt setup (e.g. The <code>set_intr_gate</code> in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/idt.c">arch/x86/kernel/idt.c</a>). The first 32 vector numbers from <code>0</code> to <code>31</code> are reserved by the processor and used for the processing of architecture-defined exceptions and interrupts. You can find the table with the description of these vector numbers in the second part of the Linux kernel initialization process - <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-2">Early interrupt and exception handling</a>. Vector numbers from <code>32</code> to <code>255</code> are designated as user-defined interrupts and are not reserved by the processor. These interrupts are generally assigned to external I/O devices to enable those devices to send interrupts to the processor.</p>
<p>Now let's talk about the types of interrupts. Broadly speaking, we can split interrupts into 2 major classes:</p>
<ul>
<li>External or hardware generated interrupts</li>
<li>Software-generated interrupts</li>
</ul>
<p>The first - external interrupts are received through the <code>Local APIC</code> or pins on the processor which are connected to the <code>Local APIC</code>. The second - software-generated interrupts are caused by an exceptional condition in the processor itself (sometimes using special architecture-specific instructions). A common example of an exceptional condition is <code>division by zero</code>. Another example is exiting a program with the <code>syscall</code> instruction.</p>
<p>As mentioned earlier, an interrupt can occur at any time for a reason which the code and CPU have no control over. On the other hand, exceptions are <code>synchronous</code> with program execution and can be classified into 3 categories:</p>
<ul>
<li><code>Faults</code></li>
<li><code>Traps</code></li>
<li><code>Aborts</code></li>
</ul>
<p>A <code>fault</code> is an exception reported before the execution of a &quot;faulty&quot; instruction (which can then be corrected). If correct, it allows the interrupted program to resume.</p>
<p>Next a <code>trap</code> is an exception, which is reported immediately following the execution of the <code>trap</code> instruction. Traps also allow the interrupted program to be continued just as a <code>fault</code> does.</p>
<p>Finally, an <code>abort</code> is an exception that does not always report the exact instruction which caused the exception and does not allow the interrupted program to be resumed.</p>
<p>Also, we already know from the previous <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-3">part</a> that interrupts can be classified as <code>maskable</code> and <code>non-maskable</code>. Maskable interrupts are interrupts which can be blocked with the two following instructions for <code>x86_64</code> - <code>sti</code> and <code>cli</code>. We can find them in the Linux kernel source code:</p>
<pre><code class="language-C">static inline void native_irq_disable(void)
{
        asm volatile(&quot;cli&quot;: : :&quot;memory&quot;);
}
</code></pre>
<p>and</p>
<pre><code class="language-C">static inline void native_irq_enable(void)
{
        asm volatile(&quot;sti&quot;: : :&quot;memory&quot;);
}
</code></pre>
<p>These two instructions modify the <code>IF</code> flag bit within the interrupt register. The <code>sti</code> instruction sets the <code>IF</code> flag and the <code>cli</code> instruction clears this flag. Non-maskable interrupts are always reported. Usually any failure in the hardware is mapped to such non-maskable interrupts.</p>
<p>If multiple exceptions or interrupts occur at the same time, the processor handles them in order of their predefined priorities. We can determine the priorities from the highest to the lowest in the following table:</p>
<pre><code>+----------------------------------------------------------------+
|              |                                                 |
|   Priority   | Description                                     |
|              |                                                 |
+--------------+-------------------------------------------------+
|              | Hardware Reset and Machine Checks               |
|     1        | - RESET                                         |
|              | - Machine Check                                 |
+--------------+-------------------------------------------------+
|              | Trap on Task Switch                             |
|     2        | - T flag in TSS is set                          |
|              |                                                 |
+--------------+-------------------------------------------------+
|              | External Hardware Interventions                 |
|              | - FLUSH                                         |
|     3        | - STOPCLK                                       |
|              | - SMI                                           |
|              | - INIT                                          |
+--------------+-------------------------------------------------+
|              | Traps on the Previous Instruction               |
|     4        | - Breakpoints                                   |
|              | - Debug Trap Exceptions                         |
+--------------+-------------------------------------------------+
|     5        | Nonmaskable Interrupts                          |
+--------------+-------------------------------------------------+
|     6        | Maskable Hardware Interrupts                    |
+--------------+-------------------------------------------------+
|     7        | Code Breakpoint Fault                           |
+--------------+-------------------------------------------------+
|     8        | Faults from Fetching Next Instruction           |
|              | Code-Segment Limit Violation                    |
|              | Code Page Fault                                 |
+--------------+-------------------------------------------------+
|              | Faults from Decoding the Next Instruction       |
|              | Instruction length &gt; 15 bytes                   |
|     9        | Invalid Opcode                                  |
|              | Coprocessor Not Available                       |
|              |                                                 |
+--------------+-------------------------------------------------+
|     10       | Faults on Executing an Instruction              |
|              | Overflow                                        |
|              | Bound error                                     |
|              | Invalid TSS                                     |
|              | Segment Not Present                             |
|              | Stack fault                                     |
|              | General Protection                              |
|              | Data Page Fault                                 |
|              | Alignment Check                                 |
|              | x87 FPU Floating-point exception                |
|              | SIMD floating-point exception                   |
|              | Virtualization exception                        |
+--------------+-------------------------------------------------+
</code></pre>
<p>Now that we know a little about the various types of interrupts and exceptions, it is time to move on to a more practical part. We start with the description of the <code>Interrupt Descriptor Table</code>. As mentioned earlier, the <code>IDT</code> stores entry points of the interrupts and exceptions handlers. The <code>IDT</code> is similar in structure to the <code>Global Descriptor Table</code> which we saw in the second part of the <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-2">Kernel booting process</a>. But of course it has some differences. Instead of <code>descriptors</code>, the <code>IDT</code> entries are called <code>gates</code>. It can contain one of the following gates:</p>
<ul>
<li>Interrupt gates</li>
<li>Task gates</li>
<li>Trap gates.</li>
</ul>
<p>In the <code>x86</code> architecture. Only <a href="http://en.wikipedia.org/wiki/Long_mode">long mode</a> interrupt gates and trap gates can be referenced in the <code>x86_64</code>. Like the <code>Global Descriptor Table</code>, the <code>Interrupt Descriptor table</code> is an array of 8-byte gates on <code>x86</code> and an array of 16-byte gates on <code>x86_64</code>. We can remember from the second part of the <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-2">Kernel booting process</a>, that <code>Global Descriptor Table</code> must contain <code>NULL</code> descriptor as its first element. Unlike the <code>Global Descriptor Table</code>, the <code>Interrupt Descriptor Table</code> may contain a gate; it is not mandatory. For example, you may remember that we have loaded the Interrupt Descriptor table with the <code>NULL</code> gates only in the earlier <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-3">part</a> while transitioning into <a href="http://en.wikipedia.org/wiki/Protected_mode">protected mode</a>:</p>
<pre><code class="language-C">/*
 * Set up the IDT
 */
static void setup_idt(void)
{
	static const struct gdt_ptr null_idt = {0, 0};
	asm volatile(&quot;lidtl %0&quot; : : &quot;m&quot; (null_idt));
}
</code></pre>
<p>From the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/pm.c">arch/x86/boot/pm.c</a>. The <code>Interrupt Descriptor table</code> can be located anywhere in the linear address space and the base address of it must be aligned on an 8-byte boundary on <code>x86</code> or 16-byte boundary on <code>x86_64</code>. The base address of the <code>IDT</code> is stored in the special register - <code>IDTR</code>. There are two instructions on <code>x86</code>-compatible processors to modify the <code>IDTR</code> register:</p>
<ul>
<li><code>LIDT</code></li>
<li><code>SIDT</code></li>
</ul>
<p>The first instruction <code>LIDT</code> is used to load the base-address of the <code>IDT</code> i.e., the specified operand into the <code>IDTR</code>. The second instruction <code>SIDT</code> is used to read and store the contents of the <code>IDTR</code> into the specified operand. The <code>IDTR</code> register is 48-bits on the <code>x86</code> and contains the following information:</p>
<pre><code>+-----------------------------------+----------------------+
|                                   |                      |
|     Base address of the IDT       |   Limit of the IDT   |
|                                   |                      |
+-----------------------------------+----------------------+
47                                16 15                    0
</code></pre>
<p>Looking at the implementation of <code>setup_idt</code>, we have prepared a <code>null_idt</code> and loaded it to the <code>IDTR</code> register with the <code>lidt</code> instruction. Note that <code>null_idt</code> has <code>gdt_ptr</code> type which is defined as:</p>
<pre><code class="language-C">struct gdt_ptr {
        u16 len;
        u32 ptr;
} __attribute__((packed));
</code></pre>
<p>Here we can see the definition of the structure with the two fields of 2-bytes and 4-bytes each (a total of 48-bits) as we can see in the diagram. Now let's look at the <code>IDT</code> entries structure. The <code>IDT</code> entries structure is an array of the 16-byte entries which are called gates in the <code>x86_64</code>. They have the following structure:</p>
<pre><code>127                                                                             96
+-------------------------------------------------------------------------------+
|                                                                               |
|                                Reserved                                       |
|                                                                               |
+--------------------------------------------------------------------------------
95                                                                              64
+-------------------------------------------------------------------------------+
|                                                                               |
|                               Offset 63..32                                   |
|                                                                               |
+-------------------------------------------------------------------------------+
63                               48 47      46  44   42    39             34    32
+-------------------------------------------------------------------------------+
|                                  |       |  D  |   |     |      |   |   |     |
|       Offset 31..16              |   P   |  P  | 0 |Type |0 0 0 | 0 | 0 | IST |
|                                  |       |  L  |   |     |      |   |   |     |
 -------------------------------------------------------------------------------+
31                                   16 15                                      0
+-------------------------------------------------------------------------------+
|                                      |                                        |
|          Segment Selector            |                 Offset 15..0           |
|                                      |                                        |
+-------------------------------------------------------------------------------+
</code></pre>
<p>To form an index into the IDT, the processor scales the exception or interrupt vector by sixteen. The processor handles the occurrence of exceptions and interrupts just like it handles calls of a procedure when it sees the <code>call</code> instruction. A processor uses a unique number or <code>vector number</code> of the interrupt or the exception as the index to find the necessary <code>Interrupt Descriptor Table</code> entry. Now let's take a closer look at an <code>IDT</code> entry.</p>
<p>As we can see, <code>IDT</code> entry on the diagram consists of the following fields:</p>
<ul>
<li><code>0-15</code> bits  - offset from the segment selector which is used by the processor as the base address of the entry point of the interrupt handler;</li>
<li><code>16-31</code> bits - base address of the segment select which contains the entry point of the interrupt handler;</li>
<li><code>IST</code> - a new special mechanism in the <code>x86_64</code>, which is described below;</li>
<li><code>DPL</code> - Descriptor Privilege Level;</li>
<li><code>P</code> - Segment Present flag;</li>
<li><code>48-63</code> bits - the second part of the handler base address;</li>
<li><code>64-95</code> bits - the third part of the base address of the handler;</li>
<li><code>96-127</code> bits - and the last bits are reserved by the CPU.</li>
</ul>
<p>And the last <code>Type</code> field describes the type of the <code>IDT</code> entry. There are three different kinds of handlers for interrupts:</p>
<ul>
<li>Interrupt gate</li>
<li>Trap gate</li>
<li>Task gate</li>
</ul>
<p>The <code>IST</code> or <code>Interrupt Stack Table</code> is a new mechanism in the <code>x86_64</code>. It is used as an alternative to the legacy stack-switch mechanism. Previously the <code>x86</code> architecture provided a mechanism to automatically switch stack frames in response to an interrupt. The <code>IST</code> is a modified version of the <code>x86</code> Stack switching mode. This mechanism unconditionally switches stacks when it is enabled and can be enabled for any interrupt in the <code>IDT</code> entry related with the certain interrupt (we will soon see it). From this we can understand that <code>IST</code> is not necessary for all interrupts. Some interrupts can continue to use the legacy stack switching mode. The <code>IST</code> mechanism provides up to seven <code>IST</code> pointers in the <a href="http://en.wikipedia.org/wiki/Task_state_segment">Task State Segment</a> or <code>TSS</code> which is the special structure which contains information about a process. The <code>TSS</code> is used for stack switching during the execution of an interrupt or exception handler in the Linux kernel. Each pointer is referenced by an interrupt gate from the <code>IDT</code>.</p>
<p>The <code>Interrupt Descriptor Table</code> represented by the array of the <code>gate_desc</code> structures:</p>
<pre><code class="language-C">extern gate_desc idt_table[];
</code></pre>
<p>where <code>gate_struct</code> is defined as:
<a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/desc_defs.h">/arch/x86/include/asm/desc_defs.h</a></p>
<pre><code class="language-C">struct gate_struct {
	u16		offset_low;
	u16		segment;
	struct idt_bits	bits;
	u16		offset_middle;
#ifdef CONFIG_X86_64
	u32		offset_high;
	u32		reserved;
#endif
} __attribute__((packed));
</code></pre>
<p>Each active thread has a large stack in the Linux kernel for the <code>x86_64</code> architecture. The stack size is defined as <code>THREAD_SIZE</code> and is equal to:</p>
<pre><code class="language-C">#define PAGE_SHIFT      12
#define PAGE_SIZE       (_AC(1,UL) &lt;&lt; PAGE_SHIFT)
...
...
...
#define THREAD_SIZE_ORDER       (2 + KASAN_STACK_ORDER)
#define THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)
</code></pre>
<p>The <code>PAGE_SIZE</code> is <code>4096</code>-bytes and the <code>THREAD_SIZE_ORDER</code> depends on the <code>KASAN_STACK_ORDER</code>. As we can see, the <code>KASAN_STACK</code> depends on the <code>CONFIG_KASAN</code> kernel configuration parameter and is defined as:</p>
<pre><code class="language-C">#ifdef CONFIG_KASAN
    #define KASAN_STACK_ORDER 1
#else
    #define KASAN_STACK_ORDER 0
#endif
</code></pre>
<p><code>KASan</code> is a runtime memory <a href="http://lwn.net/Articles/618180/">debugger</a>. Thus, the <code>THREAD_SIZE</code> will be <code>16384</code> bytes if <code>CONFIG_KASAN</code> is disabled or <code>32768</code> if this kernel configuration option is enabled. These stacks contain useful data as long as a thread is alive or in a zombie state. While the thread is in user-space, the kernel stack is empty except for the <code>thread_info</code> structure (details about this structure are available in the fourth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">part</a> of the Linux kernel initialization process) at the end of the stack. The active or zombie threads aren't the only threads with their own stack. There also exist specialized stacks that are associated with each available CPU. These stacks are active when the kernel is executing on that CPU. When the user-space is executing on the CPU, these stacks do not contain any useful information. Each CPU has a few special per-cpu stacks as well. The first is the <code>interrupt stack</code> used for the external hardware interrupts. Its size is determined as follows:</p>
<pre><code class="language-C">#define IRQ_STACK_ORDER (2 + KASAN_STACK_ORDER)
#define IRQ_STACK_SIZE (PAGE_SIZE &lt;&lt; IRQ_STACK_ORDER)
</code></pre>
<p>Or <code>16384</code> bytes. The per-cpu interrupt stack is represented by the <code>irq_stack</code> struct and the <code>fixed_percpu_data</code> struct in the Linux kernel for <code>x86_64</code>:</p>
<pre><code class="language-C">/* Per CPU interrupt stacks */
struct irq_stack {
	char		stack[IRQ_STACK_SIZE];
} __aligned(IRQ_STACK_SIZE);
</code></pre>
<pre><code class="language-C">#ifdef CONFIG_X86_64
struct fixed_percpu_data {
	/*
	 * GCC hardcodes the stack canary as %gs:40.  Since the
	 * irq_stack is the object at %gs:0, we reserve the bottom
	 * 48 bytes of the irq stack for the canary.
	 */
	char		gs_base[40];
	unsigned long	stack_canary;
};
...
#endif
</code></pre>
<p>The <code>irq_stack</code> struct contains a 16 kilobytes array.
Also, you can see that the fixed_percpu_data contains two fields:</p>
<ul>
<li><code>gs_base</code> - The <code>gs</code> register always points to the bottom of the <code>fixed_percpu_data</code>. On the <code>x86_64</code>, the <code>gs</code> register is shared by per-cpu area and stack canary (more about <code>per-cpu</code> variables you can read in the special <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">part</a>).  All per-cpu symbols are zero-based and the <code>gs</code> points to the base of the per-cpu area. You already know that <a href="http://en.wikipedia.org/wiki/Memory_segmentation">segmented memory model</a> is abolished in the long mode, but we can set the base address for the two segment registers - <code>fs</code> and <code>gs</code> with the <a href="http://en.wikipedia.org/wiki/Model-specific_register">Model specific registers</a> and these registers can be still be used as address registers. If you remember the first <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">part</a> of the Linux kernel initialization process, you can remember that we have set the <code>gs</code> register:</li>
</ul>
<pre><code class="language-assembly">	movl	$MSR_GS_BASE,%ecx
	movl	initial_gs(%rip),%eax
	movl	initial_gs+4(%rip),%edx
	wrmsr
</code></pre>
<p>where <code>initial_gs</code> points to the <code>fixed_percpu_data</code>:</p>
<pre><code class="language-assembly">SYM_DATA(initial_gs,	.quad INIT_PER_CPU_VAR(fixed_percpu_data))
</code></pre>
<ul>
<li><code>stack_canary</code> - <a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries">Stack canary</a> for the interrupt stack is a <code>stack protector</code>
to verify that the stack hasn't been overwritten. Note that <code>gs_base</code> is a 40 bytes array. <code>GCC</code> requires that stack canary will be on the fixed offset from the base of the <code>gs</code> and its value must be <code>40</code> for the <code>x86_64</code> and <code>20</code> for the <code>x86</code>.</li>
</ul>
<p>The <code>fixed_percpu_data</code> is the first datum in the <code>percpu</code> area, we can see it in the <code>System.map</code>:</p>
<pre><code>0000000000000000 D __per_cpu_start
0000000000000000 D fixed_percpu_data
00000000000001e0 A kexec_control_code_size
0000000000001000 D cpu_debug_store
0000000000002000 D irq_stack_backing_store
0000000000006000 D cpu_tss_rw
0000000000009000 D gdt_page
000000000000a000 d exception_stacks
...
...
...
</code></pre>
<p>We can see its definition in the code:</p>
<pre><code class="language-C">DECLARE_PER_CPU_FIRST(struct fixed_percpu_data, fixed_percpu_data) __visible;
</code></pre>
<p>Now, it's time to look at the initialization of the <code>fixed_percpu_data</code>. Besides the <code>fixed_percpu_data</code> definition, we can see the definition of the following per-cpu variables in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/processor.h">arch/x86/include/asm/processor.h</a>:</p>
<pre><code class="language-C">DECLARE_PER_CPU(struct irq_stack *, hardirq_stack_ptr);
...
DECLARE_PER_CPU(unsigned int, irq_count);
...
/* Per CPU softirq stack pointer */
DECLARE_PER_CPU(struct irq_stack *, softirq_stack_ptr);
</code></pre>
<p>The first and third are the stack pointers for hardware and software interrupts. It is obvious from the name of the variables, that these point to the top of stacks. The second - <code>irq_count</code> is used to check if a CPU is already on an interrupt stack or not. Initialization of the <code>hardirq_stack_ptr</code> is located in the <code>irq_init_percpu_irqstack</code> function in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/irq_64.c">arch/x86/kernel/irq_64.c</a>:</p>
<pre><code class="language-C">int irq_init_percpu_irqstack(unsigned int cpu)
{
	if (per_cpu(hardirq_stack_ptr, cpu))
		return 0;
	return map_irq_stack(cpu);
}
</code></pre>
<p>Here we go over all the CPUs one-by-one and setup the <code>hardirq_stack_ptr</code>.<br />
Where <code>map_irq_stack</code> is called to initialize the <code>hardirq_stack_ptr</code>,<br />
to point onto the <code>irq_stack_backing_store</code> of the current CPU with an offset of IRQ_STACK_SIZE,<br />
either with guard pages or without when KASan is enabled.</p>
<p>After the initialization of the interrupt stack, we need to initialize the gs register within <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/cpu/common.c">arch/x86/kernel/cpu/common.c</a>:</p>
<pre><code class="language-C">void load_percpu_segment(int cpu)
{
        ...
        ...
        ...
        __loadsegment_simple(gs, 0);
        wrmsrl(MSR_GS_BASE, cpu_kernelmode_gs_base(cpu));
        ...
        load_stack_canary_segment();
}
</code></pre>
<p>and as we already know the <code>gs</code> register points to the bottom of the interrupt stack.</p>
<pre><code class="language-assembly">	movl	$MSR_GS_BASE,%ecx
	movl	initial_gs(%rip),%eax
	movl	initial_gs+4(%rip),%edx
	wrmsr

    SYM_DATA(initial_gs,
    .quad INIT_PER_CPU_VAR(fixed_percpu_data))
</code></pre>
<p>Here we can see the <code>wrmsr</code> instruction, which loads the data from <code>edx:eax</code> into the <a href="http://en.wikipedia.org/wiki/Model-specific_register">Model specific register</a> pointed by the <code>ecx</code> register. In our case the model specific register is <code>MSR_GS_BASE</code>, which contains the base address of the memory segment pointed to by the <code>gs</code> register. <code>edx:eax</code> points to the address of the <code>initial_gs,</code> which is the base address of our <code>fixed_percpu_data</code>.</p>
<p>We already know that <code>x86_64</code> has a feature called <code>Interrupt Stack Table</code> or <code>IST</code> and this feature provides the ability to switch to a new stack for events like a non-maskable interrupt, double fault, etc. There can be up to seven <code>IST</code> entries per-cpu. Some of them are:</p>
<ul>
<li><code>DOUBLEFAULT_STACK</code></li>
<li><code>NMI_STACK</code></li>
<li><code>DEBUG_STACK</code></li>
<li><code>MCE_STACK</code></li>
</ul>
<p>or</p>
<pre><code class="language-C">#define DOUBLEFAULT_STACK 1
#define NMI_STACK 2
#define DEBUG_STACK 3
#define MCE_STACK 4
</code></pre>
<p>All interrupt-gate descriptors, which switch to a new stack with the <code>IST</code>, are initialized within the <code>idt_setup_from_table</code> function. That function initializes every gate descriptor within the <code>struct idt_data def_idts[]</code> array.
For example:</p>
<pre><code class="language-C">static const __initconst struct idt_data def_idts[] = {
    ...
	INTG(X86_TRAP_NMI,		nmi),
    ...
	INTG(X86_TRAP_DF,		double_fault),
</code></pre>
<p>where <code>nmi</code> and <code>double_fault</code> are entry points created at <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S">arch/x86/kernel/entry_64.S</a>:</p>
<pre><code class="language-assembly">idtentry double_fault			do_double_fault			has_error_code=1 paranoid=2 read_cr2=1
...
...
...
SYM_CODE_START(nmi)
...
...
...
SYM_CODE_END(nmi)
</code></pre>
<p>for the the given interrupt handlers declared at <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/traps.h">arch/x86/include/asm/traps.h</a>:</p>
<pre><code class="language-C">asmlinkage void nmi(void);
asmlinkage void double_fault(void);
</code></pre>
<p>When an interrupt or an exception occurs, the new <code>ss</code> selector is forced to <code>NULL</code> and the <code>ss</code> selector’s <code>rpl</code> field is set to the new <code>cpl</code>. The old <code>ss</code>, <code>rsp</code>, register flags, <code>cs</code>, <code>rip</code> are pushed onto the new stack. In 64-bit mode, the size of interrupt stack-frame pushes is fixed at 8-bytes, so that we will get the following stack:</p>
<pre><code>+---------------+
|               |
|      SS       | 40
|      RSP      | 32
|     RFLAGS    | 24
|      CS       | 16
|      RIP      | 8
|   Error code  | 0
|               |
+---------------+
</code></pre>
<p>If the <code>IST</code> field in the interrupt gate is not <code>0</code>, we read the <code>IST</code> pointer into <code>rsp</code>. If the interrupt vector number has an error code associated with it, we then push the error code onto the stack. If the interrupt vector number has no error code, we go ahead and push the dummy error code on to the stack. We need to do this to ensure stack consistency. Next, we load the segment-selector field from the gate descriptor into the CS register and must verify that the target code-segment is a 64-bit mode code segment by the checking bit <code>21</code> i.e. the <code>L</code> bit in the <code>Global Descriptor Table</code>. Finally, we load the offset field from the gate descriptor into <code>rip</code> which will be the entry-point of the interrupt handler. After this the interrupt handler begins to execute and when the interrupt handler finishes its execution, it must return control to the interrupted process with the <code>iret</code> instruction. The <code>iret</code> instruction unconditionally pops the stack pointer (<code>ss:rsp</code>) to restore the stack of the interrupted process and does not depend on the <code>cpl</code> change.</p>
<p>That's all.</p>
<h2 id="conclusion-16"><a class="header" href="#conclusion-16">Conclusion</a></h2>
<p>It is the end of the first part of <code>Interrupts and Interrupt Handling</code> in the Linux kernel. We covered some theory and the first steps of initialization of stuff related to interrupts and exceptions. In the next part we will continue to dive into the more practical aspects of interrupts and interrupt handling.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-16"><a class="header" href="#links-16">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Programmable_Interrupt_Controller">PIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">Advanced Programmable Interrupt Controller</a></li>
<li><a href="http://en.wikipedia.org/wiki/Protected_mode">protected mode</a></li>
<li><a href="http://en.wikipedia.org/wiki/Long_mode">long mode</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/x86/kernel-stacks">kernel stacks</a></li>
<li><a href="http://en.wikipedia.org/wiki/Task_state_segment">Task State Segment</a></li>
<li><a href="http://en.wikipedia.org/wiki/Memory_segmentation">segmented memory model</a></li>
<li><a href="http://en.wikipedia.org/wiki/Model-specific_register">Model specific registers</a></li>
<li><a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries">Stack canary</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/initialization">Previous chapter</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts-and-interrupt-handling-part-2"><a class="header" href="#interrupts-and-interrupt-handling-part-2">Interrupts and Interrupt Handling. Part 2.</a></h1>
<h2 id="start-to-dive-into-interrupt-and-exceptions-handling-in-the-linux-kernel"><a class="header" href="#start-to-dive-into-interrupt-and-exceptions-handling-in-the-linux-kernel">Start to dive into interrupt and exceptions handling in the Linux kernel</a></h2>
<p>We saw some theory about interrupts and exception handling in the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-1">introduction</a> and as I mentioned in that part, we will now start to dive into interrupts and exceptions within the Linux kernel source code. We'll commence by initializing the basic components as we did in the other chapters. But, we will not see the Linux kernel source code from the very early <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/header.S#L292">code lines</a>, as this was presented in the example within the <a href="https://0xax.gitbook.io/linux-insides/summary/booting">Linux kernel booting process</a> chapter. In the beginning we will deal with the first sections of the Linux kernel source code, which are related to interrupts and exceptions.</p>
<p>If you've read the previous parts, you can remember that the earliest place in the Linux kernel <code>x86_64</code> architecture-specific source code, which is related to the interrupt is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/pm.c">arch/x86/boot/pm.c</a> source code file and represents the first setup of the <a href="http://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt Descriptor Table</a>. It occurs right before the transition into the <a href="http://en.wikipedia.org/wiki/Protected_mode">protected mode</a> in the <code>go_to_protected_mode</code> function by calling <code>setup_idt</code>:</p>
<pre><code class="language-C">void go_to_protected_mode(void)
{
	...
	setup_idt();
	...
}
</code></pre>
<p>The <code>setup_idt</code> function is defined in the same source code file as the <code>go_to_protected_mode</code> function and just loads the address of the <code>NULL</code> interrupt descriptor table:</p>
<pre><code class="language-C">static void setup_idt(void)
{
	static const struct gdt_ptr null_idt = {0, 0};
	asm volatile(&quot;lidtl %0&quot; : : &quot;m&quot; (null_idt));
}
</code></pre>
<p>where <code>gdt_ptr</code> represents a special 48-bit <code>GDTR</code> register, which must contain the base address of the <code>Global Descriptor Table</code>:</p>
<pre><code class="language-C">struct gdt_ptr {
	u16 len;
	u32 ptr;
} __attribute__((packed));
</code></pre>
<p>Of course in our case the <code>gdt_ptr</code> does not represent the <code>GDTR</code> register, but <code>IDTR</code> since we set the <code>Interrupt Descriptor Table</code>. You will not find an <code>idt_ptr</code> structure, because if it had been in the Linux kernel source code, it would have been the same as a <code>gdt_ptr</code> but with a different name. It would make no sense to create two structures that only differ in their names. Note here that we do not fill the <code>Interrupt Descriptor Table</code> with entries, because it is too early to handle any interrupts or exceptions at this point. That's why we just fill the <code>IDT</code> with <code>NULL</code>.</p>
<p>After the setup of the <a href="http://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt descriptor table</a>, <a href="http://en.wikipedia.org/wiki/GDT">Global Descriptor Table</a> and other stuff we jump into <a href="http://en.wikipedia.org/wiki/Protected_mode">protected mode</a> in the - <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/pmjump.S">arch/x86/boot/pmjump.S</a> file. You can read more about it in the <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-3">part</a>, which describes the transition to protected mode.</p>
<p>The entry to protected mode is located in the <code>boot_params.hdr.code32_start</code> and passed together with the <code>boot_params</code> to the <code>protected_mode_jump</code> function at the end of <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/pm.c">arch/x86/boot/pm.c</a>:</p>
<pre><code class="language-C">protected_mode_jump(boot_params.hdr.code32_start,
			    (u32)&amp;boot_params + (ds() &lt;&lt; 4));
</code></pre>
<p>The <code>protected_mode_jump</code> function is defined at <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/pmjump.S">arch/x86/boot/pmjump.S</a> and receives these two parameters within the <code>ax</code> and <code>dx</code> registers, using one of the <a href="http://en.wikipedia.org/wiki/Intel_8086">8086</a> calling  <a href="http://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions">conventions</a>:</p>
<pre><code class="language-assembly">SYM_FUNC_START_NOALIGN(protected_mode_jump)
	...
	...
	...
	.byte	0x66, 0xea		# ljmpl opcode
2:	.long	.Lin_pm32		# offset
	.word	__BOOT_CS		# segment
SYM_FUNC_END(protected_mode_jump)
</code></pre>
<p>where <code>in_pm32</code> contains a jump to the 32-bit entry point:</p>
<pre><code class="language-assembly">SYM_FUNC_START_LOCAL_NOALIGN(.Lin_pm32)
	...
	...
	jmpl	*%eax			# Jump to the 32-bit entrypoint
SYM_FUNC_END(.Lin_pm32)
</code></pre>
<p>As you can remember the 32-bit entry point is in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a> assembly file, although it contains <code>_64</code> in its name. We can see the two similar files in the <code>arch/x86/boot/compressed</code> directory:</p>
<ul>
<li><code>arch/x86/boot/compressed/head_32.S</code>.</li>
<li><code>arch/x86/boot/compressed/head_64.S</code>;</li>
</ul>
<p>But the 32-bit mode entry point is the second file in our case. The first file is not even compiled for <code>x86_64</code>. Let's look at the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/Makefile">arch/x86/boot/compressed/Makefile</a>:</p>
<pre><code>vmlinux-objs-y := $(obj)/vmlinux.lds $(obj)/kernel_info.o $(obj)/head_$(BITS).o \
...
...
</code></pre>
<p>We can see here that <code>head_*</code> depends on the <code>$(BITS)</code> variable, which is based on the architecture. The variable is defined within <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/Makefile">arch/x86/Makefile</a>:</p>
<pre><code>ifeq ($(CONFIG_X86_32),y)
...
	BITS := 32
else
	BITS := 64
	...
endif
</code></pre>
<p>Now as we jumped into <code>startup_32</code> from <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a>, we will not encounter anything related to interrupt handling here. The code inside of <code>startup_32</code> makes necessary preparations, before transitioning into the <a href="http://en.wikipedia.org/wiki/Long_mode">long mode</a> with a direct jump. The <code>long mode</code> entry is located in <code>startup_64</code> and it makes arrangements for the <a href="https://0xax.gitbooks.io/linux-insides/content/Booting/linux-bootstrap-5.html">kernel decompression</a> that occurs in the <code>decompress_kernel</code> function inside of <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/misc.c">arch/x86/boot/compressed/misc.c</a>. After the kernel is decompressed, we jump into <code>startup_64</code> defined at <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/head_64.S">arch/x86/kernel/head_64.S</a>. In <code>startup_64</code> we start to build identity-mapped pages, check the <a href="http://en.wikipedia.org/wiki/NX_bit">NX</a> bit, setup the <code>Extended Feature Enable Register</code> (see in links) and update the early <code>Global Descriptor Table</code> with the <code>lgdt</code> instruction. And proceed to setup <code>gs</code> register with the following code:</p>
<pre><code class="language-assembly">movl	$MSR_GS_BASE,%ecx
movl	initial_gs(%rip),%eax
movl	initial_gs+4(%rip),%edx
wrmsr
</code></pre>
<p>We already saw this code in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-1">part</a>. First of all pay attention on the last <code>wrmsr</code> instruction. This instruction writes data from the <code>edx:eax</code> registers to the <a href="http://en.wikipedia.org/wiki/Model-specific_register">model specific register</a> specified by the <code>ecx</code> register. We can see that <code>ecx</code> contains <code>$MSR_GS_BASE</code> which is declared in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/msr-index.h">arch/x86/include/asm/msr-index.h</a> and looks like:</p>
<pre><code class="language-C">#define MSR_GS_BASE             0xc0000101
</code></pre>
<p>From this we can understand that <code>MSR_GS_BASE</code> defines the number of the <code>model specific register</code>. Since registers <code>cs</code>, <code>ds</code>, <code>es</code>, and <code>ss</code> are not used in the 64-bit mode, their fields are ignored. But we can access memory over <code>fs</code> and <code>gs</code> registers. The model specific register provides a <code>back door</code> to the hidden parts of these segment registers and allows to use 64-bit base address for segment register addressed by the <code>fs</code> and <code>gs</code>. So the <code>MSR_GS_BASE</code> is the hidden part and this part is mapped on the <code>GS.base</code> field. Let's look on the <code>initial_gs</code>:</p>
<pre><code class="language-assembly">GLOBAL(initial_gs)
	.quad	INIT_PER_CPU_VAR(irq_stack_union)
</code></pre>
<p>We pass <code>irq_stack_union</code> symbol to the <code>INIT_PER_CPU_VAR</code> macro which just concatenates the <code>init_per_cpu__</code> prefix with the given symbol. In our case we will get the <code>init_per_cpu__irq_stack_union</code> symbol. Let's look at the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/vmlinux.lds.S">linker</a> script. There we can see following definition:</p>
<pre><code>#define INIT_PER_CPU(x) init_per_cpu__##x = x + __per_cpu_load
INIT_PER_CPU(irq_stack_union);
</code></pre>
<p>It tells us that the address of the <code>init_per_cpu__irq_stack_union</code> will be <code>irq_stack_union + __per_cpu_load</code>. Now we need to understand where <code>init_per_cpu__irq_stack_union</code> and <code>__per_cpu_load</code> are what they mean. The first <code>irq_stack_union</code> is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/processor.h">arch/x86/include/asm/processor.h</a> with the <code>DECLARE_INIT_PER_CPU</code> macro which expands to call the <code>init_per_cpu_var</code> macro:</p>
<pre><code class="language-C">DECLARE_INIT_PER_CPU(irq_stack_union);

#define DECLARE_INIT_PER_CPU(var) \
       extern typeof(per_cpu_var(var)) init_per_cpu_var(var)

#define init_per_cpu_var(var)  init_per_cpu__##var
</code></pre>
<p>If we expand all macros we will get the same <code>init_per_cpu__irq_stack_union</code> as we got after expanding the <code>INIT_PER_CPU</code> macro, but you can note that it is not just a symbol, but a variable. Let's look at the <code>typeof(per_cpu_var(var))</code> expression. Our <code>var</code> is <code>irq_stack_union</code> and the <code>per_cpu_var</code> macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/percpu.h">arch/x86/include/asm/percpu.h</a>:</p>
<pre><code class="language-C">#define PER_CPU_VAR(var)        %__percpu_seg:var
</code></pre>
<p>where:</p>
<pre><code class="language-C">#ifdef CONFIG_X86_64
    #define __percpu_seg gs
endif
</code></pre>
<p>So, we are accessing <code>gs:irq_stack_union</code> and getting its type which is <code>irq_union</code>. Ok, we defined the first variable and know its address, now let's look at the second <code>__per_cpu_load</code> symbol. There are a couple of <code>per-cpu</code> variables which are located after this symbol. The <code>__per_cpu_load</code> is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/asm-generic/sections.h">include/asm-generic/sections.h</a>:</p>
<pre><code class="language-C">extern char __per_cpu_load[], __per_cpu_start[], __per_cpu_end[];
</code></pre>
<p>and presented base address of the <code>per-cpu</code> variables from the data area. So, we know the address of the <code>irq_stack_union</code>, <code>__per_cpu_load</code> and we know that <code>init_per_cpu__irq_stack_union</code> must be placed right after <code>__per_cpu_load</code>. And we can see it in the <a href="http://en.wikipedia.org/wiki/System.map">System.map</a>:</p>
<pre><code>...
...
...
ffffffff819ed000 D __init_begin
ffffffff819ed000 D __per_cpu_load
ffffffff819ed000 A init_per_cpu__irq_stack_union
...
...
...
</code></pre>
<p>Now we know about <code>initial_gs</code>, so let's look at the code:</p>
<pre><code class="language-assembly">movl	$MSR_GS_BASE,%ecx
movl	initial_gs(%rip),%eax
movl	initial_gs+4(%rip),%edx
wrmsr
</code></pre>
<p>Here we specified a model specific register with <code>MSR_GS_BASE</code>, put the content of the <code>initial_gs</code> to the <code>edx:eax</code> pair and execute the <code>wrmsr</code> instruction for filling the <code>gs</code> register with the base address of the <code>init_per_cpu__irq_stack_union</code> which will be at the bottom of the interrupt stack. After this we will jump to the C code on the <code>x86_64_start_kernel</code> from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/head64.c">arch/x86/kernel/head64.c</a>. In the <code>x86_64_start_kernel</code> function we do the last preparations before we jump into the generic and architecture-independent kernel code and one of these preparations is filling the early <code>Interrupt Descriptor Table</code> with the interrupts handlers entries or <code>early_idt_handlers</code>. You can remember it, if you have read the part about the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-2">Early interrupt and exception handling</a> and can remember following code:</p>
<pre><code class="language-C">for (i = 0; i &lt; NUM_EXCEPTION_VECTORS; i++)
	set_intr_gate(i, early_idt_handlers[i]);

load_idt((const struct desc_ptr *)&amp;idt_descr);
</code></pre>
<p>but I wrote <code>Early interrupt and exception handling</code> part when Linux kernel version was - <code>3.18</code>. For this day actual version of the Linux kernel is <code>4.1.0-rc6+</code> and <code> Andy Lutomirski</code> sent the <a href="https://lkml.org/lkml/2015/6/2/106">patch</a> and soon it will be in the mainline kernel that changes behaviour for the <code>early_idt_handlers</code>. <strong>NOTE</strong> While I wrote this part the <a href="https://github.com/torvalds/linux/commit/425be5679fd292a3c36cb1fe423086708a99f11a">patch</a> already turned in the Linux kernel source code. Let's look on it. Now the same part looks like:</p>
<pre><code class="language-C">for (i = 0; i &lt; NUM_EXCEPTION_VECTORS; i++)
	set_intr_gate(i, early_idt_handler_array[i]);

load_idt((const struct desc_ptr *)&amp;idt_descr);
</code></pre>
<p>As you can see it has only one difference in the name of the array of the interrupts handlers entry points. Now it is <code>early_idt_handler_array</code>:</p>
<pre><code class="language-C">extern const char early_idt_handler_array[NUM_EXCEPTION_VECTORS][EARLY_IDT_HANDLER_SIZE];
</code></pre>
<p>where <code>NUM_EXCEPTION_VECTORS</code> and <code>EARLY_IDT_HANDLER_SIZE</code> are defined as:</p>
<pre><code class="language-C">#define NUM_EXCEPTION_VECTORS 32
#define EARLY_IDT_HANDLER_SIZE 9
</code></pre>
<p>So, the <code>early_idt_handler_array</code> is an array of the interrupts handlers entry points and contains one entry point on every nine bytes. You can remember that previous <code>early_idt_handlers</code> was defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/head_64.S">arch/x86/kernel/head_64.S</a>. The <code>early_idt_handler_array</code> is defined in the same source code file too:</p>
<pre><code class="language-assembly">ENTRY(early_idt_handler_array)
...
...
...
ENDPROC(early_idt_handler_array)
</code></pre>
<p>It fills <code>early_idt_handler_array</code> with the <code>.rept NUM_EXCEPTION_VECTORS</code> and contains entry of the <code>early_make_pgtable</code> interrupt handler (you can read more about its implementation in the part about <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-2">Early interrupt and exception handling</a>). For now, we have reached the end of the x86_64 architecture-specific code and the next part is the generic kernel code. You probably already know, that we will return to the architecture-specific code in the <code>setup_arch</code> function and other places, but this is the end of the <code>x86_64</code> early code.</p>
<h2 id="setting-stack-canary-for-the-interrupt-stack"><a class="header" href="#setting-stack-canary-for-the-interrupt-stack">Setting stack canary for the interrupt stack</a></h2>
<p>The next stop after the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/head_64.S">arch/x86/kernel/head_64.S</a> is the biggest <code>start_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>. If you've read the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">chapter</a> about the Linux kernel initialization process, you must remember it. This function does all initialization stuff before kernel will launch first <code>init</code> process with the <a href="https://en.wikipedia.org/wiki/Process_identifier">pid</a> - <code>1</code>. The first thing that is related to the interrupts and exceptions handling is the call of the <code>boot_init_stack_canary</code> function.</p>
<p>This function sets the <a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries">canary</a> value to protect interrupt stack overflow. We already saw a little some details about implementation of the <code>boot_init_stack_canary</code> in the previous part and now let's take a closer look on it. You can find implementation of this function in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/stackprotector.h">arch/x86/include/asm/stackprotector.h</a> and its depends on the <code>CONFIG_CC_STACKPROTECTOR</code> kernel configuration option. If this option is not set this function will not do anything:</p>
<pre><code class="language-C">#ifdef CONFIG_CC_STACKPROTECTOR
...
...
...
#else
static inline void boot_init_stack_canary(void)
{
}
#endif
</code></pre>
<p>If the <code>CONFIG_CC_STACKPROTECTOR</code> kernel configuration option is set, the <code>boot_init_stack_canary</code> function starts from the check stat <code>irq_stack_union</code> that represents <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> interrupt stack has offset equal to forty bytes from the <code>stack_canary</code> value:</p>
<pre><code class="language-C">#ifdef CONFIG_X86_64
        BUILD_BUG_ON(offsetof(union irq_stack_union, stack_canary) != 40);
#endif
</code></pre>
<p>As we can read in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-1">part</a> the <code>irq_stack_union</code> represented by the following union:</p>
<pre><code class="language-C">union irq_stack_union {
	char irq_stack[IRQ_STACK_SIZE];

    struct {
		char gs_base[40];
		unsigned long stack_canary;
	};
};
</code></pre>
<p>which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/processor.h">arch/x86/include/asm/processor.h</a>. We know that <a href="http://en.wikipedia.org/wiki/Union_type">union</a> in the <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> programming language is a data structure which stores only one field in a memory. We can see here that structure has first field - <code>gs_base</code> which is 40 bytes size and represents bottom of the <code>irq_stack</code>. So, after this our check with the <code>BUILD_BUG_ON</code> macro should end successfully. (you can read the first part about Linux kernel initialization <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">process</a> if you're interesting about the <code>BUILD_BUG_ON</code> macro).</p>
<p>After this we calculate new <code>canary</code> value based on the random number and <a href="http://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a>:</p>
<pre><code class="language-C">get_random_bytes(&amp;canary, sizeof(canary));
tsc = __native_read_tsc();
canary += tsc + (tsc &lt;&lt; 32UL);
</code></pre>
<p>and write <code>canary</code> value to the <code>irq_stack_union</code> with the <code>this_cpu_write</code> macro:</p>
<pre><code class="language-C">this_cpu_write(irq_stack_union.stack_canary, canary);
</code></pre>
<p>more about <code>this_cpu_*</code> operation you can read in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/this_cpu_ops.txt">Linux kernel documentation</a>.</p>
<h2 id="disablingenabling-local-interrupts"><a class="header" href="#disablingenabling-local-interrupts">Disabling/Enabling local interrupts</a></h2>
<p>The next step in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> which is related to the interrupts and interrupts handling after we have set the <code>canary</code> value to the interrupt stack - is the call of the <code>local_irq_disable</code> macro.</p>
<p>This macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irqflags.h">include/linux/irqflags.h</a> header file and as you can understand, we can disable interrupts for the CPU with the call of this macro. Let's look on its implementation. First of all note that it depends on the <code>CONFIG_TRACE_IRQFLAGS_SUPPORT</code> kernel configuration option:</p>
<pre><code class="language-C">#ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT
...
#define local_irq_disable() \
         do { raw_local_irq_disable(); trace_hardirqs_off(); } while (0)
...
#else
...
#define local_irq_disable()     do { raw_local_irq_disable(); } while (0)
...
#endif
</code></pre>
<p>They are both similar and as you can see have only one difference: the <code>local_irq_disable</code> macro contains call of the <code>trace_hardirqs_off</code> when <code>CONFIG_TRACE_IRQFLAGS_SUPPORT</code> is enabled. There is special feature in the <a href="http://lwn.net/Articles/321663/">lockdep</a> subsystem - <code>irq-flags tracing</code> for tracing <code>hardirq</code> and <code>softirq</code> state. In our case <code>lockdep</code> subsystem can give us interesting information about hard/soft irqs on/off events which are occurs in the system. The <code>trace_hardirqs_off</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/locking/lockdep.c">kernel/locking/lockdep.c</a>:</p>
<pre><code class="language-C">void trace_hardirqs_off(void)
{
         trace_hardirqs_off_caller(CALLER_ADDR0);
}
EXPORT_SYMBOL(trace_hardirqs_off);
</code></pre>
<p>and just calls <code>trace_hardirqs_off_caller</code> function. The <code>trace_hardirqs_off_caller</code> checks the <code>hardirqs_enabled</code> field of the current process and increases the <code>redundant_hardirqs_off</code> if call of the <code>local_irq_disable</code> was redundant or the <code>hardirqs_off_events</code> if it was not. These two fields and other <code>lockdep</code> statistic related fields are defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/locking/lockdep_internals.h">kernel/locking/lockdep_internals.h</a> and located in the <code>lockdep_stats</code> structure:</p>
<pre><code class="language-C">struct lockdep_stats {
...
...
...
int     softirqs_off_events;
int     redundant_softirqs_off;
...
...
...
}
</code></pre>
<p>If you will set <code>CONFIG_DEBUG_LOCKDEP</code> kernel configuration option, the <code>lockdep_stats_debug_show</code> function will write all tracing information to the <code>/proc/lockdep</code>:</p>
<pre><code class="language-C">static void lockdep_stats_debug_show(struct seq_file *m)
{
#ifdef CONFIG_DEBUG_LOCKDEP
	unsigned long long hi1 = debug_atomic_read(hardirqs_on_events),
	                         hi2 = debug_atomic_read(hardirqs_off_events),
							 hr1 = debug_atomic_read(redundant_hardirqs_on),
    ...
	...
	...
    seq_printf(m, &quot; hardirq on events:             %11llu\n&quot;, hi1);
    seq_printf(m, &quot; hardirq off events:            %11llu\n&quot;, hi2);
    seq_printf(m, &quot; redundant hardirq ons:         %11llu\n&quot;, hr1);
#endif
}
</code></pre>
<p>and you can see its result with the:</p>
<pre><code>$ sudo cat /proc/lockdep
 hardirq on events:             12838248974
 hardirq off events:            12838248979
 redundant hardirq ons:               67792
 redundant hardirq offs:         3836339146
 softirq on events:                38002159
 softirq off events:               38002187
 redundant softirq ons:                   0
 redundant softirq offs:                  0
</code></pre>
<p>Ok, now we know a little about tracing, but more info will be in the separate part about <code>lockdep</code> and <code>tracing</code>. You can see that the both <code>local_irq_disable</code> macros have the same part - <code>raw_local_irq_disable</code>. This macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/irqflags.h">arch/x86/include/asm/irqflags.h</a> and expands to the call of the:</p>
<pre><code class="language-C">static inline void native_irq_disable(void)
{
        asm volatile(&quot;cli&quot;: : :&quot;memory&quot;);
}
</code></pre>
<p>And you already must remember that <code>cli</code> instruction clears the <a href="http://en.wikipedia.org/wiki/Interrupt_flag">IF</a> flag which determines ability of a processor to handle an interrupt or an exception. Besides the <code>local_irq_disable</code>, as you already can know there is an inverse macro - <code>local_irq_enable</code>. This macro has the same tracing mechanism and very similar on the <code>local_irq_enable</code>, but as you can understand from its name, it enables interrupts with the <code>sti</code> instruction:</p>
<pre><code class="language-C">static inline void native_irq_enable(void)
{
        asm volatile(&quot;sti&quot;: : :&quot;memory&quot;);
}
</code></pre>
<p>Now we know how <code>local_irq_disable</code> and <code>local_irq_enable</code> work. It was the first call of the <code>local_irq_disable</code> macro, but we will meet these macros many times in the Linux kernel source code. But for now we are in the <code>start_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> and we just disabled <code>local</code> interrupts. Why local and why we did it? Previously kernel provided a method to disable interrupts on all processors and it was called <code>cli</code>. This function was <a href="https://lwn.net/Articles/291956/">removed</a> and now we have <code>local_irq_{enabled,disable}</code> to disable or enable interrupts on the current processor. After we've disabled the interrupts with the <code>local_irq_disable</code> macro, we set the:</p>
<pre><code class="language-C">early_boot_irqs_disabled = true;
</code></pre>
<p>The <code>early_boot_irqs_disabled</code> variable defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/kernel.h">include/linux/kernel.h</a>:</p>
<pre><code class="language-C">extern bool early_boot_irqs_disabled;
</code></pre>
<p>and used in the different places. For example it used in the <code>smp_call_function_many</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/smp.c">kernel/smp.c</a> for the checking possible deadlock when interrupts are disabled:</p>
<pre><code class="language-C">WARN_ON_ONCE(cpu_online(this_cpu) &amp;&amp; irqs_disabled()
                     &amp;&amp; !oops_in_progress &amp;&amp; !early_boot_irqs_disabled);
</code></pre>
<h2 id="early-trap-initialization-during-kernel-initialization"><a class="header" href="#early-trap-initialization-during-kernel-initialization">Early trap initialization during kernel initialization</a></h2>
<p>The next functions after the <code>local_disable_irq</code> are <code>boot_cpu_init</code> and <code>page_address_init</code>, but they are not related to the interrupts and exceptions (more about this functions you can read in the chapter about Linux kernel <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">initialization process</a>). The next is the <code>setup_arch</code> function. As you can remember this function located in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> source code file and makes initialization of many different architecture-dependent <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">stuff</a>. The first interrupts related function which we can see in the <code>setup_arch</code> is the - <code>early_trap_init</code> function. This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a> and fills <code>Interrupt Descriptor Table</code> with the couple of entries:</p>
<pre><code class="language-C">void __init early_trap_init(void)
{
        set_intr_gate_ist(X86_TRAP_DB, &amp;debug, DEBUG_STACK);
        set_system_intr_gate_ist(X86_TRAP_BP, &amp;int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
        set_intr_gate(X86_TRAP_PF, page_fault);
#endif
        load_idt(&amp;idt_descr);
}
</code></pre>
<p>Here we can see calls of three different functions:</p>
<ul>
<li><code>set_intr_gate_ist</code></li>
<li><code>set_system_intr_gate_ist</code></li>
<li><code>set_intr_gate</code></li>
</ul>
<p>All of these functions defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/desc.h">arch/x86/include/asm/desc.h</a> and do the similar thing but not the same. The first <code>set_intr_gate_ist</code> function inserts a new interrupt gate in the <code>IDT</code>. Let's look on its implementation:</p>
<pre><code class="language-C">static inline void set_intr_gate_ist(int n, void *addr, unsigned ist)
{
        BUG_ON((unsigned)n &gt; 0xFF);
        _set_gate(n, GATE_INTERRUPT, addr, 0, ist, __KERNEL_CS);
}
</code></pre>
<p>First of all we can see the check that <code>n</code> which is <a href="http://en.wikipedia.org/wiki/Interrupt_vector_table">vector number</a> of the interrupt is not greater than <code>0xff</code> or 255. We need to check it because we remember from the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-1">part</a> that vector number of an interrupt must be between <code>0</code> and <code>255</code>. In the next step we can see the call of the <code>_set_gate</code> function that sets a given interrupt gate to the <code>IDT</code> table:</p>
<pre><code class="language-C">static inline void _set_gate(int gate, unsigned type, void *addr,
                             unsigned dpl, unsigned ist, unsigned seg)
{
        gate_desc s;

        pack_gate(&amp;s, type, (unsigned long)addr, dpl, ist, seg);
        write_idt_entry(idt_table, gate, &amp;s);
        write_trace_idt_entry(gate, &amp;s);
}
</code></pre>
<p>Here we start from the <code>pack_gate</code> function which takes clean <code>IDT</code> entry represented by the <code>gate_desc</code> structure and fills it with the base address and limit, <a href="https://www.kernel.org/doc/Documentation/x86/x86_64/kernel-stacks">Interrupt Stack Table</a>, <a href="http://en.wikipedia.org/wiki/Privilege_level">Privilege level</a>, type of an interrupt which can be one of the following values:</p>
<ul>
<li><code>GATE_INTERRUPT</code></li>
<li><code>GATE_TRAP</code></li>
<li><code>GATE_CALL</code></li>
<li><code>GATE_TASK</code></li>
</ul>
<p>and set the present bit for the given <code>IDT</code> entry:</p>
<pre><code class="language-C">static inline void pack_gate(gate_desc *gate, unsigned type, unsigned long func,
                             unsigned dpl, unsigned ist, unsigned seg)
{
        gate-&gt;offset_low        = PTR_LOW(func);
        gate-&gt;segment           = __KERNEL_CS;
        gate-&gt;ist               = ist;
        gate-&gt;p                 = 1;
        gate-&gt;dpl               = dpl;
        gate-&gt;zero0             = 0;
        gate-&gt;zero1             = 0;
        gate-&gt;type              = type;
        gate-&gt;offset_middle     = PTR_MIDDLE(func);
        gate-&gt;offset_high       = PTR_HIGH(func);
}
</code></pre>
<p>After this we write just filled interrupt gate to the <code>IDT</code> with the <code>write_idt_entry</code> macro which expands to the <code>native_write_idt_entry</code> and just copy the interrupt gate to the <code>idt_table</code> table by the given index:</p>
<pre><code class="language-C">#define write_idt_entry(dt, entry, g)           native_write_idt_entry(dt, entry, g)

static inline void native_write_idt_entry(gate_desc *idt, int entry, const gate_desc *gate)
{
        memcpy(&amp;idt[entry], gate, sizeof(*gate));
}
</code></pre>
<p>where <code>idt_table</code> is just array of <code>gate_desc</code>:</p>
<pre><code class="language-C">extern gate_desc idt_table[];
</code></pre>
<p>That's all. The second <code>set_system_intr_gate_ist</code> function has only one difference from the <code>set_intr_gate_ist</code>:</p>
<pre><code class="language-C">static inline void set_system_intr_gate_ist(int n, void *addr, unsigned ist)
{
        BUG_ON((unsigned)n &gt; 0xFF);
        _set_gate(n, GATE_INTERRUPT, addr, 0x3, ist, __KERNEL_CS);
}
</code></pre>
<p>Do you see it? Look on the fourth parameter of the <code>_set_gate</code>. It is <code>0x3</code>. In the <code>set_intr_gate</code> it was <code>0x0</code>. We know that this parameter represent <code>DPL</code> or privilege level. We also know that <code>0</code> is the highest privilege level and <code>3</code> is the lowest. Now we know how <code>set_system_intr_gate_ist</code>, <code>set_intr_gate_ist</code>, <code>set_intr_gate</code> work and we can return to the <code>early_trap_init</code> function. Let's look on it again:</p>
<pre><code class="language-C">set_intr_gate_ist(X86_TRAP_DB, &amp;debug, DEBUG_STACK);
set_system_intr_gate_ist(X86_TRAP_BP, &amp;int3, DEBUG_STACK);
</code></pre>
<p>We set two <code>IDT</code> entries for the <code>#DB</code> interrupt and <code>int3</code>. These functions takes the same set of parameters:</p>
<ul>
<li>vector number of an interrupt;</li>
<li>address of an interrupt handler;</li>
<li>interrupt stack table index.</li>
</ul>
<p>That's all. More about interrupts and handlers you will know in the next parts.</p>
<h2 id="conclusion-17"><a class="header" href="#conclusion-17">Conclusion</a></h2>
<p>It is the end of the second part about interrupts and interrupt handling in the Linux kernel. We saw the some theory in the previous part and started to dive into interrupts and exceptions handling in the current part. We have started from the earliest parts in the Linux kernel source code which are related to the interrupts. In the next part we will continue to dive into this interesting theme and will know more about interrupt handling process.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-17"><a class="header" href="#links-17">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Interrupt_descriptor_table">IDT</a></li>
<li><a href="http://en.wikipedia.org/wiki/Protected_mode">Protected mode</a></li>
<li><a href="http://en.wikipedia.org/wiki/X86_calling_conventions#List_of_x86_calling_conventions">List of x86 calling conventions</a></li>
<li><a href="http://en.wikipedia.org/wiki/Intel_8086">8086</a></li>
<li><a href="http://en.wikipedia.org/wiki/Long_mode">Long mode</a></li>
<li><a href="http://en.wikipedia.org/wiki/NX_bit">NX</a></li>
<li><a href="http://en.wikipedia.org/wiki/Control_register#Additional_Control_registers_in_x86-64_series">Extended Feature Enable Register</a></li>
<li><a href="http://en.wikipedia.org/wiki/Model-specific_register">Model-specific register</a></li>
<li><a href="https://en.wikipedia.org/wiki/Process_identifier">Process identifier</a></li>
<li><a href="http://lwn.net/Articles/321663/">lockdep</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/irqflags-tracing.txt">irqflags tracing</a></li>
<li><a href="http://en.wikipedia.org/wiki/Interrupt_flag">IF</a></li>
<li><a href="http://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries">Stack canary</a></li>
<li><a href="http://en.wikipedia.org/wiki/Union_type">Union type</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/this_cpu_ops.txt">this_cpu_* operations</a></li>
<li><a href="http://en.wikipedia.org/wiki/Interrupt_vector_table">vector number</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/x86/x86_64/kernel-stacks">Interrupt Stack Table</a></li>
<li><a href="http://en.wikipedia.org/wiki/Privilege_level">Privilege level</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-1">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts-and-interrupt-handling-part-3"><a class="header" href="#interrupts-and-interrupt-handling-part-3">Interrupts and Interrupt Handling. Part 3.</a></h1>
<h2 id="exception-handling"><a class="header" href="#exception-handling">Exception Handling</a></h2>
<p>This is the third part of the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">chapter</a> about interrupts and an exceptions handling in the Linux kernel and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">part</a> we stopped at the <code>setup_arch</code> function from the <a href="https://github.com/torvalds/linux/blame/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> source code file.</p>
<p>We already know that this function executes initialization of architecture-specific stuff. In our case the <code>setup_arch</code> function does <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture related initializations. The <code>setup_arch</code> is big function, and in the previous part we stopped on the setting of the two exception handlers for the two following exceptions:</p>
<ul>
<li><code>#DB</code> - debug exception, transfers control from the interrupted process to the debug handler;</li>
<li><code>#BP</code> - breakpoint exception, caused by the <code>int 3</code> instruction.</li>
</ul>
<p>These exceptions allow the <code>x86_64</code> architecture to have early exception processing for the purpose of debugging via the <a href="https://en.wikipedia.org/wiki/KGDB">kgdb</a>.</p>
<p>As you can remember we set these exceptions handlers in the <code>early_trap_init</code> function:</p>
<pre><code class="language-C">void __init early_trap_init(void)
{
        set_intr_gate_ist(X86_TRAP_DB, &amp;debug, DEBUG_STACK);
        set_system_intr_gate_ist(X86_TRAP_BP, &amp;int3, DEBUG_STACK);
        load_idt(&amp;idt_descr);
}
</code></pre>
<p>from the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a>. We already saw implementation of the <code>set_intr_gate_ist</code> and <code>set_system_intr_gate_ist</code> functions in the previous part and now we will look on the implementation of these two exception handlers.</p>
<h2 id="debug-and-breakpoint-exceptions"><a class="header" href="#debug-and-breakpoint-exceptions">Debug and Breakpoint exceptions</a></h2>
<p>Ok, we setup exception handlers in the <code>early_trap_init</code> function for the <code>#DB</code> and <code>#BP</code> exceptions and now is time to consider their implementations. But before we will do this, first of all let's look on details of these exceptions.</p>
<p>The first exceptions - <code>#DB</code> or <code>debug</code> exception occurs when a debug event occurs. For example - attempt to change the contents of a <a href="http://en.wikipedia.org/wiki/X86_debug_register">debug register</a>. Debug registers are special registers that were presented in <code>x86</code> processors starting from the <a href="http://en.wikipedia.org/wiki/Intel_80386">Intel 80386</a> processor and as you can understand from name of this CPU extension, main purpose of these registers is debugging.</p>
<p>These registers allow to set breakpoints on the code and read or write data to trace it. Debug registers may be accessed only in the privileged mode and an attempt to read or write the debug registers when executing at any other privilege level causes a <a href="https://en.wikipedia.org/wiki/General_protection_fault">general protection fault</a> exception. That's why we have used <code>set_intr_gate_ist</code> for the <code>#DB</code> exception, but not the <code>set_system_intr_gate_ist</code>.</p>
<p>The vector number of the <code>#DB</code> exceptions is <code>1</code> (we pass it as <code>X86_TRAP_DB</code>) and as we may read in specification, this exception has no error code:</p>
<pre><code>+-----------------------------------------------------+
|Vector|Mnemonic|Description         |Type |Error Code|
+-----------------------------------------------------+
|1     | #DB    |Reserved            |F/T  |NO        |
+-----------------------------------------------------+
</code></pre>
<p>The second exception is <code>#BP</code> or <code>breakpoint</code> exception occurs when processor executes the <a href="http://en.wikipedia.org/wiki/INT_%28x86_instruction%29#INT_3">int 3</a> instruction. Unlike the <code>DB</code> exception, the <code>#BP</code> exception may occur in userspace. We can add it anywhere in our code, for example let's look on the simple program:</p>
<pre><code class="language-C">// breakpoint.c
#include &lt;stdio.h&gt;

int main() {
    int i;
    while (i &lt; 6){
	    printf(&quot;i equal to: %d\n&quot;, i);
	    __asm__(&quot;int3&quot;);
		++i;
    }
}
</code></pre>
<p>If we will compile and run this program, we will see following output:</p>
<pre><code>$ gcc breakpoint.c -o breakpoint
$ ./breakpoint
i equal to: 0
Trace/breakpoint trap
</code></pre>
<p>But if will run it with gdb, we will see our breakpoint and can continue execution of our program:</p>
<pre><code>$ gdb breakpoint
...
...
...
(gdb) run
Starting program: /home/alex/breakpoints
i equal to: 0

Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000000000400585 in main ()
=&gt; 0x0000000000400585 &lt;main+31&gt;:	83 45 fc 01	add    DWORD PTR [rbp-0x4],0x1
(gdb) c
Continuing.
i equal to: 1

Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000000000400585 in main ()
=&gt; 0x0000000000400585 &lt;main+31&gt;:	83 45 fc 01	add    DWORD PTR [rbp-0x4],0x1
(gdb) c
Continuing.
i equal to: 2

Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000000000400585 in main ()
=&gt; 0x0000000000400585 &lt;main+31&gt;:	83 45 fc 01	add    DWORD PTR [rbp-0x4],0x1
...
...
...
</code></pre>
<p>From this moment we know a little about these two exceptions and we can move on to consideration of their handlers.</p>
<h2 id="preparation-before-an-exception-handler"><a class="header" href="#preparation-before-an-exception-handler">Preparation before an exception handler</a></h2>
<p>As you may note before, the <code>set_intr_gate_ist</code> and <code>set_system_intr_gate_ist</code> functions takes an addresses of exceptions handlers in theirs second parameter. In or case our two exception handlers will be:</p>
<ul>
<li><code>debug</code>;</li>
<li><code>int3</code>.</li>
</ul>
<p>You will not find these functions in the C code. All of that could be found in the kernel's <code>*.c/*.h</code> files only definition of these functions which are located in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/include/asm/traps.h">arch/x86/include/asm/traps.h</a> kernel header file:</p>
<pre><code class="language-C">asmlinkage void debug(void);
</code></pre>
<p>and</p>
<pre><code class="language-C">asmlinkage void int3(void);
</code></pre>
<p>You may note <code>asmlinkage</code> directive in definitions of these functions. The directive is the special specificator of the <a href="http://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a>. Actually for a <code>C</code> functions which are called from assembly, we need in explicit declaration of the function calling convention. In our case, if function made with <code>asmlinkage</code> descriptor, then <code>gcc</code> will compile the function to retrieve parameters from stack.</p>
<p>So, both handlers are defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> assembly source code file with the <code>idtentry</code> macro:</p>
<pre><code class="language-assembly">idtentry debug do_debug has_error_code=0 paranoid=1 shift_ist=DEBUG_STACK
</code></pre>
<p>and</p>
<pre><code class="language-assembly">idtentry int3 do_int3 has_error_code=0 paranoid=1 shift_ist=DEBUG_STACK
</code></pre>
<p>Each exception handler may consists of two parts. The first part is generic part and it is the same for all exception handlers. An exception handler should to save  <a href="https://en.wikipedia.org/wiki/Processor_register">general purpose registers</a> on the stack, switch to kernel stack if an exception came from userspace and transfer control to the second part of an exception handler. The second part of an exception handler does certain work depends on certain exception. For example page fault exception handler should find virtual page for given address, invalid opcode exception handler should send <code>SIGILL</code> <a href="https://en.wikipedia.org/wiki/Unix_signal">signal</a> and etc.</p>
<p>As we just saw, an exception handler starts from definition of the <code>idtentry</code> macro from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> assembly source code file, so let's look at implementation of this macro. As we may see, the <code>idtentry</code> macro takes five arguments:</p>
<ul>
<li><code>sym</code> - defines global symbol with the <code>.globl name</code> which will be an an entry of exception handler;</li>
<li><code>do_sym</code> - symbol name which represents a secondary entry of an exception handler;</li>
<li><code>has_error_code</code> - information about existence of an error code of exception.</li>
</ul>
<p>The last two parameters are optional:</p>
<ul>
<li><code>paranoid</code> - shows us how we need to check current mode (will see explanation in details later);</li>
<li><code>shift_ist</code> - shows us is an exception running at <code>Interrupt Stack Table</code>.</li>
</ul>
<p>Definition of the <code>.idtentry</code> macro looks:</p>
<pre><code class="language-assembly">.macro idtentry sym do_sym has_error_code:req paranoid=0 shift_ist=-1
ENTRY(\sym)
...
...
...
END(\sym)
.endm
</code></pre>
<p>Before we will consider internals of the <code>idtentry</code> macro, we should to know state of stack when an exception occurs. As we may read in the <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel® 64 and IA-32 Architectures Software Developer’s Manual 3A</a>, the state of stack when an exception occurs is following:</p>
<pre><code>    +------------+
+40 | %SS        |
+32 | %RSP       |
+24 | %RFLAGS    |
+16 | %CS        |
 +8 | %RIP       |
  0 | ERROR CODE | &lt;-- %RSP
    +------------+
</code></pre>
<p>Now we may start to consider implementation of the <code>idtmacro</code>. Both <code>#DB</code> and <code>BP</code> exception handlers are defined as:</p>
<pre><code class="language-assembly">idtentry debug do_debug has_error_code=0 paranoid=1 shift_ist=DEBUG_STACK
idtentry int3 do_int3 has_error_code=0 paranoid=1 shift_ist=DEBUG_STACK
</code></pre>
<p>If we will look at these definitions, we may know that compiler will generate two routines with <code>debug</code> and <code>int3</code> names and both of these exception handlers will call <code>do_debug</code> and <code>do_int3</code> secondary handlers after some preparation. The third parameter defines existence of error code and as we may see both our exception do not have them. As we may see on the diagram above, processor pushes error code on stack if an exception provides it. In our case, the <code>debug</code> and <code>int3</code> exception do not have error codes. This may bring some difficulties because stack will look differently for exceptions which provides error code and for exceptions which not. That's why implementation of the <code>idtentry</code> macro starts from putting a fake error code to the stack if an exception does not provide it:</p>
<pre><code class="language-assembly">.ifeq \has_error_code
    pushq	$-1
.endif
</code></pre>
<p>But it is not only fake error-code. Moreover the <code>-1</code> also represents invalid system call number, so that the system call restart logic will not be triggered.</p>
<p>The last two parameters of the <code>idtentry</code> macro <code>shift_ist</code> and <code>paranoid</code> allow to know do an exception handler runned at stack from <code>Interrupt Stack Table</code> or not. You already may know that each kernel thread in the system has its own stack. In addition to these stacks, there are some specialized stacks associated with each processor in the system. One of these stacks is - exception stack. The <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture provides special feature which is called - <code>Interrupt Stack Table</code>. This feature allows to switch to a new stack for designated events such as an atomic exceptions like <code>double fault</code>, etc. So the <code>shift_ist</code> parameter allows us to know do we need to switch on <code>IST</code> stack for an exception handler or not.</p>
<p>The second parameter - <code>paranoid</code> defines the method which helps us to know did we come from userspace or not to an exception handler. The easiest way to determine this is to via <code>CPL</code> or <code>Current Privilege Level</code> in <code>CS</code> segment register. If it is equal to <code>3</code>, we came from userspace, if zero we came from kernel space:</p>
<pre><code>testl $3,CS(%rsp)
jnz userspace
...
...
...
// we are from the kernel space
</code></pre>
<p>But unfortunately this method does not give a 100% guarantee. As described in the kernel documentation:</p>
<blockquote>
<p>if we are in an NMI/MCE/DEBUG/whatever super-atomic entry context,
which might have triggered right after a normal entry wrote CS to the
stack but before we executed SWAPGS, then the only safe way to check
for GS is the slower method: the RDMSR.</p>
</blockquote>
<p>In other words for example <code>NMI</code> could happen inside the critical section of a <a href="http://www.felixcloutier.com/x86/SWAPGS.html">swapgs</a> instruction. In this way we should check value of the <code>MSR_GS_BASE</code> <a href="https://en.wikipedia.org/wiki/Model-specific_register">model specific register</a> which stores pointer to the start of per-cpu area. So to check if we did come from userspace or not, we should to check value of the <code>MSR_GS_BASE</code> model specific register and if it is negative we came from kernel space, in other way we came from userspace:</p>
<pre><code class="language-assembly">movl $MSR_GS_BASE,%ecx
rdmsr
testl %edx,%edx
js 1f
</code></pre>
<p>In first two lines of code we read value of the <code>MSR_GS_BASE</code> model specific register into <code>edx:eax</code> pair. We can't set negative value to the <code>gs</code> from userspace. But from other side we know that direct mapping of the physical memory starts from the <code>0xffff880000000000</code> virtual address. In this way, <code>MSR_GS_BASE</code> will contain an address from <code>0xffff880000000000</code> to <code>0xffffc7ffffffffff</code>. After the <code>rdmsr</code> instruction will be executed, the smallest possible value in the <code>%edx</code> register will be - <code>0xffff8800</code> which is <code>-30720</code> in unsigned 4 bytes. That's why kernel space <code>gs</code> which points to start of <code>per-cpu</code> area will contain negative value.</p>
<p>After we push fake error code on the stack, we should allocate space for general purpose registers with:</p>
<pre><code class="language-assembly">ALLOC_PT_GPREGS_ON_STACK
</code></pre>
<p>macro which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/calling.h">arch/x86/entry/calling.h</a> header file. This macro just allocates 15*8 bytes space on the stack to preserve general purpose registers:</p>
<pre><code class="language-assembly">.macro ALLOC_PT_GPREGS_ON_STACK addskip=0
    addq	$-(15*8+\addskip), %rsp
.endm
</code></pre>
<p>So the stack will look like this after execution of the <code>ALLOC_PT_GPREGS_ON_STACK</code>:</p>
<pre><code>     +------------+
+160 | %SS        |
+152 | %RSP       |
+144 | %RFLAGS    |
+136 | %CS        |
+128 | %RIP       |
+120 | ERROR CODE |
     |------------|
+112 |            |
+104 |            |
 +96 |            |
 +88 |            |
 +80 |            |
 +72 |            |
 +64 |            |
 +56 |            |
 +48 |            |
 +40 |            |
 +32 |            |
 +24 |            |
 +16 |            |
  +8 |            |
  +0 |            | &lt;- %RSP
     +------------+
</code></pre>
<p>After we allocated space for general purpose registers, we do some checks to understand did an exception come from userspace or not and if yes, we should move back to an interrupted process stack or stay on exception stack:</p>
<pre><code class="language-assembly">.if \paranoid
    .if \paranoid == 1
	    testb	$3, CS(%rsp)
	    jnz	1f
	.endif
	call	paranoid_entry
.else
	call	error_entry
.endif
</code></pre>
<p>Let's consider all of these there cases in course.</p>
<h2 id="an-exception-occurred-in-userspace"><a class="header" href="#an-exception-occurred-in-userspace">An exception occurred in userspace</a></h2>
<p>In the first let's consider a case when an exception has <code>paranoid=1</code> like our <code>debug</code> and <code>int3</code> exceptions. In this case we check selector from <code>CS</code> segment register and jump at <code>1f</code> label if we came from userspace or the <code>paranoid_entry</code> will be called in other way.</p>
<p>Let's consider first case when we came from userspace to an exception handler. As described above we should jump at <code>1</code> label. The <code>1</code> label starts from the call of the</p>
<pre><code class="language-assembly">call	error_entry
</code></pre>
<p>routine which saves all general purpose registers in the previously allocated area on the stack:</p>
<pre><code class="language-assembly">SAVE_C_REGS 8
SAVE_EXTRA_REGS 8
</code></pre>
<p>These both macros are defined in the  <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/calling.h">arch/x86/entry/calling.h</a> header file and just move values of general purpose registers to a certain place at the stack, for example:</p>
<pre><code class="language-assembly">.macro SAVE_EXTRA_REGS offset=0
	movq %r15, 0*8+\offset(%rsp)
	movq %r14, 1*8+\offset(%rsp)
	movq %r13, 2*8+\offset(%rsp)
	movq %r12, 3*8+\offset(%rsp)
	movq %rbp, 4*8+\offset(%rsp)
	movq %rbx, 5*8+\offset(%rsp)
.endm
</code></pre>
<p>After execution of <code>SAVE_C_REGS</code> and <code>SAVE_EXTRA_REGS</code> the stack will look:</p>
<pre><code>     +------------+
+160 | %SS        |
+152 | %RSP       |
+144 | %RFLAGS    |
+136 | %CS        |
+128 | %RIP       |
+120 | ERROR CODE |
     |------------|
+112 | %RDI       |
+104 | %RSI       |
 +96 | %RDX       |
 +88 | %RCX       |
 +80 | %RAX       |
 +72 | %R8        |
 +64 | %R9        |
 +56 | %R10       |
 +48 | %R11       |
 +40 | %RBX       |
 +32 | %RBP       |
 +24 | %R12       |
 +16 | %R13       |
  +8 | %R14       |
  +0 | %R15       | &lt;- %RSP
     +------------+
</code></pre>
<p>After the kernel saved general purpose registers at the stack, we should check that we came from userspace space again with:</p>
<pre><code class="language-assembly">testb	$3, CS+8(%rsp)
jz	.Lerror_kernelspace
</code></pre>
<p>because we may have potentially fault if as described in documentation truncated <code>%RIP</code> was reported. Anyway, in both cases the <a href="http://www.felixcloutier.com/x86/SWAPGS.html">SWAPGS</a> instruction will be executed and values from <code>MSR_KERNEL_GS_BASE</code> and <code>MSR_GS_BASE</code> will be swapped. From this moment the <code>%gs</code> register will point to the base address of kernel structures. So, the <code>SWAPGS</code> instruction is called and it was main point of the <code>error_entry</code> routing.</p>
<p>Now we can back to the <code>idtentry</code> macro. We may see following assembler code after the call of <code>error_entry</code>:</p>
<pre><code class="language-assembly">movq	%rsp, %rdi
call	sync_regs
</code></pre>
<p>Here we put base address of stack pointer <code>%rdi</code> register which will be first argument (according to <a href="https://www.uclibc.org/docs/psABI-x86_64.pdf">x86_64 ABI</a>) of the <code>sync_regs</code> function and call this function which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a> source code file:</p>
<pre><code class="language-C">asmlinkage __visible notrace struct pt_regs *sync_regs(struct pt_regs *eregs)
{
	struct pt_regs *regs = task_pt_regs(current);
	*regs = *eregs;
	return regs;
}
</code></pre>
<p>This function takes the result of the <code>task_ptr_regs</code> macro which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/processor.h">arch/x86/include/asm/processor.h</a> header file, stores it in the stack pointer and returns it. The <code>task_ptr_regs</code> macro expands to the address of <code>thread.sp0</code> which represents pointer to the normal kernel stack:</p>
<pre><code class="language-C">#define task_pt_regs(tsk)       ((struct pt_regs *)(tsk)-&gt;thread.sp0 - 1)
</code></pre>
<p>As we came from userspace, this means that exception handler will run in real process context. After we got stack pointer from the <code>sync_regs</code> we switch stack:</p>
<pre><code class="language-assembly">movq	%rax, %rsp
</code></pre>
<p>The last two steps before an exception handler will call secondary handler are:</p>
<ol>
<li>Passing pointer to <code>pt_regs</code> structure which contains preserved general purpose registers to the <code>%rdi</code> register:</li>
</ol>
<pre><code class="language-assembly">movq	%rsp, %rdi
</code></pre>
<p>as it will be passed as first parameter of secondary exception handler.</p>
<ol start="2">
<li>Pass error code to the <code>%rsi</code> register as it will be second argument of an exception handler and set it to <code>-1</code> on the stack for the same purpose as we did it before - to prevent restart of a system call:</li>
</ol>
<pre><code>.if \has_error_code
	movq	ORIG_RAX(%rsp), %rsi
	movq	$-1, ORIG_RAX(%rsp)
.else
	xorl	%esi, %esi
.endif
</code></pre>
<p>Additionally you may see that we zeroed the <code>%esi</code> register above in a case if an exception does not provide error code.</p>
<p>In the end we just call secondary exception handler:</p>
<pre><code class="language-assembly">call	\do_sym
</code></pre>
<p>which:</p>
<pre><code class="language-C">dotraplinkage void do_debug(struct pt_regs *regs, long error_code);
</code></pre>
<p>will be for <code>debug</code> exception and:</p>
<pre><code class="language-C">dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code);
</code></pre>
<p>will be for <code>int 3</code> exception. In this part we will not see implementations of secondary handlers, because they are very specific, but will see some of them in one of next parts.</p>
<p>We just considered first case when an exception occurred in userspace. Let's consider last two.</p>
<h2 id="an-exception-with-paranoid--0-occurred-in-kernelspace"><a class="header" href="#an-exception-with-paranoid--0-occurred-in-kernelspace">An exception with paranoid &gt; 0 occurred in kernelspace</a></h2>
<p>In this case an exception was occurred in kernelspace and <code>idtentry</code> macro is defined with <code>paranoid=1</code> for this exception. This value of <code>paranoid</code> means that we should use slower way that we saw in the beginning of this part to check do we really came from kernelspace or not. The <code>paranoid_entry</code> routing allows us to know this:</p>
<pre><code class="language-assembly">ENTRY(paranoid_entry)
	cld
	SAVE_C_REGS 8
	SAVE_EXTRA_REGS 8
	movl	$1, %ebx
	movl	$MSR_GS_BASE, %ecx
	rdmsr
	testl	%edx, %edx
	js	1f
	SWAPGS
	xorl	%ebx, %ebx
1:	ret
END(paranoid_entry)
</code></pre>
<p>As you may see, this function represents the same that we covered before. We use second (slow) method to get information about previous state of an interrupted task. As we checked this and executed <code>SWAPGS</code> in a case if we came from userspace, we should to do the same that we did before: We need to put pointer to a structure which holds general purpose registers to the <code>%rdi</code> (which will be first parameter of a secondary handler) and put error code if an exception provides it to the <code>%rsi</code> (which will be second parameter of a secondary handler):</p>
<pre><code class="language-assembly">movq	%rsp, %rdi

.if \has_error_code
	movq	ORIG_RAX(%rsp), %rsi
	movq	$-1, ORIG_RAX(%rsp)
.else
	xorl	%esi, %esi
.endif
</code></pre>
<p>The last step before a secondary handler of an exception will be called is cleanup of new <code>IST</code> stack frame:</p>
<pre><code class="language-assembly">.if \shift_ist != -1
	subq	$EXCEPTION_STKSZ, CPU_TSS_IST(\shift_ist)
.endif
</code></pre>
<p>You may remember that we passed the <code>shift_ist</code> as argument of the <code>idtentry</code> macro. Here we check its value and if its not equal to <code>-1</code>, we get pointer to a stack from <code>Interrupt Stack Table</code> by <code>shift_ist</code> index and setup it.</p>
<p>In the end of this second way we just call secondary exception handler as we did it before:</p>
<pre><code class="language-assembly">call	\do_sym
</code></pre>
<p>The last method is similar to previous both, but an exception occurred with <code>paranoid=0</code> and we may use fast method determination of where we are from.</p>
<h2 id="exit-from-an-exception-handler"><a class="header" href="#exit-from-an-exception-handler">Exit from an exception handler</a></h2>
<p>After secondary handler will finish its works, we will return to the <code>idtentry</code> macro and the next step will be jump to the <code>error_exit</code>:</p>
<pre><code class="language-assembly">jmp	error_exit
</code></pre>
<p>routine. The <code>error_exit</code> function defined in the same <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> assembly source code file and the main goal of this function is to know where we are from (from userspace or kernelspace) and execute <code>SWPAGS</code> depends on this. Restore registers to previous state and execute <code>iret</code> instruction to transfer control to an interrupted task.</p>
<p>That's all.</p>
<h2 id="conclusion-18"><a class="header" href="#conclusion-18">Conclusion</a></h2>
<p>It is the end of the third part about interrupts and interrupt handling in the Linux kernel. We saw the initialization of the <a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt descriptor table</a> in the previous part with the <code>#DB</code> and <code>#BP</code> gates and started to dive into preparation before control will be transferred to an exception handler and implementation of some interrupt handlers in this part. In the next part we will continue to dive into this theme and will go next by the <code>setup_arch</code> function and will try to understand interrupts handling related stuff.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-18"><a class="header" href="#links-18">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/X86_debug_register">Debug registers</a></li>
<li><a href="http://en.wikipedia.org/wiki/Intel_80386">Intel 80385</a></li>
<li><a href="http://en.wikipedia.org/wiki/INT_%28x86_instruction%29#INT_3">INT 3</a></li>
<li><a href="http://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a></li>
<li><a href="http://en.wikipedia.org/wiki/Task_state_segment">TSS</a></li>
<li><a href="https://sourceware.org/binutils/docs/as/Error.html#Error">GNU assembly .error directive</a></li>
<li><a href="http://en.wikipedia.org/wiki/DWARF">dwarf2</a></li>
<li><a href="https://sourceware.org/binutils/docs/as/CFI-directives.html">CFI directives</a></li>
<li><a href="http://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a></li>
<li><a href="http://en.wikipedia.org/wiki/System_call">system call</a></li>
<li><a href="http://www.felixcloutier.com/x86/SWAPGS.html">swapgs</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unix_signal#SIGTRAP">SIGTRAP</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">Per-CPU variables</a></li>
<li><a href="https://en.wikipedia.org/wiki/KGDB">kgdb</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts-and-interrupt-handling-part-4"><a class="header" href="#interrupts-and-interrupt-handling-part-4">Interrupts and Interrupt Handling. Part 4.</a></h1>
<h2 id="initialization-of-non-early-interrupt-gates"><a class="header" href="#initialization-of-non-early-interrupt-gates">Initialization of non-early interrupt gates</a></h2>
<p>This is fourth part about an interrupts and exceptions handling in the Linux kernel and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-3">part</a> we saw first early <code>#DB</code> and <code>#BP</code> exceptions handlers from the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a>. We stopped on the right after the <code>early_trap_init</code> function that called in the <code>setup_arch</code> function which defined in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a>. In this part we will continue to dive into an interrupts and exceptions handling in the Linux kernel for <code>x86_64</code> and continue to do it from the place where we left off in the last part. First thing which is related to the interrupts and exceptions handling is the setup of the <code>#PF</code> or <a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a> handler with the <code>early_trap_pf_init</code> function. Let's start from it.</p>
<h2 id="early-page-fault-handler"><a class="header" href="#early-page-fault-handler">Early page fault handler</a></h2>
<p>The <code>early_trap_pf_init</code> function defined in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a>. It uses <code>set_intr_gate</code> macro that fills <a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt Descriptor Table</a> with the given entry:</p>
<pre><code class="language-C">void __init early_trap_pf_init(void)
{
#ifdef CONFIG_X86_64
         set_intr_gate(X86_TRAP_PF, page_fault);
#endif
}
</code></pre>
<p>This macro defined in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/include/asm/desc.h">arch/x86/include/asm/desc.h</a>. We already saw macros like this in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-3">part</a> - <code>set_system_intr_gate</code> and <code>set_intr_gate_ist</code>. This macro checks that given vector number is not greater than <code>255</code> (maximum vector number) and calls <code>_set_gate</code> function as <code>set_system_intr_gate</code> and <code>set_intr_gate_ist</code> did it:</p>
<pre><code class="language-C">#define set_intr_gate(n, addr)                                  \
do {                                                            \
        BUG_ON((unsigned)n &gt; 0xFF);                             \
        _set_gate(n, GATE_INTERRUPT, (void *)addr, 0, 0,        \
                  __KERNEL_CS);                                 \
        _trace_set_gate(n, GATE_INTERRUPT, (void *)trace_##addr,\
                        0, 0, __KERNEL_CS);                     \
} while (0)
</code></pre>
<p>The <code>set_intr_gate</code> macro takes two parameters:</p>
<ul>
<li>vector number of a interrupt;</li>
<li>address of an interrupt handler;</li>
</ul>
<p>In our case they are:</p>
<ul>
<li><code>X86_TRAP_PF</code> - <code>14</code>;</li>
<li><code>page_fault</code> - the interrupt handler entry point.</li>
</ul>
<p>The <code>X86_TRAP_PF</code> is the element of enum which defined in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/include/asm/traprs.h">arch/x86/include/asm/traprs.h</a>:</p>
<pre><code class="language-C">enum {
	...
	...
	...
	...
	X86_TRAP_PF,            /* 14, Page Fault */
	...
	...
	...
}
</code></pre>
<p>When the <code>early_trap_pf_init</code> will be called, the <code>set_intr_gate</code> will be expanded to the call of the <code>_set_gate</code> which will fill the <code>IDT</code> with the handler for the page fault. Now let's look on the implementation of the <code>page_fault</code> handler. The <code>page_fault</code> handler defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> assembly source code file as all exceptions handlers. Let's look on it:</p>
<pre><code class="language-assembly">trace_idtentry page_fault do_page_fault has_error_code=1
</code></pre>
<p>We saw in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-3">part</a> how <code>#DB</code> and <code>#BP</code> handlers defined. They were defined with the <code>idtentry</code> macro, but here we can see <code>trace_idtentry</code>. This macro defined in the same source code file and depends on the <code>CONFIG_TRACING</code> kernel configuration option:</p>
<pre><code class="language-assembly">#ifdef CONFIG_TRACING
.macro trace_idtentry sym do_sym has_error_code:req
idtentry trace(\sym) trace(\do_sym) has_error_code=\has_error_code
idtentry \sym \do_sym has_error_code=\has_error_code
.endm
#else
.macro trace_idtentry sym do_sym has_error_code:req
idtentry \sym \do_sym has_error_code=\has_error_code
.endm
#endif
</code></pre>
<p>We will not dive into exceptions <a href="https://en.wikipedia.org/wiki/Tracing_%28software%29">Tracing</a> now. If <code>CONFIG_TRACING</code> is not set, we can see that <code>trace_idtentry</code> macro just expands to the normal <code>idtentry</code>. We already saw implementation of the <code>idtentry</code> macro in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-3">part</a>, so let's start from the <code>page_fault</code> exception handler.</p>
<p>As we can see in the <code>idtentry</code> definition, the handler of the <code>page_fault</code> is <code>do_page_fault</code> function which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/fault.c">arch/x86/mm/fault.c</a> and as all exceptions handlers it takes two arguments:</p>
<ul>
<li><code>regs</code> - <code>pt_regs</code> structure that holds state of an interrupted process;</li>
<li><code>error_code</code> - error code of the page fault exception.</li>
</ul>
<p>Let's look inside this function. First of all we read content of the <a href="https://en.wikipedia.org/wiki/Control_register">cr2</a> control register:</p>
<pre><code class="language-C">dotraplinkage void notrace
do_page_fault(struct pt_regs *regs, unsigned long error_code)
{
	unsigned long address = read_cr2();
	...
	...
	...
}
</code></pre>
<p>This register contains a linear address which caused <code>page fault</code>. In the next step we make a call of the <code>exception_enter</code> function from the <a href="https://github.com/torvalds/linux/blob/master/include/linux/context_tracking.h">include/linux/context_tracking.h</a>. The <code>exception_enter</code> and <code>exception_exit</code> are functions from context tracking subsystem in the Linux kernel used by the <a href="https://en.wikipedia.org/wiki/Read-copy-update">RCU</a> to remove its dependency on the timer tick while a processor runs in userspace. Almost in every exception handler we will see similar code:</p>
<pre><code class="language-C">enum ctx_state prev_state;
prev_state = exception_enter();
...
... // exception handler here
...
exception_exit(prev_state);
</code></pre>
<p>The <code>exception_enter</code> function checks that <code>context tracking</code> is enabled with the <code>context_tracking_is_enabled</code> and if it is in enabled state, we get previous context with the <code>this_cpu_read</code> (more about <code>this_cpu_*</code> operations you can read in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/this_cpu_ops.txt">Documentation</a>). After this it calls <code>context_tracking_user_exit</code> function which informs the context tracking that the processor is exiting userspace mode and entering the kernel:</p>
<pre><code class="language-C">static inline enum ctx_state exception_enter(void)
{
        enum ctx_state prev_ctx;

        if (!context_tracking_is_enabled())
                return 0;

        prev_ctx = this_cpu_read(context_tracking.state);
        context_tracking_user_exit();

        return prev_ctx;
}
</code></pre>
<p>The state can be one of the:</p>
<pre><code class="language-C">enum ctx_state {
    IN_KERNEL = 0,
	IN_USER,
} state;
</code></pre>
<p>And in the end we return previous context. Between the <code>exception_enter</code> and <code>exception_exit</code> we call actual page fault handler:</p>
<pre><code class="language-C">__do_page_fault(regs, error_code, address);
</code></pre>
<p>The <code>__do_page_fault</code> is defined in the same source code file as <code>do_page_fault</code> - <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/fault.c">arch/x86/mm/fault.c</a>. In the beginning of the <code>__do_page_fault</code> we check state of the <a href="https://www.kernel.org/doc/Documentation/kmemcheck.txt">kmemcheck</a> checker. The <code>kmemcheck</code> detects warns about some uses of uninitialized memory. We need to check it because page fault can be caused by kmemcheck:</p>
<pre><code class="language-C">if (kmemcheck_active(regs))
		kmemcheck_hide(regs);
	prefetchw(&amp;mm-&gt;mmap_sem);
</code></pre>
<p>After this we can see the call of the <code>prefetchw</code> which executes instruction with the same <a href="http://www.felixcloutier.com/x86/PREFETCHW.html">name</a> which fetches <a href="https://en.wikipedia.org/?title=3DNow!">X86_FEATURE_3DNOW</a> to get exclusive <a href="https://en.wikipedia.org/wiki/CPU_cache">cache line</a>. The main purpose of prefetching is to hide the latency of a memory access. In the next step we check that we got page fault not in the kernel space with the following condition:</p>
<pre><code class="language-C">if (unlikely(fault_in_kernel_space(address))) {
...
...
...
}
</code></pre>
<p>where <code>fault_in_kernel_space</code> is:</p>
<pre><code class="language-C">static int fault_in_kernel_space(unsigned long address)
{
        return address &gt;= TASK_SIZE_MAX;
}
</code></pre>
<p>The <code>TASK_SIZE_MAX</code> macro expands to the:</p>
<pre><code class="language-C">#define TASK_SIZE_MAX   ((1UL &lt;&lt; 47) - PAGE_SIZE)
</code></pre>
<p>or <code>0x00007ffffffff000</code>. Pay attention on <code>unlikely</code> macro. There are two macros in the Linux kernel:</p>
<pre><code class="language-C">#define likely(x)      __builtin_expect(!!(x), 1)
#define unlikely(x)    __builtin_expect(!!(x), 0)
</code></pre>
<p>You can <a href="http://lxr.free-electrons.com/ident?i=unlikely">often</a> find these macros in the code of the Linux kernel. Main purpose of these macros is optimization. Sometimes this situation is that we need to check the condition of the code and we know that it will rarely be <code>true</code> or <code>false</code>. With these macros we can tell to the compiler about this. For example</p>
<pre><code class="language-C">static int proc_root_readdir(struct file *file, struct dir_context *ctx)
{
        if (ctx-&gt;pos &lt; FIRST_PROCESS_ENTRY) {
                int error = proc_readdir(file, ctx);
                if (unlikely(error &lt;= 0))
                        return error;
...
...
...
}
</code></pre>
<p>Here we can see <code>proc_root_readdir</code> function which will be called when the Linux <a href="https://en.wikipedia.org/wiki/Virtual_file_system">VFS</a> needs to read the <code>root</code> directory contents. If condition marked with <code>unlikely</code>, compiler can put <code>false</code> code right after branching. Now let's back to the our address check. Comparison between the given address and the <code>0x00007ffffffff000</code> will give us to know, was page fault in the kernel mode or user mode. After this check we know it. After this <code>__do_page_fault</code> routine will try to understand the problem that provoked page fault exception and then will pass address to the appropriate routine. It can be <code>kmemcheck</code> fault, spurious fault, <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> fault and etc. Will not dive into implementation details of the page fault exception handler in this part, because we need to know many different concepts which are provided by the Linux kernel, but will see it in the chapter about the <a href="https://0xax.gitbook.io/linux-insides/summary/mm">memory management</a> in the Linux kernel.</p>
<h2 id="back-to-start_kernel"><a class="header" href="#back-to-start_kernel">Back to start_kernel</a></h2>
<p>There are many different function calls after the <code>early_trap_pf_init</code> in the <code>setup_arch</code> function from different kernel subsystems, but there are no one interrupts and exceptions handling related. So, we have to go back where we came from - <code>start_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c#L492">init/main.c</a>. The first things after the <code>setup_arch</code> is the <code>trap_init</code> function from the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a>. This function makes initialization of the remaining exceptions handlers (remember that we already setup 3 handlers for the <code>#DB</code> - debug exception, <code>#BP</code> - breakpoint exception and <code>#PF</code> - page fault exception). The <code>trap_init</code> function starts from the check of the <a href="https://en.wikipedia.org/wiki/Extended_Industry_Standard_Architecture">Extended Industry Standard Architecture</a>:</p>
<pre><code class="language-C">#ifdef CONFIG_EISA
        void __iomem *p = early_ioremap(0x0FFFD9, 4);

        if (readl(p) == 'E' + ('I'&lt;&lt;8) + ('S'&lt;&lt;16) + ('A'&lt;&lt;24))
                EISA_bus = 1;
        early_iounmap(p, 4);
#endif
</code></pre>
<p>Note that it depends on the <code>CONFIG_EISA</code> kernel configuration parameter which represents <code>EISA</code> support. Here we use <code>early_ioremap</code> function to map <code>I/O</code> memory on the page tables. We use <code>readl</code> function to read first <code>4</code> bytes from the mapped region and if they are equal to <code>EISA</code> string we set <code>EISA_bus</code> to one. In the end we just unmap previously mapped region. More about <code>early_ioremap</code> you can read in the part which describes <a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-2">Fix-Mapped Addresses and ioremap</a>.</p>
<p>After this we start to fill the <code>Interrupt Descriptor Table</code> with the different interrupt gates. First of all we set <code>#DE</code> or <code>Divide Error</code> and <code>#NMI</code> or <code>Non-maskable Interrupt</code>:</p>
<pre><code class="language-C">set_intr_gate(X86_TRAP_DE, divide_error);
set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);
</code></pre>
<p>We use <code>set_intr_gate</code> macro to set the interrupt gate for the <code>#DE</code> exception and <code>set_intr_gate_ist</code> for the <code>#NMI</code>. You can remember that we already used these macros when we have set the interrupts gates for the page fault handler, debug handler and etc, you can find explanation of it in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-3">part</a>. After this we setup exception gates for the following exceptions:</p>
<pre><code class="language-C">set_system_intr_gate(X86_TRAP_OF, &amp;overflow);
set_intr_gate(X86_TRAP_BR, bounds);
set_intr_gate(X86_TRAP_UD, invalid_op);
set_intr_gate(X86_TRAP_NM, device_not_available);
</code></pre>
<p>Here we can see:</p>
<ul>
<li><code>#OF</code> or <code>Overflow</code> exception. This exception indicates that an overflow trap occurred when an special <a href="http://x86.renejeschke.de/html/file_module_x86_id_142.html">INTO</a> instruction was executed;</li>
<li><code>#BR</code> or <code>BOUND Range exceeded</code> exception. This exception indicates that a <code>BOUND-range-exceed</code> fault occurred when a <a href="http://pdos.csail.mit.edu/6.828/2005/readings/i386/BOUND.htm">BOUND</a> instruction was executed;</li>
<li><code>#UD</code> or <code>Invalid Opcode</code> exception. Occurs when a processor attempted to execute invalid or reserved <a href="https://en.wikipedia.org/?title=Opcode">opcode</a>, processor attempted to execute instruction with invalid operand(s) and etc;</li>
<li><code>#NM</code> or <code>Device Not Available</code> exception. Occurs when the processor tries to execute <code>x87 FPU</code> floating point instruction while <code>EM</code> flag in the <a href="https://en.wikipedia.org/wiki/Control_register#CR0">control register</a> <code>cr0</code> was set.</li>
</ul>
<p>In the next step we set the interrupt gate for the <code>#DF</code> or <code>Double fault</code> exception:</p>
<pre><code class="language-C">set_intr_gate_ist(X86_TRAP_DF, &amp;double_fault, DOUBLEFAULT_STACK);
</code></pre>
<p>This exception occurs when processor detected a second exception while calling an exception handler for a prior exception. In usual way when the processor detects another exception while trying to call an exception handler, the two exceptions can be handled serially. If the processor cannot handle them serially, it signals the double-fault or <code>#DF</code> exception.</p>
<p>The following set of the interrupt gates is:</p>
<pre><code class="language-C">set_intr_gate(X86_TRAP_OLD_MF, &amp;coprocessor_segment_overrun);
set_intr_gate(X86_TRAP_TS, &amp;invalid_TSS);
set_intr_gate(X86_TRAP_NP, &amp;segment_not_present);
set_intr_gate_ist(X86_TRAP_SS, &amp;stack_segment, STACKFAULT_STACK);
set_intr_gate(X86_TRAP_GP, &amp;general_protection);
set_intr_gate(X86_TRAP_SPURIOUS, &amp;spurious_interrupt_bug);
set_intr_gate(X86_TRAP_MF, &amp;coprocessor_error);
set_intr_gate(X86_TRAP_AC, &amp;alignment_check);
</code></pre>
<p>Here we can see setup for the following exception handlers:</p>
<ul>
<li><code>#CSO</code> or <code>Coprocessor Segment Overrun</code> - this exception indicates that math <a href="https://en.wikipedia.org/wiki/Coprocessor">coprocessor</a> of an old processor detected a page or segment violation. Modern processors do not generate this exception</li>
<li><code>#TS</code> or <code>Invalid TSS</code> exception - indicates that there was an error related to the <a href="https://en.wikipedia.org/wiki/Task_state_segment">Task State Segment</a>.</li>
<li><code>#NP</code> or <code>Segment Not Present</code> exception indicates that the <code>present flag</code> of a segment or gate descriptor is clear during attempt to load one of <code>cs</code>, <code>ds</code>, <code>es</code>, <code>fs</code>, or <code>gs</code> register.</li>
<li><code>#SS</code> or <code>Stack Fault</code> exception indicates one of the stack related conditions was detected, for example a not-present stack segment is detected when attempting to load the <code>ss</code> register.</li>
<li><code>#GP</code> or <code>General Protection</code> exception indicates that the processor detected one of a class of protection violations called general-protection violations. There are many different conditions that can cause general-protection exception. For example loading the <code>ss</code>, <code>ds</code>, <code>es</code>, <code>fs</code>, or <code>gs</code> register with a segment selector for a system segment, writing to a code segment or a read-only data segment, referencing an entry in the <code>Interrupt Descriptor Table</code> (following an interrupt or exception) that is not an interrupt, trap, or task gate and many many more.</li>
<li><code>Spurious Interrupt</code> - a hardware interrupt that is unwanted.</li>
<li><code>#MF</code> or <code>x87 FPU Floating-Point Error</code> exception caused when the <a href="https://en.wikipedia.org/wiki/X86_instruction_listings#x87_floating-point_instructions">x87 FPU</a> has detected a floating point error.</li>
<li><code>#AC</code> or <code>Alignment Check</code> exception Indicates that the processor detected an unaligned memory operand when alignment checking was enabled.</li>
</ul>
<p>After that we setup this exception gates, we can see setup of the <code>Machine-Check</code> exception:</p>
<pre><code class="language-C">#ifdef CONFIG_X86_MCE
	set_intr_gate_ist(X86_TRAP_MC, &amp;machine_check, MCE_STACK);
#endif
</code></pre>
<p>Note that it depends on the <code>CONFIG_X86_MCE</code> kernel configuration option and indicates that the processor detected an internal <a href="https://en.wikipedia.org/wiki/Machine-check_exception">machine error</a> or a bus error, or that an external agent detected a bus error. The next exception gate is for the <a href="https://en.wikipedia.org/?title=SIMD">SIMD</a> Floating-Point exception:</p>
<pre><code class="language-C">set_intr_gate(X86_TRAP_XF, &amp;simd_coprocessor_error);
</code></pre>
<p>which indicates the processor has detected an <code>SSE</code> or <code>SSE2</code> or <code>SSE3</code> SIMD floating-point exception. There are six classes of numeric exception conditions that can occur while executing an SIMD floating-point instruction:</p>
<ul>
<li>Invalid operation</li>
<li>Divide-by-zero</li>
<li>Denormal operand</li>
<li>Numeric overflow</li>
<li>Numeric underflow</li>
<li>Inexact result (Precision)</li>
</ul>
<p>In the next step we fill the <code>used_vectors</code> array which defined in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/include/asm/desc.h">arch/x86/include/asm/desc.h</a> header file and represents <code>bitmap</code>:</p>
<pre><code class="language-C">DECLARE_BITMAP(used_vectors, NR_VECTORS);
</code></pre>
<p>of the first <code>32</code> interrupts (more about bitmaps in the Linux kernel you can read in the part which describes <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumasks and bitmaps</a>)</p>
<pre><code class="language-C">for (i = 0; i &lt; FIRST_EXTERNAL_VECTOR; i++)
	set_bit(i, used_vectors)
</code></pre>
<p>where <code>FIRST_EXTERNAL_VECTOR</code> is:</p>
<pre><code class="language-C">#define FIRST_EXTERNAL_VECTOR           0x20
</code></pre>
<p>After this we setup the interrupt gate for the <code>ia32_syscall</code> and add <code>0x80</code> to the <code>used_vectors</code> bitmap:</p>
<pre><code class="language-C">#ifdef CONFIG_IA32_EMULATION
        set_system_intr_gate(IA32_SYSCALL_VECTOR, ia32_syscall);
        set_bit(IA32_SYSCALL_VECTOR, used_vectors);
#endif
</code></pre>
<p>There is <code>CONFIG_IA32_EMULATION</code> kernel configuration option on <code>x86_64</code> Linux kernels. This option provides ability to execute 32-bit processes in compatibility-mode. In the next parts we will see how it works, in the meantime we need only to know that there is yet another interrupt gate in the <code>IDT</code> with the vector number <code>0x80</code>. In the next step we maps <code>IDT</code> to the fixmap area:</p>
<pre><code class="language-C">__set_fixmap(FIX_RO_IDT, __pa_symbol(idt_table), PAGE_KERNEL_RO);
idt_descr.address = fix_to_virt(FIX_RO_IDT);
</code></pre>
<p>and write its address to the <code>idt_descr.address</code> (more about fix-mapped addresses you can read in the second part of the <a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-2">Linux kernel memory management</a> chapter). After this we can see the call of the <code>cpu_init</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/cpu/common.c">arch/x86/kernel/cpu/common.c</a>. This function makes initialization of the all <code>per-cpu</code> state. In the beginning of the <code>cpu_init</code> we do the following things: First of all we wait while current cpu is initialized and than we call the <code>cr4_init_shadow</code> function which stores shadow copy of the <code>cr4</code> control register for the current cpu and load CPU microcode if need with the following function calls:</p>
<pre><code class="language-C">wait_for_master_cpu(cpu);
cr4_init_shadow();
load_ucode_ap();
</code></pre>
<p>Next we get the <code>Task State Segment</code> for the current cpu and <code>orig_ist</code> structure which represents origin <code>Interrupt Stack Table</code> values with the:</p>
<pre><code class="language-C">t = &amp;per_cpu(cpu_tss, cpu);
oist = &amp;per_cpu(orig_ist, cpu);
</code></pre>
<p>As we got values of the <code>Task State Segment</code> and <code>Interrupt Stack Table</code> for the current processor, we clear following bits in the <code>cr4</code> control register:</p>
<pre><code class="language-C">cr4_clear_bits(X86_CR4_VME|X86_CR4_PVI|X86_CR4_TSD|X86_CR4_DE);
</code></pre>
<p>with this we disable <code>vm86</code> extension, virtual interrupts, timestamp (<a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">RDTSC</a> can only be executed with the highest privilege) and debug extension. After this we reload the <code>Global Descriptor Table</code> and <code>Interrupt Descriptor table</code> with the:</p>
<pre><code class="language-C">	switch_to_new_gdt(cpu);
	loadsegment(fs, 0);
	load_current_idt();
</code></pre>
<p>After this we setup array of the Thread-Local Storage Descriptors, configure <a href="https://en.wikipedia.org/wiki/NX_bit">NX</a> and load CPU microcode. Now is time to setup and load <code>per-cpu</code> Task State Segments. We are going in a loop through the all exception stack which is <code>N_EXCEPTION_STACKS</code> or <code>4</code> and fill it with <code>Interrupt Stack Tables</code>:</p>
<pre><code class="language-C">	if (!oist-&gt;ist[0]) {
		char *estacks = per_cpu(exception_stacks, cpu);

		for (v = 0; v &lt; N_EXCEPTION_STACKS; v++) {
			estacks += exception_stack_sizes[v];
			oist-&gt;ist[v] = t-&gt;x86_tss.ist[v] =
					(unsigned long)estacks;
			if (v == DEBUG_STACK-1)
				per_cpu(debug_stack_addr, cpu) = (unsigned long)estacks;
		}
	}
</code></pre>
<p>As we have filled <code>Task State Segments</code> with the <code>Interrupt Stack Tables</code> we can set <code>TSS</code> descriptor for the current processor and load it with the:</p>
<pre><code class="language-C">set_tss_desc(cpu, t);
load_TR_desc();
</code></pre>
<p>where <code>set_tss_desc</code> macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/desc.h">arch/x86/include/asm/desc.h</a> writes given  descriptor to the <code>Global Descriptor Table</code> of the given processor:</p>
<pre><code class="language-C">#define set_tss_desc(cpu, addr) __set_tss_desc(cpu, GDT_ENTRY_TSS, addr)
static inline void __set_tss_desc(unsigned cpu, unsigned int entry, void *addr)
{
        struct desc_struct *d = get_cpu_gdt_table(cpu);
        tss_desc tss;
        set_tssldt_descriptor(&amp;tss, (unsigned long)addr, DESC_TSS,
                              IO_BITMAP_OFFSET + IO_BITMAP_BYTES +
                              sizeof(unsigned long) - 1);
        write_gdt_entry(d, entry, &amp;tss, DESC_TSS);
}
</code></pre>
<p>and <code>load_TR_desc</code> macro expands to the <code>ltr</code> or <code>Load Task Register</code> instruction:</p>
<pre><code class="language-C">#define load_TR_desc()                          native_load_tr_desc()
static inline void native_load_tr_desc(void)
{
        asm volatile(&quot;ltr %w0&quot;::&quot;q&quot; (GDT_ENTRY_TSS*8));
}
</code></pre>
<p>In the end of the <code>trap_init</code> function we can see the following code:</p>
<pre><code class="language-C">set_intr_gate_ist(X86_TRAP_DB, &amp;debug, DEBUG_STACK);
set_system_intr_gate_ist(X86_TRAP_BP, &amp;int3, DEBUG_STACK);
...
...
...
#ifdef CONFIG_X86_64
        memcpy(&amp;nmi_idt_table, &amp;idt_table, IDT_ENTRIES * 16);
        set_nmi_gate(X86_TRAP_DB, &amp;debug);
        set_nmi_gate(X86_TRAP_BP, &amp;int3);
#endif
</code></pre>
<p>Here we copy <code>idt_table</code> to the <code>nmi_dit_table</code> and setup exception handlers for the <code>#DB</code> or <code>Debug exception</code> and <code>#BR</code> or <code>Breakpoint exception</code>. You can remember that we already set these interrupt gates in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-3">part</a>, so why do we need to setup it again? We setup it again because when we initialized it before in the <code>early_trap_init</code> function, the <code>Task State Segment</code> was not ready yet, but now it is ready after the call of the <code>cpu_init</code> function.</p>
<p>That's all. Soon we will consider all handlers of these interrupts/exceptions.</p>
<h2 id="conclusion-19"><a class="header" href="#conclusion-19">Conclusion</a></h2>
<p>It is the end of the fourth part about interrupts and interrupt handling in the Linux kernel. We saw the initialization of the <a href="https://en.wikipedia.org/wiki/Task_state_segment">Task State Segment</a> in this part and initialization of the different interrupt handlers as <code>Divide Error</code>, <code>Page Fault</code> exception and etc. You can note that we saw just initialization stuff, and will dive into details about handlers for these exceptions. In the next part we will start to do it.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-19"><a class="header" href="#links-19">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt Descriptor Table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tracing_%28software%29">Tracing</a></li>
<li><a href="https://en.wikipedia.org/wiki/Control_register">cr2</a></li>
<li><a href="https://en.wikipedia.org/wiki/Read-copy-update">RCU</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/this_cpu_ops.txt">this_cpu_* operations</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/kmemcheck.txt">kmemcheck</a></li>
<li><a href="http://www.felixcloutier.com/x86/PREFETCHW.html">prefetchw</a></li>
<li><a href="https://en.wikipedia.org/?title=3DNow!">3DNow</a></li>
<li><a href="https://en.wikipedia.org/wiki/CPU_cache">CPU caches</a></li>
<li><a href="https://en.wikipedia.org/wiki/Virtual_file_system">VFS</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm">Linux kernel memory management</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-2">Fix-Mapped Addresses and ioremap</a></li>
<li><a href="https://en.wikipedia.org/wiki/Extended_Industry_Standard_Architecture">Extended Industry Standard Architecture</a></li>
<li><a href="https://en.wikipedia.org/wiki/INT_%28x86_instruction%29">INT isntruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_142.html">INTO</a></li>
<li><a href="http://pdos.csail.mit.edu/6.828/2005/readings/i386/BOUND.htm">BOUND</a></li>
<li><a href="https://en.wikipedia.org/?title=Opcode">opcode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Control_register#CR0">control register</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_instruction_listings#x87_floating-point_instructions">x87 FPU</a></li>
<li><a href="https://en.wikipedia.org/wiki/Machine-check_exception">MCE exception</a></li>
<li><a href="https://en.wikipedia.org/?title=SIMD">SIMD</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumasks and bitmaps</a></li>
<li><a href="https://en.wikipedia.org/wiki/NX_bit">NX</a></li>
<li><a href="https://en.wikipedia.org/wiki/Task_state_segment">Task State Segment</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-3">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts-and-interrupt-handling-part-5"><a class="header" href="#interrupts-and-interrupt-handling-part-5">Interrupts and Interrupt Handling. Part 5.</a></h1>
<h2 id="implementation-of-exception-handlers"><a class="header" href="#implementation-of-exception-handlers">Implementation of exception handlers</a></h2>
<p>This is the fifth part about an interrupts and exceptions handling in the Linux kernel and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-4">part</a> we stopped on the setting of interrupt gates to the <a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt descriptor Table</a>. We did it in the <code>trap_init</code> function from the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a> source code file. We saw only setting of these interrupt gates in the previous part and in the current part we will see implementation of the exception handlers for these gates. The preparation before an exception handler will be executed is in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> assembly file and occurs in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S#L820">idtentry</a> macro that defines exceptions entry points:</p>
<pre><code class="language-assembly">idtentry divide_error		     do_divide_error		    has_error_code=0
idtentry overflow		     do_overflow		    has_error_code=0
idtentry invalid_op		     do_invalid_op		    has_error_code=0
idtentry bounds			     do_bounds			    has_error_code=0
idtentry device_not_available	     do_device_not_available	    has_error_code=0
idtentry coprocessor_segment_overrun do_coprocessor_segment_overrun has_error_code=0
idtentry invalid_TSS		     do_invalid_TSS		    has_error_code=1
idtentry segment_not_present	     do_segment_not_present	    has_error_code=1
idtentry spurious_interrupt_bug	     do_spurious_interrupt_bug      has_error_code=0
idtentry coprocessor_error	     do_coprocessor_error	    has_error_code=0
idtentry alignment_check	     do_alignment_check		    has_error_code=1
idtentry simd_coprocessor_error	     do_simd_coprocessor_error      has_error_code=0
</code></pre>
<p>The <code>idtentry</code> macro does following preparation before an actual exception handler (<code>do_divide_error</code> for the <code>divide_error</code>, <code>do_overflow</code> for the <code>overflow</code>, etc.) will get control. In another words the <code>idtentry</code> macro allocates place for the registers (<a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/uapi/asm/ptrace.h#L43">pt_regs</a> structure) on the stack, pushes dummy error code for the stack consistency if an interrupt/exception has no error code, checks the segment selector in the <code>cs</code> segment register and switches depends on the previous state (userspace or kernelspace). After all of these preparations it makes a call to an actual interrupt/exception handler:</p>
<pre><code class="language-assembly">.macro idtentry sym do_sym has_error_code:req paranoid=0 shift_ist=-1
ENTRY(\sym)
	...
	...
	...
	call	\do_sym
	...
	...
	...
END(\sym)
.endm
</code></pre>
<p>After an exception handler will finish its work, the <code>idtentry</code> macro restores stack and general purpose registers of an interrupted task and executes <a href="http://x86.renejeschke.de/html/file_module_x86_id_145.html">iret</a> instruction:</p>
<pre><code class="language-assembly">ENTRY(paranoid_exit)
	...
	...
	...
	RESTORE_EXTRA_REGS
	RESTORE_C_REGS
	REMOVE_PT_GPREGS_FROM_STACK 8
	INTERRUPT_RETURN
END(paranoid_exit)
</code></pre>
<p>where <code>INTERRUPT_RETURN</code> is:</p>
<pre><code class="language-assembly">#define INTERRUPT_RETURN	jmp native_iret
...
ENTRY(native_iret)
.global native_irq_return_iret
native_irq_return_iret:
iretq
</code></pre>
<p>More about the <code>idtentry</code> macro you can read in the third part of the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-3">https://0xax.gitbooks.io/linux-insides/content/Interrupts/linux-interrupts-3.html</a> chapter. Ok, now we saw the preparation before an exception handler will be executed and now time to look on the handlers. First of all let's look on the following handlers:</p>
<ul>
<li>divide_error</li>
<li>overflow</li>
<li>invalid_op</li>
<li>coprocessor_segment_overrun</li>
<li>invalid_TSS</li>
<li>segment_not_present</li>
<li>stack_segment</li>
<li>alignment_check</li>
</ul>
<p>All these handlers defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a> source code file with the <code>DO_ERROR</code> macro:</p>
<pre><code class="language-C">DO_ERROR(X86_TRAP_DE,     SIGFPE,  &quot;divide error&quot;,                divide_error)
DO_ERROR(X86_TRAP_OF,     SIGSEGV, &quot;overflow&quot;,                    overflow)
DO_ERROR(X86_TRAP_UD,     SIGILL,  &quot;invalid opcode&quot;,              invalid_op)
DO_ERROR(X86_TRAP_OLD_MF, SIGFPE,  &quot;coprocessor segment overrun&quot;, coprocessor_segment_overrun)
DO_ERROR(X86_TRAP_TS,     SIGSEGV, &quot;invalid TSS&quot;,                 invalid_TSS)
DO_ERROR(X86_TRAP_NP,     SIGBUS,  &quot;segment not present&quot;,         segment_not_present)
DO_ERROR(X86_TRAP_SS,     SIGBUS,  &quot;stack segment&quot;,               stack_segment)
DO_ERROR(X86_TRAP_AC,     SIGBUS,  &quot;alignment check&quot;,             alignment_check)
</code></pre>
<p>As we can see the <code>DO_ERROR</code> macro takes 4 parameters:</p>
<ul>
<li>Vector number of an interrupt;</li>
<li>Signal number which will be sent to the interrupted process;</li>
<li>String which describes an exception;</li>
<li>Exception handler entry point.</li>
</ul>
<p>This macro defined in the same source code file and expands to the function with the <code>do_handler</code> name:</p>
<pre><code class="language-C">#define DO_ERROR(trapnr, signr, str, name)                              \
dotraplinkage void do_##name(struct pt_regs *regs, long error_code)     \
{                                                                       \
        do_error_trap(regs, error_code, str, trapnr, signr);            \
}
</code></pre>
<p>Note on the <code>##</code> tokens. This is special feature - <a href="https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html#Concatenation">GCC macro Concatenation</a> which concatenates two given strings. For example, first <code>DO_ERROR</code> in our example will expands to the:</p>
<pre><code class="language-C">dotraplinkage void do_divide_error(struct pt_regs *regs, long error_code)     \
{
	...
}
</code></pre>
<p>We can see that all functions which are generated by the <code>DO_ERROR</code> macro just make a call to the <code>do_error_trap</code> function from the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a>. Let's look on implementation of the <code>do_error_trap</code> function.</p>
<h2 id="trap-handlers"><a class="header" href="#trap-handlers">Trap handlers</a></h2>
<p>The <code>do_error_trap</code> function starts and ends from the two following functions:</p>
<pre><code class="language-C">enum ctx_state prev_state = exception_enter();
...
...
...
exception_exit(prev_state);
</code></pre>
<p>from the <a href="https://github.com/torvalds/linux/tree/master/include/linux/context_tracking.h">include/linux/context_tracking.h</a>. The context tracking in the Linux kernel subsystem which provide kernel boundaries probes to keep track of the transitions between level contexts with two basic initial contexts: <code>user</code> or <code>kernel</code>. The <code>exception_enter</code> function checks that context tracking is enabled. After this if it is enabled, the <code>exception_enter</code> reads previous context and compares it with the <code>CONTEXT_KERNEL</code>. If the previous context is <code>user</code>, we call <code>context_tracking_exit</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/context_tracking.c">kernel/context_tracking.c</a> which inform the context tracking subsystem that a processor is exiting user mode and entering the kernel mode:</p>
<pre><code class="language-C">if (!context_tracking_is_enabled())
	return 0;

prev_ctx = this_cpu_read(context_tracking.state);
if (prev_ctx != CONTEXT_KERNEL)
	context_tracking_exit(prev_ctx);

return prev_ctx;
</code></pre>
<p>If previous context is non <code>user</code>, we just return it. The <code>pre_ctx</code> has <code>enum ctx_state</code> type which defined in the <a href="https://github.com/torvalds/linux/tree/master/include/linux/context_tracking_state.h">include/linux/context_tracking_state.h</a> and looks as:</p>
<pre><code class="language-C">enum ctx_state {
	CONTEXT_KERNEL = 0,
	CONTEXT_USER,
	CONTEXT_GUEST,
} state;
</code></pre>
<p>The second function is <code>exception_exit</code> defined in the same <a href="https://github.com/torvalds/linux/tree/master/include/linux/context_tracking.h">include/linux/context_tracking.h</a> file and checks that context tracking is enabled and call the <code>context_tracking_enter</code> function if the previous context was <code>user</code>:</p>
<pre><code class="language-C">static inline void exception_exit(enum ctx_state prev_ctx)
{
	if (context_tracking_is_enabled()) {
		if (prev_ctx != CONTEXT_KERNEL)
			context_tracking_enter(prev_ctx);
	}
}
</code></pre>
<p>The <code>context_tracking_enter</code> function informs the context tracking subsystem that a processor is going to enter to the user mode from the kernel mode. We can see the following code between the <code>exception_enter</code> and <code>exception_exit</code>:</p>
<pre><code class="language-C">if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, signr) !=
		NOTIFY_STOP) {
	conditional_sti(regs);
	do_trap(trapnr, signr, str, regs, error_code,
		fill_trap_info(regs, signr, trapnr, &amp;info));
}
</code></pre>
<p>First of all it calls the <code>notify_die</code> function which defined in the <a href="https://github.com/torvalds/linux/tree/master/kernel/notifier.c">kernel/notifier.c</a>. To get notified for <a href="https://en.wikipedia.org/wiki/Kernel_panic">kernel panic</a>, <a href="https://en.wikipedia.org/wiki/Linux_kernel_oops">kernel oops</a>, <a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">Non-Maskable Interrupt</a> or other events the caller needs to insert itself in the <code>notify_die</code> chain and the <code>notify_die</code> function does it. The Linux kernel has special mechanism that allows kernel to ask when something happens and this mechanism called <code>notifiers</code> or <code>notifier chains</code>. This mechanism used for example for the <code>USB</code> hotplug events (look on the <a href="https://github.com/torvalds/linux/tree/master/drivers/usb/core/notify.c">drivers/usb/core/notify.c</a>), for the memory <a href="https://en.wikipedia.org/wiki/Hot_swapping">hotplug</a> (look on the <a href="https://github.com/torvalds/linux/tree/master/include/linux/memory.h">include/linux/memory.h</a>, the <code>hotplug_memory_notifier</code> macro, etc...), system reboots, etc. A notifier chain is thus a simple, singly-linked list. When a Linux kernel subsystem wants to be notified of specific events, it fills out a special <code>notifier_block</code> structure and passes it to the <code>notifier_chain_register</code> function. An event can be sent with the call of the <code>notifier_call_chain</code> function. First of all the <code>notify_die</code> function fills <code>die_args</code> structure with the trap number, trap string, registers and other values:</p>
<pre><code class="language-C">struct die_args args = {
       .regs   = regs,
       .str    = str,
       .err    = err,
       .trapnr = trap,
       .signr  = sig,
}
</code></pre>
<p>and returns the result of the <code>atomic_notifier_call_chain</code> function with the <code>die_chain</code>:</p>
<pre><code class="language-C">static ATOMIC_NOTIFIER_HEAD(die_chain);
return atomic_notifier_call_chain(&amp;die_chain, val, &amp;args);
</code></pre>
<p>which just expands to the <code>atomic_notifier_head</code> structure that contains lock and <code>notifier_block</code>:</p>
<pre><code class="language-C">struct atomic_notifier_head {
        spinlock_t lock;
        struct notifier_block __rcu *head;
};
</code></pre>
<p>The <code>atomic_notifier_call_chain</code> function calls each function in a notifier chain in turn and returns the value of the last notifier function called. If the <code>notify_die</code> in the <code>do_error_trap</code> does not return <code>NOTIFY_STOP</code> we execute <code>conditional_sti</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a> that checks the value of the <a href="https://en.wikipedia.org/wiki/Interrupt_flag">interrupt flag</a> and enables interrupt depends on it:</p>
<pre><code class="language-C">static inline void conditional_sti(struct pt_regs *regs)
{
        if (regs-&gt;flags &amp; X86_EFLAGS_IF)
                local_irq_enable();
}
</code></pre>
<p>more about <code>local_irq_enable</code> macro you can read in the second <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-2">part</a> of this chapter. The next and last call in the <code>do_error_trap</code> is the <code>do_trap</code> function. First of all the <code>do_trap</code> function defined the <code>tsk</code> variable which has <code>task_struct</code> type and represents the current interrupted process. After the definition of the <code>tsk</code>, we can see the call of the <code>do_trap_no_signal</code> function:</p>
<pre><code class="language-C">struct task_struct *tsk = current;

if (!do_trap_no_signal(tsk, trapnr, str, regs, error_code))
	return;
</code></pre>
<p>The <code>do_trap_no_signal</code> function makes two checks:</p>
<ul>
<li>Did we come from the <a href="https://en.wikipedia.org/wiki/Virtual_8086_mode">Virtual 8086</a> mode;</li>
<li>Did we come from the kernelspace.</li>
</ul>
<pre><code class="language-C">if (v8086_mode(regs)) {
	...
}

if (!user_mode(regs)) {
	...
}

return -1;
</code></pre>
<p>We will not consider first case because the <a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a> does not support the <a href="https://en.wikipedia.org/wiki/Virtual_8086_mode">Virtual 8086</a> mode. In the second case we invoke <code>fixup_exception</code> function which will try to recover a fault and <code>die</code> if we can't:</p>
<pre><code class="language-C">if (!fixup_exception(regs)) {
	tsk-&gt;thread.error_code = error_code;
	tsk-&gt;thread.trap_nr = trapnr;
	die(str, regs, error_code);
}
</code></pre>
<p>The <code>die</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/dumpstack.c">arch/x86/kernel/dumpstack.c</a> source code file, prints useful information about stack, registers, kernel modules and caused kernel <a href="https://en.wikipedia.org/wiki/Linux_kernel_oops">oops</a>. If we came from the userspace the <code>do_trap_no_signal</code> function will return <code>-1</code> and the execution of the <code>do_trap</code> function will continue. If we passed through the <code>do_trap_no_signal</code> function and did not exit from the <code>do_trap</code> after this, it means that previous context was - <code>user</code>.  Most exceptions caused by the processor are interpreted by Linux as error conditions, for example division by zero, invalid opcode, etc. When an exception occurs the Linux kernel sends a <a href="https://en.wikipedia.org/wiki/Unix_signal">signal</a> to the interrupted process that caused the exception to notify it of an incorrect condition. So, in the <code>do_trap</code> function we need to send a signal with the given number (<code>SIGFPE</code> for the divide error, <code>SIGILL</code> for a illegal instruction, etc.). First of all we save error code and vector number in the current interrupts process with the filling <code>thread.error_code</code> and <code>thread_trap_nr</code>:</p>
<pre><code class="language-C">tsk-&gt;thread.error_code = error_code;
tsk-&gt;thread.trap_nr = trapnr;
</code></pre>
<p>After this we make a check do we need to print information about unhandled signals for the interrupted process. We check that <code>show_unhandled_signals</code> variable is set, that <code>unhandled_signal</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/signal.c">kernel/signal.c</a> will return unhandled signal(s) and <a href="https://en.wikipedia.org/wiki/Printk">printk</a> rate limit:</p>
<pre><code class="language-C">#ifdef CONFIG_X86_64
	if (show_unhandled_signals &amp;&amp; unhandled_signal(tsk, signr) &amp;&amp;
	    printk_ratelimit()) {
		pr_info(&quot;%s[%d] trap %s ip:%lx sp:%lx error:%lx&quot;,
			tsk-&gt;comm, tsk-&gt;pid, str,
			regs-&gt;ip, regs-&gt;sp, error_code);
		print_vma_addr(&quot; in &quot;, regs-&gt;ip);
		pr_cont(&quot;\n&quot;);
	}
#endif
</code></pre>
<p>And send a given signal to interrupted process:</p>
<pre><code class="language-C">force_sig_info(signr, info ?: SEND_SIG_PRIV, tsk);
</code></pre>
<p>This is the end of the <code>do_trap</code>. We just saw generic implementation for eight different exceptions which are defined with the <code>DO_ERROR</code> macro. Now let's look at other exception handlers.</p>
<h2 id="double-fault"><a class="header" href="#double-fault">Double fault</a></h2>
<p>The next exception is <code>#DF</code> or <code>Double fault</code>. This exception occurs when the processor detected a second exception while calling an exception handler for a prior exception. We set the trap gate for this exception in the previous part:</p>
<pre><code class="language-C">set_intr_gate_ist(X86_TRAP_DF, &amp;double_fault, DOUBLEFAULT_STACK);
</code></pre>
<p>Note that this exception runs on the <code>DOUBLEFAULT_STACK</code> <a href="https://www.kernel.org/doc/Documentation/x86/x86_64/kernel-stacks">Interrupt Stack Table</a> which has index - <code>1</code>:</p>
<pre><code class="language-C">#define DOUBLEFAULT_STACK 1
</code></pre>
<p>The <code>double_fault</code> is handler for this exception and defined in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a>. The <code>double_fault</code> handler starts from the definition of two variables: string that describes exception and interrupted process, as other exception handlers:</p>
<pre><code class="language-C">static const char str[] = &quot;double fault&quot;;
struct task_struct *tsk = current;
</code></pre>
<p>The handler of the double fault exception split on two parts. The first part is the check which checks that a fault is a <code>non-IST</code> fault on the <code>espfix64</code> stack. Actually the <code>iret</code> instruction restores only the bottom <code>16</code> bits when returning to a <code>16</code> bit segment. The <code>espfix</code> feature solves this problem. So if the <code>non-IST</code> fault on the espfix64 stack we modify the stack to make it look like <code>General Protection Fault</code>:</p>
<pre><code class="language-C">struct pt_regs *normal_regs = task_pt_regs(current);

memmove(&amp;normal_regs-&gt;ip, (void *)regs-&gt;sp, 5*8);
ormal_regs-&gt;orig_ax = 0;
regs-&gt;ip = (unsigned long)general_protection;
regs-&gt;sp = (unsigned long)&amp;normal_regs-&gt;orig_ax;
return;
</code></pre>
<p>In the second case we do almost the same that we did in the previous exception handlers. The first is the call of the <code>ist_enter</code> function that discards previous context, <code>user</code> in our case:</p>
<pre><code class="language-C">ist_enter(regs);
</code></pre>
<p>And after this we fill the interrupted process with the vector number of the <code>Double fault</code> exception and error code as we did it in the previous handlers:</p>
<pre><code class="language-C">tsk-&gt;thread.error_code = error_code;
tsk-&gt;thread.trap_nr = X86_TRAP_DF;
</code></pre>
<p>Next we print useful information about the double fault (<a href="https://en.wikipedia.org/wiki/Process_identifier">PID</a> number, registers content):</p>
<pre><code class="language-C">#ifdef CONFIG_DOUBLEFAULT
	df_debug(regs, error_code);
#endif
</code></pre>
<p>And die:</p>
<pre><code>	for (;;)
		die(str, regs, error_code);
</code></pre>
<p>That's all.</p>
<h2 id="device-not-available-exception-handler"><a class="header" href="#device-not-available-exception-handler">Device not available exception handler</a></h2>
<p>The next exception is the <code>#NM</code> or <code>Device not available</code>. The <code>Device not available</code> exception can occur depending on these things:</p>
<ul>
<li>The processor executed an <a href="https://en.wikipedia.org/wiki/X87">x87 FPU</a> floating-point instruction while the EM flag in <a href="https://en.wikipedia.org/wiki/Control_register">control register</a> <code>cr0</code> was set;</li>
<li>The processor executed a <code>wait</code> or <code>fwait</code> instruction while the <code>MP</code> and <code>TS</code> flags of register <code>cr0</code> were set;</li>
<li>The processor executed an <a href="https://en.wikipedia.org/wiki/X87">x87 FPU</a>, <a href="https://en.wikipedia.org/wiki/MMX_%28instruction_set%29">MMX</a> or <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE</a> instruction while the <code>TS</code> flag in control register <code>cr0</code> was set and the <code>EM</code> flag is clear.</li>
</ul>
<p>The handler of the <code>Device not available</code> exception is the <code>do_device_not_available</code> function and it defined in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a> source code file too. It starts and ends from the getting of the previous context, as other traps which we saw in the beginning of this part:</p>
<pre><code class="language-C">enum ctx_state prev_state;
prev_state = exception_enter();
...
...
...
exception_exit(prev_state);
</code></pre>
<p>In the next step we check that <code>FPU</code> is not eager:</p>
<pre><code class="language-C">BUG_ON(use_eager_fpu());
</code></pre>
<p>When we switch into a task or interrupt we may avoid loading the <code>FPU</code> state. If a task will use it, we catch <code>Device not Available exception</code> exception. If we loading the <code>FPU</code> state during task switching, the <code>FPU</code> is eager. In the next step we check <code>cr0</code> control register on the <code>EM</code> flag which can show us is <code>x87</code> floating point unit present (flag clear) or not (flag set):</p>
<pre><code class="language-C">#ifdef CONFIG_MATH_EMULATION
	if (read_cr0() &amp; X86_CR0_EM) {
		struct math_emu_info info = { };

		conditional_sti(regs);

		info.regs = regs;
		math_emulate(&amp;info);
		exception_exit(prev_state);
		return;
	}
#endif
</code></pre>
<p>If the <code>x87</code> floating point unit not presented, we enable interrupts with the <code>conditional_sti</code>, fill the <code>math_emu_info</code> (defined in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/include/asm/math_emu.h">arch/x86/include/asm/math_emu.h</a>) structure with the registers of an interrupt task and call <code>math_emulate</code> function from the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/math-emu/fpu_entry.c">arch/x86/math-emu/fpu_entry.c</a>. As you can understand from function's name, it emulates <code>X87 FPU</code> unit (more about the <code>x87</code> we will know in the special chapter). In other way, if <code>X86_CR0_EM</code> flag is clear which means that <code>x87 FPU</code> unit is presented, we call the <code>fpu__restore</code> function from the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/kernel/fpu/core.c">arch/x86/kernel/fpu/core.c</a> which copies the <code>FPU</code> registers from the <code>fpustate</code> to the live hardware registers. After this <code>FPU</code> instructions can be used:</p>
<pre><code class="language-C">fpu__restore(&amp;current-&gt;thread.fpu);
</code></pre>
<h2 id="general-protection-fault-exception-handler"><a class="header" href="#general-protection-fault-exception-handler">General protection fault exception handler</a></h2>
<p>The next exception is the <code>#GP</code> or <code>General protection fault</code>. This exception occurs when the processor detected one of a class of protection violations called <code>general-protection violations</code>. It can be:</p>
<ul>
<li>Exceeding the segment limit when accessing the <code>cs</code>, <code>ds</code>, <code>es</code>, <code>fs</code> or <code>gs</code> segments;</li>
<li>Loading the <code>ss</code>, <code>ds</code>, <code>es</code>, <code>fs</code> or <code>gs</code> register with a segment selector for a system segment.;</li>
<li>Violating any of the privilege rules;</li>
<li>and other...</li>
</ul>
<p>The exception handler for this exception is the <code>do_general_protection</code> from the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a>. The <code>do_general_protection</code> function starts and ends as other exception handlers from the getting of the previous context:</p>
<pre><code class="language-C">prev_state = exception_enter();
...
exception_exit(prev_state);
</code></pre>
<p>After this we enable interrupts if they were disabled and check that we came from the <a href="https://en.wikipedia.org/wiki/Virtual_8086_mode">Virtual 8086</a> mode:</p>
<pre><code class="language-C">conditional_sti(regs);

if (v8086_mode(regs)) {
	local_irq_enable();
	handle_vm86_fault((struct kernel_vm86_regs *) regs, error_code);
	goto exit;
}
</code></pre>
<p>As long mode does not support this mode, we will not consider exception handling for this case. In the next step check that previous mode was kernel mode and try to fix the trap. If we can't fix the current general protection fault exception we fill the interrupted process with the vector number and error code of the exception and add it to the <code>notify_die</code> chain:</p>
<pre><code class="language-C">if (!user_mode(regs)) {
	if (fixup_exception(regs))
		goto exit;

	tsk-&gt;thread.error_code = error_code;
	tsk-&gt;thread.trap_nr = X86_TRAP_GP;
	if (notify_die(DIE_GPF, &quot;general protection fault&quot;, regs, error_code,
		       X86_TRAP_GP, SIGSEGV) != NOTIFY_STOP)
		die(&quot;general protection fault&quot;, regs, error_code);
	goto exit;
}
</code></pre>
<p>If we can fix exception we go to the <code>exit</code> label which exits from exception state:</p>
<pre><code class="language-C">exit:
	exception_exit(prev_state);
</code></pre>
<p>If we came from user mode we send <code>SIGSEGV</code> signal to the interrupted process from user mode as we did it in the <code>do_trap</code> function:</p>
<pre><code class="language-C">if (show_unhandled_signals &amp;&amp; unhandled_signal(tsk, SIGSEGV) &amp;&amp;
		printk_ratelimit()) {
	pr_info(&quot;%s[%d] general protection ip:%lx sp:%lx error:%lx&quot;,
		tsk-&gt;comm, task_pid_nr(tsk),
		regs-&gt;ip, regs-&gt;sp, error_code);
	print_vma_addr(&quot; in &quot;, regs-&gt;ip);
	pr_cont(&quot;\n&quot;);
}

force_sig_info(SIGSEGV, SEND_SIG_PRIV, tsk);
</code></pre>
<p>That's all.</p>
<h2 id="conclusion-20"><a class="header" href="#conclusion-20">Conclusion</a></h2>
<p>It is the end of the fifth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">Interrupts and Interrupt Handling</a> chapter and we saw implementation of some interrupt handlers in this part. In the next part we will continue to dive into interrupt and exception handlers and will see handler for the <a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">Non-Maskable Interrupts</a>, handling of the math <a href="https://en.wikipedia.org/wiki/Coprocessor">coprocessor</a> and <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> coprocessor exceptions and many many more.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-20"><a class="header" href="#links-20">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt descriptor Table</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_145.html">iret instruction</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html#Concatenation">GCC macro Concatenation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Kernel_panic">kernel panic</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linux_kernel_oops">kernel oops</a></li>
<li><a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">Non-Maskable Interrupt</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hot_swapping">hotplug</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_flag">interrupt flag</a></li>
<li><a href="https://en.wikipedia.org/wiki/Long_mode">long mode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unix_signal">signal</a></li>
<li><a href="https://en.wikipedia.org/wiki/Printk">printk</a></li>
<li><a href="https://en.wikipedia.org/wiki/Coprocessor">coprocessor</a></li>
<li><a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/x86/x86_64/kernel-stacks">Interrupt Stack Table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Process_identifier">PID</a></li>
<li><a href="https://en.wikipedia.org/wiki/X87">x87 FPU</a></li>
<li><a href="https://en.wikipedia.org/wiki/Control_register">control register</a></li>
<li><a href="https://en.wikipedia.org/wiki/MMX_%28instruction_set%29">MMX</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-4">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts-and-interrupt-handling-part-6"><a class="header" href="#interrupts-and-interrupt-handling-part-6">Interrupts and Interrupt Handling. Part 6.</a></h1>
<h2 id="non-maskable-interrupt-handler"><a class="header" href="#non-maskable-interrupt-handler">Non-maskable interrupt handler</a></h2>
<p>It is sixth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">Interrupts and Interrupt Handling in the Linux kernel</a> chapter and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-5">part</a> we saw implementation of some exception handlers for the <a href="https://en.wikipedia.org/wiki/General_protection_fault">General Protection Fault</a> exception, divide exception, invalid <a href="https://en.wikipedia.org/wiki/Opcode">opcode</a> exceptions, etc. As I wrote in the previous part we will see implementations of the rest exceptions in this part. We will see implementation of the following handlers:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">Non-Maskable</a> interrupt;</li>
<li><a href="http://pdos.csail.mit.edu/6.828/2005/readings/i386/BOUND.htm">BOUND</a> Range Exceeded Exception;</li>
<li><a href="https://en.wikipedia.org/wiki/Coprocessor">Coprocessor</a> exception;</li>
<li><a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> coprocessor exception.</li>
</ul>
<p>in this part. So, let's start.</p>
<h2 id="non-maskable-interrupt-handling"><a class="header" href="#non-maskable-interrupt-handling">Non-Maskable interrupt handling</a></h2>
<p>A <a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">Non-Maskable</a> interrupt is a hardware interrupt that cannot be ignored by standard masking techniques. In a general way, a non-maskable interrupt can be generated in either of two ways:</p>
<ul>
<li>External hardware asserts the non-maskable interrupt <a href="https://en.wikipedia.org/wiki/CPU_socket">pin</a> on the CPU.</li>
<li>The processor receives a message on the system bus or the APIC serial bus with a delivery mode <code>NMI</code>.</li>
</ul>
<p>When the processor receives a <code>NMI</code> from one of these sources, the processor handles it immediately by calling the <code>NMI</code> handler pointed to by interrupt vector which has number <code>2</code> (see table in the first <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-1">part</a>). We already filled the <a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt Descriptor Table</a> with the <a href="https://en.wikipedia.org/wiki/Interrupt_vector_table">vector number</a>, address of the <code>nmi</code> interrupt handler and <code>NMI_STACK</code> <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/kernel-stacks">Interrupt Stack Table entry</a>:</p>
<pre><code class="language-C">set_intr_gate_ist(X86_TRAP_NMI, &amp;nmi, NMI_STACK);
</code></pre>
<p>in the <code>trap_init</code> function which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a> source code file. In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">parts</a> we saw that entry points of the all interrupt handlers are defined with the:</p>
<pre><code class="language-assembly">.macro idtentry sym do_sym has_error_code:req paranoid=0 shift_ist=-1
ENTRY(\sym)
...
...
...
END(\sym)
.endm
</code></pre>
<p>macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> assembly source code file. But the handler of the <code>Non-Maskable</code> interrupts is not defined with this macro. It has own entry point:</p>
<pre><code class="language-assembly">ENTRY(nmi)
...
...
...
END(nmi)
</code></pre>
<p>in the same <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> assembly file. Lets dive into it and will try to understand how <code>Non-Maskable</code> interrupt handler works. The <code>nmi</code> handlers starts from the call of the:</p>
<pre><code class="language-assembly">PARAVIRT_ADJUST_EXCEPTION_FRAME
</code></pre>
<p>macro but we will not dive into details about it in this part, because this macro related to the <a href="https://en.wikipedia.org/wiki/Paravirtualization">Paravirtualization</a> stuff which we will see in another chapter. After this save the content of the <code>rdx</code> register on the stack:</p>
<pre><code class="language-assembly">pushq	%rdx
</code></pre>
<p>And allocated check that <code>cs</code> was not the kernel segment when an non-maskable interrupt occurs:</p>
<pre><code class="language-assembly">cmpl	$__KERNEL_CS, 16(%rsp)
jne	first_nmi
</code></pre>
<p>The <code>__KERNEL_CS</code> macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/segment.h">arch/x86/include/asm/segment.h</a> and represented second descriptor in the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a>:</p>
<pre><code class="language-C">#define GDT_ENTRY_KERNEL_CS	2
#define __KERNEL_CS	(GDT_ENTRY_KERNEL_CS*8)
</code></pre>
<p>more about <code>GDT</code> you can read in the second <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-2">part</a> of the Linux kernel booting process chapter. If <code>cs</code> is not kernel segment, it means that it is not nested <code>NMI</code> and we jump on the <code>first_nmi</code> label. Let's consider this case. First of all we put address of the current stack pointer to the <code>rdx</code> and pushes <code>1</code> to the stack in the <code>first_nmi</code> label:</p>
<pre><code class="language-assembly">first_nmi:
	movq	(%rsp), %rdx
	pushq	$1
</code></pre>
<p>Why do we push <code>1</code> on the stack? As the comment says: <code>We allow breakpoints in NMIs</code>. On the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a>, like other architectures, the CPU will not execute another <code>NMI</code> until the first <code>NMI</code> is completed. A <code>NMI</code> interrupt finished with the <a href="http://faydoc.tripod.com/cpu/iret.htm">iret</a> instruction like other interrupts and exceptions do it. If the <code>NMI</code> handler triggers either a <a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a> or <a href="https://en.wikipedia.org/wiki/Breakpoint">breakpoint</a> or another exception which are use <code>iret</code> instruction too. If this happens while in <code>NMI</code> context, the CPU will leave <code>NMI</code> context and a new <code>NMI</code> may come in. The <code>iret</code> used to return from those exceptions will re-enable <code>NMIs</code> and we will get nested non-maskable interrupts. The problem the <code>NMI</code> handler will not return to the state that it was, when the exception triggered, but instead it will return to a state that will allow new <code>NMIs</code> to preempt the running <code>NMI</code> handler. If another <code>NMI</code> comes in before the first NMI handler is complete, the new NMI will write all over the preempted <code>NMIs</code> stack. We can have nested <code>NMIs</code> where the next <code>NMI</code> is using the top of the stack of the previous <code>NMI</code>. It means that we cannot execute it because a nested non-maskable interrupt will corrupt stack of a previous non-maskable interrupt. That's why we have allocated space on the stack for temporary variable. We will check this variable that it was set when a previous <code>NMI</code> is executing and clear if it is not nested <code>NMI</code>. We push <code>1</code> here to the previously allocated space on the stack to denote that a <code>non-maskable</code> interrupt executed currently. Remember that when and <code>NMI</code> or another exception occurs we have the following <a href="https://en.wikipedia.org/wiki/Call_stack">stack frame</a>:</p>
<pre><code>+------------------------+
|         SS             |
|         RSP            |
|        RFLAGS          |
|         CS             |
|         RIP            |
+------------------------+
</code></pre>
<p>and also an error code if an exception has it. So, after all of these manipulations our stack frame will look like this:</p>
<pre><code>+------------------------+
|         SS             |
|         RSP            |
|        RFLAGS          |
|         CS             |
|         RIP            |
|         RDX            |
|          1             |
+------------------------+
</code></pre>
<p>In the next step we allocate yet another <code>40</code> bytes on the stack:</p>
<pre><code class="language-assembly">subq	$(5*8), %rsp
</code></pre>
<p>and pushes the copy of the original stack frame after the allocated space:</p>
<pre><code class="language-C">.rept 5
pushq	11*8(%rsp)
.endr
</code></pre>
<p>with the <a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC116">.rept</a> assembly directive. We need in the copy of the original stack frame. Generally we need in two copies of the interrupt stack. First is <code>copied</code> interrupts stack: <code>saved</code> stack frame and <code>copied</code> stack frame. Now we pushes original stack frame to the <code>saved</code> stack frame which locates after the just allocated <code>40</code> bytes (<code>copied</code> stack frame). This stack frame is used to fixup the <code>copied</code> stack frame that a nested NMI may change. The second - <code>copied</code> stack frame modified by any nested <code>NMIs</code> to let the first <code>NMI</code> know that we triggered a second <code>NMI</code> and we should repeat the first <code>NMI</code> handler. Ok, we have made first copy of the original stack frame, now time to make second copy:</p>
<pre><code class="language-assembly">addq	$(10*8), %rsp

.rept 5
pushq	-6*8(%rsp)
.endr
subq	$(5*8), %rsp
</code></pre>
<p>After all of these manipulations our stack frame will be like this:</p>
<pre><code>+-------------------------+
| original SS             |
| original Return RSP     |
| original RFLAGS         |
| original CS             |
| original RIP            |
+-------------------------+
| temp storage for rdx    |
+-------------------------+
| NMI executing variable  |
+-------------------------+
| copied SS               |
| copied Return RSP       |
| copied RFLAGS           |
| copied CS               |
| copied RIP              |
+-------------------------+
| Saved SS                |
| Saved Return RSP        |
| Saved RFLAGS            |
| Saved CS                |
| Saved RIP               |
+-------------------------+
</code></pre>
<p>After this we push dummy error code on the stack as we did it already in the previous exception handlers and allocate space for the general purpose registers on the stack:</p>
<pre><code class="language-assembly">pushq	$-1
ALLOC_PT_GPREGS_ON_STACK
</code></pre>
<p>We already saw implementation of the <code>ALLOC_PT_GPREGS_ON_STACK</code> macro in the third part of the interrupts <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-3">chapter</a>. This macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/calling.h">arch/x86/entry/calling.h</a> and yet another allocates <code>120</code> bytes on stack for the general purpose registers, from the <code>rdi</code> to the <code>r15</code>:</p>
<pre><code class="language-assembly">.macro ALLOC_PT_GPREGS_ON_STACK addskip=0
addq	$-(15*8+\addskip), %rsp
.endm
</code></pre>
<p>After space allocation for the general registers we can see call of the <code>paranoid_entry</code>:</p>
<pre><code class="language-assembly">call	paranoid_entry
</code></pre>
<p>We can remember from the previous parts this label. It pushes general purpose registers on the stack, reads <code>MSR_GS_BASE</code> <a href="https://en.wikipedia.org/wiki/Model-specific_register">Model Specific register</a> and checks its value. If the value of the <code>MSR_GS_BASE</code> is negative, we came from the kernel mode and just return from the <code>paranoid_entry</code>, in other way it means that we came from the usermode and need to execute <code>swapgs</code> instruction which will change user <code>gs</code> with the kernel <code>gs</code>:</p>
<pre><code class="language-assembly">ENTRY(paranoid_entry)
	cld
	SAVE_C_REGS 8
	SAVE_EXTRA_REGS 8
	movl	$1, %ebx
	movl	$MSR_GS_BASE, %ecx
	rdmsr
	testl	%edx, %edx
	js	1f
	SWAPGS
	xorl	%ebx, %ebx
1:	ret
END(paranoid_entry)
</code></pre>
<p>Note that after the <code>swapgs</code> instruction we zeroed the <code>ebx</code> register. Next time we will check content of this register and if we executed <code>swapgs</code> than <code>ebx</code> must contain <code>0</code> and <code>1</code> in other way. In the next step we store value of the <code>cr2</code> <a href="https://en.wikipedia.org/wiki/Control_register">control register</a> to the <code>r12</code> register, because the <code>NMI</code> handler can cause <code>page fault</code> and corrupt the value of this control register:</p>
<pre><code class="language-C">movq	%cr2, %r12
</code></pre>
<p>Now time to call actual <code>NMI</code> handler. We push the address of the <code>pt_regs</code> to the <code>rdi</code>, error code to the <code>rsi</code> and call the <code>do_nmi</code> handler:</p>
<pre><code class="language-assembly">movq	%rsp, %rdi
movq	$-1, %rsi
call	do_nmi
</code></pre>
<p>We will back to the <code>do_nmi</code> little later in this part, but now let's look what occurs after the <code>do_nmi</code> will finish its execution. After the <code>do_nmi</code> handler will be finished we check the <code>cr2</code> register, because we can got page fault during <code>do_nmi</code> performed and if we got it we restore original <code>cr2</code>, in other way we jump on the label <code>1</code>. After this we test content of the <code>ebx</code> register (remember it must contain <code>0</code> if we have used <code>swapgs</code> instruction and <code>1</code> if we didn't use it) and execute <code>SWAPGS_UNSAFE_STACK</code> if it contains <code>1</code> or jump to the <code>nmi_restore</code> label. The <code>SWAPGS_UNSAFE_STACK</code> macro just expands to the <code>swapgs</code> instruction. In the <code>nmi_restore</code> label we restore general purpose registers, clear allocated space on the stack for this registers, clear our temporary variable and exit from the interrupt handler with the <code>INTERRUPT_RETURN</code> macro:</p>
<pre><code class="language-assembly">	movq	%cr2, %rcx
	cmpq	%rcx, %r12
	je	1f
	movq	%r12, %cr2
1:
	testl	%ebx, %ebx
	jnz	nmi_restore
nmi_swapgs:
	SWAPGS_UNSAFE_STACK
nmi_restore:
	RESTORE_EXTRA_REGS
	RESTORE_C_REGS
	/* Pop the extra iret frame at once */
	REMOVE_PT_GPREGS_FROM_STACK 6*8
	/* Clear the NMI executing stack variable */
	movq	$0, 5*8(%rsp)
	INTERRUPT_RETURN
</code></pre>
<p>where <code>INTERRUPT_RETURN</code> is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/irqflags.h">arch/x86/include/asm/irqflags.h</a> and just expands to the <code>iret</code> instruction. That's all.</p>
<p>Now let's consider case when another <code>NMI</code> interrupt occurred when previous <code>NMI</code> interrupt didn't finish its execution. You can remember from the beginning of this part that we've made a check that we came from userspace and jump on the <code>first_nmi</code> in this case:</p>
<pre><code class="language-assembly">cmpl	$__KERNEL_CS, 16(%rsp)
jne	first_nmi
</code></pre>
<p>Note that in this case it is first <code>NMI</code> every time, because if the first <code>NMI</code> caught page fault, breakpoint or another exception it will be executed in the kernel mode. If we didn't come from userspace, first of all we test our temporary variable:</p>
<pre><code class="language-assembly">cmpl	$1, -8(%rsp)
je	nested_nmi
</code></pre>
<p>and if it is set to <code>1</code> we jump to the <code>nested_nmi</code> label. If it is not <code>1</code>, we test the <code>IST</code> stack. In the case of nested <code>NMIs</code> we check that we are above the <code>repeat_nmi</code>. In this case we ignore it, in other way we check that we above than <code>end_repeat_nmi</code> and jump on the <code>nested_nmi_out</code> label.</p>
<p>Now let's look on the <code>do_nmi</code> exception handler. This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/nmi.c">arch/x86/kernel/nmi.c</a> source code file and takes two parameters:</p>
<ul>
<li>address of the <code>pt_regs</code>;</li>
<li>error code.</li>
</ul>
<p>as all exception handlers. The <code>do_nmi</code> starts from the call of the <code>nmi_nesting_preprocess</code> function and ends with the call of the <code>nmi_nesting_postprocess</code>. The <code>nmi_nesting_preprocess</code> function checks that we likely do not work with the debug stack and if we on the debug stack set the <code>update_debug_stack</code> <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> variable to <code>1</code> and call the <code>debug_stack_set_zero</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/cpu/common.c">arch/x86/kernel/cpu/common.c</a>. This function increases the <code>debug_stack_use_ctr</code> per-cpu variable and loads new <code>Interrupt Descriptor Table</code>:</p>
<pre><code class="language-C">static inline void nmi_nesting_preprocess(struct pt_regs *regs)
{
        if (unlikely(is_debug_stack(regs-&gt;sp))) {
                debug_stack_set_zero();
                this_cpu_write(update_debug_stack, 1);
        }
}
</code></pre>
<p>The <code>nmi_nesting_postprocess</code> function checks the <code>update_debug_stack</code> per-cpu variable which we set in the <code>nmi_nesting_preprocess</code> and resets debug stack or in another words it loads origin <code>Interrupt Descriptor Table</code>. After the call of the <code>nmi_nesting_preprocess</code> function, we can see the call of the <code>nmi_enter</code> in the <code>do_nmi</code>. The <code>nmi_enter</code> increases <code>lockdep_recursion</code> field of the interrupted process, update preempt counter and informs the <a href="https://en.wikipedia.org/wiki/Read-copy-update">RCU</a> subsystem about <code>NMI</code>. There is also <code>nmi_exit</code> function that does the same stuff as <code>nmi_enter</code>, but vice-versa. After the <code>nmi_enter</code> we increase <code>__nmi_count</code> in the <code>irq_stat</code> structure and call the <code>default_do_nmi</code> function. First of all in the <code>default_do_nmi</code> we check the address of the previous nmi and update address of the last nmi to the actual:</p>
<pre><code class="language-C">if (regs-&gt;ip == __this_cpu_read(last_nmi_rip))
    b2b = true;
else
    __this_cpu_write(swallow_nmi, false);

__this_cpu_write(last_nmi_rip, regs-&gt;ip);
</code></pre>
<p>After this first of all we need to handle CPU-specific <code>NMIs</code>:</p>
<pre><code class="language-C">handled = nmi_handle(NMI_LOCAL, regs, b2b);
__this_cpu_add(nmi_stats.normal, handled);
</code></pre>
<p>And then non-specific <code>NMIs</code> depends on its reason:</p>
<pre><code class="language-C">reason = x86_platform.get_nmi_reason();
if (reason &amp; NMI_REASON_MASK) {
	if (reason &amp; NMI_REASON_SERR)
		pci_serr_error(reason, regs);
	else if (reason &amp; NMI_REASON_IOCHK)
		io_check_error(reason, regs);

	__this_cpu_add(nmi_stats.external, 1);
	return;
}
</code></pre>
<p>That's all.</p>
<h2 id="range-exceeded-exception"><a class="header" href="#range-exceeded-exception">Range Exceeded Exception</a></h2>
<p>The next exception is the <code>BOUND</code> range exceeded exception. The <code>BOUND</code> instruction determines if the first operand (array index) is within the bounds of an array specified the second operand (bounds operand). If the index is not within bounds, a <code>BOUND</code> range exceeded exception or <code>#BR</code> is occurred. The handler of the <code>#BR</code> exception is the <code>do_bounds</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a>. The <code>do_bounds</code> handler starts with the call of the <code>exception_enter</code> function and ends with the call of the <code>exception_exit</code>:</p>
<pre><code class="language-C">prev_state = exception_enter();

if (notify_die(DIE_TRAP, &quot;bounds&quot;, regs, error_code,
	           X86_TRAP_BR, SIGSEGV) == NOTIFY_STOP)
    goto exit;
...
...
...
exception_exit(prev_state);
return;
</code></pre>
<p>After we have got the state of the previous context, we add the exception to the <code>notify_die</code> chain and if it will return <code>NOTIFY_STOP</code> we return from the exception. More about notify chains and the <code>context tracking</code> functions you can read in the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-5">previous part</a>. In the next step we enable interrupts if they were disabled with the <code>contidional_sti</code> function that checks <code>IF</code> flag and call the <code>local_irq_enable</code> depends on its value:</p>
<pre><code class="language-C">conditional_sti(regs);

if (!user_mode(regs))
	die(&quot;bounds&quot;, regs, error_code);
</code></pre>
<p>and check that if we didn't came from user mode we send <code>SIGSEGV</code> signal with the <code>die</code> function. After this we check is <a href="https://en.wikipedia.org/wiki/Intel_MPX">MPX</a> enabled or not, and if this feature is disabled we jump on the <code>exit_trap</code> label:</p>
<pre><code class="language-C">if (!cpu_feature_enabled(X86_FEATURE_MPX)) {
	goto exit_trap;
}

where we execute `do_trap` function (more about it you can find in the previous part):

```C
exit_trap:
	do_trap(X86_TRAP_BR, SIGSEGV, &quot;bounds&quot;, regs, error_code, NULL);
	exception_exit(prev_state);
</code></pre>
<p>If <code>MPX</code> feature is enabled we check the <code>BNDSTATUS</code> with the <code>get_xsave_field_ptr</code> function and if it is zero, it means that the <code>MPX</code> was not responsible for this exception:</p>
<pre><code class="language-C">bndcsr = get_xsave_field_ptr(XSTATE_BNDCSR);
if (!bndcsr)
		goto exit_trap;
</code></pre>
<p>After all of this, there is still only one way when <code>MPX</code> is responsible for this exception. We will not dive into the details about Intel Memory Protection Extensions in this part, but will see it in another chapter.</p>
<h2 id="coprocessor-exception-and-simd-exception"><a class="header" href="#coprocessor-exception-and-simd-exception">Coprocessor exception and SIMD exception</a></h2>
<p>The next two exceptions are <a href="https://en.wikipedia.org/wiki/X87">x87 FPU</a> Floating-Point Error exception or <code>#MF</code> and <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> Floating-Point Exception or <code>#XF</code>. The first exception occurs when the <code>x87 FPU</code> has detected floating point error. For example divide by zero, numeric overflow, etc. The second exception occurs when the processor has detected <a href="https://en.wikipedia.org/wiki/SSE3">SSE/SSE2/SSE3</a> <code>SIMD</code> floating-point exception. It can be the same as for the <code>x87 FPU</code>. The handlers for these exceptions are <code>do_coprocessor_error</code> and <code>do_simd_coprocessor_error</code> are defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/traps.c</a> and very similar on each other. They both make a call of the <code>math_error</code> function from the same source code file but pass different vector number. The <code>do_coprocessor_error</code> passes <code>X86_TRAP_MF</code> vector number to the <code>math_error</code>:</p>
<pre><code class="language-C">dotraplinkage void do_coprocessor_error(struct pt_regs *regs, long error_code)
{
	enum ctx_state prev_state;

	prev_state = exception_enter();
	math_error(regs, error_code, X86_TRAP_MF);
	exception_exit(prev_state);
}
</code></pre>
<p>and <code>do_simd_coprocessor_error</code> passes <code>X86_TRAP_XF</code> to the <code>math_error</code> function:</p>
<pre><code class="language-C">dotraplinkage void
do_simd_coprocessor_error(struct pt_regs *regs, long error_code)
{
	enum ctx_state prev_state;

	prev_state = exception_enter();
	math_error(regs, error_code, X86_TRAP_XF);
	exception_exit(prev_state);
}
</code></pre>
<p>First of all the <code>math_error</code> function defines current interrupted task, address of its FPU, string which describes an exception, add it to the <code>notify_die</code> chain and return from the exception handler if it will return <code>NOTIFY_STOP</code>:</p>
<pre><code class="language-C">	struct task_struct *task = current;
	struct fpu *fpu = &amp;task-&gt;thread.fpu;
	siginfo_t info;
	char *str = (trapnr == X86_TRAP_MF) ? &quot;fpu exception&quot; :
						&quot;simd exception&quot;;

	if (notify_die(DIE_TRAP, str, regs, error_code, trapnr, SIGFPE) == NOTIFY_STOP)
		return;
</code></pre>
<p>After this we check that we are from the kernel mode and if yes we will try to fix an exception with the <code>fixup_exception</code> function. If we cannot we fill the task with the exception's error code and vector number and die:</p>
<pre><code class="language-C">if (!user_mode(regs)) {
	if (!fixup_exception(regs)) {
		task-&gt;thread.error_code = error_code;
		task-&gt;thread.trap_nr = trapnr;
		die(str, regs, error_code);
	}
	return;
}
</code></pre>
<p>If we came from the user mode, we save the <code>fpu</code> state, fill the task structure with the vector number of an exception and <code>siginfo_t</code> with the number of signal, <code>errno</code>, the address where exception occurred and signal code:</p>
<pre><code class="language-C">fpu__save(fpu);

task-&gt;thread.trap_nr	= trapnr;
task-&gt;thread.error_code = error_code;
info.si_signo		= SIGFPE;
info.si_errno		= 0;
info.si_addr		= (void __user *)uprobe_get_trap_addr(regs);
info.si_code = fpu__exception_code(fpu, trapnr);
</code></pre>
<p>After this we check the signal code and if it is non-zero we return:</p>
<pre><code class="language-C">if (!info.si_code)
	return;
</code></pre>
<p>Or send the <code>SIGFPE</code> signal in the end:</p>
<pre><code class="language-C">force_sig_info(SIGFPE, &amp;info, task);
</code></pre>
<p>That's all.</p>
<h2 id="conclusion-21"><a class="header" href="#conclusion-21">Conclusion</a></h2>
<p>It is the end of the sixth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">Interrupts and Interrupt Handling</a> chapter and we saw implementation of some exception handlers in this part, like <code>non-maskable</code> interrupt, <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> and <a href="https://en.wikipedia.org/wiki/X87">x87 FPU</a> floating point exception. Finally, we finished with the <code>trap_init</code> function in this part and will go ahead in the next part. The next our point is the external interrupts and the <code>early_irq_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-21"><a class="header" href="#links-21">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/General_protection_fault">General Protection Fault</a></li>
<li><a href="https://en.wikipedia.org/wiki/Opcode">opcode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Non-maskable_interrupt">Non-Maskable</a></li>
<li><a href="http://pdos.csail.mit.edu/6.828/2005/readings/i386/BOUND.htm">BOUND instruction</a></li>
<li><a href="https://en.wikipedia.org/wiki/CPU_socket">CPU socket</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_descriptor_table">Interrupt Descriptor Table</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/kernel-stacks">Interrupt Stack Table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Paravirtualization">Paravirtualization</a></li>
<li><a href="http://tigcc.ticalc.org/doc/gnuasm.html#SEC116">.rept</a></li>
<li><a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a></li>
<li><a href="https://en.wikipedia.org/wiki/Coprocessor">Coprocessor</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="http://faydoc.tripod.com/cpu/iret.htm">iret</a></li>
<li><a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a></li>
<li><a href="https://en.wikipedia.org/wiki/Breakpoint">breakpoint</a></li>
<li><a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Call_stack">stack frame</a></li>
<li><a href="https://en.wikipedia.org/wiki/Model-specific_register">Model Specific register</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a></li>
<li><a href="https://en.wikipedia.org/wiki/Read-copy-update">RCU</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_MPX">MPX</a></li>
<li><a href="https://en.wikipedia.org/wiki/X87">x87 FPU</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-5">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts-and-interrupt-handling-part-7"><a class="header" href="#interrupts-and-interrupt-handling-part-7">Interrupts and Interrupt Handling. Part 7.</a></h1>
<h2 id="introduction-to-external-interrupts"><a class="header" href="#introduction-to-external-interrupts">Introduction to external interrupts</a></h2>
<p>This is the seventh part of the Interrupts and Interrupt Handling in the Linux kernel <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">chapter</a> and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-6">part</a> we have finished with the exceptions which are generated by the processor. In this part we will continue to dive to the interrupt handling and will start with the external hardware interrupt handling. As you can remember, in the previous part we have finished with the <code>trap_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/traps.c">arch/x86/kernel/trap.c</a> and the next step is the call of the <code>early_irq_init</code> function from <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>.</p>
<p>Interrupts are signal that are sent across <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> or <code>Interrupt Request Line</code> by a hardware or software. External hardware interrupts allow devices like keyboard, mouse and etc, to indicate that it needs attention of the processor. Once the processor receives the <code>Interrupt Request</code>, it will temporary stop execution of the running program and invoke special routine which depends on an interrupt. We already know that this routine is called interrupt handler (or how we will call it <code>ISR</code> or <code>Interrupt Service Routine</code> from this part). The <code>ISR</code> or <code>Interrupt Handler Routine</code> can be found in Interrupt Vector table that is located at fixed address in the memory. After the interrupt is handled processor resumes the interrupted process. At the boot/initialization time, the Linux kernel identifies all devices in the machine, and appropriate interrupt handlers are loaded into the interrupt table. As we saw in the previous parts, most exceptions are handled simply by the sending a <a href="https://en.wikipedia.org/wiki/Unix_signal">Unix signal</a> to the interrupted process. That's how the kernel can handle an exception quickly. Unfortunately we can not use this approach for the external hardware interrupts, because often they arrive after (and sometimes long after) the process to which they are related has been suspended. So it would make no sense to send a Unix signal to the current process. External interrupt handling depends on the type of an interrupt:</p>
<ul>
<li><code>I/O</code> interrupts;</li>
<li>Timer interrupts;</li>
<li>Interprocessor interrupts.</li>
</ul>
<p>I will try to describe all types of interrupts in this book.</p>
<p>Generally, a handler of an <code>I/O</code> interrupt must be flexible enough to service several devices at the same time. For example in the <a href="https://en.wikipedia.org/wiki/Conventional_PCI">PCI</a> bus architecture several devices may share the same <code>IRQ</code> line. In the simplest way the Linux kernel must do following thing when an <code>I/O</code> interrupt occurred:</p>
<ul>
<li>Save the value of an <code>IRQ</code> and the register's contents on the kernel stack;</li>
<li>Send an acknowledgment to the hardware controller which is servicing the <code>IRQ</code> line;</li>
<li>Execute the interrupt service routine (next we will call it <code>ISR</code>) which is associated with the device;</li>
<li>Restore registers and return from an interrupt;</li>
</ul>
<p>Ok, we know a little theory and now let's start with the <code>early_irq_init</code> function. The implementation of the <code>early_irq_init</code> function is in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c">kernel/irq/irqdesc.c</a>. This function make early initialization of the <code>irq_desc</code> structure. The <code>irq_desc</code> structure is the foundation of interrupt management code in the Linux kernel. An array of this structure, which has the same name - <code>irq_desc</code>, keeps track of every interrupt request source in the Linux kernel. This structure defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irqdesc.h">include/linux/irqdesc.h</a> and as you can note it depends on the <code>CONFIG_SPARSE_IRQ</code> kernel configuration option. This kernel configuration option enables support for sparse IRQs. The <code>irq_desc</code> structure contains many different fields:</p>
<ul>
<li><code>irq_common_data</code> - per irq and chip data passed down to chip functions;</li>
<li><code>status_use_accessors</code> - contains status of the interrupt source which is combination of the values from the <code>enum</code> from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irq.h">include/linux/irq.h</a> and different macros which are defined in the same source code file;</li>
<li><code>kstat_irqs</code> - irq stats per-cpu;</li>
<li><code>handle_irq</code> - highlevel irq-events handler;</li>
<li><code>action</code> - identifies the interrupt service routines to be invoked when the <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> occurs;</li>
<li><code>irq_count</code> - counter of interrupt occurrences on the IRQ line;</li>
<li><code>depth</code> - <code>0</code> if the IRQ line is enabled and a positive value if it has been disabled at least once;</li>
<li><code>last_unhandled</code> - aging timer for unhandled count;</li>
<li><code>irqs_unhandled</code> - count of the unhandled interrupts;</li>
<li><code>lock</code>  - a spin lock used to serialize the accesses to the <code>IRQ</code> descriptor;</li>
<li><code>pending_mask</code> - pending rebalanced interrupts;</li>
<li><code>owner</code> - an owner of interrupt descriptor. Interrupt descriptors can be allocated from modules. This field is need to proved refcount on the module which provides the interrupts;</li>
<li>and etc.</li>
</ul>
<p>Of course it is not all fields of the <code>irq_desc</code> structure, because it is too long to describe each field of this structure, but we will see it all soon. Now let's start to dive into the implementation of the <code>early_irq_init</code> function.</p>
<h2 id="early-external-interrupts-initialization"><a class="header" href="#early-external-interrupts-initialization">Early external interrupts initialization</a></h2>
<p>Now, let's look on the implementation of the <code>early_irq_init</code> function. Note that implementation of the <code>early_irq_init</code> function depends on the <code>CONFIG_SPARSE_IRQ</code> kernel configuration option. Now we consider implementation of the <code>early_irq_init</code> function when the <code>CONFIG_SPARSE_IRQ</code> kernel configuration option is not set. This function starts from the declaration of the following variables: <code>irq</code> descriptors counter, loop counter, memory node and the <code>irq_desc</code> descriptor:</p>
<pre><code class="language-C">int __init early_irq_init(void)
{
        int count, i, node = first_online_node;
        struct irq_desc *desc;
		...
		...
		...
}
</code></pre>
<p>The <code>node</code> is an online <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">NUMA</a> node which depends on the <code>MAX_NUMNODES</code> value which depends on the <code>CONFIG_NODES_SHIFT</code> kernel configuration parameter:</p>
<pre><code class="language-C">#define MAX_NUMNODES    (1 &lt;&lt; NODES_SHIFT)
...
...
...
#ifdef CONFIG_NODES_SHIFT
    #define NODES_SHIFT     CONFIG_NODES_SHIFT
#else
    #define NODES_SHIFT     0
#endif
</code></pre>
<p>As I already wrote, implementation of the <code>first_online_node</code> macro depends on the <code>MAX_NUMNODES</code> value:</p>
<pre><code class="language-C">#if MAX_NUMNODES &gt; 1
  #define first_online_node       first_node(node_states[N_ONLINE])
#else
  #define first_online_node       0
</code></pre>
<p>The <code>node_states</code> is the <a href="https://en.wikipedia.org/wiki/Enumerated_type">enum</a> which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/nodemask.h">include/linux/nodemask.h</a> and represent the set of the states of a node. In our case we are searching an online node and it will be <code>0</code> if <code>MAX_NUMNODES</code> is one or zero. If the <code>MAX_NUMNODES</code> is greater than one, the <code>node_states[N_ONLINE]</code> will return <code>1</code> and the <code>first_node</code> macro will be expanded to the call of the <code>__first_node</code> function which will return <code>minimal</code> or the first online node:</p>
<pre><code class="language-C">#define first_node(src) __first_node(&amp;(src))

static inline int __first_node(const nodemask_t *srcp)
{
        return min_t(int, MAX_NUMNODES, find_first_bit(srcp-&gt;bits, MAX_NUMNODES));
}
</code></pre>
<p>More about this will be in the another chapter about the <code>NUMA</code>. The next step after the declaration of these local variables is the call of the:</p>
<pre><code class="language-C">init_irq_default_affinity();
</code></pre>
<p>function. The <code>init_irq_default_affinity</code> function defined in the same source code file and depends on the <code>CONFIG_SMP</code> kernel configuration option allocates a given <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumask</a> structure (in our case it is the <code>irq_default_affinity</code>):</p>
<pre><code class="language-C">#if defined(CONFIG_SMP)
cpumask_var_t irq_default_affinity;

static void __init init_irq_default_affinity(void)
{
        alloc_cpumask_var(&amp;irq_default_affinity, GFP_NOWAIT);
        cpumask_setall(irq_default_affinity);
}
#else
static void __init init_irq_default_affinity(void)
{
}
#endif
</code></pre>
<p>We know that when a hardware, such as disk controller or keyboard, needs attention from the processor, it throws an interrupt. The interrupt tells to the processor that something has happened and that the processor should interrupt current process and handle an incoming event. In order to prevent multiple devices from sending the same interrupts, the <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> system was established where each device in a computer system is assigned its own special IRQ so that its interrupts are unique. Linux kernel can assign certain <code>IRQs</code> to specific processors. This is known as <code>SMP IRQ affinity</code>, and it allows you to control how your system will respond to various hardware events (that's why it has certain implementation only if the <code>CONFIG_SMP</code> kernel configuration option is set). After we allocated <code>irq_default_affinity</code> cpumask, we can see <code>printk</code> output:</p>
<pre><code class="language-C">printk(KERN_INFO &quot;NR_IRQS:%d\n&quot;, NR_IRQS);
</code></pre>
<p>which prints <code>NR_IRQS</code>:</p>
<pre><code class="language-C">~$ dmesg | grep NR_IRQS
[    0.000000] NR_IRQS:4352
</code></pre>
<p>The <code>NR_IRQS</code> is the maximum number of the <code>irq</code> descriptors or in another words maximum number of interrupts. Its value depends on the state of the <code>CONFIG_X86_IO_APIC</code> kernel configuration option. If the <code>CONFIG_X86_IO_APIC</code> is not set and the Linux kernel uses an old <a href="https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller">PIC</a> chip, the <code>NR_IRQS</code> is:</p>
<pre><code class="language-C">#define NR_IRQS_LEGACY                    16

#ifdef CONFIG_X86_IO_APIC
...
...
...
#else
# define NR_IRQS                        NR_IRQS_LEGACY
#endif
</code></pre>
<p>In other way, when the <code>CONFIG_X86_IO_APIC</code> kernel configuration option is set, the <code>NR_IRQS</code> depends on the amount of the processors and amount of the interrupt vectors:</p>
<pre><code class="language-C">#define CPU_VECTOR_LIMIT               (64 * NR_CPUS)
#define NR_VECTORS                     256
#define IO_APIC_VECTOR_LIMIT           ( 32 * MAX_IO_APICS )
#define MAX_IO_APICS                   128

# define NR_IRQS                                       \
        (CPU_VECTOR_LIMIT &gt; IO_APIC_VECTOR_LIMIT ?     \
                (NR_VECTORS + CPU_VECTOR_LIMIT)  :     \
                (NR_VECTORS + IO_APIC_VECTOR_LIMIT))
...
...
...
</code></pre>
<p>We remember from the previous parts, that the amount of processors we can set during Linux kernel configuration process with the <code>CONFIG_NR_CPUS</code> configuration option:</p>
<p><img src="Interrupts/images/kernel.png" alt="kernel" /></p>
<p>In the first case (<code>CPU_VECTOR_LIMIT &gt; IO_APIC_VECTOR_LIMIT</code>), the <code>NR_IRQS</code> will be <code>4352</code>, in the second case (<code>CPU_VECTOR_LIMIT &lt; IO_APIC_VECTOR_LIMIT</code>), the <code>NR_IRQS</code> will be <code>768</code>. In my case the <code>NR_CPUS</code> is <code>8</code> as you can see in the my configuration, the <code>CPU_VECTOR_LIMIT</code> is <code>512</code> and the <code>IO_APIC_VECTOR_LIMIT</code> is <code>4096</code>. So <code>NR_IRQS</code> for my configuration is <code>4352</code>:</p>
<pre><code>~$ dmesg | grep NR_IRQS
[    0.000000] NR_IRQS:4352
</code></pre>
<p>In the next step we assign array of the IRQ descriptors to the <code>irq_desc</code> variable which we defined in the start of the <code>early_irq_init</code> function and calculate count of the <code>irq_desc</code> array with the <code>ARRAY_SIZE</code> macro:</p>
<pre><code class="language-C">desc = irq_desc;
count = ARRAY_SIZE(irq_desc);
</code></pre>
<p>The <code>irq_desc</code> array defined in the same source code file and looks like:</p>
<pre><code class="language-C">struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
        [0 ... NR_IRQS-1] = {
                .handle_irq     = handle_bad_irq,
                .depth          = 1,
                .lock           = __RAW_SPIN_LOCK_UNLOCKED(irq_desc-&gt;lock),
        }
};
</code></pre>
<p>The <code>irq_desc</code> is array of the <code>irq</code> descriptors. It has three already initialized fields:</p>
<ul>
<li><code>handle_irq</code> - as I already wrote above, this field is the highlevel irq-event handler. In our case it initialized with the <code>handle_bad_irq</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/handle.c">kernel/irq/handle.c</a> source code file and handles spurious and unhandled IRQs;</li>
<li><code>depth</code> - <code>0</code> if the IRQ line is enabled and a positive value if it has been disabled at least once;</li>
<li><code>lock</code> - A spin lock used to serialize the accesses to the <code>IRQ</code> descriptor.</li>
</ul>
<p>As we calculated count of the interrupts and initialized our <code>irq_desc</code> array, we start to fill descriptors in the loop:</p>
<pre><code class="language-C">for (i = 0; i &lt; count; i++) {
    desc[i].kstat_irqs = alloc_percpu(unsigned int);
    alloc_masks(&amp;desc[i], GFP_KERNEL, node);
    raw_spin_lock_init(&amp;desc[i].lock);
    lockdep_set_class(&amp;desc[i].lock, &amp;irq_desc_lock_class);
	desc_set_defaults(i, &amp;desc[i], node, NULL);
}
</code></pre>
<p>We are going through the all interrupt descriptors and do the following things:</p>
<p>First of all we allocate <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a> variable for the <code>irq</code> kernel statistic with the <code>alloc_percpu</code> macro. This macro allocates one instance of an object of the given type for every processor on the system. You can access kernel statistic from the userspace via <code>/proc/stat</code>:</p>
<pre><code>~$ cat /proc/stat
cpu  207907 68 53904 5427850 14394 0 394 0 0 0
cpu0 25881 11 6684 679131 1351 0 18 0 0 0
cpu1 24791 16 5894 679994 2285 0 24 0 0 0
cpu2 26321 4 7154 678924 664 0 71 0 0 0
cpu3 26648 8 6931 678891 414 0 244 0 0 0
...
...
...
</code></pre>
<p>Where the sixth column is the servicing interrupts. After this we allocate <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumask</a> for the given irq descriptor affinity and initialize the <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a> for the given interrupt descriptor. After this before the <a href="https://en.wikipedia.org/wiki/Critical_section">critical section</a>, the lock will be acquired with a call of the <code>raw_spin_lock</code> and unlocked with the call of the <code>raw_spin_unlock</code>. In the next step we call the <code>lockdep_set_class</code> macro which set the <a href="https://lwn.net/Articles/185666/">Lock validator</a> <code>irq_desc_lock_class</code> class for the lock of the given interrupt descriptor. More about <code>lockdep</code>, <code>spinlock</code> and other synchronization primitives will be described in the separate chapter.</p>
<p>In the end of the loop we call the <code>desc_set_defaults</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c">kernel/irq/irqdesc.c</a>. This function takes four parameters:</p>
<ul>
<li>number of a irq;</li>
<li>interrupt descriptor;</li>
<li>online <code>NUMA</code> node;</li>
<li>owner of interrupt descriptor. Interrupt descriptors can be allocated from modules. This field is need to proved refcount on the module which provides the interrupts;</li>
</ul>
<p>and fills the rest of the <code>irq_desc</code> fields. The <code>desc_set_defaults</code> function fills interrupt number, <code>irq</code> chip, platform-specific per-chip private data for the chip methods, per-IRQ data for the <code>irq_chip</code> methods and <a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">MSI</a> descriptor for the per <code>irq</code> and <code>irq</code> chip data:</p>
<pre><code class="language-C">desc-&gt;irq_data.irq = irq;
desc-&gt;irq_data.chip = &amp;no_irq_chip;
desc-&gt;irq_data.chip_data = NULL;
desc-&gt;irq_data.handler_data = NULL;
desc-&gt;irq_data.msi_desc = NULL;
...
...
...
</code></pre>
<p>The <code>irq_data.chip</code> structure provides general <code>API</code> like the <code>irq_set_chip</code>, <code>irq_set_irq_type</code> and etc, for the irq controller <a href="https://github.com/torvalds/linux/tree/master/drivers/irqchip">drivers</a>. You can find it in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/chip.c">kernel/irq/chip.c</a> source code file.</p>
<p>After this we set the status of the accessor for the given descriptor and set disabled state of the interrupts:</p>
<pre><code class="language-C">...
...
...
irq_settings_clr_and_set(desc, ~0, _IRQ_DEFAULT_INIT_FLAGS);
irqd_set(&amp;desc-&gt;irq_data, IRQD_IRQ_DISABLED);
...
...
...
</code></pre>
<p>In the next step we set the high level interrupt handlers to the <code>handle_bad_irq</code> which handles spurious and unhandled IRQs (as the hardware stuff is not initialized yet, we set this handler), set <code>irq_desc.desc</code> to <code>1</code> which means that an <code>IRQ</code> is disabled, reset count of the unhandled interrupts and interrupts in general:</p>
<pre><code class="language-C">...
...
...
desc-&gt;handle_irq = handle_bad_irq;
desc-&gt;depth = 1;
desc-&gt;irq_count = 0;
desc-&gt;irqs_unhandled = 0;
desc-&gt;name = NULL;
desc-&gt;owner = owner;
...
...
...
</code></pre>
<p>After this we go through the all <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">possible</a> processor with the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/cpumask.h#L714">for_each_possible_cpu</a> helper and set the <code>kstat_irqs</code> to zero for the given interrupt descriptor:</p>
<pre><code class="language-C">	for_each_possible_cpu(cpu)
		*per_cpu_ptr(desc-&gt;kstat_irqs, cpu) = 0;
</code></pre>
<p>and call the <code>desc_smp_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c">kernel/irq/irqdesc.c</a> that initializes <code>NUMA</code> node of the given interrupt descriptor, sets default <code>SMP</code> affinity and clears the <code>pending_mask</code> of the given interrupt descriptor depends on the value of the <code>CONFIG_GENERIC_PENDING_IRQ</code> kernel configuration option:</p>
<pre><code class="language-C">static void desc_smp_init(struct irq_desc *desc, int node)
{
        desc-&gt;irq_data.node = node;
        cpumask_copy(desc-&gt;irq_data.affinity, irq_default_affinity);
#ifdef CONFIG_GENERIC_PENDING_IRQ
        cpumask_clear(desc-&gt;pending_mask);
#endif
}
</code></pre>
<p>In the end of the <code>early_irq_init</code> function we return the return value of the <code>arch_early_irq_init</code> function:</p>
<pre><code class="language-C">return arch_early_irq_init();
</code></pre>
<p>This function defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/apic/vector.c">kernel/apic/vector.c</a> and contains only one call of the <code>arch_early_ioapic_init</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/apic/io_apic.c">kernel/apic/io_apic.c</a>. As we can understand from the <code>arch_early_ioapic_init</code> function's name, this function makes early initialization of the <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">I/O APIC</a>. First of all it make a check of the number of the legacy interrupts with the call of the <code>nr_legacy_irqs</code> function. If we have no legacy interrupts with the <a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a> programmable interrupt controller we set <code>io_apic_irqs</code> to the <code>0xffffffffffffffff</code>:</p>
<pre><code class="language-C">if (!nr_legacy_irqs())
	io_apic_irqs = ~0UL;
</code></pre>
<p>After this we are going through the all <code>I/O APICs</code> and allocate space for the registers with the call of the <code>alloc_ioapic_saved_registers</code>:</p>
<pre><code class="language-C">for_each_ioapic(i)
	alloc_ioapic_saved_registers(i);
</code></pre>
<p>And in the end of the <code>arch_early_ioapic_init</code> function we are going through the all legacy IRQs (from <code>IRQ0</code> to <code>IRQ15</code>) in the loop and allocate space for the <code>irq_cfg</code> which represents configuration of an irq on the given <code>NUMA</code> node:</p>
<pre><code class="language-C">for (i = 0; i &lt; nr_legacy_irqs(); i++) {
    cfg = alloc_irq_and_cfg_at(i, node);
    cfg-&gt;vector = IRQ0_VECTOR + i;
    cpumask_setall(cfg-&gt;domain);
}
</code></pre>
<p>That's all.</p>
<h2 id="sparse-irqs"><a class="header" href="#sparse-irqs">Sparse IRQs</a></h2>
<p>We already saw in the beginning of this part that implementation of the <code>early_irq_init</code> function depends on the <code>CONFIG_SPARSE_IRQ</code> kernel configuration option. Previously we saw implementation of the <code>early_irq_init</code> function when the <code>CONFIG_SPARSE_IRQ</code> configuration option is not set, now let's look at its implementation when this option is set. Implementation of this function very similar, but little differ. We can see the same definition of variables and call of the <code>init_irq_default_affinity</code> in the beginning of the <code>early_irq_init</code> function:</p>
<pre><code class="language-C">#ifdef CONFIG_SPARSE_IRQ
int __init early_irq_init(void)
{
    int i, initcnt, node = first_online_node;
	struct irq_desc *desc;

	init_irq_default_affinity();
	...
	...
	...
}
#else
...
...
...
</code></pre>
<p>But after this we can see the following call:</p>
<pre><code class="language-C">initcnt = arch_probe_nr_irqs();
</code></pre>
<p>The <code>arch_probe_nr_irqs</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/apic/vector.c">arch/x86/kernel/apic/vector.c</a> and calculates count of the pre-allocated IRQs and update <code>nr_irqs</code> with this number. But stop. Why are there pre-allocated IRQs? There is alternative form of interrupts called - <a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">Message Signaled Interrupts</a> available in the <a href="https://en.wikipedia.org/wiki/Conventional_PCI">PCI</a>. Instead of assigning a fixed number of the interrupt request, the device is allowed to record a message at a particular address of RAM, in fact, the display on the <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#Integrated_local_APICs">Local APIC</a>. <code>MSI</code> permits a device to allocate <code>1</code>, <code>2</code>, <code>4</code>, <code>8</code>, <code>16</code> or <code>32</code> interrupts and <code>MSI-X</code> permits a device to allocate up to <code>2048</code> interrupts. Now we know that IRQs can be pre-allocated. More about <code>MSI</code> will be in a next part, but now let's look on the <code>arch_probe_nr_irqs</code> function. We can see the check which assign amount of the interrupt vectors for the each processor in the system to the <code>nr_irqs</code> if it is greater and calculate the <code>nr</code> which represents number of <code>MSI</code> interrupts:</p>
<pre><code class="language-C">int nr_irqs = NR_IRQS;

if (nr_irqs &gt; (NR_VECTORS * nr_cpu_ids))
	nr_irqs = NR_VECTORS * nr_cpu_ids;

nr = (gsi_top + nr_legacy_irqs()) + 8 * nr_cpu_ids;
</code></pre>
<p>Take a look on the <code>gsi_top</code> variable. Each <code>APIC</code> is identified with its own <code>ID</code> and with the offset where its <code>IRQ</code> starts. It is called <code>GSI</code> base or <code>Global System Interrupt</code> base. So the <code>gsi_top</code> represents it. We get the <code>Global System Interrupt</code> base from the <a href="https://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Configuration Table</a> table (you can remember that we have parsed this table in the sixth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-6">part</a> of the Linux kernel initialization process chapter).</p>
<p>After this we update the <code>nr</code> depends on the value of the <code>gsi_top</code>:</p>
<pre><code class="language-C">#if defined(CONFIG_PCI_MSI) || defined(CONFIG_HT_IRQ)
        if (gsi_top &lt;= NR_IRQS_LEGACY)
                nr +=  8 * nr_cpu_ids;
        else
                nr += gsi_top * 16;
#endif
</code></pre>
<p>Update the <code>nr_irqs</code> if it less than <code>nr</code> and return the number of the legacy IRQs:</p>
<pre><code class="language-C">if (nr &lt; nr_irqs)
    nr_irqs = nr;

return nr_legacy_irqs();
}
</code></pre>
<p>The next after the <code>arch_probe_nr_irqs</code> is printing information about number of <code>IRQs</code>:</p>
<pre><code class="language-C">printk(KERN_INFO &quot;NR_IRQS:%d nr_irqs:%d %d\n&quot;, NR_IRQS, nr_irqs, initcnt);
</code></pre>
<p>We can find it in the <a href="https://en.wikipedia.org/wiki/Dmesg">dmesg</a> output:</p>
<pre><code>$ dmesg | grep NR_IRQS
[    0.000000] NR_IRQS:4352 nr_irqs:488 16
</code></pre>
<p>After this we do some checks that <code>nr_irqs</code> and <code>initcnt</code> values is not greater than maximum allowable number of <code>irqs</code>:</p>
<pre><code class="language-C">if (WARN_ON(nr_irqs &gt; IRQ_BITMAP_BITS))
    nr_irqs = IRQ_BITMAP_BITS;

if (WARN_ON(initcnt &gt; IRQ_BITMAP_BITS))
    initcnt = IRQ_BITMAP_BITS;
</code></pre>
<p>where <code>IRQ_BITMAP_BITS</code> is equal to the <code>NR_IRQS</code> if the <code>CONFIG_SPARSE_IRQ</code> is not set and <code>NR_IRQS + 8196</code> in other way. In the next step we are going over all interrupt descriptors which need to be allocated in the loop and allocate space for the descriptor and insert to the <code>irq_desc_tree</code> <a href="https://0xax.gitbook.io/linux-insides/summary/datastructures/linux-datastructures-2">radix tree</a>:</p>
<pre><code class="language-C">for (i = 0; i &lt; initcnt; i++) {
    desc = alloc_desc(i, node, NULL);
    set_bit(i, allocated_irqs);
	irq_insert_desc(i, desc);
}
</code></pre>
<p>In the end of the <code>early_irq_init</code> function we return the value of the call of the <code>arch_early_irq_init</code> function as we did it already in the previous variant when the <code>CONFIG_SPARSE_IRQ</code> option was not set:</p>
<pre><code class="language-C">return arch_early_irq_init();
</code></pre>
<p>That's all.</p>
<h2 id="conclusion-22"><a class="header" href="#conclusion-22">Conclusion</a></h2>
<p>It is the end of the seventh part of the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">Interrupts and Interrupt Handling</a> chapter and we started to dive into external hardware interrupts in this part. We saw early initialization of the <code>irq_desc</code> structure which represents description of an external interrupt and contains information about it like list of irq actions, information about interrupt handler, interrupt's owner, count of the unhandled interrupt and etc. In the next part we will continue to research external interrupts.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-22"><a class="header" href="#links-22">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a></li>
<li><a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">numa</a></li>
<li><a href="https://en.wikipedia.org/wiki/Enumerated_type">Enum type</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumask</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a></li>
<li><a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Critical_section">critical section</a></li>
<li><a href="https://lwn.net/Articles/185666/">Lock validator</a></li>
<li><a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">MSI</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">I/O APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#Integrated_local_APICs">Local APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a></li>
<li><a href="https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller">PIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Configuration Table</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/datastructures/linux-datastructures-2">radix tree</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dmesg">dmesg</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts-and-interrupt-handling-part-8"><a class="header" href="#interrupts-and-interrupt-handling-part-8">Interrupts and Interrupt Handling. Part 8.</a></h1>
<h2 id="non-early-initialization-of-the-irqs"><a class="header" href="#non-early-initialization-of-the-irqs">Non-early initialization of the IRQs</a></h2>
<p>This is the eighth part of the Interrupts and Interrupt Handling in the Linux kernel <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">chapter</a> and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-7">part</a> we started to dive into the external hardware <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">interrupts</a>. We looked on the implementation of the <code>early_irq_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c">kernel/irq/irqdesc.c</a> source code file and saw the initialization of the <code>irq_desc</code> structure in this function. Remind that <code>irq_desc</code> structure (defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irqdesc.h#L46">include/linux/irqdesc.h</a> is the foundation of interrupt management code in the Linux kernel and represents an interrupt descriptor. In this part we will continue to dive into the initialization stuff which is related to the external hardware interrupts.</p>
<p>Right after the call of the <code>early_irq_init</code> function in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> we can see the call of the <code>init_IRQ</code> function. This function is architecture-specific and defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/irqinit.c">arch/x86/kernel/irqinit.c</a>. The <code>init_IRQ</code> function makes initialization of the <code>vector_irq</code> <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a> variable that defined in the same <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/irqinit.c">arch/x86/kernel/irqinit.c</a> source code file:</p>
<pre><code class="language-C">...
DEFINE_PER_CPU(vector_irq_t, vector_irq) = {
         [0 ... NR_VECTORS - 1] = -1,
};
...
</code></pre>
<p>and represents <code>percpu</code> array of the interrupt vector numbers. The <code>vector_irq_t</code> defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/hw_irq.h">arch/x86/include/asm/hw_irq.h</a> and expands to the:</p>
<pre><code class="language-C">typedef int vector_irq_t[NR_VECTORS];
</code></pre>
<p>where <code>NR_VECTORS</code> is count of the vector number and as you can remember from the first <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-1">part</a> of this chapter it is <code>256</code> for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a>:</p>
<pre><code class="language-C">#define NR_VECTORS                       256
</code></pre>
<p>So, in the start of the <code>init_IRQ</code> function we fill the <code>vector_irq</code> <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a> array with the vector number of the <code>legacy</code> interrupts:</p>
<pre><code class="language-C">void __init init_IRQ(void)
{
	int i;

	for (i = 0; i &lt; nr_legacy_irqs(); i++)
		per_cpu(vector_irq, 0)[IRQ0_VECTOR + i] = i;
...
...
...
}
</code></pre>
<p>This <code>vector_irq</code> will be used during the first steps of an external hardware interrupt handling in the <code>do_IRQ</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/irq.c">arch/x86/kernel/irq.c</a>:</p>
<pre><code class="language-C">__visible unsigned int __irq_entry do_IRQ(struct pt_regs *regs)
{
	...
	...
	...
	irq = __this_cpu_read(vector_irq[vector]);

	if (!handle_irq(irq, regs)) {
		...
		...
		...
	}

	exiting_irq();
	...
	...
	return 1;
}
</code></pre>
<p>Why is <code>legacy</code> here? Actually all interrupts are handled by the modern <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#I.2FO_APICs">IO-APIC</a> controller. But these interrupts (from <code>0x30</code> to <code>0x3f</code>) by legacy interrupt-controllers like <a href="https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller">Programmable Interrupt Controller</a>. If these interrupts are handled by the <code>I/O APIC</code> then this vector space will be freed and re-used. Let's look on this code closer. First of all the <code>nr_legacy_irqs</code> defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/i8259.h">arch/x86/include/asm/i8259.h</a> and just returns the <code>nr_legacy_irqs</code> field from the <code>legacy_pic</code> structure:</p>
<pre><code class="language-C">static inline int nr_legacy_irqs(void)
{
        return legacy_pic-&gt;nr_legacy_irqs;
}
</code></pre>
<p>This structure defined in the same header file and represents non-modern programmable interrupts controller:</p>
<pre><code class="language-C">struct legacy_pic {
        int nr_legacy_irqs;
        struct irq_chip *chip;
        void (*mask)(unsigned int irq);
        void (*unmask)(unsigned int irq);
        void (*mask_all)(void);
        void (*restore_mask)(void);
        void (*init)(int auto_eoi);
        int (*irq_pending)(unsigned int irq);
        void (*make_irq)(unsigned int irq);
};
</code></pre>
<p>Actual default maximum number of the legacy interrupts represented by the <code>NR_IRQ_LEGACY</code> macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/irq_vectors.h">arch/x86/include/asm/irq_vectors.h</a>:</p>
<pre><code class="language-C">#define NR_IRQS_LEGACY                    16
</code></pre>
<p>In the loop we are accessing the <code>vecto_irq</code> per-cpu array with the <code>per_cpu</code> macro by the <code>IRQ0_VECTOR + i</code> index and write the legacy vector number there. The <code>IRQ0_VECTOR</code> macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/irq_vectors.h">arch/x86/include/asm/irq_vectors.h</a> header file and expands to the <code>0x30</code>:</p>
<pre><code class="language-C">#define FIRST_EXTERNAL_VECTOR           0x20

#define IRQ0_VECTOR                     ((FIRST_EXTERNAL_VECTOR + 16) &amp; ~15)
</code></pre>
<p>Why is <code>0x30</code> here? You can remember from the first <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-1">part</a> of this chapter that first 32 vector numbers from <code>0</code> to <code>31</code> are reserved by the processor and used for the processing of architecture-defined exceptions and interrupts. Vector numbers from <code>0x30</code> to <code>0x3f</code> are reserved for the <a href="https://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA</a>. So, it means that we fill the <code>vector_irq</code> from the <code>IRQ0_VECTOR</code> which is equal to the <code>32</code> to the <code>IRQ0_VECTOR + 16</code> (before the <code>0x30</code>).</p>
<p>In the end of the <code>init_IRQ</code> function we can see the call of the following function:</p>
<pre><code class="language-C">x86_init.irqs.intr_init();
</code></pre>
<p>from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/x86_init.c">arch/x86/kernel/x86_init.c</a> source code file. If you have read <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">chapter</a> about the Linux kernel initialization process, you can remember the <code>x86_init</code> structure. This structure contains a couple of files which point to the function related to the platform setup (<code>x86_64</code> in our case), for example <code>resources</code> - related with the memory resources, <code>mpparse</code> - related with the parsing of the <a href="https://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Configuration Table</a> table, etc.). As we can see the <code>x86_init</code> also contains the <code>irqs</code> field which contains the three following fields:</p>
<pre><code class="language-C">struct x86_init_ops x86_init __initdata
{
	...
	...
	...
    .irqs = {
                .pre_vector_init        = init_ISA_irqs,
                .intr_init              = native_init_IRQ,
                .trap_init              = x86_init_noop,
	},
	...
	...
	...
}
</code></pre>
<p>Now, we are interesting in the <code>native_init_IRQ</code>. As we can note, the name of the <code>native_init_IRQ</code> function contains the <code>native_</code> prefix which means that this function is architecture-specific. It defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/irqinit.c">arch/x86/kernel/irqinit.c</a> and executes general initialization of the <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#Integrated_local_APICs">Local APIC</a> and initialization of the <a href="https://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA</a> irqs. Let's look at the implementation of the <code>native_init_IRQ</code> function and try to understand what occurs there. The <code>native_init_IRQ</code> function starts from the execution of the following function:</p>
<pre><code class="language-C">x86_init.irqs.pre_vector_init();
</code></pre>
<p>As we can see above, the <code>pre_vector_init</code> points to the <code>init_ISA_irqs</code> function that defined in the same <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/irqinit.c">source code</a> file and as we can understand from the function's name, it makes initialization of the <code>ISA</code> related interrupts. The <code>init_ISA_irqs</code> function starts from the definition of the <code>chip</code> variable which has a <code>irq_chip</code> type:</p>
<pre><code class="language-C">void __init init_ISA_irqs(void)
{
	struct irq_chip *chip = legacy_pic-&gt;chip;
	...
	...
	...
</code></pre>
<p>The <code>irq_chip</code> structure defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irq.h">include/linux/irq.h</a> header file and represents hardware interrupt chip descriptor. It contains:</p>
<ul>
<li><code>name</code> - name of a device. Used in the <code>/proc/interrupts</code>:</li>
</ul>
<pre><code class="language-C">$ cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7
  0:         16          0          0          0          0          0          0          0   IO-APIC   2-edge      timer
  1:          2          0          0          0          0          0          0          0   IO-APIC   1-edge      i8042
  8:          1          0          0          0          0          0          0          0   IO-APIC   8-edge      rtc0
</code></pre>
<p>look at the last column;</p>
<ul>
<li><code>(*irq_mask)(struct irq_data *data)</code>  - mask an interrupt source;</li>
<li><code>(*irq_ack)(struct irq_data *data)</code> - start of a new interrupt;</li>
<li><code>(*irq_startup)(struct irq_data *data)</code> - start up the interrupt;</li>
<li><code>(*irq_shutdown)(struct irq_data *data)</code> - shutdown the interrupt</li>
<li>etc.</li>
</ul>
<p>fields. Note that the <code>irq_data</code> structure represents set of the per irq chip data passed down to chip functions. It contains <code>mask</code> - precomputed bitmask for accessing the chip registers, <code>irq</code> - interrupt number, <code>hwirq</code> - hardware interrupt number, local to the interrupt domain chip low level interrupt hardware access, etc.</p>
<p>After this depends on the <code>CONFIG_X86_64</code> and <code>CONFIG_X86_LOCAL_APIC</code> kernel configuration option call the <code>init_bsp_APIC</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/apic/apic.c">arch/x86/kernel/apic/apic.c</a>:</p>
<pre><code class="language-C">#if defined(CONFIG_X86_64) || defined(CONFIG_X86_LOCAL_APIC)
	init_bsp_APIC();
#endif
</code></pre>
<p>This function makes initialization of the <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a> of <code>bootstrap processor</code> (or processor which starts first). It starts from the check that we found <a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a> config (read more about it in the sixth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-6">part</a> of the Linux kernel initialization process chapter) and the processor has <code>APIC</code>:</p>
<pre><code class="language-C">if (smp_found_config || !cpu_has_apic)
	return;
</code></pre>
<p>Otherwise, we return from this function. In the next step we call the <code>clear_local_APIC</code> function from the same source code file that shuts down the local <code>APIC</code> (more on it in the <code>Advanced Programmable Interrupt Controller</code> chapter) and enable <code>APIC</code> of the first processor by the setting <code>unsigned int value</code> to the <code>APIC_SPIV_APIC_ENABLED</code>:</p>
<pre><code class="language-C">value = apic_read(APIC_SPIV);
value &amp;= ~APIC_VECTOR_MASK;
value |= APIC_SPIV_APIC_ENABLED;
</code></pre>
<p>and writing it with the help of the <code>apic_write</code> function:</p>
<pre><code class="language-C">apic_write(APIC_SPIV, value);
</code></pre>
<p>After we have enabled <code>APIC</code> for the bootstrap processor, we return to the <code>init_ISA_irqs</code> function and in the next step we initialize legacy <code>Programmable Interrupt Controller</code> and set the legacy chip and handler for each legacy irq:</p>
<pre><code class="language-C">legacy_pic-&gt;init(0);

for (i = 0; i &lt; nr_legacy_irqs(); i++)
    irq_set_chip_and_handler(i, chip, handle_level_irq);
</code></pre>
<p>Where can we find <code>init</code> function? The <code>legacy_pic</code> defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/i8259.c">arch/x86/kernel/i8259.c</a> and it is:</p>
<pre><code class="language-C">struct legacy_pic *legacy_pic = &amp;default_legacy_pic;
</code></pre>
<p>Where the <code>default_legacy_pic</code> is:</p>
<pre><code class="language-C">struct legacy_pic default_legacy_pic = {
	...
	...
	...
	.init = init_8259A,
	...
	...
	...
}
</code></pre>
<p>The <code>init_8259A</code> function defined in the same source code file and executes initialization of the <a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a> <code>Programmable Interrupt Controller</code> (more about it will be in the separate chapter about <code>Programmable Interrupt Controllers</code> and <code>APIC</code>).</p>
<p>Now we can return to the <code>native_init_IRQ</code> function, after the <code>init_ISA_irqs</code> function finished its work. The next step is the call of the <code>apic_intr_init</code> function that allocates special interrupt gates which are used by the <a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a> architecture for the <a href="https://en.wikipedia.org/wiki/Inter-processor_interrupt">Inter-processor interrupt</a>. The <code>alloc_intr_gate</code> macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/desc.h">arch/x86/include/asm/desc.h</a> used for the interrupt descriptor allocation:</p>
<pre><code class="language-C">#define alloc_intr_gate(n, addr)                        \
do {                                                    \
        alloc_system_vector(n);                         \
        set_intr_gate(n, addr);                         \
} while (0)
</code></pre>
<p>As we can see, first of all it expands to the call of the <code>alloc_system_vector</code> function that checks the given vector number in the <code>used_vectors</code> bitmap (read previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-7">part</a> about it) and if it is not set in the <code>used_vectors</code> bitmap we set it. After this we test that the <code>first_system_vector</code> is greater than given interrupt vector number and if it is greater we assign it:</p>
<pre><code class="language-C">if (!test_bit(vector, used_vectors)) {
	set_bit(vector, used_vectors);
    if (first_system_vector &gt; vector)
		first_system_vector = vector;
} else {
	BUG();
}
</code></pre>
<p>We already saw the <code>set_bit</code> macro, now let's look at the <code>test_bit</code> and the <code>first_system_vector</code>. The first <code>test_bit</code> macro defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> and looks like this:</p>
<pre><code class="language-C">#define test_bit(nr, addr)                      \
        (__builtin_constant_p((nr))             \
         ? constant_test_bit((nr), (addr))      \
         : variable_test_bit((nr), (addr)))
</code></pre>
<p>We can see the <a href="https://en.wikipedia.org/wiki/Ternary_operation">ternary operator</a> here makes a test with the <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a> built-in function <code>__builtin_constant_p</code> tests that given vector number (<code>nr</code>) is known at compile time. If you're feeling misunderstanding of the <code>__builtin_constant_p</code>, we can make simple test:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

#define PREDEFINED_VAL 1

int main() {
	int i = 5;
	printf(&quot;__builtin_constant_p(i) is %d\n&quot;, __builtin_constant_p(i));
	printf(&quot;__builtin_constant_p(PREDEFINED_VAL) is %d\n&quot;, __builtin_constant_p(PREDEFINED_VAL));
	printf(&quot;__builtin_constant_p(100) is %d\n&quot;, __builtin_constant_p(100));

	return 0;
}
</code></pre>
<p>and look at the result:</p>
<pre><code>$ gcc test.c -o test
$ ./test
__builtin_constant_p(i) is 0
__builtin_constant_p(PREDEFINED_VAL) is 1
__builtin_constant_p(100) is 1
</code></pre>
<p>Now I think it must be clear for you. Let's get back to the <code>test_bit</code> macro. If the <code>__builtin_constant_p</code> returns non-zero, we call <code>constant_test_bit</code> function:</p>
<pre><code class="language-C">static inline int constant_test_bit(int nr, const void *addr)
{
	const u32 *p = (const u32 *)addr;

	return ((1UL &lt;&lt; (nr &amp; 31)) &amp; (p[nr &gt;&gt; 5])) != 0;
}
</code></pre>
<p>and the <code>variable_test_bit</code> in other way:</p>
<pre><code class="language-C">static inline int variable_test_bit(int nr, const void *addr)
{
        u8 v;
        const u32 *p = (const u32 *)addr;

        asm(&quot;btl %2,%1; setc %0&quot; : &quot;=qm&quot; (v) : &quot;m&quot; (*p), &quot;Ir&quot; (nr));
        return v;
}
</code></pre>
<p>What's the difference between two these functions and why do we need in two different functions for the same purpose? As you already can guess main purpose is optimization. If we write simple example with these functions:</p>
<pre><code class="language-C">#define CONST 25

int main() {
	int nr = 24;
	variable_test_bit(nr, (int*)0x10000000);
	constant_test_bit(CONST, (int*)0x10000000)
	return 0;
}
</code></pre>
<p>and will look at the assembly output of our example we will see following assembly code:</p>
<pre><code class="language-assembly">pushq	%rbp
movq	%rsp, %rbp

movl	$268435456, %esi
movl	$25, %edi
call	constant_test_bit
</code></pre>
<p>for the <code>constant_test_bit</code>, and:</p>
<pre><code class="language-assembly">pushq	%rbp
movq	%rsp, %rbp

subq	$16, %rsp
movl	$24, -4(%rbp)
movl	-4(%rbp), %eax
movl	$268435456, %esi
movl	%eax, %edi
call	variable_test_bit
</code></pre>
<p>for the <code>variable_test_bit</code>. These two code listings starts with the same part, first of all we save base of the current stack frame in the <code>%rbp</code> register. But after this code for both examples is different. In the first example we put <code>$268435456</code> (here the <code>$268435456</code> is our second parameter - <code>0x10000000</code>) to the <code>esi</code> and <code>$25</code> (our first parameter) to the <code>edi</code> register and call <code>constant_test_bit</code>. We put function parameters to the <code>esi</code> and <code>edi</code> registers because as we are learning Linux kernel for the <code>x86_64</code> architecture we use <code>System V AMD64 ABI</code> <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">calling convention</a>. All is pretty simple. When we are using predefined constant, the compiler can just substitute its value. Now let's look at the second part. As you can see here, the compiler can not substitute value from the <code>nr</code> variable. In this case compiler must calculate its offset on the program's <a href="https://en.wikipedia.org/wiki/Call_stack">stack frame</a>. We subtract <code>16</code> from the <code>rsp</code> register to allocate stack for the local variables data and put the <code>$24</code> (value of the <code>nr</code> variable) to the <code>rbp</code> with offset <code>-4</code>. Our stack frame will be like this:</p>
<pre><code>         &lt;- stack grows

	          %[rbp]
                 |
+----------+ +---------+ +---------+ +--------+
|          | |         | | return  | |        |
|    nr    |-|         |-|         |-|  argc  |
|          | |         | | address | |        |
+----------+ +---------+ +---------+ +--------+
                 |
              %[rsp]
</code></pre>
<p>After this we put this value to the <code>eax</code>, so <code>eax</code> register now contains value of the <code>nr</code>. In the end we do the same that in the first example, we put the <code>$268435456</code> (the first parameter of the <code>variable_test_bit</code> function) and the value of the <code>eax</code> (value of <code>nr</code>) to the <code>edi</code> register (the second parameter of the <code>variable_test_bit function</code>).</p>
<p>The next step after the <code>apic_intr_init</code> function will finish its work is the setting interrupt gates from the <code>FIRST_EXTERNAL_VECTOR</code> or <code>0x20</code> up to <code>0x100</code>:</p>
<pre><code class="language-C">i = FIRST_EXTERNAL_VECTOR;

#ifndef CONFIG_X86_LOCAL_APIC
#define first_system_vector NR_VECTORS
#endif

for_each_clear_bit_from(i, used_vectors, first_system_vector) {
	set_intr_gate(i, irq_entries_start + 8 * (i - FIRST_EXTERNAL_VECTOR));
}
</code></pre>
<p>But as we are using the <code>for_each_clear_bit_from</code> helper, we set only non-initialized interrupt gates. After this we use the same <code>for_each_clear_bit_from</code> helper to fill the non-filled interrupt gates in the interrupt table with the <code>spurious_interrupt</code>:</p>
<pre><code class="language-C">#ifdef CONFIG_X86_LOCAL_APIC
for_each_clear_bit_from(i, used_vectors, NR_VECTORS)
    set_intr_gate(i, spurious_interrupt);
#endif
</code></pre>
<p>Where the <code>spurious_interrupt</code> function represent interrupt handler for the <code>spurious</code> interrupt. Here the <code>used_vectors</code> is the <code>unsigned long</code> that contains already initialized interrupt gates. We already filled first <code>32</code> interrupt vectors in the <code>trap_init</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> source code file:</p>
<pre><code class="language-C">for (i = 0; i &lt; FIRST_EXTERNAL_VECTOR; i++)
    set_bit(i, used_vectors);
</code></pre>
<p>You can remember how we did it in the sixth <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-6">part</a> of this chapter.</p>
<p>In the end of the <code>native_init_IRQ</code> function we can see the following check:</p>
<pre><code class="language-C">if (!acpi_ioapic &amp;&amp; !of_ioapic &amp;&amp; nr_legacy_irqs())
	setup_irq(2, &amp;irq2);
</code></pre>
<p>First of all let's deal with the condition. The <code>acpi_ioapic</code> variable represents existence of <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#I.2FO_APICs">I/O APIC</a>. It defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/acpi/boot.c">arch/x86/kernel/acpi/boot.c</a>. This variable set in the <code>acpi_set_irq_model_ioapic</code> function that called during the processing <code>Multiple APIC Description Table</code>. This occurs during initialization of the architecture-specific stuff in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> (more about it we will know in the other chapter about <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a>). Note that the value of the <code>acpi_ioapic</code> variable depends on the <code>CONFIG_ACPI</code> and <code>CONFIG_X86_LOCAL_APIC</code> Linux kernel configuration options. If these options were not set, this variable will be just zero:</p>
<pre><code class="language-C">#define acpi_ioapic 0
</code></pre>
<p>The second condition - <code>!of_ioapic &amp;&amp; nr_legacy_irqs()</code> checks that we do not use <a href="https://en.wikipedia.org/wiki/Open_Firmware">Open Firmware</a> <code>I/O APIC</code> and legacy interrupt controller. We already know about the <code>nr_legacy_irqs</code>. The second is <code>of_ioapic</code> variable defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/devicetree.c">arch/x86/kernel/devicetree.c</a> and initialized in the <code>dtb_ioapic_setup</code> function that build information about <code>APICs</code> in the <a href="https://en.wikipedia.org/wiki/Device_tree">devicetree</a>. Note that <code>of_ioapic</code> variable depends on the <code>CONFIG_OF</code> Linux kernel configuration option. If this option is not set, the value of the <code>of_ioapic</code> will be zero too:</p>
<pre><code class="language-C">#ifdef CONFIG_OF
extern int of_ioapic;
...
...
...
#else
#define of_ioapic 0
...
...
...
#endif
</code></pre>
<p>If the condition returns non-zero value we call the:</p>
<pre><code class="language-C">setup_irq(2, &amp;irq2);
</code></pre>
<p>function. First of all about the <code>irq2</code>. The <code>irq2</code> is the <code>irqaction</code> structure that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/irqinit.c">arch/x86/kernel/irqinit.c</a> source code file and represents <code>IRQ 2</code> line that is used to query devices connected cascade:</p>
<pre><code class="language-C">static struct irqaction irq2 = {
	.handler = no_action,
    .name = &quot;cascade&quot;,
    .flags = IRQF_NO_THREAD,
};
</code></pre>
<p>Some time ago interrupt controller consisted of two chips and one was connected to second. The second chip that was connected to the first chip via this <code>IRQ 2</code> line. This chip serviced lines from <code>8</code> to <code>15</code> and after this lines of the first chip. So, for example <a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259A</a> has following lines:</p>
<ul>
<li><code>IRQ 0</code>  - system time;</li>
<li><code>IRQ 1</code>  - keyboard;</li>
<li><code>IRQ 2</code>  - used for devices which are cascade connected;</li>
<li><code>IRQ 8</code>  - <a href="https://en.wikipedia.org/wiki/Real-time_clock">RTC</a>;</li>
<li><code>IRQ 9</code>  - reserved;</li>
<li><code>IRQ 10</code> - reserved;</li>
<li><code>IRQ 11</code> - reserved;</li>
<li><code>IRQ 12</code> - <code>ps/2</code> mouse;</li>
<li><code>IRQ 13</code> - coprocessor;</li>
<li><code>IRQ 14</code> - hard drive controller;</li>
<li><code>IRQ 1</code>  - reserved;</li>
<li><code>IRQ 3</code>  - <code>COM2</code> and <code>COM4</code>;</li>
<li><code>IRQ 4</code>  - <code>COM1</code> and <code>COM3</code>;</li>
<li><code>IRQ 5</code>  - <code>LPT2</code>;</li>
<li><code>IRQ 6</code>  - drive controller;</li>
<li><code>IRQ 7</code>  - <code>LPT1</code>.</li>
</ul>
<p>The <code>setup_irq</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/manage.c">kernel/irq/manage.c</a> and takes two parameters:</p>
<ul>
<li>vector number of an interrupt;</li>
<li><code>irqaction</code> structure related with an interrupt.</li>
</ul>
<p>This function initializes interrupt descriptor from the given vector number at the beginning:</p>
<pre><code class="language-C">struct irq_desc *desc = irq_to_desc(irq);
</code></pre>
<p>And call the <code>__setup_irq</code> function that sets up given interrupt:</p>
<pre><code class="language-C">chip_bus_lock(desc);
retval = __setup_irq(irq, desc, act);
chip_bus_sync_unlock(desc);
return retval;
</code></pre>
<p>Note that the interrupt descriptor is locked during <code>__setup_irq</code> function will work. The <code>__setup_irq</code> function does many different things: it creates a handler thread when a thread function is supplied and the interrupt does not nest into another interrupt thread, sets the flags of the chip, fills the <code>irqaction</code> structure and many many more.</p>
<p>All of the above it creates <code>/prov/vector_number</code> directory and fills it, but if you are using modern computer all values will be zero there:</p>
<pre><code>$ cat /proc/irq/2/node
0

$cat /proc/irq/2/affinity_hint
00

cat /proc/irq/2/spurious
count 0
unhandled 0
last_unhandled 0 ms
</code></pre>
<p>because probably <code>APIC</code> handles interrupts on the machine.</p>
<p>That's all.</p>
<h2 id="conclusion-23"><a class="header" href="#conclusion-23">Conclusion</a></h2>
<p>It is the end of the eighth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">Interrupts and Interrupt Handling</a> chapter and we continued to dive into external hardware interrupts in this part. In the previous part we started to do it and saw early initialization of the <code>IRQs</code>. In this part we already saw non-early interrupts initialization in the <code>init_IRQ</code> function. We saw initialization of the <code>vector_irq</code> per-cpu array which is store vector numbers of the interrupts and will be used during interrupt handling and initialization of other stuff which is related to the external hardware interrupts.</p>
<p>In the next part we will continue to learn interrupts handling related stuff and will see initialization of the <code>softirqs</code>.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-23"><a class="header" href="#links-23">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a></li>
<li><a href="https://en.wikipedia.org/wiki/Programmable_Interrupt_Controller">Programmable Interrupt Controller</a></li>
<li><a href="https://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA</a></li>
<li><a href="https://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Configuration Table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#Integrated_local_APICs">Local APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller#I.2FO_APICs">I/O APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a></li>
<li><a href="https://en.wikipedia.org/wiki/Inter-processor_interrupt">Inter-processor interrupt</a></li>
<li><a href="https://en.wikipedia.org/wiki/Ternary_operation">ternary operator</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions">calling convention</a></li>
<li><a href="http://x86-64.org/documentation/abi.pdf">PDF. System V Application Binary Interface AMD64</a></li>
<li><a href="https://en.wikipedia.org/wiki/Call_stack">Call stack</a></li>
<li><a href="https://en.wikipedia.org/wiki/Open_Firmware">Open Firmware</a></li>
<li><a href="https://en.wikipedia.org/wiki/Device_tree">devicetree</a></li>
<li><a href="https://en.wikipedia.org/wiki/Real-time_clock">RTC</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-7">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts-and-interrupt-handling-part-9"><a class="header" href="#interrupts-and-interrupt-handling-part-9">Interrupts and Interrupt Handling. Part 9.</a></h1>
<h2 id="introduction-to-deferred-interrupts-softirq-tasklets-and-workqueues"><a class="header" href="#introduction-to-deferred-interrupts-softirq-tasklets-and-workqueues">Introduction to deferred interrupts (Softirq, Tasklets and Workqueues)</a></h2>
<p>It is the nine part of the Interrupts and Interrupt Handling in the Linux kernel <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">chapter</a> and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-8">Previous part</a> we saw implementation of the <code>init_IRQ</code> from that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/irqinit.c">arch/x86/kernel/irqinit.c</a> source code file. So, we will continue to dive into the initialization stuff which is related to the external hardware interrupts in this part.</p>
<p>Interrupts may have different important characteristics and there are two among them:</p>
<ul>
<li>Handler of an interrupt must execute quickly;</li>
<li>Sometime an interrupt handler must do a large amount of work.</li>
</ul>
<p>As you can understand, it is almost impossible to make so that both characteristics were valid. Because of these, previously the handling of interrupts was split into two parts:</p>
<ul>
<li>Top half;</li>
<li>Bottom half;</li>
</ul>
<p>In the past there was one way to defer interrupt handling in Linux kernel. And it was called: <code>the bottom half</code> of the processor, but now it is already not actual. Now this term has remained as a common noun referring to all the different ways of organizing deferred processing of an interrupt.The deferred processing of an interrupt suggests that some of the actions for an interrupt may be postponed to a later execution when the system will be less loaded. As you can suggest, an interrupt handler can do large amount of work that is impermissible as it executes in the context where interrupts are disabled. That's why processing of an interrupt can be split in two different parts. In the first part, the main handler of an interrupt does only minimal and the most important job. After this it schedules the second part and finishes its work. When the system is less busy and context of the processor allows to handle interrupts, the second part starts its work and finishes to process remaining part of a deferred interrupt.</p>
<p>There are three types of <code>deferred interrupts</code> in the Linux kernel:</p>
<ul>
<li><code>softirqs</code>;</li>
<li><code>tasklets</code>;</li>
<li><code>workqueues</code>;</li>
</ul>
<p>And we will see description of all of these types in this part. As I said, we saw only a little bit about this theme, so, now is time to dive deep into details about this theme.</p>
<h2 id="softirqs"><a class="header" href="#softirqs">Softirqs</a></h2>
<p>With the advent of parallelisms in the Linux kernel, all new schemes of implementation of the bottom half handlers are built on the performance of the processor specific kernel thread that called <code>ksoftirqd</code> (will be discussed below). Each processor has its own thread that is called <code>ksoftirqd/n</code> where the <code>n</code> is the number of the processor. We can see it in the output of the <code>systemd-cgls</code> util:</p>
<pre><code>$ systemd-cgls -k | grep ksoft
├─   3 [ksoftirqd/0]
├─  13 [ksoftirqd/1]
├─  18 [ksoftirqd/2]
├─  23 [ksoftirqd/3]
├─  28 [ksoftirqd/4]
├─  33 [ksoftirqd/5]
├─  38 [ksoftirqd/6]
├─  43 [ksoftirqd/7]
</code></pre>
<p>The <code>spawn_ksoftirqd</code> function starts this these threads. As we can see this function called as early <a href="https://kernelnewbies.org/Documents/InitcallMechanism">initcall</a>:</p>
<pre><code class="language-C">early_initcall(spawn_ksoftirqd);
</code></pre>
<p>Softirqs are determined statically at compile-time of the Linux kernel and the <code>open_softirq</code> function takes care of <code>softirq</code> initialization. The <code>open_softirq</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/softirq.c">kernel/softirq.c</a>:</p>
<pre><code class="language-C">void open_softirq(int nr, void (*action)(struct softirq_action *))
{
	softirq_vec[nr].action = action;
}
</code></pre>
<p>and as we can see this function uses two parameters:</p>
<ul>
<li>the index of the <code>softirq_vec</code> array;</li>
<li>a pointer to the softirq function to be executed;</li>
</ul>
<p>First of all let's look on the <code>softirq_vec</code> array:</p>
<pre><code class="language-C">static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;
</code></pre>
<p>it defined in the same source code file. As we can see, the <code>softirq_vec</code> array may contain <code>NR_SOFTIRQS</code> or <code>10</code> types of <code>softirqs</code> that has type <code>softirq_action</code>. First of all about its elements. In the current version of the Linux kernel there are ten softirq vectors defined; two for tasklet processing, two for networking, two for the block layer, two for timers, and one each for the scheduler and read-copy-update processing. All of these kinds are represented by the following enum:</p>
<pre><code class="language-C">enum
{
        HI_SOFTIRQ=0,
        TIMER_SOFTIRQ,
        NET_TX_SOFTIRQ,
        NET_RX_SOFTIRQ,
        BLOCK_SOFTIRQ,
        BLOCK_IOPOLL_SOFTIRQ,
        TASKLET_SOFTIRQ,
        SCHED_SOFTIRQ,
        HRTIMER_SOFTIRQ,
        RCU_SOFTIRQ,
        NR_SOFTIRQS
};
</code></pre>
<p>All names of these kinds of softirqs are represented by the following array:</p>
<pre><code class="language-C">const char * const softirq_to_name[NR_SOFTIRQS] = {
        &quot;HI&quot;, &quot;TIMER&quot;, &quot;NET_TX&quot;, &quot;NET_RX&quot;, &quot;BLOCK&quot;, &quot;BLOCK_IOPOLL&quot;,
        &quot;TASKLET&quot;, &quot;SCHED&quot;, &quot;HRTIMER&quot;, &quot;RCU&quot;
};
</code></pre>
<p>Or we can see it in the output of the <code>/proc/softirqs</code>:</p>
<pre><code>~$ cat /proc/softirqs
                    CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7
          HI:          5          0          0          0          0          0          0          0
       TIMER:     332519     310498     289555     272913     282535     279467     282895     270979
      NET_TX:       2320          0          0          2          1          1          0          0
      NET_RX:     270221        225        338        281        311        262        430        265
       BLOCK:     134282         32         40         10         12          7          8          8
BLOCK_IOPOLL:          0          0          0          0          0          0          0          0
     TASKLET:     196835          2          3          0          0          0          0          0
       SCHED:     161852     146745     129539     126064     127998     128014     120243     117391
     HRTIMER:          0          0          0          0          0          0          0          0
         RCU:     337707     289397     251874     239796     254377     254898     267497     256624
</code></pre>
<p>As we can see the <code>softirq_vec</code> array has <code>softirq_action</code> types. This is the main data structure related to the <code>softirq</code> mechanism, so all <code>softirqs</code> represented by the <code>softirq_action</code> structure. The <code>softirq_action</code> structure consists a single field only: an action pointer to the softirq function:</p>
<pre><code class="language-C">struct softirq_action
{
         void    (*action)(struct softirq_action *);
};
</code></pre>
<p>So, after this we can understand that the <code>open_softirq</code> function fills the <code>softirq_vec</code> array with the given <code>softirq_action</code>. The registered deferred interrupt (with the call of the <code>open_softirq</code> function) for it to be queued for execution, it should be activated by the call of the <code>raise_softirq</code> function. This function takes only one parameter -- a softirq index <code>nr</code>. Let's look on its implementation:</p>
<pre><code class="language-C">void raise_softirq(unsigned int nr)
{
        unsigned long flags;

        local_irq_save(flags);
        raise_softirq_irqoff(nr);
        local_irq_restore(flags);
}
</code></pre>
<p>Here we can see the call of the <code>raise_softirq_irqoff</code> function between the <code>local_irq_save</code> and the <code>local_irq_restore</code> macros. The <code>local_irq_save</code> defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/irqflags.h">include/linux/irqflags.h</a> header file and saves the state of the <a href="https://en.wikipedia.org/wiki/Interrupt_flag">IF</a> flag of the <a href="https://en.wikipedia.org/wiki/FLAGS_register">eflags</a> register and disables interrupts on the local processor. The <code>local_irq_restore</code> macro defined in the same header file and does the opposite thing: restores the <code>interrupt flag</code> and enables interrupts. We disable interrupts here because a <code>softirq</code> interrupt runs in the interrupt context and that one softirq (and no others) will be run.</p>
<p>The <code>raise_softirq_irqoff</code> function marks the softirq as deferred by setting the bit corresponding to the given index <code>nr</code> in the <code>softirq</code> bit mask (<code>__softirq_pending</code>) of the local processor. It does it with the help of the:</p>
<pre><code class="language-C">__raise_softirq_irqoff(nr);
</code></pre>
<p>macro. After this, it checks the result of the <code>in_interrupt</code> that returns <code>irq_count</code> value. We already saw the <code>irq_count</code> in the first <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-1">part</a> of this chapter and it is used to check if a CPU is already on an interrupt stack or not. We just exit from the <code>raise_softirq_irqoff</code>, restore <code>IF</code> flag and enable interrupts on the local processor, if we are in the interrupt context, otherwise  we call the <code>wakeup_softirqd</code>:</p>
<pre><code class="language-C">if (!in_interrupt())
	wakeup_softirqd();
</code></pre>
<p>Where the <code>wakeup_softirqd</code> function activates the <code>ksoftirqd</code> kernel thread of the local processor:</p>
<pre><code class="language-C">static void wakeup_softirqd(void)
{
	struct task_struct *tsk = __this_cpu_read(ksoftirqd);

    if (tsk &amp;&amp; tsk-&gt;state != TASK_RUNNING)
        wake_up_process(tsk);
}
</code></pre>
<p>Each <code>ksoftirqd</code> kernel thread runs the <code>run_ksoftirqd</code> function that checks existence of deferred interrupts and calls the <code>__do_softirq</code> function depending on the result of the check. This function reads the <code>__softirq_pending</code> softirq bit mask of the local processor and executes the deferrable functions corresponding to every bit set. During execution of a deferred function, new pending <code>softirqs</code> might occur. The main problem here that execution of the userspace code can be delayed for a long time while the <code>__do_softirq</code> function will handle deferred interrupts. For this purpose, it has the limit of the time when it must be finished:</p>
<pre><code class="language-C">unsigned long end = jiffies + MAX_SOFTIRQ_TIME;
...
...
...
restart:
while ((softirq_bit = ffs(pending))) {
	...
	h-&gt;action(h);
	...
}
...
...
...
pending = local_softirq_pending();
if (pending) {
	if (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp;
		--max_restart)
            goto restart;
}
...
</code></pre>
<p>Checks of the existence of the deferred interrupts are performed periodically. There are several points where these checks occur. The main point is the call of the <code>do_IRQ</code> function defined in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/irq.c">arch/x86/kernel/irq.c</a>, which provides the main means for actual interrupt processing in the Linux kernel. When <code>do_IRQ</code> finishes handling an interrupt, it calls the <code>exiting_irq</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/apic.h">arch/x86/include/asm/apic.h</a> that expands to the call of the <code>irq_exit</code> function. <code>irq_exit</code> checks for deferred interrupts and the current context and calls the <code>invoke_softirq</code> function:</p>
<pre><code class="language-C">if (!in_interrupt() &amp;&amp; local_softirq_pending())
    invoke_softirq();
</code></pre>
<p>that also executes <code>__do_softirq</code>. To summarize, each <code>softirq</code> goes through the following stages:</p>
<ul>
<li>Registration of a <code>softirq</code> with the <code>open_softirq</code> function.</li>
<li>Activation of a <code>softirq</code> by marking it as deferred with the <code>raise_softirq</code> function.</li>
<li>After this, all marked <code>softirqs</code> will be triggered in the next time the Linux kernel schedules a round of executions of deferrable functions.</li>
<li>And execution of the deferred functions that have the same type.</li>
</ul>
<p>As I already wrote, the <code>softirqs</code> are statically allocated and it is a problem for a kernel module that can be loaded. The second concept that built on top of <code>softirq</code> -- the <code>tasklets</code> solves this problem.</p>
<h2 id="tasklets"><a class="header" href="#tasklets">Tasklets</a></h2>
<p>If you read the source code of the Linux kernel that is related to the <code>softirq</code>, you notice that it is used very rarely. The preferable way to implement deferrable functions are <code>tasklets</code>. As I already wrote above the <code>tasklets</code> are built on top of the <code>softirq</code> concept and generally on top of two <code>softirqs</code>:</p>
<ul>
<li><code>TASKLET_SOFTIRQ</code>;</li>
<li><code>HI_SOFTIRQ</code>.</li>
</ul>
<p>In short words, <code>tasklets</code> are <code>softirqs</code> that can be allocated and initialized at runtime and unlike <code>softirqs</code>, tasklets that have the same type cannot be run on multiple processors at a time. Ok, now we know a little bit about the <code>softirqs</code>, of course previous text does not cover all aspects about this, but now we can directly look on the code and to know more about the <code>softirqs</code> step by step on practice and to know about <code>tasklets</code>. Let's return back to the implementation of the <code>softirq_init</code> function that we talked about in the beginning of this part. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/softirq.c">kernel/softirq.c</a> source code file, let's look on its implementation:</p>
<pre><code class="language-C">void __init softirq_init(void)
{
        int cpu;

        for_each_possible_cpu(cpu) {
                per_cpu(tasklet_vec, cpu).tail =
                        &amp;per_cpu(tasklet_vec, cpu).head;
                per_cpu(tasklet_hi_vec, cpu).tail =
                        &amp;per_cpu(tasklet_hi_vec, cpu).head;
        }

        open_softirq(TASKLET_SOFTIRQ, tasklet_action);
        open_softirq(HI_SOFTIRQ, tasklet_hi_action);
}
</code></pre>
<p>We can see definition of the integer <code>cpu</code> variable at the beginning of the <code>softirq_init</code> function. Next we will use it as parameter for the <code>for_each_possible_cpu</code> macro that goes through the all possible processors in the system. If the <code>possible processor</code> is the new terminology for you, you can read more about it the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">CPU masks</a> chapter. In short words, <code>possible cpus</code> is the set of processors that can be plugged in anytime during the life of that system boot. All <code>possible processors</code> stored in the <code>cpu_possible_bits</code> bitmap, you can find its definition in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/cpu.c">kernel/cpu.c</a>:</p>
<pre><code class="language-C">static DECLARE_BITMAP(cpu_possible_bits, CONFIG_NR_CPUS) __read_mostly;
...
...
...
const struct cpumask *const cpu_possible_mask = to_cpumask(cpu_possible_bits);
</code></pre>
<p>Ok, we defined the integer <code>cpu</code> variable and go through the all possible processors with the <code>for_each_possible_cpu</code> macro and makes initialization of the two following <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> variables:</p>
<ul>
<li><code>tasklet_vec</code>;</li>
<li><code>tasklet_hi_vec</code>;</li>
</ul>
<p>These two <code>per-cpu</code> variables defined in the same source <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/softirq.c">code</a> file as the <code>softirq_init</code> function and represent two <code>tasklet_head</code> structures:</p>
<pre><code class="language-C">static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);
static DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);
</code></pre>
<p>Where <code>tasklet_head</code> structure represents a list of <code>Tasklets</code> and contains two fields, head and tail:</p>
<pre><code class="language-C">struct tasklet_head {
        struct tasklet_struct *head;
        struct tasklet_struct **tail;
};
</code></pre>
<p>The <code>tasklet_struct</code> structure is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/interrupt.h">include/linux/interrupt.h</a> and represents the <code>Tasklet</code>. Previously we did not see this word in this book. Let's try to understand what the <code>tasklet</code> is. Actually, the tasklet is one of mechanisms to handle deferred interrupt. Let's look on the implementation of the <code>tasklet_struct</code> structure:</p>
<pre><code class="language-C">struct tasklet_struct
{
        struct tasklet_struct *next;
        unsigned long state;
        atomic_t count;
        void (*func)(unsigned long);
        unsigned long data;
};
</code></pre>
<p>As we can see this structure contains five fields, they are:</p>
<ul>
<li>Next tasklet in the scheduling queue;</li>
<li>State of the tasklet;</li>
<li>Represent current state of the tasklet, active or not;</li>
<li>Main callback of the tasklet;</li>
<li>Parameter of the callback.</li>
</ul>
<p>In our case, we set only for initialize only two arrays of tasklets in the <code>softirq_init</code> function: the <code>tasklet_vec</code> and the <code>tasklet_hi_vec</code>. Tasklets and high-priority tasklets are stored in the <code>tasklet_vec</code> and <code>tasklet_hi_vec</code> arrays, respectively. So, we have initialized these arrays and now we can see two calls of the <code>open_softirq</code> function that is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/softirq.c">kernel/softirq.c</a> source code file:</p>
<pre><code class="language-C">open_softirq(TASKLET_SOFTIRQ, tasklet_action);
open_softirq(HI_SOFTIRQ, tasklet_hi_action);
</code></pre>
<p>at the end of the <code>softirq_init</code> function. The main purpose of the <code>open_softirq</code> function is the initialization of <code>softirq</code>. Let's look on the implementation of the <code>open_softirq</code> function.</p>
<p>In our case they are: <code>tasklet_action</code> and the <code>tasklet_hi_action</code> or the <code>softirq</code> function associated with the <code>HI_SOFTIRQ</code> softirq is named <code>tasklet_hi_action</code> and <code>softirq</code> function associated with the <code>TASKLET_SOFTIRQ</code> is named <code>tasklet_action</code>. The Linux kernel provides API for the manipulating of <code>tasklets</code>. First of all it is the <code>tasklet_init</code> function that takes <code>tasklet_struct</code>, function and parameter for it and initializes the given <code>tasklet_struct</code> with the given data:</p>
<pre><code class="language-C">void tasklet_init(struct tasklet_struct *t,
                  void (*func)(unsigned long), unsigned long data)
{
    t-&gt;next = NULL;
    t-&gt;state = 0;
    atomic_set(&amp;t-&gt;count, 0);
    t-&gt;func = func;
    t-&gt;data = data;
}
</code></pre>
<p>There are additional methods to initialize a tasklet statically with the two following macros:</p>
<pre><code class="language-C">DECLARE_TASKLET(name, func, data);
DECLARE_TASKLET_DISABLED(name, func, data);
</code></pre>
<p>The Linux kernel provides three following functions to mark a tasklet as ready to run:</p>
<pre><code class="language-C">void tasklet_schedule(struct tasklet_struct *t);
void tasklet_hi_schedule(struct tasklet_struct *t);
void tasklet_hi_schedule_first(struct tasklet_struct *t);
</code></pre>
<p>The first function schedules a tasklet with the normal priority, the second with the high priority and the third out of turn. Implementation of the all of these three functions is similar, so we will consider only the first -- <code>tasklet_schedule</code>. Let's look on its implementation:</p>
<pre><code class="language-C">static inline void tasklet_schedule(struct tasklet_struct *t)
{
    if (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))
        __tasklet_schedule(t);
}

void __tasklet_schedule(struct tasklet_struct *t)
{
        unsigned long flags;

        local_irq_save(flags);
        t-&gt;next = NULL;
        *__this_cpu_read(tasklet_vec.tail) = t;
        __this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next));
        raise_softirq_irqoff(TASKLET_SOFTIRQ);
        local_irq_restore(flags);
}
</code></pre>
<p>As we can see it checks and sets the state of the given tasklet to the <code>TASKLET_STATE_SCHED</code> and executes the <code>__tasklet_schedule</code> with the given tasklet. The <code>__tasklet_schedule</code> looks very similar to the <code>raise_softirq</code> function that we saw above. It saves the <code>interrupt flag</code> and disables interrupts at the beginning. After this, it updates <code>tasklet_vec</code> with the new tasklet and calls the <code>raise_softirq_irqoff</code> function that we saw above. When the Linux kernel scheduler will decide to run deferred functions, the <code>tasklet_action</code> function will be called for deferred functions which are associated with the <code>TASKLET_SOFTIRQ</code> and <code>tasklet_hi_action</code> for deferred functions which are associated with the <code>HI_SOFTIRQ</code>. These functions are very similar and there is only one difference between them -- <code>tasklet_action</code> uses <code>tasklet_vec</code> and <code>tasklet_hi_action</code> uses <code>tasklet_hi_vec</code>.</p>
<p>Let's look on the implementation of the <code>tasklet_action</code> function:</p>
<pre><code class="language-C">static void tasklet_action(struct softirq_action *a)
{
    local_irq_disable();
    list = __this_cpu_read(tasklet_vec.head);
    __this_cpu_write(tasklet_vec.head, NULL);
    __this_cpu_write(tasklet_vec.tail, this_cpu_ptr(&amp;tasklet_vec.head));
    local_irq_enable();

    while (list) {
		if (tasklet_trylock(t)) {
	        t-&gt;func(t-&gt;data);
            tasklet_unlock(t);
	    }
		...
		...
		...
    }
}
</code></pre>
<p>In the beginning of the <code>tasklet_action</code> function, we disable interrupts for the local processor with the help of the <code>local_irq_disable</code> macro (you can read about this macro in the second <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-2">part</a> of this chapter). In the next step, we take a head of the list that contains tasklets with normal priority and set this per-cpu list to <code>NULL</code> because all tasklets must be executed in a general way. After this we enable interrupts for the local processor and go through the list of tasklets in the loop. In every iteration of the loop we call the <code>tasklet_trylock</code> function for the given tasklet that updates state of the given tasklet on <code>TASKLET_STATE_RUN</code>:</p>
<pre><code class="language-C">static inline int tasklet_trylock(struct tasklet_struct *t)
{
    return !test_and_set_bit(TASKLET_STATE_RUN, &amp;(t)-&gt;state);
}
</code></pre>
<p>If this operation was successful we execute tasklet's action (it was set in the <code>tasklet_init</code>) and call the <code>tasklet_unlock</code> function that clears tasklet's <code>TASKLET_STATE_RUN</code> state.</p>
<p>In general, that's all about <code>tasklets</code> concept. Of course this does not cover full <code>tasklets</code>, but I think that it is a good point from where you can continue to learn this concept.</p>
<p>The <code>tasklets</code> are <a href="http://lxr.free-electrons.com/ident?i=tasklet_init">widely</a> used concept in the Linux kernel, but as I wrote in the beginning of this part there is third mechanism for deferred functions -- <code>workqueue</code>. In the next paragraph we will see what it is.</p>
<h2 id="workqueues"><a class="header" href="#workqueues">Workqueues</a></h2>
<p>The <code>workqueue</code> is another concept for handling deferred functions. It is similar to <code>tasklets</code> with some differences. Workqueue functions run in the context of a kernel process, but <code>tasklet</code> functions run in the software interrupt context. This means that <code>workqueue</code> functions must not be atomic as <code>tasklet</code> functions. Tasklets always run on the processor from which they were originally submitted. Workqueues work in the same way, but only by default. The <code>workqueue</code> concept represented by the:</p>
<pre><code class="language-C">struct worker_pool {
    spinlock_t              lock;
    int                     cpu;
    int                     node;
    int                     id;
    unsigned int            flags;

    struct list_head        worklist;
    int                     nr_workers;
...
...
...
</code></pre>
<p>structure that is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/workqueue.c">kernel/workqueue.c</a> source code file in the Linux kernel. I will not write the source code of this structure here, because it has quite a lot of fields, but we will consider some of those fields.</p>
<p>In its most basic form, the work queue subsystem is an interface for creating kernel threads to handle work that is queued from elsewhere. All of these kernel threads are called -- <code>worker threads</code>. The work queue are maintained by the <code>work_struct</code> that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/workqueue.h">include/linux/workqueue.h</a>. Let's look on this structure:</p>
<pre><code class="language-C">struct work_struct {
    atomic_long_t data;
    struct list_head entry;
    work_func_t func;
#ifdef CONFIG_LOCKDEP
    struct lockdep_map lockdep_map;
#endif
};
</code></pre>
<p>Here are two things that we are interested: <code>func</code> -- the function that will be scheduled by the <code>workqueue</code> and the <code>data</code> - parameter of this function. The Linux kernel provides special per-cpu threads that are called <code>kworker</code>:</p>
<pre><code>systemd-cgls -k | grep kworker
├─    5 [kworker/0:0H]
├─   15 [kworker/1:0H]
├─   20 [kworker/2:0H]
├─   25 [kworker/3:0H]
├─   30 [kworker/4:0H]
...
...
...
</code></pre>
<p>This process can be used to schedule the deferred functions of the workqueues (as <code>ksoftirqd</code> for <code>softirqs</code>). Besides this we can create new separate worker thread for a <code>workqueue</code>. The Linux kernel provides following macros for the creation of workqueue:</p>
<pre><code class="language-C">#define DECLARE_WORK(n, f) \
    struct work_struct n = __WORK_INITIALIZER(n, f)
</code></pre>
<p>for static creation. It takes two parameters: name of the workqueue and the workqueue function. For creation of workqueue in runtime, we can use the:</p>
<pre><code class="language-C">#define INIT_WORK(_work, _func)       \
    __INIT_WORK((_work), (_func), 0)

#define __INIT_WORK(_work, _func, _onstack)                     \
    do {                                                        \
            __init_work((_work), _onstack);                     \
            (_work)-&gt;data = (atomic_long_t) WORK_DATA_INIT();   \
            INIT_LIST_HEAD(&amp;(_work)-&gt;entry);                    \
             (_work)-&gt;func = (_func);                           \
    } while (0)
</code></pre>
<p>macro that takes <code>work_struct</code> structure that has to be created and the function to be scheduled in this workqueue. After a <code>work</code> was created with the one of these macros, we need to put it to the <code>workqueue</code>. We can do it with the help of the <code>queue_work</code> or the <code>queue_delayed_work</code> functions:</p>
<pre><code class="language-C">static inline bool queue_work(struct workqueue_struct *wq,
                              struct work_struct *work)
{
    return queue_work_on(WORK_CPU_UNBOUND, wq, work);
}
</code></pre>
<p>The <code>queue_work</code> function just calls the <code>queue_work_on</code> function that queues work on specific processor. Note that in our case we pass the <code>WORK_CPU_UNBOUND</code> to the <code>queue_work_on</code> function. It is a part of the <code>enum</code> that is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/workqueue.h">include/linux/workqueue.h</a> and represents workqueue which are not bound to any specific processor. The <code>queue_work_on</code> function tests and set the <code>WORK_STRUCT_PENDING_BIT</code> bit of the given <code>work</code> and executes the <code>__queue_work</code> function with the <code>workqueue</code> for the given processor and given <code>work</code>:</p>
<pre><code class="language-C">bool queue_work_on(int cpu, struct workqueue_struct *wq,
           struct work_struct *work)
{
    bool ret = false;
    ...
    if (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {
        __queue_work(cpu, wq, work);
        ret = true;
    }
    ...
    return ret;
}
</code></pre>
<p>The <code>__queue_work</code> function gets the <code>work pool</code>. Yes, the <code>work pool</code> not <code>workqueue</code>. Actually, all <code>works</code> are not placed in the <code>workqueue</code>, but to the <code>work pool</code> that is represented by the <code>worker_pool</code> structure in the Linux kernel. As you can see above, the <code>workqueue_struct</code> structure has the <code>pwqs</code> field which is list of <code>worker_pools</code>. When we create a <code>workqueue</code>, it stands out for each processor the <code>pool_workqueue</code>. Each <code>pool_workqueue</code> associated with <code>worker_pool</code>, which is allocated on the same processor and corresponds to the type of priority queue. Through them <code>workqueue</code> interacts with <code>worker_pool</code>. So in the <code>__queue_work</code> function we set the cpu to the current processor with the <code>raw_smp_processor_id</code> (you can find information about this macro in the fourth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">part</a> of the Linux kernel initialization process chapter), getting the <code>pool_workqueue</code> for the given <code>workqueue_struct</code> and insert the given <code>work</code> to the given <code>workqueue</code>:</p>
<pre><code class="language-C">static void __queue_work(int cpu, struct workqueue_struct *wq,
                         struct work_struct *work)
{
...
...
...
if (req_cpu == WORK_CPU_UNBOUND)
    cpu = raw_smp_processor_id();

if (!(wq-&gt;flags &amp; WQ_UNBOUND))
    pwq = per_cpu_ptr(wq-&gt;cpu_pwqs, cpu);
else
    pwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));
...
...
...
insert_work(pwq, work, worklist, work_flags);
</code></pre>
<p>As we can create <code>works</code> and <code>workqueue</code>, we need to know when they are executed. As I already wrote, all <code>works</code> are executed by the kernel thread. When this kernel thread is scheduled, it starts to execute <code>works</code> from the given <code>workqueue</code>. Each worker thread executes a loop inside the <code>worker_thread</code> function. This thread makes many different things and part of these things are similar to what we saw before in this part. As it starts executing, it removes all <code>work_struct</code> or <code>works</code> from its <code>workqueue</code>.</p>
<p>That's all.</p>
<h2 id="conclusion-24"><a class="header" href="#conclusion-24">Conclusion</a></h2>
<p>It is the end of the ninth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">Interrupts and Interrupt Handling</a> chapter and we continued to dive into external hardware interrupts in this part. In the previous part we saw initialization of the <code>IRQs</code> and main <code>irq_desc</code> structure. In this part we saw three concepts: the <code>softirq</code>, <code>tasklet</code> and <code>workqueue</code> that are used for the deferred functions.</p>
<p>The next part will be last part of the <code>Interrupts and Interrupt Handling</code> chapter and we will look on the real hardware driver and will try to learn how it works with the interrupts subsystem.</p>
<p>If you have any questions or suggestions, write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-24"><a class="header" href="#links-24">Links</a></h2>
<ul>
<li><a href="https://kernelnewbies.org/Documents/InitcallMechanism">initcall</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_flag">IF</a></li>
<li><a href="https://en.wikipedia.org/wiki/FLAGS_register">eflags</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">CPU masks</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a></li>
<li><a href="https://github.com/torvalds/linux/blob/6f0d349d922ba44e4348a17a78ea51b7135965b1/Documentation/core-api/workqueue.rst">Workqueue</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-8">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts-and-interrupt-handling-part-10"><a class="header" href="#interrupts-and-interrupt-handling-part-10">Interrupts and Interrupt Handling. Part 10.</a></h1>
<h2 id="last-part"><a class="header" href="#last-part">Last part</a></h2>
<p>This is the tenth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">chapter</a> about interrupts and interrupt handling in the Linux kernel and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-9">part</a> we saw a little about deferred interrupts and related concepts like <code>softirq</code>, <code>tasklet</code> and <code>workqeue</code>. In this part we will continue to dive into this theme and now it's time to look at real hardware driver.</p>
<p>Let's consider serial driver of the <a href="http://netwinder.osuosl.org/pub/netwinder/docs/intel/datashts/27813501.pdf">StrongARM** SA-110/21285 Evaluation Board</a> board for example and will look how this driver requests an <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> line,
what happens when an interrupt is triggered and etc. The source code of this driver is placed in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/drivers/tty/serial/21285.c">drivers/tty/serial/21285.c</a> source code file. Ok, we have source code, let's start.</p>
<h2 id="initialization-of-a-kernel-module"><a class="header" href="#initialization-of-a-kernel-module">Initialization of a kernel module</a></h2>
<p>We will start to consider this driver as we usually did it with all new concepts that we saw in this book. We will start to consider it from the initialization. As you already may know, the Linux kernel provides two macros for initialization and finalization of a driver or a kernel module:</p>
<ul>
<li><code>module_init</code>;</li>
<li><code>module_exit</code>.</li>
</ul>
<p>And we can find usage of these macros in our driver source code:</p>
<pre><code class="language-C">module_init(serial21285_init);
module_exit(serial21285_exit);
</code></pre>
<p>The most part of device drivers can be compiled as a loadable kernel <a href="https://en.wikipedia.org/wiki/Loadable_kernel_module">module</a> or in another way they can be statically linked into the Linux kernel. In the first case initialization of a device driver will be produced via the <code>module_init</code> and <code>module_exit</code> macros that are defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init.h">include/linux/init.h</a>:</p>
<pre><code class="language-C">#define module_init(initfn)                                     \
        static inline initcall_t __inittest(void)               \
        { return initfn; }                                      \
        int init_module(void) __attribute__((alias(#initfn)));

#define module_exit(exitfn)                                     \
        static inline exitcall_t __exittest(void)               \
        { return exitfn; }                                      \
        void cleanup_module(void) __attribute__((alias(#exitfn)));
</code></pre>
<p>and will be called by the <a href="http://kernelnewbies.org/Documents/InitcallMechanism">initcall</a> functions:</p>
<ul>
<li><code>early_initcall</code></li>
<li><code>pure_initcall</code></li>
<li><code>core_initcall</code></li>
<li><code>postcore_initcall</code></li>
<li><code>arch_initcall</code></li>
<li><code>subsys_initcall</code></li>
<li><code>fs_initcall</code></li>
<li><code>rootfs_initcall</code></li>
<li><code>device_initcall</code></li>
<li><code>late_initcall</code></li>
</ul>
<p>that are called in the <code>do_initcalls</code> from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a>. Otherwise, if a device driver is statically linked into the Linux kernel, implementation of these macros will be following:</p>
<pre><code class="language-C">#define module_init(x)  __initcall(x);
#define module_exit(x)  __exitcall(x);
</code></pre>
<p>In this way implementation of module loading placed in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/module.c">kernel/module.c</a> source code file and initialization occurs in the <code>do_init_module</code> function. We will not dive into details about loadable modules in this chapter, but will see it in the special chapter that will describe Linux kernel modules. Ok, the <code>module_init</code> macro takes one parameter - the <code>serial21285_init</code> in our case. As we can understand from function's name, this function does stuff related to the driver initialization. Let's look at it:</p>
<pre><code class="language-C">static int __init serial21285_init(void)
{
	int ret;

	printk(KERN_INFO &quot;Serial: 21285 driver\n&quot;);

	serial21285_setup_ports();

	ret = uart_register_driver(&amp;serial21285_reg);
	if (ret == 0)
		uart_add_one_port(&amp;serial21285_reg, &amp;serial21285_port);

	return ret;
}
</code></pre>
<p>As we can see, first of all it prints information about the driver to the kernel buffer and the call of the <code>serial21285_setup_ports</code> function. This function setups the base <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">uart</a> clock of the <code>serial21285_port</code> device:</p>
<pre><code class="language-C">unsigned int mem_fclk_21285 = 50000000;

static void serial21285_setup_ports(void)
{
	serial21285_port.uartclk = mem_fclk_21285 / 4;
}
</code></pre>
<p>Here the <code>serial21285</code> is the structure that describes <code>uart</code> driver:</p>
<pre><code class="language-C">static struct uart_driver serial21285_reg = {
	.owner			= THIS_MODULE,
	.driver_name	= &quot;ttyFB&quot;,
	.dev_name		= &quot;ttyFB&quot;,
	.major			= SERIAL_21285_MAJOR,
	.minor			= SERIAL_21285_MINOR,
	.nr			    = 1,
	.cons			= SERIAL_21285_CONSOLE,
};
</code></pre>
<p>If the driver registered successfully we attach the driver-defined port <code>serial21285_port</code> structure with the <code>uart_add_one_port</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/drivers/tty/serial/serial_core.c">drivers/tty/serial/serial_core.c</a> source code file and return from the <code>serial21285_init</code> function:</p>
<pre><code class="language-C">if (ret == 0)
	uart_add_one_port(&amp;serial21285_reg, &amp;serial21285_port);

return ret;
</code></pre>
<p>That's all. Our driver is initialized. When an <code>uart</code> port is opened with the call of the <code>uart_open</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/drivers/tty/serial/serial_core.c">drivers/tty/serial/serial_core.c</a>, it will call the <code>uart_startup</code> function to start up the serial port. This function will call the <code>startup</code> function that is part of the <code>uart_ops</code> structure. Each <code>uart</code> driver has the definition of this structure, in our case it is:</p>
<pre><code class="language-C">static struct uart_ops serial21285_ops = {
	...
	.startup	= serial21285_startup,
	...
}
</code></pre>
<p><code>serial21285</code> structure. As we can see the <code>.strartup</code> field references on the <code>serial21285_startup</code> function. Implementation of this function is very interesting for us, because it is related to the interrupts and interrupt handling.</p>
<h2 id="requesting-irq-line"><a class="header" href="#requesting-irq-line">Requesting irq line</a></h2>
<p>Let's look at the implementation of the <code>serial21285</code> function:</p>
<pre><code class="language-C">static int serial21285_startup(struct uart_port *port)
{
	int ret;

	tx_enabled(port) = 1;
	rx_enabled(port) = 1;

	ret = request_irq(IRQ_CONRX, serial21285_rx_chars, 0,
			  serial21285_name, port);
	if (ret == 0) {
		ret = request_irq(IRQ_CONTX, serial21285_tx_chars, 0,
				  serial21285_name, port);
		if (ret)
			free_irq(IRQ_CONRX, port);
	}

	return ret;
}
</code></pre>
<p>First of all about <code>TX</code> and <code>RX</code>. A serial bus of a device consists of just two wires: one for sending data and another for receiving. As such, serial devices should have two serial pins: the receiver - <code>RX</code>, and the transmitter - <code>TX</code>. With the call of first two macros: <code>tx_enabled</code> and <code>rx_enabled</code>, we enable these wires. The following part of these function is the greatest interest for us. Note on <code>request_irq</code> functions. This function registers an interrupt handler and enables a given interrupt line. Let's look at the implementation of this function and get into the details. This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/interrupt.h">include/linux/interrupt.h</a> header file and looks as:</p>
<pre><code class="language-C">static inline int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
            const char *name, void *dev)
{
        return request_threaded_irq(irq, handler, NULL, flags, name, dev);
}
</code></pre>
<p>As we can see, the <code>request_irq</code> function takes five parameters:</p>
<ul>
<li><code>irq</code> - the interrupt number that being requested;</li>
<li><code>handler</code> - the pointer to the interrupt handler;</li>
<li><code>flags</code> - the bitmask options;</li>
<li><code>name</code> - the name of the owner of an interrupt;</li>
<li><code>dev</code> - the pointer used for shared interrupt lines;</li>
</ul>
<p>Now let's look at the calls of the <code>request_irq</code> functions in our example. As we can see the first parameter is <code>IRQ_CONRX</code>. We know that it is number of the interrupt, but what is it <code>CONRX</code>? This macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/arm/mach-footbridge/include/mach/irqs.h">arch/arm/mach-footbridge/include/mach/irqs.h</a> header file. We can find the full list of interrupts that the <code>21285</code> board can generate. Note that in the second call of the <code>request_irq</code> function we pass the <code>IRQ_CONTX</code> interrupt number. Both these interrupts will handle <code>RX</code> and <code>TX</code> event in our driver. Implementation of these macros is easy:</p>
<pre><code class="language-C">#define IRQ_CONRX               _DC21285_IRQ(0)
#define IRQ_CONTX               _DC21285_IRQ(1)
...
...
...
#define _DC21285_IRQ(x)         (16 + (x))
</code></pre>
<p>The <a href="https://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA</a> IRQs on this board are from <code>0</code> to <code>15</code>, so, our interrupts will have first two numbers: <code>16</code> and <code>17</code>. Second parameters for two calls of the <code>request_irq</code> functions are <code>serial21285_rx_chars</code> and <code>serial21285_tx_chars</code>. These functions will be called when an <code>RX</code> or <code>TX</code> interrupt occurred. We will not dive in this part into details of these functions, because this chapter covers the interrupts and interrupts handling but not device and drivers. The next parameter - <code>flags</code> and as we can see, it is zero in both calls of the <code>request_irq</code> function. All acceptable flags are defined as <code>IRQF_*</code> macros in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/interrupt.h">include/linux/interrupt.h</a>. Some of it:</p>
<ul>
<li><code>IRQF_SHARED</code> - allows sharing the irq among several devices;</li>
<li><code>IRQF_PERCPU</code> - an interrupt is per cpu;</li>
<li><code>IRQF_NO_THREAD</code> - an interrupt cannot be threaded;</li>
<li><code>IRQF_NOBALANCING</code> - excludes this interrupt from irq balancing;</li>
<li><code>IRQF_IRQPOLL</code> - an interrupt is used for polling;</li>
<li>and etc.</li>
</ul>
<p>In our case we pass <code>0</code>, so it will be <code>IRQF_TRIGGER_NONE</code>. This flag means that it does not imply any kind of edge or level triggered interrupt behaviour. To the fourth parameter (<code>name</code>), we pass the <code>serial21285_name</code> that defined as:</p>
<pre><code class="language-C">static const char serial21285_name[] = &quot;Footbridge UART&quot;;
</code></pre>
<p>and will be displayed in the output of the <code>/proc/interrupts</code>. And in the last parameter we pass the pointer to the our main <code>uart_port</code> structure. Now we know a little about <code>request_irq</code> function and its parameters, let's look at its implementation. As we can see above, the <code>request_irq</code> function just makes a call of the <code>request_threaded_irq</code> function inside. The <code>request_threaded_irq</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/manage.c">kernel/irq/manage.c</a> source code file and allocates a given interrupt line. If we will look at this function, it starts from the definition of the <code>irqaction</code> and the <code>irq_desc</code>:</p>
<pre><code class="language-C">int request_threaded_irq(unsigned int irq, irq_handler_t handler,
                         irq_handler_t thread_fn, unsigned long irqflags,
                         const char *devname, void *dev_id)
{
        struct irqaction *action;
        struct irq_desc *desc;
        int retval;
		...
		...
		...
}
</code></pre>
<p>We already saw the <code>irqaction</code> and the <code>irq_desc</code> structures in this chapter. The first structure represents per interrupt action descriptor and contains pointers to the interrupt handler, name of the device, interrupt number, etc. The second structure represents a descriptor of an interrupt and contains pointer to the <code>irqaction</code>, interrupt flags, etc. Note that the <code>request_threaded_irq</code> function called by the <code>request_irq</code> with the additional parameter: <code>irq_handler_t thread_fn</code>. If this parameter is not <code>NULL</code>, the <code>irq</code> thread will be created and the given <code>irq</code> handler will be executed in this thread. In the next step we need to make following checks:</p>
<pre><code class="language-C">if (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||
            (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||
            ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))
               return -EINVAL;
</code></pre>
<p>First of all we check that real <code>dev_id</code> is passed for the shared interrupt and the <code>IRQF_COND_SUSPEND</code> only makes sense for shared interrupts. Otherwise we exit from this function with the <code>-EINVAL</code> error. After this we convert the given <code>irq</code> number to the <code>irq</code> descriptor with the help of the <code>irq_to_desc</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/irqdesc.c">kernel/irq/irqdesc.c</a> source code file and exit from this function with the <code>-EINVAL</code> error if it was not successful:</p>
<pre><code class="language-C">desc = irq_to_desc(irq);
if (!desc)
    return -EINVAL;
</code></pre>
<p>The <code>irq_to_desc</code> function checks that given <code>irq</code> number is less than maximum number of IRQs and returns the irq descriptor where the <code>irq</code> number is offset from the <code>irq_desc</code> array:</p>
<pre><code class="language-C">struct irq_desc *irq_to_desc(unsigned int irq)
{
        return (irq &lt; NR_IRQS) ? irq_desc + irq : NULL;
}
</code></pre>
<p>As we have converted <code>irq</code> number to the <code>irq</code> descriptor we make the check the status of the descriptor that an interrupt can be requested:</p>
<pre><code class="language-C">if (!irq_settings_can_request(desc) || WARN_ON(irq_settings_is_per_cpu_devid(desc)))
    return -EINVAL;
</code></pre>
<p>and exit with the <code>-EINVAL</code> otherwise. After this we check the given interrupt handler. If it was not passed to the <code>request_irq</code> function, we check the <code>thread_fn</code>. If both handlers are <code>NULL</code>, we return with the <code>-EINVAL</code>. If an interrupt handler was not passed to the <code>request_irq</code> function, but the <code>thread_fn</code> is not null, we set handler to the <code>irq_default_primary_handler</code>:</p>
<pre><code class="language-C">if (!handler) {
    if (!thread_fn)
        return -EINVAL;
	handler = irq_default_primary_handler;
}
</code></pre>
<p>In the next step we allocate memory for our <code>irqaction</code> with the <code>kzalloc</code> function and return from the function if this operation was not successful:</p>
<pre><code class="language-C">action = kzalloc(sizeof(struct irqaction), GFP_KERNEL);
if (!action)
    return -ENOMEM;
</code></pre>
<p>More about <code>kzalloc</code> will be in the separate chapter about <a href="https://0xax.gitbook.io/linux-insides/summary/mm">memory management</a> in the Linux kernel. As we allocated space for the <code>irqaction</code>, we start to initialize this structure with the values of interrupt handler, interrupt flags, device name, etc:</p>
<pre><code class="language-C">action-&gt;handler = handler;
action-&gt;thread_fn = thread_fn;
action-&gt;flags = irqflags;
action-&gt;name = devname;
action-&gt;dev_id = dev_id;
</code></pre>
<p>In the end of the <code>request_threaded_irq</code> function we call the <code>__setup_irq</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/irq/manage.c">kernel/irq/manage.c</a> and registers a given <code>irqaction</code>. Release memory for the <code>irqaction</code> and return:</p>
<pre><code class="language-C">chip_bus_lock(desc);
retval = __setup_irq(irq, desc, action);
chip_bus_sync_unlock(desc);

if (retval)
	kfree(action);

return retval;
</code></pre>
<p>Note that the call of the <code>__setup_irq</code> function is placed between the <code>chip_bus_lock</code> and the <code>chip_bus_sync_unlock</code> functions. These functions lock/unlock access to slow buses (like <a href="https://en.wikipedia.org/wiki/I%C2%B2C">i2c</a>) chips. Now let's look at the implementation of the <code>__setup_irq</code> function. In the beginning of the <code>__setup_irq</code> function we can see a couple of different checks. First of all we check that the given interrupt descriptor is not <code>NULL</code>, <code>irqchip</code> is not <code>NULL</code> and that given interrupt descriptor module owner is not <code>NULL</code>. After this we check if the interrupt is nested into another interrupt thread or not, and if it is nested we replace the <code>irq_default_primary_handler</code> with the <code>irq_nested_primary_handler</code>.</p>
<p>In the next step we create an irq handler thread with the <code>kthread_create</code> function, if the given interrupt is not nested and the <code>thread_fn</code> is not <code>NULL</code>:</p>
<pre><code class="language-C">if (new-&gt;thread_fn &amp;&amp; !nested) {
	struct task_struct *t;
	t = kthread_create(irq_thread, new, &quot;irq/%d-%s&quot;, irq, new-&gt;name);
	...
}
</code></pre>
<p>And fill the rest of the given interrupt descriptor fields in the end. So, our <code>16</code> and <code>17</code> interrupt request lines are registered and the <code>serial21285_rx_chars</code> and <code>serial21285_tx_chars</code> functions will be invoked when an interrupt controller will get event related to these interrupts. Now let's look at what happens when an interrupt occurs.</p>
<h2 id="prepare-to-handle-an-interrupt"><a class="header" href="#prepare-to-handle-an-interrupt">Prepare to handle an interrupt</a></h2>
<p>In the previous paragraph we saw the requesting of the irq line for the given interrupt descriptor and registration of the <code>irqaction</code> structure for the given interrupt. We already know that when an interrupt event occurs, an interrupt controller notifies the processor about this event and processor tries to find appropriate interrupt gate for this interrupt. If you have read the eighth <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-8">part</a> of this chapter, you may remember the <code>native_init_IRQ</code> function. This function makes initialization of the local <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a>. The following part of this function is the most interesting part for us right now:</p>
<pre><code class="language-C">for_each_clear_bit_from(i, used_vectors, first_system_vector) {
	set_intr_gate(i, irq_entries_start +
		8 * (i - FIRST_EXTERNAL_VECTOR));
}
</code></pre>
<p>Here we iterate over all the cleared bit of the <code>used_vectors</code> bitmap starting at <code>first_system_vector</code> that is:</p>
<pre><code class="language-C">int first_system_vector = FIRST_SYSTEM_VECTOR; // 0xef
</code></pre>
<p>and set interrupt gates with the <code>i</code> vector number and the <code>irq_entries_start + 8 * (i - FIRST_EXTERNAL_VECTOR)</code> start address. Only one thing is unclear here - the <code>irq_entries_start</code>. This symbol defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> assembly file and provides <code>irq</code> entries. Let's look at it:</p>
<pre><code class="language-assembly">	.align 8
ENTRY(irq_entries_start)
    vector=FIRST_EXTERNAL_VECTOR
    .rept (FIRST_SYSTEM_VECTOR - FIRST_EXTERNAL_VECTOR)
	pushq	$(~vector+0x80)
    vector=vector+1
	jmp	common_interrupt
	.align	8
    .endr
END(irq_entries_start)
</code></pre>
<p>Here we can see the <a href="https://en.wikipedia.org/wiki/GNU_Assembler">GNU assembler</a> <code>.rept</code> instruction which repeats the sequence of lines that are before <code>.endr</code> - <code>FIRST_SYSTEM_VECTOR - FIRST_EXTERNAL_VECTOR</code> times. As we already know, the <code>FIRST_SYSTEM_VECTOR</code> is <code>0xef</code>, and the <code>FIRST_EXTERNAL_VECTOR</code> is equal to <code>0x20</code>. So, it will work:</p>
<pre><code class="language-python">&gt;&gt;&gt; 0xef - 0x20
207
</code></pre>
<p>times. In the body of the <code>.rept</code> instruction we push entry stubs on the stack (note that we use negative numbers for the interrupt vector numbers, because positive numbers already reserved to identify <a href="https://en.wikipedia.org/wiki/System_call">system calls</a>), increase the <code>vector</code> variable and jump on the <code>common_interrupt</code> label. In the <code>common_interrupt</code> we adjust vector number on the stack and execute <code>interrupt</code> number with the <code>do_IRQ</code> parameter:</p>
<pre><code class="language-assembly">common_interrupt:
	addq	$-0x80, (%rsp)
	interrupt do_IRQ
</code></pre>
<p>The macro <code>interrupt</code> defined in the same source code file and saves <a href="https://en.wikipedia.org/wiki/Processor_register">general purpose</a> registers on the stack, change the userspace <code>gs</code> on the kernel with the <code>SWAPGS</code> assembler instruction if need, increase <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> - <code>irq_count</code> variable that shows that we are in interrupt and call the <code>do_IRQ</code> function. This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/irq.c">arch/x86/kernel/irq.c</a> source code file and handles our device interrupt. Let's look at this function. The <code>do_IRQ</code> function takes one parameter - <code>pt_regs</code> structure that stores values of the userspace registers:</p>
<pre><code class="language-C">__visible unsigned int __irq_entry do_IRQ(struct pt_regs *regs)
{
    struct pt_regs *old_regs = set_irq_regs(regs);
    unsigned vector = ~regs-&gt;orig_ax;
    unsigned irq;

	irq_enter();
    exit_idle();
	...
	...
	...
}
</code></pre>
<p>At the beginning of this function we can see call of the <code>set_irq_regs</code> function that returns saved <code>per-cpu</code> irq register pointer and the calls of the <code>irq_enter</code> and <code>exit_idle</code> functions. The first function <code>irq_enter</code> enters to an interrupt context with the updating <code>__preempt_count</code> variable and the second function - <code>exit_idle</code> checks that current process is <code>idle</code> with <a href="https://en.wikipedia.org/wiki/Process_identifier">pid</a> - <code>0</code> and notify the <code>idle_notifier</code> with the <code>IDLE_END</code>.</p>
<p>In the next step we read the <code>irq</code> for the current cpu and call the <code>handle_irq</code> function:</p>
<pre><code class="language-C">irq = __this_cpu_read(vector_irq[vector]);

if (!handle_irq(irq, regs)) {
	...
	...
	...
}
...
...
...
</code></pre>
<p>The <code>handle_irq</code> function defined in the <a href="https://github.com/torvalds/linux/blob/arch/x86/kernel/irq_64.c">arch/x86/kernel/irq_64.c</a> source code file, checks the given interrupt descriptor and call the <code>generic_handle_irq_desc</code>:</p>
<pre><code class="language-C">desc = irq_to_desc(irq);
	if (unlikely(!desc))
		return false;
generic_handle_irq_desc(irq, desc);
</code></pre>
<p>Where the <code>generic_handle_irq_desc</code> calls the interrupt handler:</p>
<pre><code class="language-C">static inline void generic_handle_irq_desc(unsigned int irq, struct irq_desc *desc)
{
       desc-&gt;handle_irq(irq, desc);
}
</code></pre>
<p>But stop... What is it <code>handle_irq</code> and why do we call our interrupt handler from the interrupt descriptor when we know that <code>irqaction</code> points to the actual interrupt handler? Actually the <code>irq_desc-&gt;handle_irq</code> is a high-level API for the calling interrupt handler routine. It is setup during initialization of the <a href="https://en.wikipedia.org/wiki/Device_tree">device tree</a> and <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a> initialization. The kernel selects correct function and call chain of the <code>irq-&gt;action(s)</code> there. In this way, the <code>serial21285_tx_chars</code> or the <code>serial21285_rx_chars</code> function will be executed after an interrupt occurs.</p>
<p>In the end of the <code>do_IRQ</code> function we call the <code>irq_exit</code> function that will exit from the interrupt context, the <code>set_irq_regs</code> with the old userspace registers and return:</p>
<pre><code class="language-C">irq_exit();
set_irq_regs(old_regs);
return 1;
</code></pre>
<p>We already know that when an <code>IRQ</code> finishes its work, deferred interrupts will be executed if they exist.</p>
<h2 id="exit-from-interrupt"><a class="header" href="#exit-from-interrupt">Exit from interrupt</a></h2>
<p>Ok, the interrupt handler finished its execution and now we must return from the interrupt. When the work of the <code>do_IRQ</code> function is finished, we will return back to the assembler code in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> to the <code>ret_from_intr</code> label. First of all we disable interrupts with the <code>DISABLE_INTERRUPTS</code> macro that expands to the <code>cli</code> instruction and decreases value of the <code>irq_count</code> <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> variable. Remember, this variable had value - <code>1</code>, when we were in interrupt context:</p>
<pre><code class="language-assembly">DISABLE_INTERRUPTS(CLBR_NONE)
TRACE_IRQS_OFF
decl	PER_CPU_VAR(irq_count)
</code></pre>
<p>In the last step we check the previous context (user or kernel), restore it in a correct way and exit from an interrupt with the:</p>
<pre><code class="language-assembly">INTERRUPT_RETURN
</code></pre>
<p>where the <code>INTERRUPT_RETURN</code> macro is:</p>
<pre><code class="language-C">#define INTERRUPT_RETURN	jmp native_iret
</code></pre>
<p>and</p>
<pre><code class="language-assembly">ENTRY(native_iret)

.global native_irq_return_iret
native_irq_return_iret:
	iretq
</code></pre>
<p>That's all.</p>
<h2 id="conclusion-25"><a class="header" href="#conclusion-25">Conclusion</a></h2>
<p>It is the end of the tenth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">Interrupts and Interrupt Handling</a> chapter and as you have read in the beginning of this part - it is the last part of this chapter. This chapter started from the explanation of the theory of interrupts and we have learned what is it interrupt and kinds of interrupts, then we saw exceptions and handling of this kind of interrupts, deferred interrupts and finally we looked on the hardware interrupts and the handling of theirs in this part. Of course, this part and even this chapter does not cover full aspects of interrupts and interrupt handling in the Linux kernel. It is not realistic to do this. At least for me. It was the big part, I don't know how about you, but it was really big for me. This theme is much bigger than this chapter and I am not sure that somewhere there is a book that covers it. We have missed many part and aspects of interrupts and interrupt handling, but I think it will be good point to dive in the kernel code related to the interrupts and interrupts handling.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-25"><a class="header" href="#links-25">Links</a></h2>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/serial/driver">Serial driver documentation</a></li>
<li><a href="http://netwinder.osuosl.org/pub/netwinder/docs/intel/datashts/27813501.pdf">StrongARM** SA-110/21285 Evaluation Board</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a></li>
<li><a href="https://en.wikipedia.org/wiki/Loadable_kernel_module">module</a></li>
<li><a href="http://kernelnewbies.org/Documents/InitcallMechanism">initcall</a></li>
<li><a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver/transmitter">uart</a></li>
<li><a href="https://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm">memory management</a></li>
<li><a href="https://en.wikipedia.org/wiki/I%C2%B2C">i2c</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_Assembler">GNU assembler</a></li>
<li><a href="https://en.wikipedia.org/wiki/Processor_register">Processor register</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a></li>
<li><a href="https://en.wikipedia.org/wiki/Process_identifier">pid</a></li>
<li><a href="https://en.wikipedia.org/wiki/Device_tree">device tree</a></li>
<li><a href="https://en.wikipedia.org/wiki/System_call">system calls</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-9">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-calls"><a class="header" href="#system-calls">System calls</a></h1>
<p>This chapter describes the <code>system call</code> concept in the Linux kernel.</p>
<ul>
<li><a href="SysCall/linux-syscall-1.html">Introduction to system call concept</a> - this part is introduction to the <code>system call</code> concept in the Linux kernel.</li>
<li><a href="SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a> - this part describes how the Linux kernel handles a system call from a userspace application.</li>
<li><a href="SysCall/linux-syscall-3.html">vsyscall and vDSO</a> - third part describes <code>vsyscall</code> and <code>vDSO</code> concepts.</li>
<li><a href="SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a> - this part describes startup process of a program.</li>
<li><a href="SysCall/linux-syscall-5.html">Implementation of the open system call</a> - this part describes implementation of the <a href="http://man7.org/linux/man-pages/man2/open.2.html">open</a> system call.</li>
<li><a href="SysCall/linux-syscall-6.html">Limits on resources in Linux</a> - this part describes implementation of the <a href="https://linux.die.net/man/2/getrlimit">getrlimit/setrlimit</a> system calls.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-calls-in-the-linux-kernel-part-1"><a class="header" href="#system-calls-in-the-linux-kernel-part-1">System calls in the Linux kernel. Part 1.</a></h1>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>This post opens up a new chapter in <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">linux-insides</a> book, and as you may understand from the title, this chapter will be devoted to the <a href="https://en.wikipedia.org/wiki/System_call">System call</a> concept in the Linux kernel. The choice of topic for this chapter is not accidental. In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">chapter</a> we saw interrupts and interrupt handling. The concept of system calls is very similar to that of interrupts. This is because the most common way to implement system calls is as software interrupts. We will see many different aspects that are related to the system call concept. For example, we will learn what's happening when a system call occurs from userspace. We will see an implementation of a couple system call handlers in the Linux kernel, <a href="https://en.wikipedia.org/wiki/VDSO">VDSO</a> and <a href="https://lwn.net/Articles/446528/">vsyscall</a> concepts and many many more.</p>
<p>Before we dive into Linux system call implementation, it is good to know some theory about system calls. Let's do it in the following paragraph.</p>
<h2 id="system-call-what-is-it"><a class="header" href="#system-call-what-is-it">System call. What is it?</a></h2>
<p>A system call is just a userspace request of a kernel service. Yes, the operating system kernel provides many services. When your program wants to write to or read from a file, start to listen for connections on a <a href="https://en.wikipedia.org/wiki/Network_socket">socket</a>, delete or create directory, or even to finish its work, a program uses a system call. In other words, a system call is just a <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> kernel space function that user space programs call to handle some request.</p>
<p>The Linux kernel provides a set of these functions and each architecture provides its own set. For example: the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> provides <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl">322</a> system calls and the <a href="https://en.wikipedia.org/wiki/X86">x86</a> provides <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_32.tbl">358</a> different system calls. Ok, a system call is just a function. Let's look on a simple <code>Hello world</code> example that's written in the assembly programming language:</p>
<pre><code class="language-assembly">.data

msg:
    .ascii &quot;Hello, world!\n&quot;
    len = . - msg

.text
    .global _start

_start:
	movq  $1, %rax
    movq  $1, %rdi
    movq  $msg, %rsi
    movq  $len, %rdx
    syscall

    movq  $60, %rax
    xorq  %rdi, %rdi
    syscall
</code></pre>
<p>We can compile the above with the following commands:</p>
<pre><code>$ gcc -c test.S
$ ld -o test test.o
</code></pre>
<p>and run it as follows:</p>
<pre><code>./test
Hello, world!
</code></pre>
<p>Ok, what do we see here? This simple code represents <code>Hello world</code> assembly program for the Linux <code>x86_64</code> architecture. We can see two sections here:</p>
<ul>
<li><code>.data</code></li>
<li><code>.text</code></li>
</ul>
<p>The first section - <code>.data</code> stores initialized data of our program (<code>Hello world</code> string and its length in our case). The second section - <code>.text</code> contains the code of our program. We can split the code of our program into two parts: first part will be before the first <code>syscall</code> instruction and the second part will be between first and second <code>syscall</code> instructions. First of all what does the <code>syscall</code> instruction do in our code and generally? As we can read in the <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">64-ia-32-architectures-software-developer-vol-2b-manual</a>:</p>
<pre><code>SYSCALL invokes an OS system-call handler at privilege level 0. It does so by
loading RIP from the IA32_LSTAR MSR (after saving the address of the instruction
following SYSCALL into RCX). (The WRMSR instruction ensures that the
IA32_LSTAR MSR always contain a canonical address.)
...
...
...
SYSCALL loads the CS and SS selectors with values derived from bits 47:32 of the
IA32_STAR MSR. However, the CS and SS descriptor caches are not loaded from the
descriptors (in GDT or LDT) referenced by those selectors.

Instead, the descriptor caches are loaded with fixed values. It is the respon-
sibility of OS software to ensure that the descriptors (in GDT or LDT) referenced
by those selector values correspond to the fixed values loaded into the descriptor
caches; the SYSCALL instruction does not ensure this correspondence.
</code></pre>
<p>To summarize, the <code>syscall</code> instruction jumps to the address stored in the <code>MSR_LSTAR</code> <a href="https://en.wikipedia.org/wiki/Model-specific_register">Model specific register</a> (Long system target address register). The kernel is responsible for providing its own custom function for handling syscalls as well as writing the address of this handler function to the <code>MSR_LSTAR</code> register upon system startup.
The custom function is <code>entry_SYSCALL_64</code>, which is defined in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S#L98">arch/x86/entry/entry_64.S</a>. The address of this syscall handling function is written to the <code>MSR_LSTAR</code> register during startup in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/cpu/common.c#L1335">arch/x86/kernel/cpu/common.c</a>.</p>
<pre><code class="language-C">wrmsrl(MSR_LSTAR, entry_SYSCALL_64);
</code></pre>
<p>So, the <code>syscall</code> instruction invokes a handler of a given system call. But how does it know which handler to call? Actually it gets this information from the general purpose <a href="https://en.wikipedia.org/wiki/Processor_register">registers</a>. As you can see in the system call <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl">table</a>, each system call has a unique number. In our example the first system call is <code>write</code>, which writes data to the given file. Let's look in the system call table and try to find the <code>write</code> system call. As we can see, the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl#L10">write</a> system call has number <code>1</code>. We pass the number of this system call through the <code>rax</code> register in our example. The next general purpose registers: <code>%rdi</code>, <code>%rsi</code>, and <code>%rdx</code> take the three parameters of the <code>write</code> syscall. In our case, they are:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/File_descriptor">File descriptor</a> (<code>1</code> is <a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29">stdout</a> in our case)</li>
<li>Pointer to our string</li>
<li>Size of data</li>
</ul>
<p>Yes, you heard right. Parameters for a system call. As I already wrote above, a system call is a just <code>C</code> function in the kernel space. In our case first system call is write. This system call defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/read_write.c">fs/read_write.c</a> source code file and looks like:</p>
<pre><code class="language-C">SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,
		size_t, count)
{
	...
	...
	...
}
</code></pre>
<p>Or in other words:</p>
<pre><code class="language-C">ssize_t write(int fd, const void *buf, size_t nbytes);
</code></pre>
<p>Don't worry about the <code>SYSCALL_DEFINE3</code> macro for now, we'll come back to it.</p>
<p>The second part of our example is the same, but we call another system call. In this case we call the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl#L69">exit</a> system call. This system call gets only one parameter:</p>
<ul>
<li>Return value</li>
</ul>
<p>and handles the way our program exits. We can pass the program name of our program to the <a href="https://en.wikipedia.org/wiki/Strace">strace</a> util and we will see our system calls:</p>
<pre><code>$ strace test
execve(&quot;./test&quot;, [&quot;./test&quot;], [/* 62 vars */]) = 0
write(1, &quot;Hello, world!\n&quot;, 14Hello, world!
)         = 14
_exit(0)                                = ?

+++ exited with 0 +++
</code></pre>
<p>In the first line of the <code>strace</code> output, we can see the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl#L68">execve</a> system call that executes our program, and the second and third are system calls that we have used in our program: <code>write</code> and <code>exit</code>. Note that we pass the parameter through the general purpose registers in our example. The order of the registers is not accidental. The order of the registers is defined by the following agreement - <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions">x86-64 calling conventions</a>. This, and the other agreement for the <code>x86_64</code> architecture are explained in the special document - <a href="https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-r252.pdf">System V Application Binary Interface. PDF</a>. In a general way, argument(s) of a function are placed either in registers or pushed on the stack. The right order is:</p>
<ul>
<li><code>rdi</code></li>
<li><code>rsi</code></li>
<li><code>rdx</code></li>
<li><code>rcx</code></li>
<li><code>r8</code></li>
<li><code>r9</code></li>
</ul>
<p>for the first six parameters of a function. If a function has more than six arguments, the remaining parameters will be placed on the stack.</p>
<p>We do not use system calls in our code directly, but our program uses them when we want to print something, check access to a file or just write or read something to it.</p>
<p>For example:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

int main(int argc, char **argv)
{
   FILE *fp;
   char buff[255];

   fp = fopen(&quot;test.txt&quot;, &quot;r&quot;);
   fgets(buff, 255, fp);
   printf(&quot;%s\n&quot;, buff);
   fclose(fp);

   return 0;
}
</code></pre>
<p>There are no <code>fopen</code>, <code>fgets</code>, <code>printf</code>, and <code>fclose</code> system calls in the Linux kernel, but <code>open</code>, <code>read</code>, <code>write</code>, and <code>close</code> instead. I think you know that <code>fopen</code>, <code>fgets</code>, <code>printf</code>, and <code>fclose</code> are defined in the <code>C</code> <a href="https://en.wikipedia.org/wiki/GNU_C_Library">standard library</a>. Actually, these functions are just wrappers for the system calls. We do not call system calls directly in our code, but instead use these <a href="https://en.wikipedia.org/wiki/Wrapper_function">wrapper</a> functions from the standard library. The main reason of this is simple: a system call must be performed quickly, very quickly. As a system call must be quick, it must be small. The standard library takes responsibility to perform system calls with the correct parameters and makes different checks before it will call the given system call. Let's compile our program with the following command:</p>
<pre><code>$ gcc test.c -o test
</code></pre>
<p>and examine it with the <a href="https://en.wikipedia.org/wiki/Ltrace">ltrace</a> util:</p>
<pre><code>$ ltrace ./test
__libc_start_main([ &quot;./test&quot; ] &lt;unfinished ...&gt;
fopen(&quot;test.txt&quot;, &quot;r&quot;)                                             = 0x602010
fgets(&quot;Hello World!\n&quot;, 255, 0x602010)                             = 0x7ffd2745e700
puts(&quot;Hello World!\n&quot;Hello World!

)                                                                  = 14
fclose(0x602010)                                                   = 0
+++ exited (status 0) +++
</code></pre>
<p>The <code>ltrace</code> util displays a set of userspace calls of a program. The <code>fopen</code> function opens the given text file, the <code>fgets</code> function reads file content to the <code>buf</code> buffer, the <code>puts</code> function prints the buffer to <code>stdout</code>, and the <code>fclose</code> function closes the file given by the file descriptor. And as I already wrote, all of these functions call an appropriate system call. For example, <code>puts</code> calls the <code>write</code> system call inside, we can see it if we will add <code>-S</code> option to the <code>ltrace</code> program:</p>
<pre><code>write@SYS(1, &quot;Hello World!\n\n&quot;, 14) = 14
</code></pre>
<p>Yes, system calls are ubiquitous. Each program needs to open/write/read files and network connections, allocate memory, and many other things that can be provided only by the kernel. The <a href="https://en.wikipedia.org/wiki/Procfs">proc</a> file system contains special files in a format: <code>/proc/${pid}/syscall</code> that exposes the system call number and argument registers for the system call currently being executed by the process. For example, pid 1 is <a href="https://en.wikipedia.org/wiki/Systemd">systemd</a> for me:</p>
<pre><code>$ sudo cat /proc/1/comm
systemd

$ sudo cat /proc/1/syscall
232 0x4 0x7ffdf82e11b0 0x1f 0xffffffff 0x100 0x7ffdf82e11bf 0x7ffdf82e11a0 0x7f9114681193
</code></pre>
<p>the system call with number - <code>232</code> which is <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl#L241">epoll_wait</a> system call that waits for an I/O event on an <a href="https://en.wikipedia.org/wiki/Epoll">epoll</a> file descriptor. Or for example <code>emacs</code> editor where I'm writing this part:</p>
<pre><code>$ ps ax | grep emacs
2093 ?        Sl     2:40 emacs

$ sudo cat /proc/2093/comm
emacs

$ sudo cat /proc/2093/syscall
270 0xf 0x7fff068a5a90 0x7fff068a5b10 0x0 0x7fff068a59c0 0x7fff068a59d0 0x7fff068a59b0 0x7f777dd8813c
</code></pre>
<p>the system call with the number <code>270</code> which is <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl#L279">sys_pselect6</a> system call that allows <code>emacs</code> to monitor multiple file descriptors.</p>
<p>Now we know a little about system call, what is it and why we need in it. So let's look at the <code>write</code> system call that our program used.</p>
<h2 id="implementation-of-write-system-call"><a class="header" href="#implementation-of-write-system-call">Implementation of write system call</a></h2>
<p>Let's look at the implementation of this system call directly in the source code of the Linux kernel. As we already know, the <code>write</code> system call is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/read_write.c">fs/read_write.c</a> source code file and looks like this:</p>
<pre><code class="language-C">SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,
		size_t, count)
{
	struct fd f = fdget_pos(fd);
	ssize_t ret = -EBADF;

	if (f.file) {
		loff_t pos = file_pos_read(f.file);
		ret = vfs_write(f.file, buf, count, &amp;pos);
		if (ret &gt;= 0)
			file_pos_write(f.file, pos);
		fdput_pos(f);
	}

	return ret;
}
</code></pre>
<p>First of all, the <code>SYSCALL_DEFINE3</code> macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/syscalls.h">include/linux/syscalls.h</a> header file and expands to the definition of the <code>sys_name(...)</code> function. Let's look at this macro:</p>
<pre><code class="language-C">#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)

#define SYSCALL_DEFINEx(x, sname, ...)                \
        SYSCALL_METADATA(sname, x, __VA_ARGS__)       \
        __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)
</code></pre>
<p>As we can see the <code>SYSCALL_DEFINE3</code> macro takes <code>name</code> parameter which will represent name of a system call and variadic number of parameters. This macro just expands to the <code>SYSCALL_DEFINEx</code> macro that takes the number of the parameters the given system call, the <code>_##name</code> stub for the future name of the system call (more about tokens concatenation with the <code>##</code> you can read in the <a href="https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html">documentation</a> of <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a>). Next we can see the <code>SYSCALL_DEFINEx</code> macro. This macro expands to the two following macros:</p>
<ul>
<li><code>SYSCALL_METADATA</code>;</li>
<li><code>__SYSCALL_DEFINEx</code>.</li>
</ul>
<p>Implementation of the first macro <code>SYSCALL_METADATA</code> depends on the <code>CONFIG_FTRACE_SYSCALLS</code> kernel configuration option. As we can understand from the name of this option, it allows to enable tracer to catch the syscall entry and exit events. If this kernel configuration option is enabled, the <code>SYSCALL_METADATA</code> macro executes initialization of the <code>syscall_metadata</code> structure that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/trace/syscall.h">include/trace/syscall.h</a> header file and contains different useful fields as name of a system call, number of a system call in the system call <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl">table</a>, number of parameters of a system call, list of parameter types and etc:</p>
<pre><code class="language-C">#define SYSCALL_METADATA(sname, nb, ...)                             \
	...                                                              \
	...                                                              \
	...                                                              \
    struct syscall_metadata __used                                   \
              __syscall_meta_##sname = {                             \
                    .name           = &quot;sys&quot;#sname,                   \
                    .syscall_nr     = -1,                            \
                    .nb_args        = nb,                            \
                    .types          = nb ? types_##sname : NULL,     \
                    .args           = nb ? args_##sname : NULL,      \
                    .enter_event    = &amp;event_enter_##sname,          \
                    .exit_event     = &amp;event_exit_##sname,           \
                    .enter_fields   = LIST_HEAD_INIT(__syscall_meta_##sname.enter_fields), \
             };                                                                            \

    static struct syscall_metadata __used                           \
              __attribute__((section(&quot;__syscalls_metadata&quot;)))       \
             *__p_syscall_meta_##sname = &amp;__syscall_meta_##sname;
</code></pre>
<p>If the <code>CONFIG_FTRACE_SYSCALLS</code> kernel option is not enabled during kernel configuration, the <code>SYSCALL_METADATA</code> macro expands to an empty string:</p>
<pre><code class="language-C">#define SYSCALL_METADATA(sname, nb, ...)
</code></pre>
<p>The second macro <code>__SYSCALL_DEFINEx</code> expands to the definition of the five following functions:</p>
<pre><code class="language-C">#define __SYSCALL_DEFINEx(x, name, ...)                                 \
        asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))       \
                __attribute__((alias(__stringify(SyS##name))));         \
                                                                        \
        static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__));  \
                                                                        \
        asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__));      \
                                                                        \
        asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__))       \
        {                                                               \
                long ret = SYSC##name(__MAP(x,__SC_CAST,__VA_ARGS__));  \
                __MAP(x,__SC_TEST,__VA_ARGS__);                         \
                __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));       \
                return ret;                                             \
        }                                                               \
                                                                        \
        static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__))
</code></pre>
<p>The first <code>sys##name</code> is definition of the syscall handler function with the given name - <code>sys_system_call_name</code>. The <code>__SC_DECL</code> macro takes the <code>__VA_ARGS__</code> and combines call input parameter system type and the parameter name, because the macro definition is unable to determine the parameter types. And the <code>__MAP</code> macro applies <code>__SC_DECL</code> macro to the <code>__VA_ARGS__</code> arguments. The other functions that are generated by the <code>__SYSCALL_DEFINEx</code> macro are need to protect from the <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0029">CVE-2009-0029</a> and we will not dive into details about this here. Ok, as result of the <code>SYSCALL_DEFINE3</code> macro, we will have:</p>
<pre><code class="language-C">asmlinkage long sys_write(unsigned int fd, const char __user * buf, size_t count);
</code></pre>
<p>Now we know a little about the system call's definition and we can go back to the implementation of the <code>write</code> system call. Let's look on the implementation of this system call again:</p>
<pre><code class="language-C">SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,
		size_t, count)
{
	struct fd f = fdget_pos(fd);
	ssize_t ret = -EBADF;

	if (f.file) {
		loff_t pos = file_pos_read(f.file);
		ret = vfs_write(f.file, buf, count, &amp;pos);
		if (ret &gt;= 0)
			file_pos_write(f.file, pos);
		fdput_pos(f);
	}

	return ret;
}
</code></pre>
<p>As we already know and can see from the code, it takes three arguments:</p>
<ul>
<li><code>fd</code>    - file descriptor;</li>
<li><code>buf</code>   - buffer to write;</li>
<li><code>count</code> - length of buffer to write.</li>
</ul>
<p>and writes data from a buffer declared by the user to a given device or a file. Note that the second parameter <code>buf</code>, defined with the <code>__user</code> attribute. The main purpose of this attribute is for checking the Linux kernel code with the <a href="https://en.wikipedia.org/wiki/Sparse">sparse</a> util. It is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/compiler.h">include/linux/compiler.h</a> header file and depends on the <code>__CHECKER__</code> definition in the Linux kernel. That's all about useful meta-information related to our <code>sys_write</code> system call, let's try to understand how this system call is implemented. As we can see it starts from the definition of the <code>f</code> structure that has <code>fd</code> structure type that represents file descriptor in the Linux kernel and we put the result of the call of the <code>fdget_pos</code> function. The <code>fdget_pos</code> function defined in the same <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/read_write.c">source</a> code file and just expands the call of the <code>__to_fd</code> function:</p>
<pre><code class="language-C">static inline struct fd fdget_pos(int fd)
{
        return __to_fd(__fdget_pos(fd));
}
</code></pre>
<p>The main purpose of the <code>fdget_pos</code> is to convert the given file descriptor which is just a number to the <code>fd</code> structure. Through the long chain of function calls, the <code>fdget_pos</code> function gets the file descriptor table of the current process, <code>current-&gt;files</code>, and tries to find a corresponding file descriptor number there. As we got the <code>fd</code> structure for the given file descriptor number, we check it and return if it does not exist. We get the current position in the file with the call of the <code>file_pos_read</code> function that just returns <code>f_pos</code> field of our file:</p>
<pre><code class="language-C">static inline loff_t file_pos_read(struct file *file)
{
        return file-&gt;f_pos;
}
</code></pre>
<p>and calls the <code>vfs_write</code> function. The <code>vfs_write</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/read_write.c">fs/read_write.c</a> source code file and does the work for us - writes given buffer to the given file starting from the given position. We will not dive into details about the <code>vfs_write</code> function, because this function is weakly related to the <code>system call</code> concept but mostly about <a href="https://en.wikipedia.org/wiki/Virtual_file_system">Virtual file system</a> concept which we will see in another chapter. After the <code>vfs_write</code> has finished its work, we check the result and if it was finished successfully we change the position in the file with the <code>file_pos_write</code> function:</p>
<pre><code class="language-C">if (ret &gt;= 0)
	file_pos_write(f.file, pos);
</code></pre>
<p>that just updates <code>f_pos</code> with the given position in the given file:</p>
<pre><code class="language-C">static inline void file_pos_write(struct file *file, loff_t pos)
{
        file-&gt;f_pos = pos;
}
</code></pre>
<p>At the end of the our <code>write</code> system call handler, we can see the call of the following function:</p>
<pre><code class="language-C">fdput_pos(f);
</code></pre>
<p>unlocks the <code>f_pos_lock</code> mutex that protects file position during concurrent writes from threads that share file descriptor.</p>
<p>That's all.</p>
<p>We have seen the partial implementation of one system call provided by the Linux kernel. Of course we have missed some parts in the implementation of the <code>write</code> system call, because as I mentioned above, we will see only system calls related stuff in this chapter and will not see other stuff related to other subsystems, such as <a href="https://en.wikipedia.org/wiki/Virtual_file_system">Virtual file system</a>.</p>
<h2 id="conclusion-26"><a class="header" href="#conclusion-26">Conclusion</a></h2>
<p>This concludes the first part covering system call concepts in the Linux kernel. We have covered the theory of system calls so far and in the next part we will continue to dive into this topic, touching Linux kernel code related to system calls.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-26"><a class="header" href="#links-26">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/System_call">system call</a></li>
<li><a href="https://en.wikipedia.org/wiki/VDSO">vdso</a></li>
<li><a href="https://lwn.net/Articles/446528/">vsyscall</a></li>
<li><a href="https://en.wikipedia.org/wiki/Processor_register">general purpose registers</a></li>
<li><a href="https://en.wikipedia.org/wiki/Network_socket">socket</a></li>
<li><a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C programming language</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86">x86</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions">x86-64 calling conventions</a></li>
<li><a href="http://www.x86-64.org/documentation/abi.pdf">System V Application Binary Interface. PDF</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a></li>
<li><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel manual. PDF</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl">system call table</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html">GCC macro documentation</a></li>
<li><a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a></li>
<li><a href="https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29">stdout</a></li>
<li><a href="https://en.wikipedia.org/wiki/Strace">strace</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_C_Library">standard library</a></li>
<li><a href="https://en.wikipedia.org/wiki/Wrapper_function">wrapper functions</a></li>
<li><a href="https://en.wikipedia.org/wiki/Ltrace">ltrace</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sparse">sparse</a></li>
<li><a href="https://en.wikipedia.org/wiki/Procfs">proc file system</a></li>
<li><a href="https://en.wikipedia.org/wiki/Virtual_file_system">Virtual file system</a></li>
<li><a href="https://en.wikipedia.org/wiki/Systemd">systemd</a></li>
<li><a href="https://en.wikipedia.org/wiki/Epoll">epoll</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">Previous chapter</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-calls-in-the-linux-kernel-part-2"><a class="header" href="#system-calls-in-the-linux-kernel-part-2">System calls in the Linux kernel. Part 2.</a></h1>
<h2 id="how-does-the-linux-kernel-handle-a-system-call"><a class="header" href="#how-does-the-linux-kernel-handle-a-system-call">How does the Linux kernel handle a system call</a></h2>
<p>The previous <a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-1">part</a> was the first part of the chapter that describes the <a href="https://en.wikipedia.org/wiki/System_call">system call</a> concepts in the Linux kernel.
In the previous part we learned what a system call is in the Linux kernel, and in operating systems in general. This was introduced from a user-space perspective, and part of the <a href="http://man7.org/linux/man-pages/man2/write.2.html">write</a> system call implementation was discussed. In this part we continue our look at system calls, starting with some theory before moving onto the Linux kernel code.</p>
<p>A user application does not make the system call directly from our applications. We did not write the <code>Hello world!</code> program like:</p>
<pre><code class="language-C">int main(int argc, char **argv)
{
	...
	...
	...
	sys_write(fd1, buf, strlen(buf));
	...
	...
}
</code></pre>
<p>We can use something similar with the help of <a href="https://en.wikipedia.org/wiki/GNU_C_Library">C standard library</a> and it will look something like this:</p>
<pre><code class="language-C">#include &lt;unistd.h&gt;

int main(int argc, char **argv)
{
	...
	...
	...
	write(fd1, buf, strlen(buf));
	...
	...
}
</code></pre>
<p>But anyway, <code>write</code> is not a direct system call and not a kernel function. An application must fill general purpose registers with the correct values in the correct order and use the <code>syscall</code> instruction to make the actual system call. In this part we will look at what occurs in the Linux kernel when the <code>syscall</code> instruction is met by the processor.</p>
<h2 id="initialization-of-the-system-calls-table"><a class="header" href="#initialization-of-the-system-calls-table">Initialization of the system calls table</a></h2>
<p>From the previous part we know that system call concept is very similar to an interrupt. Furthermore, system calls are implemented as software interrupts. So, when the processor handles a <code>syscall</code> instruction from a user application, this instruction causes an exception which transfers control to an exception handler. As we know, all exception handlers (or in other words kernel <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> functions that will react on an exception) are placed in the kernel code. But how does the Linux kernel search for the address of the necessary system call handler for the related system call? The Linux kernel contains a special table called the <code>system call table</code>. The system call table is represented by the <code>sys_call_table</code> array in the Linux kernel which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscall_64.c">arch/x86/entry/syscall_64.c</a> source code file. Let's look at its implementation:</p>
<pre><code class="language-C">asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
	[0 ... __NR_syscall_max] = &amp;sys_ni_syscall,
    #include &lt;asm/syscalls_64.h&gt;
};
</code></pre>
<p>As we can see, the <code>sys_call_table</code> is an array of <code>__NR_syscall_max + 1</code> size where the <code>__NR_syscall_max</code> macro represents the maximum number of system calls for the given <a href="https://en.wikipedia.org/wiki/List_of_CPU_architectures">architecture</a>. This book is about the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture, so for our case the <code>__NR_syscall_max</code> is <code>547</code> and this is the correct number at the time of writing (current Linux kernel version is <code>5.0.0-rc7</code>). We can see this macro in the header file generated by <a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt">Kbuild</a> during kernel compilation - <code>include/generated/asm-offsets.h</code>:</p>
<pre><code class="language-C">#define __NR_syscall_max 547
</code></pre>
<p>There will be the same number of system calls in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl#L331">arch/x86/entry/syscalls/syscall_64.tbl</a> for the <code>x86_64</code>. There are two important topics here; the type of the <code>sys_call_table</code> array, and the initialization of elements in this array. First of all, the type. The <code>sys_call_ptr_t</code> represents a pointer to a system call table. It is defined as <a href="https://en.wikipedia.org/wiki/Typedef">typedef</a> for a function pointer that returns nothing and does not take arguments:</p>
<pre><code class="language-C">typedef void (*sys_call_ptr_t)(void);
</code></pre>
<p>The second thing is the initialization of the <code>sys_call_table</code> array. As we can see in the code above, all elements of our array that contain pointers to the system call handlers point to the <code>sys_ni_syscall</code>. The <code>sys_ni_syscall</code> function represents not-implemented system calls. To start with, all elements of the <code>sys_call_table</code> array point to the not-implemented system call. This is the correct initial behaviour, because we only initialize storage of the pointers to the system call handlers, it is populated later on. Implementation of the <code>sys_ni_syscall</code> is pretty easy, it just returns <a href="http://man7.org/linux/man-pages/man3/errno.3.html">-errno</a> or <code>-ENOSYS</code> in our case:</p>
<pre><code class="language-C">asmlinkage long sys_ni_syscall(void)
{
	return -ENOSYS;
}
</code></pre>
<p>The <code>-ENOSYS</code> error tells us that:</p>
<pre><code>ENOSYS          Function not implemented (POSIX.1)
</code></pre>
<p>Also a note on <code>...</code> in the initialization of the <code>sys_call_table</code>. We can do it with a <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a> compiler extension called - <a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">Designated Initializers</a>. This extension allows us to initialize elements in non-fixed order. As you can see, we include the <code>asm/syscalls_64.h</code> header at the end of the array. This header file is generated by the special script at <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscalltbl.sh">arch/x86/entry/syscalls/syscalltbl.sh</a> and generates our header file from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl">syscall table</a>. The <code>asm/syscalls_64.h</code> contains definitions of the following macros:</p>
<pre><code class="language-C">__SYSCALL_COMMON(0, sys_read, sys_read)
__SYSCALL_COMMON(1, sys_write, sys_write)
__SYSCALL_COMMON(2, sys_open, sys_open)
__SYSCALL_COMMON(3, sys_close, sys_close)
__SYSCALL_COMMON(5, sys_newfstat, sys_newfstat)
...
...
...
</code></pre>
<p>The <code>__SYSCALL_COMMON</code> macro is defined in the same source code <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscall_64.c">file</a> and expands to the <code>__SYSCALL_64</code> macro which expands to the function definition:</p>
<pre><code class="language-C">#define __SYSCALL_COMMON(nr, sym, compat) __SYSCALL_64(nr, sym, compat)
#define __SYSCALL_64(nr, sym, compat) [nr] = sym,
</code></pre>
<p>So, after this, our <code>sys_call_table</code> takes the following form:</p>
<pre><code class="language-C">asmlinkage const sys_call_ptr_t sys_call_table[__NR_syscall_max+1] = {
	[0 ... __NR_syscall_max] = &amp;sys_ni_syscall,
	[0] = sys_read,
	[1] = sys_write,
	[2] = sys_open,
	...
	...
	...
};
</code></pre>
<p>After this all elements that point to the non-implemented system calls will contain the address of the <code>sys_ni_syscall</code> function that just returns <code>-ENOSYS</code> as we saw above, and other elements will point to the <code>sys_syscall_name</code> functions.</p>
<p>At this point, we have filled the system call table and the Linux kernel knows where each system call handler is. But the Linux kernel does not call a <code>sys_syscall_name</code> function immediately after it is instructed to handle a system call from a user space application. Remember the <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts">chapter</a> about interrupts and interrupt handling. When the Linux kernel gets the control to handle an interrupt, it had to do some preparations like save user space registers, switch to a new stack and many more tasks before it will call an interrupt handler. There is the same situation with the system call handling. The preparation for handling a system call is the first thing, but before the Linux kernel will start these preparations, the entry point of a system call must be initialized and only the Linux kernel knows how to perform this preparation. In the next paragraph we will see the process of the initialization of the system call entry in the Linux kernel.</p>
<h2 id="initialization-of-the-system-call-entry"><a class="header" href="#initialization-of-the-system-call-entry">Initialization of the system call entry</a></h2>
<p>When a system call occurs in the system, where are the first bytes of code that starts to handle it? As we can read in the Intel manual - <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">64-ia-32-architectures-software-developer-vol-2b-manual</a>:</p>
<pre><code>SYSCALL invokes an OS system-call handler at privilege level 0.
It does so by loading RIP from the IA32_LSTAR MSR
</code></pre>
<p>It means that we need to put the system call entry in to the <code>IA32_LSTAR</code> <a href="https://en.wikipedia.org/wiki/Model-specific_register">model specific register</a>. This operation takes place during the Linux kernel initialization process. If you have read the fourth <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-4">part</a> of the chapter that describes interrupts and interrupt handling in the Linux kernel, you know that the Linux kernel calls the <code>trap_init</code> function during the initialization process. This function is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> source code file and executes the initialization of the <code>non-early</code> exception handlers like divide error, <a href="https://en.wikipedia.org/wiki/Coprocessor">coprocessor</a> error, etc. Besides the initialization of the <code>non-early</code> exceptions handlers, this function calls the <code>cpu_init</code> function from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/cpu/common.c">arch/x86/kernel/cpu/common.c</a> source code file which besides initialization of <code>per-cpu</code> state, calls the <code>syscall_init</code> function from the same source code file.</p>
<p>This function performs the initialization of the system call entry point. Let's look on the implementation of this function. It does not take parameters and first of all it fills two model specific registers:</p>
<pre><code class="language-C">wrmsrl(MSR_STAR,  ((u64)__USER32_CS)&lt;&lt;48  | ((u64)__KERNEL_CS)&lt;&lt;32);
wrmsrl(MSR_LSTAR, entry_SYSCALL_64);
</code></pre>
<p>The first model specific register - <code>MSR_STAR</code> contains <code>63:48</code> bits of the user code segment. These bits will be loaded to the <code>CS</code> and <code>SS</code> segment registers for the <code>sysret</code> instruction which provides functionality to return from a system call to user code with the related privilege. Also the <code>MSR_STAR</code> contains <code>47:32</code> bits from the kernel code that will be used as the base selector for <code>CS</code> and <code>SS</code> segment registers when user space applications execute a system call. In the second line of code we fill the <code>MSR_LSTAR</code> register with the <code>entry_SYSCALL_64</code> symbol that represents system call entry. The <code>entry_SYSCALL_64</code> is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> assembly file and contains code related to the preparation performed before a system call handler is executed (I already wrote about these preparations, read above). We will not consider the <code>entry_SYSCALL_64</code> now, but will return to it later in this chapter.</p>
<p>After we have set the entry point for system calls, we need to set the following model specific registers:</p>
<ul>
<li><code>MSR_CSTAR</code> - target <code>rip</code> for the compatibility mode callers;</li>
<li><code>MSR_IA32_SYSENTER_CS</code> - target <code>cs</code> for the <code>sysenter</code> instruction;</li>
<li><code>MSR_IA32_SYSENTER_ESP</code> - target <code>esp</code> for the <code>sysenter</code> instruction;</li>
<li><code>MSR_IA32_SYSENTER_EIP</code> - target <code>eip</code> for the <code>sysenter</code> instruction.</li>
</ul>
<p>The values of these model specific register depend on the <code>CONFIG_IA32_EMULATION</code> kernel configuration option. If this kernel configuration option is enabled, it allows legacy 32-bit programs to run under a 64-bit kernel. In the first case, if the <code>CONFIG_IA32_EMULATION</code> kernel configuration option is enabled, we fill these model specific registers with the entry point for the system calls the compatibility mode:</p>
<pre><code class="language-C">wrmsrl(MSR_CSTAR, entry_SYSCALL_compat);
</code></pre>
<p>and with the kernel code segment, put zero to the stack pointer and write the address of the <code>entry_SYSENTER_compat</code> symbol to the <a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a>:</p>
<pre><code class="language-C">wrmsrl_safe(MSR_IA32_SYSENTER_CS, (u64)__KERNEL_CS);
wrmsrl_safe(MSR_IA32_SYSENTER_ESP, 0ULL);
wrmsrl_safe(MSR_IA32_SYSENTER_EIP, (u64)entry_SYSENTER_compat);
</code></pre>
<p>In another way, if the <code>CONFIG_IA32_EMULATION</code> kernel configuration option is disabled, we write <code>ignore_sysret</code> symbol to the <code>MSR_CSTAR</code>:</p>
<pre><code class="language-C">wrmsrl(MSR_CSTAR, ignore_sysret);
</code></pre>
<p>that is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a> assembly file and just returns <code>-ENOSYS</code> error code:</p>
<pre><code class="language-assembly">ENTRY(ignore_sysret)
	mov	$-ENOSYS, %eax
	sysret
END(ignore_sysret)
</code></pre>
<p>Now we need to fill <code>MSR_IA32_SYSENTER_CS</code>, <code>MSR_IA32_SYSENTER_ESP</code>, <code>MSR_IA32_SYSENTER_EIP</code> model specific registers as we did in the previous code when the <code>CONFIG_IA32_EMULATION</code> kernel configuration option was enabled. In this case (when the <code>CONFIG_IA32_EMULATION</code> configuration option is not set) we fill the <code>MSR_IA32_SYSENTER_ESP</code> and the <code>MSR_IA32_SYSENTER_EIP</code> with zero and put the invalid segment of the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a> to the <code>MSR_IA32_SYSENTER_CS</code> model specific register:</p>
<pre><code class="language-C">wrmsrl_safe(MSR_IA32_SYSENTER_CS, (u64)GDT_ENTRY_INVALID_SEG);
wrmsrl_safe(MSR_IA32_SYSENTER_ESP, 0ULL);
wrmsrl_safe(MSR_IA32_SYSENTER_EIP, 0ULL);
</code></pre>
<p>You can read more about the <code>Global Descriptor Table</code> in the second <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-2">part</a> of the chapter that describes the booting process of the Linux kernel.</p>
<p>At the end of the <code>syscall_init</code> function, we just mask flags in the <a href="https://en.wikipedia.org/wiki/FLAGS_register">flags register</a> by writing the set of flags to the <code>MSR_SYSCALL_MASK</code> model specific register:</p>
<pre><code class="language-C">wrmsrl(MSR_SYSCALL_MASK,
	   X86_EFLAGS_TF|X86_EFLAGS_DF|X86_EFLAGS_IF|
	   X86_EFLAGS_IOPL|X86_EFLAGS_AC|X86_EFLAGS_NT);
</code></pre>
<p>These flags will be cleared during syscall initialization. That's all, it is the end of the <code>syscall_init</code> function and it means that system call entry is ready to work. Now we can see what will occur when a user application executes the <code>syscall</code> instruction.</p>
<h2 id="preparation-before-system-call-handler-is-called"><a class="header" href="#preparation-before-system-call-handler-is-called">Preparation before system call handler is called</a></h2>
<p>As I already wrote, before a system call or an interrupt handler is called by the Linux kernel we need to do some preparations. The <code>idtentry</code> macro performs the preparations required before an exception handler is executed, the <code>interrupt</code> macro performs the preparations required before an interrupt handler is called and the <code>entry_SYSCALL_64</code> will do the preparations required before a system call handler is executed.</p>
<p>The <code>entry_SYSCALL_64</code> is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a>  assembly file and starts from the following macro:</p>
<pre><code class="language-assembly">SWAPGS_UNSAFE_STACK
</code></pre>
<p>This macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/irqflags.h">arch/x86/include/asm/irqflags.h</a> header file and expands to the <code>swapgs</code> instruction:</p>
<pre><code class="language-C">#define SWAPGS_UNSAFE_STACK	swapgs
</code></pre>
<p>which exchanges the current GS base register value with the value contained in the <code>MSR_KERNEL_GS_BASE </code> model specific register. In other words we moved it on to the kernel stack. After this we point the old stack pointer to the <code>rsp_scratch</code> <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> variable and setup the stack pointer to point to the top of stack for the current processor:</p>
<pre><code class="language-assembly">movq	%rsp, PER_CPU_VAR(rsp_scratch)
movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
</code></pre>
<p>In the next step we push the stack segment and the old stack pointer to the stack:</p>
<pre><code class="language-assembly">pushq	$__USER_DS
pushq	PER_CPU_VAR(rsp_scratch)
</code></pre>
<p>After this we enable interrupts, because interrupts are <code>off</code> on entry and save the general purpose <a href="https://en.wikipedia.org/wiki/Processor_register">registers</a> (besides <code>bp</code>, <code>bx</code> and from <code>r12</code> to <code>r15</code>), flags, <code>-ENOSYS</code> for the non-implemented system call and code segment register on the stack:</p>
<pre><code class="language-assembly">ENABLE_INTERRUPTS(CLBR_NONE)

pushq	%r11
pushq	$__USER_CS
pushq	%rcx
pushq	%rax
pushq	%rdi
pushq	%rsi
pushq	%rdx
pushq	%rcx
pushq	$-ENOSYS
pushq	%r8
pushq	%r9
pushq	%r10
pushq	%r11
sub	$(6*8), %rsp
</code></pre>
<p>When a system call occurs from the user's application, general purpose registers have the following state:</p>
<ul>
<li><code>rax</code> - contains system call number;</li>
<li><code>rcx</code> - contains return address to the user space;</li>
<li><code>r11</code> - contains register flags;</li>
<li><code>rdi</code> - contains first argument of a system call handler;</li>
<li><code>rsi</code> - contains second argument of a system call handler;</li>
<li><code>rdx</code> - contains third argument of a system call handler;</li>
<li><code>r10</code> - contains fourth argument of a system call handler;</li>
<li><code>r8</code>  - contains fifth argument of a system call handler;</li>
<li><code>r9</code>  - contains sixth argument of a system call handler;</li>
</ul>
<p>Other general purpose registers (as <code>rbp</code>, <code>rbx</code> and from <code>r12</code> to <code>r15</code>) are callee-preserved in <a href="http://www.x86-64.org/documentation/abi.pdf">C ABI</a>). So we push register flags on the top of the stack, then user code segment, return address to the user space, system call number, first three arguments, dump error code for the non-implemented system call and other arguments on the stack.</p>
<p>In the next step we check the <code>_TIF_WORK_SYSCALL_ENTRY</code> in the current <code>thread_info</code>:</p>
<pre><code class="language-assembly">testl	$_TIF_WORK_SYSCALL_ENTRY, ASM_THREAD_INFO(TI_flags, %rsp, SIZEOF_PTREGS)
jnz	tracesys
</code></pre>
<p>The <code>_TIF_WORK_SYSCALL_ENTRY</code> macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/thread_info.h">arch/x86/include/asm/thread_info.h</a> header file and provides set of the thread information flags that are related to the system calls tracing:</p>
<pre><code class="language-C">#define _TIF_WORK_SYSCALL_ENTRY \
    (_TIF_SYSCALL_TRACE | _TIF_SYSCALL_EMU | _TIF_SYSCALL_AUDIT |   \
    _TIF_SECCOMP | _TIF_SINGLESTEP | _TIF_SYSCALL_TRACEPOINT |     \
    _TIF_NOHZ)
</code></pre>
<p>We will not consider debugging/tracing related stuff in this chapter, but will see it in the separate chapter that will be devoted to the debugging and tracing techniques in the Linux kernel. After the <code>tracesys</code> label, the next label is the <code>entry_SYSCALL_64_fastpath</code>. In the <code>entry_SYSCALL_64_fastpath</code> we check the <code>__SYSCALL_MASK</code> that is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/unistd.h">arch/x86/include/asm/unistd.h</a> header file and</p>
<pre><code class="language-C"># ifdef CONFIG_X86_X32_ABI
#  define __SYSCALL_MASK (~(__X32_SYSCALL_BIT))
# else
#  define __SYSCALL_MASK (~0)
# endif
</code></pre>
<p>where the <code>__X32_SYSCALL_BIT</code> is</p>
<pre><code class="language-C">#define __X32_SYSCALL_BIT	0x40000000
</code></pre>
<p>As we can see the <code>__SYSCALL_MASK</code> depends on the <code>CONFIG_X86_X32_ABI</code> kernel configuration option and represents the mask for the 32-bit <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> in the 64-bit kernel.</p>
<p>So we check the value of the <code>__SYSCALL_MASK</code> and if the <code>CONFIG_X86_X32_ABI</code> is disabled we compare the value of the <code>rax</code> register to the maximum syscall number (<code>__NR_syscall_max</code>), alternatively if the <code>CONFIG_X86_X32_ABI</code> is enabled we mask the <code>eax</code> register with the <code>__X32_SYSCALL_BIT</code> and do the same comparison:</p>
<pre><code class="language-assembly">#if __SYSCALL_MASK == ~0
	cmpq	$__NR_syscall_max, %rax
#else
	andl	$__SYSCALL_MASK, %eax
	cmpl	$__NR_syscall_max, %eax
#endif
</code></pre>
<p>After this we check the result of the last comparison with the <code>ja</code> instruction that executes if <code>CF</code> and <code>ZF</code> flags are zero:</p>
<pre><code class="language-assembly">ja	1f
</code></pre>
<p>and if we have the correct system call for this, we move the fourth argument from the <code>r10</code> to the <code>rcx</code> to keep <a href="http://www.x86-64.org/documentation/abi.pdf">x86_64 C ABI</a> compliant and execute the <code>call</code> instruction with the address of a system call handler:</p>
<pre><code class="language-assembly">movq	%r10, %rcx
call	*sys_call_table(, %rax, 8)
</code></pre>
<p>Note, the <code>sys_call_table</code> is an array that we saw above in this part. As we already know the <code>rax</code> general purpose register contains the number of a system call and each element of the <code>sys_call_table</code> is 8-bytes. So we are using <code>*sys_call_table(, %rax, 8)</code> this notation to find the correct offset in the <code>sys_call_table</code> array for the given system call handler.</p>
<p>That's all. We did all the required preparations and the system call handler was called for the given interrupt handler, for example <code>sys_read</code>, <code>sys_write</code> or other system call handler that is defined with the <code>SYSCALL_DEFINE[N]</code> macro in the Linux kernel code.</p>
<h2 id="exit-from-a-system-call"><a class="header" href="#exit-from-a-system-call">Exit from a system call</a></h2>
<p>After a system call handler finishes its work, we will return back to the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/entry_64.S">arch/x86/entry/entry_64.S</a>, right after where we have called the system call handler:</p>
<pre><code class="language-assembly">call	*sys_call_table(, %rax, 8)
</code></pre>
<p>The next step after we've returned from a system call handler is to put the return value of a system handler on to the stack. We know that a system call returns the result to the user program in the general purpose <code>rax</code> register, so we are moving its value on to the stack after the system call handler has finished its work:</p>
<pre><code class="language-C">movq	%rax, RAX(%rsp)
</code></pre>
<p>on the <code>RAX</code> place.</p>
<p>After this we can see the call of the <code>LOCKDEP_SYS_EXIT</code> macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/irqflags.h">arch/x86/include/asm/irqflags.h</a>:</p>
<pre><code class="language-assembly">LOCKDEP_SYS_EXIT
</code></pre>
<p>The implementation of this macro depends on the <code>CONFIG_DEBUG_LOCK_ALLOC</code> kernel configuration option that allows us to debug locks on exit from a system call. And again, we will not consider it in this chapter, but will return to it in a separate one. In the end of the <code>entry_SYSCALL_64</code> function we restore all general purpose registers besides <code>rcx</code> and <code>r11</code>, because the <code>rcx</code> register must contain the return address to the application that called system call and the <code>r11</code> register contains the old <a href="https://en.wikipedia.org/wiki/FLAGS_register">flags register</a>. After all general purpose registers are restored, we fill <code>rcx</code> with the return address, <code>r11</code> register with the flags and <code>rsp</code> with the old stack pointer:</p>
<pre><code class="language-assembly">RESTORE_C_REGS_EXCEPT_RCX_R11

movq	RIP(%rsp), %rcx
movq	EFLAGS(%rsp), %r11
movq	RSP(%rsp), %rsp

USERGS_SYSRET64
</code></pre>
<p>In the end we just call the <code>USERGS_SYSRET64</code> macro that expands to the call of the <code>swapgs</code> instruction which exchanges again the user <code>GS</code> and kernel <code>GS</code> and the <code>sysretq</code> instruction which executes on exit from a system call handler:</p>
<pre><code class="language-C">#define USERGS_SYSRET64				\
	swapgs;	           				\
	sysretq;
</code></pre>
<p>Now we know what occurs when a user application calls a system call. The full path of this process is as follows:</p>
<ul>
<li>User application contains code that fills general purpose register with the values (system call number and arguments of this system call);</li>
<li>Processor switches from the user mode to kernel mode and starts execution of the system call entry - <code>entry_SYSCALL_64</code>;</li>
<li><code>entry_SYSCALL_64</code> switches to the kernel stack and saves some general purpose registers, old stack and code segment, flags and etc... on the stack;</li>
<li><code>entry_SYSCALL_64</code> checks the system call number in the <code>rax</code> register, searches a system call handler in the <code>sys_call_table</code> and calls it, if the number of a system call is correct;</li>
<li>If a system call is not correct, jump on exit from system call;</li>
<li>After a system call handler will finish its work, restore general purpose registers, old stack, flags and return address and exit from the <code>entry_SYSCALL_64</code> with the <code>sysretq</code> instruction.</li>
</ul>
<p>That's all.</p>
<h2 id="conclusion-27"><a class="header" href="#conclusion-27">Conclusion</a></h2>
<p>This is the end of the second part about the system calls concept in the Linux kernel. In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-1">part</a> we saw theory about this concept from the user application view. In this part we continued to dive into the stuff which is related to the system call concept and saw what the Linux kernel does when a system call occurs.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-27"><a class="header" href="#links-27">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/System_call">system call</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/write.2.html">write</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_C_Library">C standard library</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_CPU_architectures">list of cpu architectures</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/kbuild/makefiles.txt">kbuild</a></li>
<li><a href="https://en.wikipedia.org/wiki/Typedef">typedef</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/errno.3.html">errno</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a></li>
<li><a href="https://en.wikipedia.org/wiki/Model-specific_register">model specific register</a></li>
<li><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">intel 2b manual</a></li>
<li><a href="https://en.wikipedia.org/wiki/Coprocessor">coprocessor</a></li>
<li><a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a></li>
<li><a href="https://en.wikipedia.org/wiki/FLAGS_register">flags register</a></li>
<li><a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a></li>
<li><a href="https://en.wikipedia.org/wiki/Processor_register">general purpose registers</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a></li>
<li><a href="http://www.x86-64.org/documentation/abi.pdf">x86_64 C ABI</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-1">previous chapter</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-calls-in-the-linux-kernel-part-3"><a class="header" href="#system-calls-in-the-linux-kernel-part-3">System calls in the Linux kernel. Part 3.</a></h1>
<h2 id="vsyscalls-and-vdso"><a class="header" href="#vsyscalls-and-vdso">vsyscalls and vDSO</a></h2>
<p>This is the third part of the <a href="https://0xax.gitbook.io/linux-insides/summary/syscall">chapter</a> that describes system calls in the Linux kernel and we saw preparations after a system call caused by a userspace application and process of handling of a system call in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-2">part</a>. In this part we will look at two concepts that are very close to the system call concept, they are called <code>vsyscall</code> and <code>vdso</code>.</p>
<p>We already know what <code>system call</code>s are. They are special routines in the Linux kernel which userspace applications ask to do privileged tasks, like to read or to write to a file, to open a socket, etc. As you may know, invoking a system call is an expensive operation in the Linux kernel, because the processor must interrupt the currently executing task and switch context to kernel mode, subsequently jumping again into userspace after the system call handler finishes its work. These two mechanisms - <code>vsyscall</code> and <code>vdso</code> are designed to speed up this process for certain system calls and in this part we will try to understand how these mechanisms work.</p>
<h2 id="introduction-to-vsyscalls"><a class="header" href="#introduction-to-vsyscalls">Introduction to vsyscalls</a></h2>
<p>The <code>vsyscall</code> or <code>virtual system call</code> is the first and oldest mechanism in the Linux kernel that is designed to accelerate execution of certain system calls. The principle of work of the <code>vsyscall</code> concept is simple. The Linux kernel maps into user space a page that contains some variables and the implementation of some system calls. We can find information about this memory space in the Linux kernel <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/x86_64/mm.txt">documentation</a> for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a>:</p>
<pre><code>ffffffffff600000 - ffffffffffdfffff (=8 MB) vsyscalls
</code></pre>
<p>or:</p>
<pre><code>~$ sudo cat /proc/1/maps | grep vsyscall
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
</code></pre>
<p>After this, these system calls will be executed in userspace and this means that there will not be <a href="https://en.wikipedia.org/wiki/Context_switch">context switching</a>. Mapping of the <code>vsyscall</code> page occurs in the <code>map_vsyscall</code> function that is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/vsyscall/vsyscall_64.c">arch/x86/entry/vsyscall/vsyscall_64.c</a> source code file. This function is called during the Linux kernel initialization in the <code>setup_arch</code> function that is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> source code file (we saw this function in the fifth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">part</a> of the Linux kernel initialization process chapter).</p>
<p>Note that implementation of the <code>map_vsyscall</code> function depends on the <code>CONFIG_X86_VSYSCALL_EMULATION</code> kernel configuration option:</p>
<pre><code class="language-C">#ifdef CONFIG_X86_VSYSCALL_EMULATION
extern void map_vsyscall(void);
#else
static inline void map_vsyscall(void) {}
#endif
</code></pre>
<p>As we can read in the help text, the <code>CONFIG_X86_VSYSCALL_EMULATION</code> configuration option: <code>Enable vsyscall emulation</code>. Why emulate <code>vsyscall</code>? Actually, the <code>vsyscall</code> is a legacy <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> due to security reasons. Virtual system calls have fixed addresses, meaning that <code>vsyscall</code> page is still at the same location every time and the location of this page is determined in the <code>map_vsyscall</code> function. Let's look on the implementation of this function:</p>
<pre><code class="language-C">void __init map_vsyscall(void)
{
    extern char __vsyscall_page;
    unsigned long physaddr_vsyscall = __pa_symbol(&amp;__vsyscall_page);
	...
	...
	...
}
</code></pre>
<p>As we can see, at the beginning of the <code>map_vsyscall</code> function we get the physical address of the <code>vsyscall</code> page with the <code>__pa_symbol</code> macro (we already saw implementation if this macro in the fourth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">path</a> of the Linux kernel initialization process). The <code>__vsyscall_page</code> symbol defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/vsyscall/vsyscall_emu_64.S">arch/x86/entry/vsyscall/vsyscall_emu_64.S</a> assembly source code file and have the following <a href="https://en.wikipedia.org/wiki/Virtual_address_space">virtual address</a>:</p>
<pre><code>ffffffff81881000 D __vsyscall_page
</code></pre>
<p>in the <code>.data..page_aligned, aw</code> <a href="https://en.wikipedia.org/wiki/Memory_segmentation">section</a> and contains call of the three following system calls:</p>
<ul>
<li><code>gettimeofday</code>;</li>
<li><code>time</code>;</li>
<li><code>getcpu</code>.</li>
</ul>
<p>Or:</p>
<pre><code class="language-assembly">__vsyscall_page:
	mov $__NR_gettimeofday, %rax
	syscall
	ret

	.balign 1024, 0xcc
	mov $__NR_time, %rax
	syscall
	ret

	.balign 1024, 0xcc
	mov $__NR_getcpu, %rax
	syscall
	ret
</code></pre>
<p>Let's go back to the implementation of the <code>map_vsyscall</code> function and return to the implementation of the <code>__vsyscall_page</code> later. After we received the physical address of the <code>__vsyscall_page</code>, we check the value of the <code>vsyscall_mode</code> variable and set the <a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-2">fix-mapped</a> address for the <code>vsyscall</code> page with the <code>__set_fixmap</code> macro:</p>
<pre><code class="language-C">if (vsyscall_mode != NONE)
	__set_fixmap(VSYSCALL_PAGE, physaddr_vsyscall,
                 vsyscall_mode == NATIVE
                             ? PAGE_KERNEL_VSYSCALL
                             : PAGE_KERNEL_VVAR);
</code></pre>
<p>The <code>__set_fixmap</code> takes three arguments: The first is index of the <code>fixed_addresses</code> <a href="https://en.wikipedia.org/wiki/Enumerated_type">enum</a>. In our case <code>VSYSCALL_PAGE</code> is the first element of the <code>fixed_addresses</code> enum for the <code>x86_64</code> architecture:</p>
<pre><code class="language-C">enum fixed_addresses {
...
...
...
#ifdef CONFIG_X86_VSYSCALL_EMULATION
	VSYSCALL_PAGE = (FIXADDR_TOP - VSYSCALL_ADDR) &gt;&gt; PAGE_SHIFT,
#endif
...
...
...
</code></pre>
<p>It equal to the <code>511</code>. The second argument is the physical address of the page that has to be mapped and the third argument is the flags of the page. Note that the flags of the <code>VSYSCALL_PAGE</code> depend on the <code>vsyscall_mode</code> variable. It will be <code>PAGE_KERNEL_VSYSCALL</code> if the <code>vsyscall_mode</code> variable is <code>NATIVE</code> and the <code>PAGE_KERNEL_VVAR</code> otherwise. Both macros (the <code>PAGE_KERNEL_VSYSCALL</code> and the <code>PAGE_KERNEL_VVAR</code>) will be expanded to the following flags:</p>
<pre><code class="language-C">#define __PAGE_KERNEL_VSYSCALL          (__PAGE_KERNEL_RX | _PAGE_USER)
#define __PAGE_KERNEL_VVAR              (__PAGE_KERNEL_RO | _PAGE_USER)
</code></pre>
<p>that represent access rights to the <code>vsyscall</code> page. Both flags have the same <code>_PAGE_USER</code> flags that means that the page can be accessed by a user-mode process running at lower privilege levels. The second flag depends on the value of the <code>vsyscall_mode</code> variable. The first flag (<code>__PAGE_KERNEL_VSYSCALL</code>) will be set in the case where <code>vsyscall_mode</code> is <code>NATIVE</code>. This means virtual system calls will be native <code>syscall</code> instructions. In other way the vsyscall will have <code>PAGE_KERNEL_VVAR</code> if the <code>vsyscall_mode</code> variable will be <code>emulate</code>. In this case virtual system calls will be turned into traps and are emulated reasonably. The <code>vsyscall_mode</code> variable gets its value in the <code>vsyscall_setup</code> function:</p>
<pre><code class="language-C">static int __init vsyscall_setup(char *str)
{
	if (str) {
		if (!strcmp(&quot;emulate&quot;, str))
			vsyscall_mode = EMULATE;
		else if (!strcmp(&quot;native&quot;, str))
			vsyscall_mode = NATIVE;
		else if (!strcmp(&quot;none&quot;, str))
			vsyscall_mode = NONE;
		else
			return -EINVAL;

		return 0;
	}

	return -EINVAL;
}
</code></pre>
<p>That will be called during early kernel parameters parsing:</p>
<pre><code class="language-C">early_param(&quot;vsyscall&quot;, vsyscall_setup);
</code></pre>
<p>More about <code>early_param</code> macro you can read in the sixth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-6">part</a> of the chapter that describes process of the initialization of the Linux kernel.</p>
<p>In the end of the <code>vsyscall_map</code> function we just check that virtual address of the <code>vsyscall</code> page is equal to the value of the <code>VSYSCALL_ADDR</code> with the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">BUILD_BUG_ON</a> macro:</p>
<pre><code class="language-C">BUILD_BUG_ON((unsigned long)__fix_to_virt(VSYSCALL_PAGE) !=
             (unsigned long)VSYSCALL_ADDR);
</code></pre>
<p>That's all. <code>vsyscall</code> page is set up. The result of the all the above is the following: If we pass <code>vsyscall=native</code> parameter to the kernel command line, virtual system calls will be handled as native <code>syscall</code> instructions in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/vsyscall/vsyscall_emu_64.S">arch/x86/entry/vsyscall/vsyscall_emu_64.S</a>. The <a href="https://en.wikipedia.org/wiki/GNU_C_Library">glibc</a> knows addresses of the virtual system call handlers. Note that virtual system call handlers are aligned by <code>1024</code> (or <code>0x400</code>) bytes:</p>
<pre><code class="language-assembly">__vsyscall_page:
	mov $__NR_gettimeofday, %rax
	syscall
	ret

	.balign 1024, 0xcc
	mov $__NR_time, %rax
	syscall
	ret

	.balign 1024, 0xcc
	mov $__NR_getcpu, %rax
	syscall
	ret
</code></pre>
<p>And the start address of the <code>vsyscall</code> page is the <code>ffffffffff600000</code> every time. So, the <a href="https://en.wikipedia.org/wiki/GNU_C_Library">glibc</a> knows the addresses of the all virtual system call handlers. You can find definition of these addresses in the <code>glibc</code> source code:</p>
<pre><code class="language-C">#define VSYSCALL_ADDR_vgettimeofday   0xffffffffff600000
#define VSYSCALL_ADDR_vtime 	      0xffffffffff600400
#define VSYSCALL_ADDR_vgetcpu	      0xffffffffff600800
</code></pre>
<p>All virtual system call requests will fall into the <code>__vsyscall_page</code> + <code>VSYSCALL_ADDR_vsyscall_name</code> offset, put the number of a virtual system call to the <code>rax</code> general purpose <a href="https://en.wikipedia.org/wiki/Processor_register">register</a> and the native for the x86_64 <code>syscall</code> instruction will be executed.</p>
<p>In the second case, if we pass <code>vsyscall=emulate</code> parameter to the kernel command line, an attempt to perform virtual system call handler will cause a <a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a> exception. Of course, remember, the <code>vsyscall</code> page has <code>__PAGE_KERNEL_VVAR</code> access rights that forbid execution. The <code>do_page_fault</code> function is the <code>#PF</code> or page fault handler. It tries to understand the reason of the last page fault. And one of the reason can be situation when virtual system call called and <code>vsyscall</code> mode is <code>emulate</code>. In this case <code>vsyscall</code> will be handled by the <code>emulate_vsyscall</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/vsyscall/vsyscall_64.c">arch/x86/entry/vsyscall/vsyscall_64.c</a> source code file.</p>
<p>The <code>emulate_vsyscall</code> function gets the number of a virtual system call, checks it, prints error and sends <a href="https://en.wikipedia.org/wiki/Segmentation_fault">segmentation fault</a> simply:</p>
<pre><code class="language-C">...
...
...
vsyscall_nr = addr_to_vsyscall_nr(address);
if (vsyscall_nr &lt; 0) {
	warn_bad_vsyscall(KERN_WARNING, regs, &quot;misaligned vsyscall...);
	goto sigsegv;
}
...
...
...
sigsegv:
	force_sig(SIGSEGV, current);
	return true;
</code></pre>
<p>As it checked number of a virtual system call, it does some yet another checks like <code>access_ok</code> violations and execute system call function depends on the number of a virtual system call:</p>
<pre><code class="language-C">switch (vsyscall_nr) {
	case 0:
		ret = sys_gettimeofday(
			(struct timeval __user *)regs-&gt;di,
			(struct timezone __user *)regs-&gt;si);
		break;
	...
	...
	...
}
</code></pre>
<p>In the end we put the result of the <code>sys_gettimeofday</code> or another virtual system call handler to the <code>ax</code> general purpose register, as we did it with the normal system calls and restore the <a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a> register and add <code>8</code> bytes to the <a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a> register. This operation emulates <code>ret</code> instruction.</p>
<pre><code class="language-C">	regs-&gt;ax = ret;

do_ret:
	regs-&gt;ip = caller;
	regs-&gt;sp += 8;
	return true;
</code></pre>
<p>That's all. Now let's look on the modern concept - <code>vDSO</code>.</p>
<h2 id="introduction-to-vdso"><a class="header" href="#introduction-to-vdso">Introduction to vDSO</a></h2>
<p>As I already wrote above, <code>vsyscall</code> is an obsolete concept and replaced by the <code>vDSO</code> or <code>virtual dynamic shared object</code>. The main difference between the <code>vsyscall</code> and <code>vDSO</code> mechanisms is that <code>vDSO</code> maps memory pages into each process in a shared object <a href="https://en.wikipedia.org/wiki/Library_%28computing%29#Shared_libraries">form</a>, but <code>vsyscall</code> is static in memory and has the same address every time. For the <code>x86_64</code> architecture it is called -<code>linux-vdso.so.1</code>. All userspace applications that dynamically link to <code>glibc</code> will use the <code>vDSO</code> automatically. For example:</p>
<pre><code>~$ ldd /bin/uname
	linux-vdso.so.1 (0x00007ffe014b7000)
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fbfee2fe000)
	/lib64/ld-linux-x86-64.so.2 (0x00005559aab7c000)
</code></pre>
<p>Or:</p>
<pre><code>~$ sudo cat /proc/1/maps | grep vdso
7fff39f73000-7fff39f75000 r-xp 00000000 00:00 0       [vdso]
</code></pre>
<p>Here we can see that <a href="https://en.wikipedia.org/wiki/Uname">uname</a> util was linked with the three libraries:</p>
<ul>
<li><code>linux-vdso.so.1</code>;</li>
<li><code>libc.so.6</code>;</li>
<li><code>ld-linux-x86-64.so.2</code>.</li>
</ul>
<p>The first provides <code>vDSO</code> functionality, the second is <code>C</code> <a href="https://en.wikipedia.org/wiki/C_standard_library">standard library</a> and the third is the program interpreter (more about this you can read in the part that describes <a href="https://0xax.gitbook.io/linux-insides/summary/misc/linux-misc-3">linkers</a>). So, the <code>vDSO</code> solves limitations of the <code>vsyscall</code>. Implementation of the <code>vDSO</code> is similar to <code>vsyscall</code>.</p>
<p>Initialization of the <code>vDSO</code> occurs in the <code>init_vdso</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/vdso/vma.c">arch/x86/entry/vdso/vma.c</a> source code file. This function starts from the initialization of the <code>vDSO</code> images for 32-bits and 64-bits depends on the <code>CONFIG_X86_X32_ABI</code> kernel configuration option:</p>
<pre><code class="language-C">static int __init init_vdso(void)
{
	init_vdso_image(&amp;vdso_image_64);

#ifdef CONFIG_X86_X32_ABI
	init_vdso_image(&amp;vdso_image_x32);
#endif
</code></pre>
<p>Both functions initialize the <code>vdso_image</code> structure. This structure is defined in the two generated source code files: the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/vdso/vdso-image-64.c">arch/x86/entry/vdso/vdso-image-64.c</a> and the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/vdso/vdso-image-32.c">arch/x86/entry/vdso/vdso-image-32.c</a>. These source code files generated by the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/vdso/vdso2c.c">vdso2c</a> program from the different source code files, represent different approaches to call a system call like <code>int 0x80</code>, <code>sysenter</code>, etc. The full set of the images depends on the kernel configuration.</p>
<p>For example for the <code>x86_64</code> Linux kernel it will contain <code>vdso_image_64</code>:</p>
<pre><code class="language-C">#ifdef CONFIG_X86_64
extern const struct vdso_image vdso_image_64;
#endif
</code></pre>
<p>But for the <code>x86</code> - <code>vdso_image_32</code>:</p>
<pre><code class="language-C">#ifdef CONFIG_X86_X32
extern const struct vdso_image vdso_image_x32;
#endif
</code></pre>
<p>If our kernel is configured for the <code>x86</code> architecture or for the <code>x86_64</code> and compatibility mode, we will have ability to call a system call with the <code>int 0x80</code> interrupt, if compatibility mode is enabled, we will be able to call a system call with the native <code>syscall instruction</code> or <code>sysenter</code> instruction in other way:</p>
<pre><code class="language-C">#if defined CONFIG_X86_32 || defined CONFIG_COMPAT
  extern const struct vdso_image vdso_image_32_int80;
#ifdef CONFIG_COMPAT
  extern const struct vdso_image vdso_image_32_syscall;
#endif
 extern const struct vdso_image vdso_image_32_sysenter;
#endif
</code></pre>
<p>As we can understand from the name of the <code>vdso_image</code> structure, it represents image of the <code>vDSO</code> for the certain mode of the system call entry. This structure contains information about size in bytes of the <code>vDSO</code> area that's always a multiple of <code>PAGE_SIZE</code> (<code>4096</code> bytes), pointer to the text mapping, start and end address of the <code>alternatives</code> (set of instructions with better alternatives for the certain type of the processor), etc. For example <code>vdso_image_64</code> looks like this:</p>
<pre><code class="language-C">const struct vdso_image vdso_image_64 = {
	.data = raw_data,
	.size = 8192,
	.text_mapping = {
		.name = &quot;[vdso]&quot;,
		.pages = pages,
	},
	.alt = 3145,
	.alt_len = 26,
	.sym_vvar_start = -8192,
	.sym_vvar_page = -8192,
	.sym_hpet_page = -4096,
};
</code></pre>
<p>Where the <code>raw_data</code> contains raw binary code of the 64-bit <code>vDSO</code> system calls which are <code>2</code> page size:</p>
<pre><code class="language-C">static struct page *pages[2];
</code></pre>
<p>or 8 Kilobytes.</p>
<p>The <code>init_vdso_image</code> function is defined in the same source code file and just initializes the <code>vdso_image.text_mapping.pages</code>. First of all this function calculates the number of pages and initializes each <code>vdso_image.text_mapping.pages[number_of_page]</code> with the <code>virt_to_page</code> macro that converts given address to the <code>page</code> structure:</p>
<pre><code class="language-C">void __init init_vdso_image(const struct vdso_image *image)
{
	int i;
	int npages = (image-&gt;size) / PAGE_SIZE;

	for (i = 0; i &lt; npages; i++)
		image-&gt;text_mapping.pages[i] =
			virt_to_page(image-&gt;data + i*PAGE_SIZE);
	...
	...
	...
}
</code></pre>
<p>The <code>init_vdso</code> function passed to the <code>subsys_initcall</code> macro adds the given function to the <code>initcalls</code> list. All functions from this list will be called in the <code>do_initcalls</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> source code file:</p>
<pre><code class="language-C">subsys_initcall(init_vdso);
</code></pre>
<p>Ok, we just saw initialization of the <code>vDSO</code> and initialization of <code>page</code> structures that are related to the memory pages that contain <code>vDSO</code> system calls. But to where do their pages map? Actually they are mapped by the kernel, when it loads binary to the memory. The Linux kernel calls the <code>arch_setup_additional_pages</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/vdso/vma.c">arch/x86/entry/vdso/vma.c</a> source code file that checks that <code>vDSO</code> enabled for the <code>x86_64</code> and calls the <code>map_vdso</code> function:</p>
<pre><code class="language-C">int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
{
	if (!vdso64_enabled)
		return 0;

	return map_vdso(&amp;vdso_image_64, true);
}
</code></pre>
<p>The <code>map_vdso</code> function is defined in the same source code file and maps pages for the <code>vDSO</code> and for the shared <code>vDSO</code> variables. That's all. The main differences between the <code>vsyscall</code> and the <code>vDSO</code> concepts is that <code>vsyscall</code> has a static address of <code>ffffffffff600000</code> and implements three system calls, whereas the <code>vDSO</code> loads dynamically and implements five system calls, as defined in <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/vdso/vdso.lds.S">arch/x86/entry/vdso/vma.c</a>:</p>
<ul>
<li><code>__vdso_clock_gettime</code>;</li>
<li><code>__vdso_getcpu</code>;</li>
<li><code>__vdso_gettimeofday</code>;</li>
<li><code>__vdso_time</code>;</li>
<li><code>__vdso_clock_getres</code>.</li>
</ul>
<p>That's all.</p>
<h2 id="conclusion-28"><a class="header" href="#conclusion-28">Conclusion</a></h2>
<p>This is the end of the third part about the system calls concept in the Linux kernel. In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-2">part</a> we discussed the implementation of the preparation from the Linux kernel side, before a system call will be handled and implementation of the <code>exit</code> process from a system call handler. In this part we continued to dive into the stuff which is related to the system call concept and learned two new concepts that are very similar to the system call - the <code>vsyscall</code> and the <code>vDSO</code>.</p>
<p>After all of these three parts, we know almost all things that are related to system calls, we know what system call is and why user applications need them.  We also know what occurs when a user application calls a system call and how the kernel handles system calls.</p>
<p>The next part will be the last part in this <a href="https://0xax.gitbook.io/linux-insides/summary/syscall">chapter</a> and we will see what occurs when a user runs the program.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-28"><a class="header" href="#links-28">Links</a></h2>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/x86_64/mm.txt">x86_64 memory map</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://en.wikipedia.org/wiki/Context_switch">context switching</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a></li>
<li><a href="https://en.wikipedia.org/wiki/Virtual_address_space">virtual address</a></li>
<li><a href="https://en.wikipedia.org/wiki/Memory_segmentation">Segmentation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Enumerated_type">enum</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-2">fix-mapped addresses</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_C_Library">glibc</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">BUILD_BUG_ON</a></li>
<li><a href="https://en.wikipedia.org/wiki/Processor_register">Processor register</a></li>
<li><a href="https://en.wikipedia.org/wiki/Page_fault">Page fault</a></li>
<li><a href="https://en.wikipedia.org/wiki/Segmentation_fault">segmentation fault</a></li>
<li><a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a></li>
<li><a href="https://en.wikipedia.org/wiki/Stack_register">stack pointer</a></li>
<li><a href="https://en.wikipedia.org/wiki/Uname">uname</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/misc/linux-misc-3">Linkers</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-2">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-calls-in-the-linux-kernel-part-4"><a class="header" href="#system-calls-in-the-linux-kernel-part-4">System calls in the Linux kernel. Part 4.</a></h1>
<h2 id="how-does-the-linux-kernel-run-a-program"><a class="header" href="#how-does-the-linux-kernel-run-a-program">How does the Linux kernel run a program</a></h2>
<p>This is the fourth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/syscall">chapter</a> that describes <a href="https://en.wikipedia.org/wiki/System_call">system calls</a> in the Linux kernel and as I wrote in the conclusion of the <a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-3">previous</a> - this part will be last in this chapter. In the previous part we stopped at the two new concepts:</p>
<ul>
<li><code>vsyscall</code>;</li>
<li><code>vDSO</code>;</li>
</ul>
<p>that are related and very similar on system call concept.</p>
<p>This part will be last part in this chapter and as you can understand from the part's title - we will see what does occur in the Linux kernel when we run our programs. So, let's start.</p>
<h2 id="how-do-we-launch-our-programs"><a class="header" href="#how-do-we-launch-our-programs">how do we launch our programs?</a></h2>
<p>There are many different ways to launch an application from a user perspective. For example we can run a program from the <a href="https://en.wikipedia.org/wiki/Unix_shell">shell</a> or double-click on the application icon. It does not matter. The Linux kernel handles application launch regardless how we do launch this application.</p>
<p>In this part we will consider the way when we just launch an application from the shell. As you know, the standard way to launch an application from shell is the following: We just launch a <a href="https://en.wikipedia.org/wiki/Terminal_emulator">terminal emulator</a> application and just write the name of the program and pass or not arguments to our program, for example:</p>
<p><img src="SysCall/images/ls_shell.png" alt="ls shell" /></p>
<p>Let's consider what does occur when we launch an application from the shell, what does shell do when we write program name, what does Linux kernel do etc. But before we will start to consider these interesting things, I want to warn that this book is about the Linux kernel. That's why we will see Linux kernel insides related stuff mostly in this part. We will not consider in details what does shell do, we will not consider complex cases, for example subshells etc.</p>
<p>My default shell is - <a href="https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29">bash</a>, so I will consider how do bash shell launches a program. So let's start. The <code>bash</code> shell as well as any program that written with <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> programming language starts from the <a href="https://en.wikipedia.org/wiki/Entry_point">main</a> function. If you will look on the source code of the <code>bash</code> shell, you will find the <code>main</code> function in the <a href="https://github.com/bminor/bash/blob/bc007799f0e1362100375bb95d952d28de4c62fb/shell.c#L357">shell.c</a> source code file. This function makes many different things before the main thread loop of the <code>bash</code> started to work. For example this function:</p>
<ul>
<li>checks and tries to open <code>/dev/tty</code>;</li>
<li>check that shell running in debug mode;</li>
<li>parses command line arguments;</li>
<li>reads shell environment;</li>
<li>loads <code>.bashrc</code>, <code>.profile</code> and other configuration files;</li>
<li>and many many more.</li>
</ul>
<p>After all of these operations we can see the call of the <code>reader_loop</code> function. This function defined in the <a href="https://github.com/bminor/bash/blob/bc007799f0e1362100375bb95d952d28de4c62fb/eval.c#L67">eval.c</a> source code file and represents main thread loop or in other words it reads and executes commands. As the <code>reader_loop</code> function made all checks and read the given program name and arguments, it calls the <code>execute_command</code> function from the <a href="https://github.com/bminor/bash/blob/bc007799f0e1362100375bb95d952d28de4c62fb/execute_cmd.c#L378">execute_cmd.c</a> source code file. The <code>execute_command</code> function through the chain of the functions calls:</p>
<pre><code>execute_command
--&gt; execute_command_internal
----&gt; execute_simple_command
------&gt; execute_disk_command
--------&gt; shell_execve
</code></pre>
<p>makes different checks like do we need to start <code>subshell</code>, was it builtin <code>bash</code> function or not etc. As I already wrote above, we will not consider all details about things that are not related to the Linux kernel. In the end of this process, the <code>shell_execve</code> function calls the <code>execve</code> system call:</p>
<pre><code class="language-C">execve (command, args, env);
</code></pre>
<p>The <code>execve</code> system call has the following signature:</p>
<pre><code>int execve(const char *filename, char *const argv [], char *const envp[]);
</code></pre>
<p>and executes a program by the given filename, with the given arguments and <a href="https://en.wikipedia.org/wiki/Environment_variable">environment variables</a>. This system call is the first in our case and only, for example:</p>
<pre><code>$ strace ls
execve(&quot;/bin/ls&quot;, [&quot;ls&quot;], [/* 62 vars */]) = 0

$ strace echo
execve(&quot;/bin/echo&quot;, [&quot;echo&quot;], [/* 62 vars */]) = 0

$ strace uname
execve(&quot;/bin/uname&quot;, [&quot;uname&quot;], [/* 62 vars */]) = 0
</code></pre>
<p>So, a user application (<code>bash</code> in our case) calls the system call and as we already know the next step is Linux kernel.</p>
<h2 id="execve-system-call"><a class="header" href="#execve-system-call">execve system call</a></h2>
<p>We saw preparation before a system call called by a user application and after a system call handler finished its work in the second <a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-2">part</a> of this chapter. We stopped at the call of the <code>execve</code> system call in the previous paragraph. This system call defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/exec.c">fs/exec.c</a> source code file and as we already know it takes three arguments:</p>
<pre><code>SYSCALL_DEFINE3(execve,
		const char __user *, filename,
		const char __user *const __user *, argv,
		const char __user *const __user *, envp)
{
	return do_execve(getname(filename), argv, envp);
}
</code></pre>
<p>Implementation of the <code>execve</code> is pretty simple here, as we can see it just returns the result of the <code>do_execve</code> function. The <code>do_execve</code> function defined in the same source code file and do the following things:</p>
<ul>
<li>Initialize two pointers on a userspace data with the given arguments and environment variables;</li>
<li>return the result of the <code>do_execveat_common</code>.</li>
</ul>
<p>We can see its implementation:</p>
<pre><code class="language-C">struct user_arg_ptr argv = { .ptr.native = __argv };
struct user_arg_ptr envp = { .ptr.native = __envp };
return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
</code></pre>
<p>The <code>do_execveat_common</code> function does main work - it executes a new program. This function takes similar set of arguments, but as you can see it takes five arguments instead of three. The first argument is the file descriptor that represent directory with our application, in our case the <code>AT_FDCWD</code> means that the given pathname is interpreted relative to the current working directory of the calling process. The fifth argument is flags. In our case we passed <code>0</code> to the <code>do_execveat_common</code>. We will check in a next step, so will see it later.</p>
<p>First of all the <code>do_execveat_common</code> function checks the <code>filename</code> pointer and returns if it is <code>NULL</code>. After this we check flags of the current process that limit of running processes is not exceeded:</p>
<pre><code class="language-C">if (IS_ERR(filename))
	return PTR_ERR(filename);

if ((current-&gt;flags &amp; PF_NPROC_EXCEEDED) &amp;&amp;
	atomic_read(&amp;current_user()-&gt;processes) &gt; rlimit(RLIMIT_NPROC)) {
	retval = -EAGAIN;
	goto out_ret;
}

current-&gt;flags &amp;= ~PF_NPROC_EXCEEDED;
</code></pre>
<p>If these two checks were successful we unset <code>PF_NPROC_EXCEEDED</code> flag in the flags of the current process to prevent fail of the <code>execve</code>. You can see that in the next step we call the <code>unshare_files</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/fork.c">kernel/fork.c</a> and unshares the files of the current task and check the result of this function:</p>
<pre><code class="language-C">retval = unshare_files(&amp;displaced);
if (retval)
	goto out_ret;
</code></pre>
<p>We need to call this function to eliminate potential leak of the execve'd binary's <a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a>. In the next step we start preparation of the <code>bprm</code> that represented by the <code>struct linux_binprm</code> structure (defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/binfmts.h">include/linux/binfmts.h</a> header file). The <code>linux_binprm</code> structure is used to hold the arguments that are used when loading binaries. For example it contains <code>vma</code> field which has <code>vm_area_struct</code> type and represents single memory area over a contiguous interval in a given address space where our application will be loaded, <code>mm</code> field which is memory descriptor of the binary, pointer to the top of memory and many other different fields.</p>
<p>First of all we allocate memory for this structure with the <code>kzalloc</code> function and check the result of the allocation:</p>
<pre><code class="language-C">bprm = kzalloc(sizeof(*bprm), GFP_KERNEL);
if (!bprm)
	goto out_files;
</code></pre>
<p>After this we start to prepare the <code>binprm</code> credentials with the call of the <code>prepare_bprm_creds</code> function:</p>
<pre><code class="language-C">retval = prepare_bprm_creds(bprm);
	if (retval)
		goto out_free;

check_unsafe_exec(bprm);
current-&gt;in_execve = 1;
</code></pre>
<p>Initialization of the <code>binprm</code> credentials in other words is initialization of the <code>cred</code> structure that stored inside of the <code>linux_binprm</code> structure. The <code>cred</code> structure contains the security context of a task for example <a href="https://en.wikipedia.org/wiki/User_identifier#Real_user_ID">real uid</a> of the task, real <a href="https://en.wikipedia.org/wiki/Globally_unique_identifier">guid</a> of the task, <code>uid</code> and <code>guid</code> for the <a href="https://en.wikipedia.org/wiki/Virtual_file_system">virtual file system</a> operations etc. In the next step as we executed preparation of the <code>bprm</code> credentials we check that now we can safely execute a program with the call of the <code>check_unsafe_exec</code> function and set the current process to the <code>in_execve</code> state.</p>
<p>After all of these operations we call the <code>do_open_execat</code> function that checks the flags that we passed to the <code>do_execveat_common</code> function (remember that we have <code>0</code> in the <code>flags</code>) and searches and opens executable file on disk, checks that our we will load a binary file from <code>noexec</code> mount points (we need to avoid execute a binary from filesystems that do not contain executable binaries like <a href="https://en.wikipedia.org/wiki/Procfs">proc</a> or <a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a>), initializes <code>file</code> structure and returns pointer on this structure. Next we can see the call the <code>sched_exec</code> after this:</p>
<pre><code class="language-C">file = do_open_execat(fd, filename, flags);
retval = PTR_ERR(file);
if (IS_ERR(file))
	goto out_unmark;

sched_exec();
</code></pre>
<p>The <code>sched_exec</code> function is used to determine the least loaded processor that can execute the new program and to migrate the current process to it.</p>
<p>After this we need to check <a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a> of the give executable binary. We try to check does the name of the our binary file starts from the <code>/</code> symbol or does the path of the given executable binary is interpreted relative to the current working directory of the calling process or in other words file descriptor is <code>AT_FDCWD</code> (read above about this).</p>
<p>If one of these checks is successful we set the binary parameter filename:</p>
<pre><code class="language-C">bprm-&gt;file = file;

if (fd == AT_FDCWD || filename-&gt;name[0] == '/') {
	bprm-&gt;filename = filename-&gt;name;
}
</code></pre>
<p>Otherwise if the filename is empty we set the binary parameter filename to the <code>/dev/fd/%d</code> or <code>/dev/fd/%d/%s</code> depends on the filename of the given executable binary which means that we will execute the file to which the file descriptor refers:</p>
<pre><code class="language-C">} else {
	if (filename-&gt;name[0] == '\0')
		pathbuf = kasprintf(GFP_TEMPORARY, &quot;/dev/fd/%d&quot;, fd);
	else
		pathbuf = kasprintf(GFP_TEMPORARY, &quot;/dev/fd/%d/%s&quot;,
		                    fd, filename-&gt;name);
	if (!pathbuf) {
		retval = -ENOMEM;
		goto out_unmark;
	}

	bprm-&gt;filename = pathbuf;
}

bprm-&gt;interp = bprm-&gt;filename;
</code></pre>
<p>Note that we set not only the <code>bprm-&gt;filename</code> but also <code>bprm-&gt;interp</code> that will contain name of the program interpreter. For now we just write the same name there, but later it will be updated with the real name of the program interpreter depends on binary format of a program. You can read above that we already prepared <code>cred</code> for the <code>linux_binprm</code>. The next step is initialization of other fields of the <code>linux_binprm</code>.  First of all we call the <code>bprm_mm_init</code> function and pass the <code>bprm</code> to it:</p>
<pre><code class="language-C">retval = bprm_mm_init(bprm);
if (retval)
	goto out_unmark;
</code></pre>
<p>The <code>bprm_mm_init</code> defined in the same source code file and as we can understand from the function's name, it makes initialization of the memory descriptor or in other words the <code>bprm_mm_init</code> function initializes <code>mm_struct</code> structure. This structure defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/mm_types.h">include/linux/mm_types.h</a> header file and represents address space of a process. We will not consider implementation of the <code>bprm_mm_init</code> function because we do not know many important stuff related to the Linux kernel memory manager, but we just need to know that this function initializes <code>mm_struct</code> and populate it with a temporary stack <code>vm_area_struct</code>.</p>
<p>After this we calculate the count of the command line arguments which were passed to our executable binary, the count of the environment variables and set it to the <code>bprm-&gt;argc</code> and <code>bprm-&gt;envc</code> respectively:</p>
<pre><code class="language-C">bprm-&gt;argc = count(argv, MAX_ARG_STRINGS);
if ((retval = bprm-&gt;argc) &lt; 0)
	goto out;

bprm-&gt;envc = count(envp, MAX_ARG_STRINGS);
if ((retval = bprm-&gt;envc) &lt; 0)
	goto out;
</code></pre>
<p>As you can see we do this operations with the help of the <code>count</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/exec.c">same</a> source code file and calculates the count of strings in the <code>argv</code> array. The <code>MAX_ARG_STRINGS</code> macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/uapi/linux/binfmts.h">include/uapi/linux/binfmts.h</a> header file and as we can understand from the macro's name, it represents maximum number of strings that were passed to the <code>execve</code> system call. The value of the <code>MAX_ARG_STRINGS</code>:</p>
<pre><code class="language-C">#define MAX_ARG_STRINGS 0x7FFFFFFF
</code></pre>
<p>After we calculated the number of the command line arguments and environment variables, we call the <code>prepare_binprm</code> function. We already call the function with the similar name before this moment. This function is called <code>prepare_binprm_cred</code> and we remember that this function initializes <code>cred</code> structure in the <code>linux_bprm</code>. Now the <code>prepare_binprm</code> function:</p>
<pre><code class="language-C">retval = prepare_binprm(bprm);
if (retval &lt; 0)
	goto out;
</code></pre>
<p>fills the <code>linux_binprm</code> structure with the <code>uid</code> from <a href="https://en.wikipedia.org/wiki/Inode">inode</a> and read <code>128</code> bytes from the binary executable file. We read only first <code>128</code> from the executable file because we need to check a type of our executable. We will read the rest of the executable file in the later step. After the preparation of the <code>linux_bprm</code> structure we copy the filename of the executable binary file, command line arguments and environment variables to the <code>linux_bprm</code> with the call of the <code>copy_strings_kernel</code> function:</p>
<pre><code class="language-C">retval = copy_strings_kernel(1, &amp;bprm-&gt;filename, bprm);
if (retval &lt; 0)
	goto out;

retval = copy_strings(bprm-&gt;envc, envp, bprm);
if (retval &lt; 0)
	goto out;

retval = copy_strings(bprm-&gt;argc, argv, bprm);
if (retval &lt; 0)
	goto out;
</code></pre>
<p>And set the pointer to the top of new program's stack that we set in the <code>bprm_mm_init</code> function:</p>
<pre><code class="language-C">bprm-&gt;exec = bprm-&gt;p;
</code></pre>
<p>The top of the stack will contain the program filename and we store this filename to the <code>exec</code> field of the <code>linux_bprm</code> structure.</p>
<p>Now we have filled <code>linux_bprm</code> structure, we call the <code>exec_binprm</code> function:</p>
<pre><code class="language-C">retval = exec_binprm(bprm);
if (retval &lt; 0)
	goto out;
</code></pre>
<p>First of all we store the <a href="https://en.wikipedia.org/wiki/Process_identifier">pid</a> and <code>pid</code> that seen from the <a href="https://en.wikipedia.org/wiki/Cgroups">namespace</a> of the current task in the <code>exec_binprm</code>:</p>
<pre><code class="language-C">old_pid = current-&gt;pid;
rcu_read_lock();
old_vpid = task_pid_nr_ns(current, task_active_pid_ns(current-&gt;parent));
rcu_read_unlock();
</code></pre>
<p>and call the:</p>
<pre><code class="language-C">search_binary_handler(bprm);
</code></pre>
<p>function. This function goes through the list of handlers that contains different binary formats. Currently the Linux kernel supports the following binary formats:</p>
<ul>
<li><code>binfmt_script</code> - support for interpreted scripts that are starts from the <a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">#!</a> line;</li>
<li><code>binfmt_misc</code> - support different binary formats, according to runtime configuration of the Linux kernel;</li>
<li><code>binfmt_elf</code> - support <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">elf</a> format;</li>
<li><code>binfmt_aout</code> - support <a href="https://en.wikipedia.org/wiki/A.out">a.out</a> format;</li>
<li><code>binfmt_flat</code> - support for <a href="https://en.wikipedia.org/wiki/Binary_file#Structure">flat</a> format;</li>
<li><code>binfmt_elf_fdpic</code> - Support for <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">elf</a> <a href="http://elinux.org/UClinux_Shared_Library#FDPIC_ELF">FDPIC</a> binaries;</li>
<li><code>binfmt_em86</code> - support for Intel <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">elf</a> binaries running on <a href="https://en.wikipedia.org/wiki/DEC_Alpha">Alpha</a> machines.</li>
</ul>
<p>So, the <code>search_binary_handler</code> tries to call the <code>load_binary</code> function and pass <code>linux_binprm</code> to it. If the binary handler supports the given executable file format, it starts to prepare the executable binary for execution:</p>
<pre><code class="language-C">int search_binary_handler(struct linux_binprm *bprm)
{
	...
	...
	...
	list_for_each_entry(fmt, &amp;formats, lh) {
		retval = fmt-&gt;load_binary(bprm);
		if (retval &lt; 0 &amp;&amp; !bprm-&gt;mm) {
			force_sigsegv(SIGSEGV, current);
			return retval;
		}
	}

	return retval;
</code></pre>
<p>Where the <code>load_binary</code> for example for the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">elf</a> checks the magic number (each <code>elf</code> binary file contains magic number in the header) in the <code>linux_bprm</code> buffer (remember that we read first <code>128</code> bytes from the executable binary file): and exit if it is not <code>elf</code> binary:</p>
<pre><code class="language-C">static int load_elf_binary(struct linux_binprm *bprm)
{
	...
	...
	...
	loc-&gt;elf_ex = *((struct elfhdr *)bprm-&gt;buf);

	if (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)
		goto out;
</code></pre>
<p>If the given executable file is in <code>elf</code> format, the <code>load_elf_binary</code> continues to execute. The <code>load_elf_binary</code> does many different things to prepare on execution executable file. For example it checks the architecture and type of the executable file:</p>
<pre><code class="language-C">if (loc-&gt;elf_ex.e_type != ET_EXEC &amp;&amp; loc-&gt;elf_ex.e_type != ET_DYN)
	goto out;
if (!elf_check_arch(&amp;loc-&gt;elf_ex))
	goto out;
</code></pre>
<p>and exit if there is wrong architecture and executable file non executable non shared. Tries to load the <code>program header table</code>:</p>
<pre><code class="language-C">elf_phdata = load_elf_phdrs(&amp;loc-&gt;elf_ex, bprm-&gt;file);
if (!elf_phdata)
	goto out;
</code></pre>
<p>that describes <a href="https://en.wikipedia.org/wiki/Memory_segmentation">segments</a>. Read the <code>program interpreter</code> and libraries that linked with the our executable binary file from disk and load it to memory. The <code>program interpreter</code> specified in the <code>.interp</code> section of the executable file and as you can read in the part that describes <a href="https://0xax.gitbook.io/linux-insides/summary/misc/linux-misc-3">Linkers</a> it is - <code>/lib64/ld-linux-x86-64.so.2</code> for the <code>x86_64</code>. It setups the stack and map <code>elf</code> binary into the correct location in memory. It maps the <a href="https://en.wikipedia.org/wiki/.bss">bss</a> and the <a href="http://man7.org/linux/man-pages/man2/sbrk.2.html">brk</a> sections and does many many other different things to prepare executable file to execute.</p>
<p>In the end of the execution of the <code>load_elf_binary</code> we call the <code>start_thread</code> function and pass three arguments to it:</p>
<pre><code class="language-C">	start_thread(regs, elf_entry, bprm-&gt;p);
	retval = 0;
out:
	kfree(loc);
out_ret:
	return retval;
</code></pre>
<p>These arguments are:</p>
<ul>
<li>Set of <a href="https://en.wikipedia.org/wiki/Processor_register">registers</a> for the new task;</li>
<li>Address of the entry point of the new task;</li>
<li>Address of the top of the stack for the new task.</li>
</ul>
<p>As we can understand from the function's name, it starts new thread, but it is not so. The <code>start_thread</code> function just prepares new task's registers to be ready to run. Let's look on the implementation of this function:</p>
<pre><code class="language-C">void
start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp)
{
        start_thread_common(regs, new_ip, new_sp,
                            __USER_CS, __USER_DS, 0);
}
</code></pre>
<p>As we can see the <code>start_thread</code> function just makes a call of the <code>start_thread_common</code> function that will do all for us:</p>
<pre><code class="language-C">static void
start_thread_common(struct pt_regs *regs, unsigned long new_ip,
                    unsigned long new_sp,
                    unsigned int _cs, unsigned int _ss, unsigned int _ds)
{
        loadsegment(fs, 0);
        loadsegment(es, _ds);
        loadsegment(ds, _ds);
        load_gs_index(0);
        regs-&gt;ip                = new_ip;
        regs-&gt;sp                = new_sp;
        regs-&gt;cs                = _cs;
        regs-&gt;ss                = _ss;
        regs-&gt;flags             = X86_EFLAGS_IF;
        force_iret();
}
</code></pre>
<p>The <code>start_thread_common</code> function fills <code>fs</code> segment register with zero and <code>es</code> and <code>ds</code> with the value of the data segment register. After this we set new values to the <a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a>, <code>cs</code> segments etc. In the end of the <code>start_thread_common</code> function we can see the <code>force_iret</code> macro that forces a system call return via <code>iret</code> instruction. Ok, we prepared new thread to run in userspace and now we can return from the <code>exec_binprm</code> and now we are in the <code>do_execveat_common</code> again. After the <code>exec_binprm</code> will finish its execution we release memory for structures that was allocated before and return.</p>
<p>After we returned from the <code>execve</code> system call handler, execution of our program will be started. We can do it, because all context related information is already configured for this purpose. As we saw the <code>execve</code> system call does not return control to a process, but code, data and other segments of the caller process are just overwritten of the program segments. The exit from our application will be implemented through the <code>exit</code> system call.</p>
<p>That's all. From this point our program will be executed.</p>
<h2 id="conclusion-29"><a class="header" href="#conclusion-29">Conclusion</a></h2>
<p>This is the end of the fourth part of the about the system calls concept in the Linux kernel. We saw almost all related stuff to the <code>system call</code> concept in these four parts. We started from the understanding of the <code>system call</code> concept, we have learned what is it and why do users applications need in this concept. Next we saw how does the Linux handle a system call from a user application. We met two similar concepts to the <code>system call</code> concept, they are <code>vsyscall</code> and <code>vDSO</code> and finally we saw how does Linux kernel run a user program.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-29"><a class="header" href="#links-29">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/System_call">System call</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unix_shell">shell</a></li>
<li><a href="https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29">bash</a></li>
<li><a href="https://en.wikipedia.org/wiki/Entry_point">entry point</a></li>
<li><a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a></li>
<li><a href="https://en.wikipedia.org/wiki/Environment_variable">environment variables</a></li>
<li><a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a></li>
<li><a href="https://en.wikipedia.org/wiki/User_identifier#Real_user_ID">real uid</a></li>
<li><a href="https://en.wikipedia.org/wiki/Virtual_file_system">virtual file system</a></li>
<li><a href="https://en.wikipedia.org/wiki/Procfs">procfs</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a></li>
<li><a href="https://en.wikipedia.org/wiki/Inode">inode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Process_identifier">pid</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cgroups">namespace</a></li>
<li><a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">#!</a></li>
<li><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">elf</a></li>
<li><a href="https://en.wikipedia.org/wiki/A.out">a.out</a></li>
<li><a href="https://en.wikipedia.org/wiki/Binary_file#Structure">flat</a></li>
<li><a href="https://en.wikipedia.org/wiki/DEC_Alpha">Alpha</a></li>
<li><a href="http://elinux.org/UClinux_Shared_Library#FDPIC_ELF">FDPIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Memory_segmentation">segments</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/misc/linux-misc-3">Linkers</a></li>
<li><a href="https://en.wikipedia.org/wiki/Processor_register">Processor register</a></li>
<li><a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-3">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="how-does-the-open-system-call-work"><a class="header" href="#how-does-the-open-system-call-work">How does the <code>open</code> system call work</a></h2>
<h2 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h2>
<p>This is the fifth part of the chapter that describes <a href="https://en.wikipedia.org/wiki/System_call">system calls</a> mechanism in the Linux kernel. Previous parts of this chapter described the mechanism of system calls in general. I will now try to describe the implementation of different system calls in the Linux kernel. Previous parts from this chapter and parts of other chapters of the book mostly described deep parts of the Linux kernel that are barely visible or  invisible from userspace. However, the greatness of the Linux kernel is not its singular existence, but its ability to enable our code to perform various useful functions such as reading/writing from/to files without the knowledge of details such as sectors, tracks and other nitty gritties of the disk layout. For eg., the kernel allows programs to send data over networks without our having to encapsulate network packets by hand etc.</p>
<p>I don't know how about you, but the inner workings of the operating system both fascinate and excite my curiosity greatly. As you may know, our programs interact with the kernel through a special mechanism called <a href="https://en.wikipedia.org/wiki/System_call">system call</a>. I will hence attempt to describe the implementation and behavior of system calls such as <code>read</code>, <code>write</code>, <code>open</code>, <code>close</code>, <code>dup</code> etc. in a series of articles.</p>
<p>Let me start with the description of the simplest (and commonly used) <a href="http://man7.org/linux/man-pages/man2/open.2.html">open</a> system call. if you have done any <code>C</code> programming at all, you should know that a file must be opened using the <code>open</code> system call before we are able to read/write to it.</p>
<pre><code class="language-C">#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;

int main(int argc, char *argv) {
        int fd = open(&quot;test&quot;, O_RDONLY);

        if fd &lt; 0 {
                perror(&quot;Opening of the file is failed\n&quot;);
        }
        else {
                printf(&quot;file successfully opened\n&quot;);
        }

        close(fd);
        return 0;
}
</code></pre>
<p>In this case, <code>open</code> is a function from standard library, but not the system call. The standard library will call the related system call for us. The <code>open</code> call will return a <a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a> which is just a unique number within our process which is associated with the opened file. Now as we opened a file and got file descriptor as result of <code>open</code> call, we may start to interact with this file. We can write into, read from it and etc. List of opened file by a process is available via <a href="https://en.wikipedia.org/wiki/Procfs">proc</a> filesystem: </p>
<pre><code>$ sudo ls /proc/1/fd/

0  10  12  14  16  2   21  23  25  27  29  30  32  34  36  38  4   41  43  45  47  49  50  53  55  58  6   61  63  67  8
1  11  13  15  19  20  22  24  26  28  3   31  33  35  37  39  40  42  44  46  48  5   51  54  57  59  60  62  65  7   9
</code></pre>
<p>I am not going to describe more details about the <code>open</code> routine from the userspace view in this post, but mostly from the kernel side. If you are not very familiar with, you can get more info in the <a href="http://man7.org/linux/man-pages/man2/open.2.html">man page</a>.</p>
<p>So let's start.</p>
<h2 id="definition-of-the-open-system-call"><a class="header" href="#definition-of-the-open-system-call">Definition of the open system call</a></h2>
<p>If you have read the <a href="https://github.com/0xAX/linux-insides/blob/master/SysCall/linux-syscall-4.md">fourth part</a> of the <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">linux-insides</a> book, you should know that system calls are defined with the help of <code>SYSCALL_DEFINE</code> macro. So, the <code>open</code> system call is no exception.</p>
<p>Definition of the <code>open</code> system call is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c">fs/open.c</a> source code file and looks pretty small for the first view:</p>
<pre><code class="language-C">SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
{
	if (force_o_largefile())
		flags |= O_LARGEFILE;

	return do_sys_open(AT_FDCWD, filename, flags, mode);
}
</code></pre>
<p>As you may guess, the <code>do_sys_open</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c">same</a> source code file does the main job. But before this function is called, let's consider the <code>if</code> clause from which the implementation of the <code>open</code> system call starts:</p>
<pre><code class="language-C">if (force_o_largefile())
	flags |= O_LARGEFILE;
</code></pre>
<p>Here we apply the <code>O_LARGEFILE</code> flag to the flags which were passed to <code>open</code> system call in a case when the <code>force_o_largefile()</code> will return true.
What is <code>O_LARGEFILE</code>? We may read this in the <a href="http://man7.org/linux/man-pages/man2/open.2.html">man page</a> for the <code>open(2)</code> system call:</p>
<blockquote>
<p>O_LARGEFILE</p>
<p>(LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened.</p>
</blockquote>
<p>As we may read in the <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Position-Primitive">GNU C Library Reference Manual</a>:</p>
<blockquote>
<p>off_t</p>
<p>This is a signed integer type used to represent file sizes.
In the GNU C Library, this type is no narrower than int.
If the source is compiled with _FILE_OFFSET_BITS == 64 this
type is transparently replaced by off64_t.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>off64_t</p>
<p>This type is used similar to off_t. The difference is that
even on 32 bit machines, where the off_t type would have 32 bits,
off64_t has 64 bits and so is able to address files up to 2^63 bytes
in length. When compiling with _FILE_OFFSET_BITS == 64 this type
is available under the name off_t.</p>
</blockquote>
<p>So it is not hard to guess that the <code>off_t</code>, <code>off64_t</code> and <code>O_LARGEFILE</code> are about a file size. In the case of the Linux kernel, the <code>O_LARGEFILE</code> is used  to disallow opening large files on 32bit systems if the caller didn't specify <code>O_LARGEFILE</code> flag during opening of a file. On 64bit systems we force on this flag in open system call. And the <code>force_o_largefile</code> macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/fcntl.h#L7">include/linux/fcntl.h</a> Linux kernel header file confirms this:</p>
<pre><code class="language-C">#ifndef force_o_largefile
#define force_o_largefile() (BITS_PER_LONG != 32)
#endif
</code></pre>
<p>This macro may be architecture-specific as for example for <a href="https://en.wikipedia.org/wiki/IA-64">IA-64</a> architecture, but in our case the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> does not provide definition of the <code>force_o_largefile</code> and it will be used from <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/fcntl.h#L7">include/linux/fcntl.h</a>.</p>
<p>So, as we may see the <code>force_o_largefile</code> is just a macro which expands to the <code>true</code> value in our case of <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture. As we are considering 64-bit architecture, the <code>force_o_largefile</code> will be expanded to <code>true</code> and the <code>O_LARGEFILE</code> flag will be added to the set of flags which were passed to the <code>open</code> system call.</p>
<p>Now as we considered meaning of the <code>O_LARGEFILE</code> flag and <code>force_o_largefile</code> macro, we can proceed to the consideration of the implementation of the <code>do_sys_open</code> function. As I wrote above, this function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c">same</a> source code file and looks:</p>
<pre><code class="language-C">long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
{
	struct open_flags op;
	int fd = build_open_flags(flags, mode, &amp;op);
	struct filename *tmp;

	if (fd)
		return fd;

	tmp = getname(filename);
	if (IS_ERR(tmp))
		return PTR_ERR(tmp);

	fd = get_unused_fd_flags(flags);
	if (fd &gt;= 0) {
		struct file *f = do_filp_open(dfd, tmp, &amp;op);
		if (IS_ERR(f)) {
			put_unused_fd(fd);
			fd = PTR_ERR(f);
		} else {
			fsnotify_open(f);
			fd_install(fd, f);
		}
	}
	putname(tmp);
	return fd;
}
</code></pre>
<p>Let's try to understand how the <code>do_sys_open</code> works step by step.</p>
<h2 id="open2-flags"><a class="header" href="#open2-flags">open(2) flags</a></h2>
<p>As you know the <code>open</code> system call takes set of <code>flags</code> as second argument that control opening a file and <code>mode</code> as third argument that specifies permission the permissions of a file if it is created. The <code>do_sys_open</code> function starts from the call of the <code>build_open_flags</code> function which does some checks that set of the given flags is valid and handles different conditions of flags and mode.</p>
<p>Let's look at the implementation of the <code>build_open_flags</code>. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c">same</a> kernel file and takes three arguments:</p>
<ul>
<li>flags - flags that control opening of a file;</li>
<li>mode - permissions for newly created file;</li>
</ul>
<p>The last argument - <code>op</code> is represented with the <code>open_flags</code> structure:</p>
<pre><code class="language-C">struct open_flags {
        int open_flag;
        umode_t mode;
        int acc_mode;
        int intent;
        int lookup_flags;
};
</code></pre>
<p>which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/internal.h#L99">fs/internal.h</a> header file and as we may see it holds information about flags and access mode for internal kernel purposes. As you already may guess the main goal of the <code>build_open_flags</code> function is to fill an instance of this structure.</p>
<p>Implementation of the <code>build_open_flags</code> function starts from the definition of local variables and one of them is:</p>
<pre><code class="language-C">int acc_mode = ACC_MODE(flags);
</code></pre>
<p>This local variable represents access mode and its initial value will be equal to the value of expanded <code>ACC_MODE</code> macro. This macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/fs.h">include/linux/fs.h</a> and looks pretty interesting:</p>
<pre><code class="language-C">#define ACC_MODE(x) (&quot;\004\002\006\006&quot;[(x)&amp;O_ACCMODE])
#define O_ACCMODE   00000003
</code></pre>
<p>The <code>&quot;\004\002\006\006&quot;</code> is an array of four chars:</p>
<pre><code>&quot;\004\002\006\006&quot; == {'\004', '\002', '\006', '\006'}
</code></pre>
<p>So, the <code>ACC_MODE</code> macro just expands to the accession to this array by <code>[(x) &amp; O_ACCMODE]</code> index. As we just saw, the <code>O_ACCMODE</code> is <code>00000003</code>. By applying <code>x &amp; O_ACCMODE</code> we will take the two least significant bits which are represents <code>read</code>, <code>write</code> or <code>read/write</code> access modes:</p>
<pre><code class="language-C">#define O_RDONLY        00000000
#define O_WRONLY        00000001
#define O_RDWR          00000002
</code></pre>
<p>After getting value from the array by the calculated index, the <code>ACC_MODE</code> will be expanded to access mode mask of a file which will hold <code>MAY_WRITE</code>, <code>MAY_READ</code> and other information.</p>
<p>We may see following condition after we have calculated initial access mode:</p>
<pre><code class="language-C">if (flags &amp; (O_CREAT | __O_TMPFILE))
	op-&gt;mode = (mode &amp; S_IALLUGO) | S_IFREG;
else
	op-&gt;mode = 0;
</code></pre>
<p>Here we reset permissions in <code>open_flags</code> instance if an open file wasn't temporary and wasn't open for creation. This is because:</p>
<blockquote>
<p>if  neither O_CREAT nor O_TMPFILE is specified, then mode is ignored.</p>
</blockquote>
<p>In other case if <code>O_CREAT</code> or <code>O_TMPFILE</code> were passed we canonicalize it to a regular file because a directory should be created with the <a href="http://man7.org/linux/man-pages/man3/opendir.3.html">opendir</a> system call.</p>
<p>At the next step we check that a file is not tried to be opened via <a href="http://man7.org/linux/man-pages/man7/fanotify.7.html">fanotify</a> and without the <code>O_CLOEXEC</code> flag:</p>
<pre><code class="language-C">flags &amp;= ~FMODE_NONOTIFY &amp; ~O_CLOEXEC;
</code></pre>
<p>We do this to not leak a <a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a>. By default, the new file descriptor is set to remain open across an <code>execve</code> system call, but the <code>open</code> system call supports <code>O_CLOEXEC</code> flag that can be used to change this default behaviour. So we do this to prevent leaking of a file descriptor when one thread opens a file to set <code>O_CLOEXEC</code> flag and in the same time the second process does a <a href="https://en.wikipedia.org/wiki/Fork_(system_call)">fork</a> + <a href="https://en.wikipedia.org/wiki/Exec_(system_call)">execve</a> and as you may remember that child will have copies of the parent's set of open file descriptors.</p>
<p>At the next step we check that if our flags contains <code>O_SYNC</code> flag, we apply <code>O_DSYNC</code> flag too:</p>
<pre><code>if (flags &amp; __O_SYNC)
	flags |= O_DSYNC;
</code></pre>
<p>The <code>O_SYNC</code> flag guarantees that the any write call will not return before all data has been transferred to the disk. The <code>O_DSYNC</code> is like <code>O_SYNC</code> except that there is no requirement to wait for any metadata (like <code>atime</code>, <code>mtime</code> and etc.) changes will be written. We apply <code>O_DSYNC</code> in a case of <code>__O_SYNC</code> because it is implemented as <code>__O_SYNC|O_DSYNC</code> in the Linux kernel.</p>
<p>After this we must be sure that if a user wants to create temporary file, the flags should contain <code>O_TMPFILE_MASK</code> or in other words it should contain or <code>O_CREAT</code> or <code>O_TMPFILE</code> or both and also it should be writeable:</p>
<pre><code class="language-C">if (flags &amp; __O_TMPFILE) {
	if ((flags &amp; O_TMPFILE_MASK) != O_TMPFILE)
		return -EINVAL;
	if (!(acc_mode &amp; MAY_WRITE))
		return -EINVAL;
} else if (flags &amp; O_PATH) {
       	flags &amp;= O_DIRECTORY | O_NOFOLLOW | O_PATH;
        acc_mode = 0;
}
</code></pre>
<p>as it is written in in the manual page:</p>
<blockquote>
<p>O_TMPFILE  must  be  specified  with one of O_RDWR or O_WRONLY</p>
</blockquote>
<p>If we didn't pass <code>O_TMPFILE</code> for creation of a temporary file, we check the <code>O_PATH</code> flag at the next condition. The <code>O_PATH</code> flag allows us to obtain a file descriptor that may be used for two following purposes:</p>
<ul>
<li>to indicate a location in the filesystem tree;</li>
<li>to perform operations that act purely at the file descriptor level.</li>
</ul>
<p>So, in this case the file itself is not opened, but operations like <code>dup</code>, <code>fcntl</code> and other can be used. So, if all file content related operations like <code>read</code>, <code>write</code> and other are not permitted, only <code>O_DIRECTORY | O_NOFOLLOW | O_PATH</code> flags can be used. We have finished with flags for this moment in the <code>build_open_flags</code> for this moment and we may fill our <code>open_flags-&gt;open_flag</code> with them:</p>
<pre><code class="language-C">op-&gt;open_flag = flags;
</code></pre>
<p>Now we have filled <code>open_flag</code> field which represents flags that will control opening of a file and <code>mode</code> that will represent <code>umask</code> of a new file if we open file for creation. There are still to fill last flags in our <code>open_flags</code> structure. The next is <code>op-&gt;acc_mode</code> which represents access mode to a opened file. We already filled the <code>acc_mode</code> local variable with the initial value at the beginning of the <code>build_open_flags</code> and now we check last two flags related to access mode:</p>
<pre><code class="language-C">if (flags &amp; O_TRUNC)
        acc_mode |= MAY_WRITE;
if (flags &amp; O_APPEND)
	acc_mode |= MAY_APPEND;
op-&gt;acc_mode = acc_mode;
</code></pre>
<p>These flags are - <code>O_TRUNC</code> that will truncate an opened file to length <code>0</code> if it existed before we open it and the <code>O_APPEND</code> flag allows to open a file in <code>append mode</code>. So the opened file will be appended during write but not overwritten.</p>
<p>The next field of the <code>open_flags</code> structure is - <code>intent</code>. It allows us to know about our intention or in other words what do we really want to do with file, open it, create, rename it or something else. So we set it to zero if our flags contains the <code>O_PATH</code> flag as we can't do anything related to a file content with this flag:</p>
<pre><code class="language-C">op-&gt;intent = flags &amp; O_PATH ? 0 : LOOKUP_OPEN;
</code></pre>
<p>or just to <code>LOOKUP_OPEN</code> intention. Additionally we set <code>LOOKUP_CREATE</code> intention if we want to create new file and to be sure that a file didn't exist before with <code>O_EXCL</code> flag:</p>
<pre><code class="language-C">if (flags &amp; O_CREAT) {
	op-&gt;intent |= LOOKUP_CREATE;
	if (flags &amp; O_EXCL)
		op-&gt;intent |= LOOKUP_EXCL;
}
</code></pre>
<p>The last flag of the <code>open_flags</code> structure is the <code>lookup_flags</code>:</p>
<pre><code class="language-C">if (flags &amp; O_DIRECTORY)
	lookup_flags |= LOOKUP_DIRECTORY;
if (!(flags &amp; O_NOFOLLOW))
	lookup_flags |= LOOKUP_FOLLOW;
op-&gt;lookup_flags = lookup_flags;

return 0;
</code></pre>
<p>We fill it with <code>LOOKUP_DIRECTORY</code> if we want to open a directory and <code>LOOKUP_FOLLOW</code> if we don't want to follow (open) <a href="https://en.wikipedia.org/wiki/Symbolic_link">symlink</a>. That's all. It is the end of the <code>build_open_flags</code> function. The <code>open_flags</code> structure is filled with modes and flags for a file opening and we can return back to the <code>do_sys_open</code>.</p>
<h2 id="actual-opening-of-a-file"><a class="header" href="#actual-opening-of-a-file">Actual opening of a file</a></h2>
<p>At the next step after <code>build_open_flags</code> function is finished and we have formed flags and modes for our file we should get the <code>filename</code> structure with the help of the <code>getname</code> function by name of a file which was passed to the <code>open</code> system call:</p>
<pre><code class="language-C">tmp = getname(filename);
if (IS_ERR(tmp))
	return PTR_ERR(tmp);
</code></pre>
<p>The <code>getname</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/namei.c">fs/namei.c</a> source code file and looks:</p>
<pre><code class="language-C">struct filename *
getname(const char __user * filename)
{
        return getname_flags(filename, 0, NULL);
}
</code></pre>
<p>So, it just calls the <code>getname_flags</code> function and returns its result. The main goal of the <code>getname_flags</code> function is to copy a file path given from userland to kernel space. The <code>filename</code> structure is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/fs.h">include/linux/fs.h</a> Linux kernel header file and contains following fields:</p>
<ul>
<li>name - pointer to a file path in kernel space;</li>
<li>uptr - original pointer from userland;</li>
<li>aname - filename from <a href="https://linux.die.net/man/8/auditd">audit</a> context;</li>
<li>refcnt - reference counter;</li>
<li>iname - a filename in a case when it will be less than <code>PATH_MAX</code>.</li>
</ul>
<p>As I already wrote above, the main goal of the <code>getname_flags</code> function is to copy name of a file which was passed to the <code>open</code> system call from user space to kernel space with the strncpy_from_user function. The next step after a filename will be copied to kernel space is getting of new non-busy file descriptor:</p>
<pre><code class="language-C">fd = get_unused_fd_flags(flags);
</code></pre>
<p>The <code>get_unused_fd_flags</code> function takes table of open files of the current process, minimum (<code>0</code>) and maximum (<code>RLIMIT_NOFILE</code>) possible number of a file descriptor in the system and flags that we have passed to the <code>open</code> system call and allocates file descriptor and mark it busy in the file descriptor table of the current process. The <code>get_unused_fd_flags</code> function sets or clears the <code>O_CLOEXEC</code> flag depends on its state in the passed flags.</p>
<p>The last and main step in the <code>do_sys_open</code> is the <code>do_filp_open</code> function:</p>
<pre><code class="language-C">struct file *f = do_filp_open(dfd, tmp, &amp;op);

if (IS_ERR(f)) {
	put_unused_fd(fd);
	fd = PTR_ERR(f);
} else {
	fsnotify_open(f);
	fd_install(fd, f);
}
</code></pre>
<p>The main goal of this function is to resolve given path name into <code>file</code> structure which represents an opened file of a process. If something going wrong and execution of the <code>do_filp_open</code> function will be failed, we should free new file descriptor with the <code>put_unused_fd</code> or in other way the <code>file</code> structure returned by the <code>do_filp_open</code> will be stored in the file descriptor table of the current process.</p>
<p>Now let's take a short look at the implementation of the <code>do_filp_open</code> function. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/namei.c">fs/namei.c</a> Linux kernel source code file and starts from initialization of the <code>nameidata</code> structure. This structure will provide a link to a file <a href="https://en.wikipedia.org/wiki/Inode">inode</a>. Actually this is one of the main point of the <code>do_filp_open</code> function to acquire an <code>inode</code> by the filename given to <code>open</code> system call. After the <code>nameidata</code> structure will be initialized, the <code>path_openat</code> function will be called:</p>
<pre><code class="language-C">filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU);

if (unlikely(filp == ERR_PTR(-ECHILD)))
	filp = path_openat(&amp;nd, op, flags);
if (unlikely(filp == ERR_PTR(-ESTALE)))
	filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL);
</code></pre>
<p>Note that it is called three times. Actually, the Linux kernel will open the file in <a href="https://www.kernel.org/doc/Documentation/RCU/whatisRCU.txt">RCU</a> mode. This is the most efficient way to open a file. If this try will be failed, the kernel enters the normal mode. The third call is relatively rare, only in the <a href="https://en.wikipedia.org/wiki/Network_File_System">nfs</a> file system is likely to be used. The <code>path_openat</code> function executes <code>path lookup</code> or in other words it tries to find a <code>dentry</code> (what the Linux kernel uses to keep track of the hierarchy of files in directories) corresponding to a path.</p>
<p>The <code>path_openat</code> function starts from the call of the <code>get_empty_flip()</code> function that allocates a new <code>file</code> structure with some additional checks like do we exceed amount of opened files in the system or not and etc. After we have got allocated new <code>file</code> structure we call the <code>do_tmpfile</code> or <code>do_o_path</code> functions in a case if we have passed <code>O_TMPFILE | O_CREATE</code> or <code>O_PATH</code> flags during call of the <code>open</code> system call. Both these cases are quite specific, so let's consider quite usual case when we want to open already existed file and want to read/write from/to it.</p>
<p>In this case the <code>path_init</code> function will be called. This function performs some preparatory work before actual path lookup. This includes search of start position of path traversal and its metadata like <code>inode</code> of the path, <code>dentry inode</code> and etc. This can be <code>root</code> directory - <code>/</code> or current directory as in our case, because we use <code>AT_CWD</code> as starting point (see call of the <code>do_sys_open</code> at the beginning of the post).</p>
<p>The next step after the <code>path_init</code> is the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/namei.c#L3457">loop</a> which executes the <code>link_path_walk</code> and <code>do_last</code>. The first function executes name resolution or in other words this function starts process of walking along a given path. It handles everything step by step except the last component of a file path. This handling includes checking of a permissions and getting a file component. As a file component is gotten, it is passed to <code>walk_component</code> that updates current directory entry from the <code>dcache</code> or asks underlying filesystem. This repeats before all path's components will not be handled in such way. After the <code>link_path_walk</code> will be executed, the <code>do_last</code> function will populate a <code>file</code> structure based on the result of the <code>link_path_walk</code>. As we reached last component of the given file path the <code>vfs_open</code> function from the <code>do_last</code> will be called.</p>
<p>This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c">fs/open.c</a> Linux kernel source code file and the main goal of this function is to call an <code>open</code> operation of underlying filesystem.</p>
<p>That's all for now. We didn't consider <strong>full</strong> implementation of the <code>open</code> system call. We skip some parts like handling case when we want to open a file from other filesystem with different mount point, resolving symlinks and etc., but it should be not so hard to follow this stuff. This stuff does not included in <strong>generic</strong> implementation of open system call and depends on underlying filesystem. If you are interested in, you may lookup the <code>file_operations.open</code> callback function for a certain <a href="https://github.com/torvalds/linux/tree/master/fs">filesystem</a>.</p>
<h2 id="conclusion-30"><a class="header" href="#conclusion-30">Conclusion</a></h2>
<p>This is the end of the fifth part of the implementation of different system calls in the Linux kernel. If you have questions or suggestions, ping me on twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a>, or just create an <a href="https://github.com/0xAX/linux-internals/issues/new">issue</a>. In the next part, we will continue to dive into system calls in the Linux kernel and see the implementation of the <a href="http://man7.org/linux/man-pages/man2/read.2.html">read</a> system call.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-internals">linux-insides</a>.</strong></p>
<h2 id="links-30"><a class="header" href="#links-30">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/System_call">system call</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/open.2.html">open</a></li>
<li><a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a></li>
<li><a href="https://en.wikipedia.org/wiki/Procfs">proc</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Position-Primitive">GNU C Library Reference Manual</a></li>
<li><a href="https://en.wikipedia.org/wiki/IA-64">IA-64</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/opendir.3.html">opendir</a></li>
<li><a href="http://man7.org/linux/man-pages/man7/fanotify.7.html">fanotify</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fork_(system_call)">fork</a></li>
<li><a href="https://en.wikipedia.org/wiki/Exec_(system_call)">execve</a></li>
<li><a href="https://en.wikipedia.org/wiki/Symbolic_link">symlink</a></li>
<li><a href="https://linux.die.net/man/8/auditd">audit</a></li>
<li><a href="https://en.wikipedia.org/wiki/Inode">inode</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/RCU/whatisRCU.txt">RCU</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/read.2.html">read</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-4">previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limits-on-resources-in-linux"><a class="header" href="#limits-on-resources-in-linux">Limits on resources in Linux</a></h1>
<p>Each process in the system uses certain amount of different resources like files, CPU time, memory and so on.</p>
<p>Such resources are not infinite and each process and we should have an instrument to manage it. Sometimes it is useful to know current limits for a certain resource or to change its value. In this post we will consider such instruments that allow us to get information about limits for a process and increase or decrease such limits.</p>
<p>We will start from userspace view and then we will look how it is implemented in the Linux kernel.</p>
<p>There are three main fundamental <a href="https://en.wikipedia.org/wiki/System_call">system calls</a> to manage resource limit for a process:</p>
<ul>
<li><code>getrlimit</code></li>
<li><code>setrlimit</code></li>
<li><code>prlimit</code></li>
</ul>
<p>The first two allows a process to read and set limits on a system resource. The last one is extension for previous functions. The <code>prlimit</code> allows to set and read the resource limits of a process specified by <a href="https://en.wikipedia.org/wiki/Process_identifier">PID</a>. Definitions of these functions looks:</p>
<p>The <code>getrlimit</code> is:</p>
<pre><code class="language-C">int getrlimit(int resource, struct rlimit *rlim);
</code></pre>
<p>The <code>setrlimit</code> is:</p>
<pre><code class="language-C">int setrlimit(int resource, const struct rlimit *rlim);
</code></pre>
<p>And the definition of the <code>prlimit</code> is:</p>
<pre><code class="language-C">int prlimit(pid_t pid, int resource, const struct rlimit *new_limit,
            struct rlimit *old_limit);
</code></pre>
<p>In the first two cases, functions takes two parameters:</p>
<ul>
<li><code>resource</code> - represents resource type (we will see available types later);</li>
<li><code>rlim</code> - combination of <code>soft</code> and <code>hard</code> limits.</li>
</ul>
<p>There are two types of limits:</p>
<ul>
<li><code>soft</code></li>
<li><code>hard</code></li>
</ul>
<p>The first provides actual limit for a resource of a process. The second is a ceiling value of a <code>soft</code> limit and can be set only by superuser. So, <code>soft</code> limit can never exceed related <code>hard</code> limit.</p>
<p>Both these values are combined in the <code>rlimit</code> structure:</p>
<pre><code class="language-C">struct rlimit {
    rlim_t rlim_cur;
    rlim_t rlim_max;
};
</code></pre>
<p>The last one function looks a little bit complex and takes <code>4</code> arguments. Besides <code>resource</code> argument, it takes:</p>
<ul>
<li><code>pid</code> - specifies an ID of a process on which the <code>prlimit</code> should be executed;</li>
<li><code>new_limit</code> - provides new limits values if it is not <code>NULL</code>;</li>
<li><code>old_limit</code> - current <code>soft</code> and <code>hard</code> limits will be placed here if it is not <code>NULL</code>.</li>
</ul>
<p>Exactly <code>prlimit</code> function is used by <a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-ulimit">ulimit</a> util. We can verify this with the help of <a href="https://linux.die.net/man/1/strace">strace</a> util.</p>
<p>For example:</p>
<pre><code>~$ strace ulimit -s 2&gt;&amp;1 | grep rl

prlimit64(0, RLIMIT_NPROC, NULL, {rlim_cur=63727, rlim_max=63727}) = 0
prlimit64(0, RLIMIT_NOFILE, NULL, {rlim_cur=1024, rlim_max=4*1024}) = 0
prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
</code></pre>
<p>Here we can see <code>prlimit64</code>, but not the <code>prlimit</code>. The fact is that we see underlying system call here instead of library call.</p>
<p>Now let's look at list of available resources:</p>
<table><thead><tr><th>Resource</th><th>Description</th></tr></thead><tbody>
<tr><td>RLIMIT_CPU</td><td>CPU time limit given in seconds</td></tr>
<tr><td>RLIMIT_FSIZE</td><td>the maximum size of files that a process may create</td></tr>
<tr><td>RLIMIT_DATA</td><td>the maximum  size  of  the process's data segment</td></tr>
<tr><td>RLIMIT_STACK</td><td>the maximum size of the process stack in bytes</td></tr>
<tr><td>RLIMIT_CORE</td><td>the maximum size of a <a href="http://man7.org/linux/man-pages/man5/core.5.html">core</a> file.</td></tr>
<tr><td>RLIMIT_RSS</td><td>the number of bytes that can be allocated for a process in RAM</td></tr>
<tr><td>RLIMIT_NPROC</td><td>the maximum number of processes that can be created by a user</td></tr>
<tr><td>RLIMIT_NOFILE</td><td>the maximum number of a file descriptor that can be opened by a process</td></tr>
<tr><td>RLIMIT_MEMLOCK</td><td>the maximum number of bytes of memory that may be locked into RAM by <a href="http://man7.org/linux/man-pages/man2/mlock.2.html">mlock</a>.</td></tr>
<tr><td>RLIMIT_AS</td><td>the maximum size of virtual memory in bytes.</td></tr>
<tr><td>RLIMIT_LOCKS</td><td>the maximum number <a href="https://linux.die.net/man/1/flock">flock</a> and locking related <a href="http://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl</a> calls</td></tr>
<tr><td>RLIMIT_SIGPENDING</td><td>maximum number of <a href="http://man7.org/linux/man-pages/man7/signal.7.html">signals</a> that may be queued for a user of the calling process</td></tr>
<tr><td>RLIMIT_MSGQUEUE</td><td>the number of bytes that can be allocated for <a href="http://man7.org/linux/man-pages/man7/mq_overview.7.html">POSIX message queues</a></td></tr>
<tr><td>RLIMIT_NICE</td><td>the maximum <a href="https://linux.die.net/man/1/nice">nice</a> value that can be set by a process</td></tr>
<tr><td>RLIMIT_RTPRIO</td><td>maximum real-time priority value</td></tr>
<tr><td>RLIMIT_RTTIME</td><td>maximum number of microseconds that a process may be scheduled under real-time scheduling policy without making blocking system call</td></tr>
</tbody></table>
<p>If you're looking into source code of open source projects, you will note that reading or updating of a resource limit is quite widely used operation.</p>
<p>For example: <a href="https://github.com/systemd/systemd/blob/01a45898fce8def67d51332bccc410eb1e8710e7/src/core/main.c">systemd</a></p>
<pre><code class="language-C">/* Don't limit the coredump size */
(void) setrlimit(RLIMIT_CORE, &amp;RLIMIT_MAKE_CONST(RLIM_INFINITY));
</code></pre>
<p>Or <a href="https://github.com/haproxy/haproxy/blob/25f067ccec52f53b0248a05caceb7841a3cb99df/src/haproxy.c">haproxy</a>:</p>
<pre><code class="language-C">getrlimit(RLIMIT_NOFILE, &amp;limit);
if (limit.rlim_cur &lt; global.maxsock) {
	Warning(&quot;[%s.main()] FD limit (%d) too low for maxconn=%d/maxsock=%d. Please raise 'ulimit-n' to %d or more to avoid any trouble.\n&quot;,
		argv[0], (int)limit.rlim_cur, global.maxconn, global.maxsock, global.maxsock);
}
</code></pre>
<p>We've just saw a little bit about resources limits related stuff in the userspace, now let's look at the same system calls in the Linux kernel.</p>
<h2 id="limits-on-resource-in-the-linux-kernel"><a class="header" href="#limits-on-resource-in-the-linux-kernel">Limits on resource in the Linux kernel</a></h2>
<p>Both implementation of <code>getrlimit</code> system call and <code>setrlimit</code> looks similar. Both they execute <code>do_prlimit</code> function that is core implementation of the <code>prlimit</code> system call and copy from/to given <code>rlimit</code> from/to userspace:</p>
<p>The <code>getrlimit</code>:</p>
<pre><code class="language-C">SYSCALL_DEFINE2(getrlimit, unsigned int, resource, struct rlimit __user *, rlim)
{
	struct rlimit value;
	int ret;

	ret = do_prlimit(current, resource, NULL, &amp;value);
	if (!ret)
		ret = copy_to_user(rlim, &amp;value, sizeof(*rlim)) ? -EFAULT : 0;

	return ret;
}
</code></pre>
<p>and <code>setrlimit</code>:</p>
<pre><code class="language-C">SYSCALL_DEFINE2(setrlimit, unsigned int, resource, struct rlimit __user *, rlim)
{
	struct rlimit new_rlim;

	if (copy_from_user(&amp;new_rlim, rlim, sizeof(*rlim)))
		return -EFAULT;
	return do_prlimit(current, resource, &amp;new_rlim, NULL);
}
</code></pre>
<p>Implementations of these system calls are defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/sys.c">kernel/sys.c</a> kernel source code file.</p>
<p>First of all the <code>do_prlimit</code> function executes a check that the given resource is valid:</p>
<pre><code class="language-C">if (resource &gt;= RLIM_NLIMITS)
	return -EINVAL;
</code></pre>
<p>and in a failure case returns <code>-EINVAL</code> error. After this check will pass successfully and new limits was passed as non <code>NULL</code> value, two following checks:</p>
<pre><code class="language-C">if (new_rlim) {
	if (new_rlim-&gt;rlim_cur &gt; new_rlim-&gt;rlim_max)
		return -EINVAL;
	if (resource == RLIMIT_NOFILE &amp;&amp;
			new_rlim-&gt;rlim_max &gt; sysctl_nr_open)
		return -EPERM;
}
</code></pre>
<p>check that the given <code>soft</code> limit does not exceed <code>hard</code> limit and in a case when the given resource is the maximum number of a file descriptors that hard limit is not greater than <code>sysctl_nr_open</code> value. The value of the <code>sysctl_nr_open</code> can be found via <a href="https://en.wikipedia.org/wiki/Procfs">procfs</a>:</p>
<pre><code>~$ cat /proc/sys/fs/nr_open
1048576
</code></pre>
<p>After all of these checks we lock <code>tasklist</code> to be sure that <a href="SysCall/">signal</a> handlers related things will not be destroyed while we updating limits for a given resource:</p>
<pre><code class="language-C">read_lock(&amp;tasklist_lock);
...
...
...
read_unlock(&amp;tasklist_lock);
</code></pre>
<p>We need to do this because <code>prlimit</code> system call allows us to update limits of another task by the given pid. As task list is locked, we take the <code>rlimit</code> instance that is responsible for the given resource limit of the given process:</p>
<pre><code class="language-C">rlim = tsk-&gt;signal-&gt;rlim + resource;
</code></pre>
<p>where the <code>tsk-&gt;signal-&gt;rlim</code> is just array of <code>struct rlimit</code> that represents certain resources. And if the <code>new_rlim</code> is not <code>NULL</code> we just update its value. If <code>old_rlim</code> is not <code>NULL</code> we fill it:</p>
<pre><code class="language-C">if (old_rlim)
    *old_rlim = *rlim;
</code></pre>
<p>That's all.</p>
<h2 id="conclusion-31"><a class="header" href="#conclusion-31">Conclusion</a></h2>
<p>This is the end of the second part that describes implementation of the system calls in the Linux kernel. If you have questions or suggestions, ping me on Twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a>, or just create an <a href="https://github.com/0xAX/linux-internals/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-internals">linux-insides</a>.</strong></p>
<h2 id="links-31"><a class="header" href="#links-31">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/System_call">system calls</a></li>
<li><a href="https://en.wikipedia.org/wiki/Process_identifier">PID</a></li>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-ulimit">ulimit</a></li>
<li><a href="https://linux.die.net/man/1/strace">strace</a></li>
<li><a href="http://man7.org/linux/man-pages/man7/mq_overview.7.html">POSIX message queues</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers-and-time-management"><a class="header" href="#timers-and-time-management">Timers and time management</a></h1>
<p>This chapter describes timers and time management related concepts in the Linux kernel.</p>
<ul>
<li><a href="Timers/linux-timers-1.html">Introduction</a> - An introduction to the timers in the Linux kernel.</li>
<li><a href="Timers/linux-timers-2.html">Introduction to the clocksource framework</a> - Describes <code>clocksource</code> framework in the Linux kernel.</li>
<li><a href="Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a> - Describes tick broadcast framework and dyntick concept.</li>
<li><a href="Timers/linux-timers-4.html">Introduction to timers</a> - Describes timers in the Linux kernel.</li>
<li><a href="Timers/linux-timers-5.html">Introduction to the clockevents framework</a> - Describes yet another clock/time management related framework : <code>clockevents</code>.</li>
<li><a href="Timers/linux-timers-6.html">x86 related clock sources</a> - Describes <code>x86_64</code> related clock sources.</li>
<li><a href="Timers/linux-timers-7.html">Time related system calls in the Linux kernel</a> - Describes time related system calls.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers-and-time-management-in-the-linux-kernel-part-1"><a class="header" href="#timers-and-time-management-in-the-linux-kernel-part-1">Timers and time management in the Linux kernel. Part 1.</a></h1>
<h2 id="introduction-4"><a class="header" href="#introduction-4">Introduction</a></h2>
<p>This is yet another post that opens a new chapter in the <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">linux-insides</a> book. The previous <a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-4">part</a> described <a href="https://en.wikipedia.org/wiki/System_call">system call</a> concepts, and now it's time to start new chapter. As one might understand from the title, this chapter will be devoted to the <code>timers</code> and <code>time management</code> in the Linux kernel. The choice of topic for the current chapter is not accidental. Timers (and generally, time management) are very important and widely used in the Linux kernel. The Linux kernel uses timers for various tasks, for example different timeouts in the <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a> implementation, the kernel knowing current time, scheduling asynchronous functions, next event interrupt scheduling and many many more.</p>
<p>So, we will start to learn implementation of the different time management related stuff in this part. We will see different types of timers and how different Linux kernel subsystems use them. As always, we will start from the earliest part of the Linux kernel and go through the initialization process of the Linux kernel. We already did it in the special <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">chapter</a> which describes the initialization process of the Linux kernel, but as you may remember we missed some things there. And one of them is the initialization of timers.</p>
<p>Let's start.</p>
<h2 id="initialization-of-non-standard-pc-hardware-clock"><a class="header" href="#initialization-of-non-standard-pc-hardware-clock">Initialization of non-standard PC hardware clock</a></h2>
<p>After the Linux kernel was decompressed (more about this you can read in the <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-5">Kernel decompression</a> part) the architecture non-specific code starts to work in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> source code file. After initialization of the <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a>, initialization of <a href="https://en.wikipedia.org/wiki/Cgroups">cgroups</a> and setting <a href="https://en.wikipedia.org/wiki/Buffer_overflow_protection">canary</a> value we can see the call of the <code>setup_arch</code> function.</p>
<p>As you may remember, this function (defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/setup.c#L842">arch/x86/kernel/setup.c</a>) prepares/initializes architecture-specific stuff (for example it reserves a place for <a href="https://en.wikipedia.org/wiki/.bss">bss</a> section, reserves a place for <a href="https://en.wikipedia.org/wiki/Initrd">initrd</a>, parses kernel command line, and many, many other things). Besides this, we can find some time management related functions there.</p>
<p>The first is:</p>
<pre><code class="language-C">x86_init.timers.wallclock_init();
</code></pre>
<p>We already saw <code>x86_init</code> structure in the chapter that describes initialization of the Linux kernel. This structure contains pointers to the default setup functions for the different platforms like <a href="https://en.wikipedia.org/wiki/Mobile_Internet_device#Intel_MID_platforms">Intel MID</a>, <a href="http://www.wpgholdings.com/epaper/US/newsRelease_20091215/255874.pdf">Intel CE4100</a>, etc. The <code>x86_init</code> structure is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/x86_init.c#L36">arch/x86/kernel/x86_init.c</a>, and as you can see it determines standard PC hardware by default.</p>
<p>As we can see, the <code>x86_init</code> structure has the <code>x86_init_ops</code> type that provides a set of functions for platform specific setup like reserving standard resources, platform specific memory setup, initialization of interrupt handlers, etc. This structure looks like:</p>
<pre><code class="language-C">struct x86_init_ops {
	struct x86_init_resources       resources;
    struct x86_init_mpparse         mpparse;
    struct x86_init_irqs            irqs;
    struct x86_init_oem             oem;
    struct x86_init_paging          paging;
    struct x86_init_timers          timers;
    struct x86_init_iommu           iommu;
    struct x86_init_pci             pci;
};
</code></pre>
<p>Note the <code>timers</code> field that has the <code>x86_init_timers</code> type. We can understand by its name that this field is related to time management and timers. <code>x86_init_timers</code> contains four fields which are all functions that returns pointer on <a href="https://en.wikipedia.org/wiki/Void_type">void</a>:</p>
<ul>
<li><code>setup_percpu_clockev</code> - set up the per cpu clock event device for the boot cpu;</li>
<li><code>tsc_pre_init</code> - platform function called before <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">TSC</a> init;</li>
<li><code>timer_init</code> - initialize the platform timer;</li>
<li><code>wallclock_init</code> - initialize the wallclock device.</li>
</ul>
<p>So, as we already know, in our case the <code>wallclock_init</code> executes initialization of the wallclock device. If we look on the <code>x86_init</code> structure, we see that <code>wallclock_init</code> points to the <code>x86_init_noop</code>:</p>
<pre><code class="language-C">struct x86_init_ops x86_init __initdata = {
	...
	...
	...
	.timers = {
		.wallclock_init		    = x86_init_noop,
	},
	...
	...
	...
}
</code></pre>
<p>Where the <code>x86_init_noop</code> is just a function that does nothing:</p>
<pre><code class="language-C">void __cpuinit x86_init_noop(void) { }
</code></pre>
<p>for the standard PC hardware. Actually, the <code>wallclock_init</code> function is used in the <a href="https://en.wikipedia.org/wiki/Mobile_Internet_device#Intel_MID_platforms">Intel MID</a> platform. Initialization of the <code>x86_init.timers.wallclock_init</code> is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/platform/intel-mid/intel-mid.c">arch/x86/platform/intel-mid/intel-mid.c</a> source code file in the <code>x86_intel_mid_early_setup</code> function:</p>
<pre><code class="language-C">void __init x86_intel_mid_early_setup(void)
{
	...
	...
	...
	x86_init.timers.wallclock_init = intel_mid_rtc_init;
	...
	...
	...
}
</code></pre>
<p>Implementation of the <code>intel_mid_rtc_init</code> function is in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/platform/intel-mid/intel_mid_vrtc.c">arch/x86/platform/intel-mid/intel_mid_vrtc.c</a> source code file and looks pretty simple. First of all, this function parses <a href="https://en.wikipedia.org/wiki/Simple_Firmware_Interface">Simple Firmware Interface</a> M-Real-Time-Clock table for getting such devices to the <code>sfi_mrtc_array</code> array and initialization of the <code>set_time</code> and <code>get_time</code> functions:</p>
<pre><code class="language-C">void __init intel_mid_rtc_init(void)
{
	unsigned long vrtc_paddr;

	sfi_table_parse(SFI_SIG_MRTC, NULL, NULL, sfi_parse_mrtc);

	vrtc_paddr = sfi_mrtc_array[0].phys_addr;
	if (!sfi_mrtc_num || !vrtc_paddr)
		return;

	vrtc_virt_base = (void __iomem *)set_fixmap_offset_nocache(FIX_LNW_VRTC,
								vrtc_paddr);

    x86_platform.get_wallclock = vrtc_get_time;
	x86_platform.set_wallclock = vrtc_set_mmss;
}
</code></pre>
<p>That's all, after this a device based on <code>Intel MID</code> will be able to get time from the hardware clock. As I already wrote, the standard PC <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture does not support <code>x86_init_noop</code> and just do nothing during call of this function. We just saw initialization of the <a href="https://en.wikipedia.org/wiki/Real-time_clock">real time clock</a> for the <a href="https://en.wikipedia.org/wiki/Mobile_Internet_device#Intel_MID_platforms">Intel MID</a> architecture, now it's time to return to the general <code>x86_64</code> architecture and will look on the time management related stuff there.</p>
<h2 id="acquainted-with-jiffies"><a class="header" href="#acquainted-with-jiffies">Acquainted with jiffies</a></h2>
<p>If we return to the <code>setup_arch</code> function (which is located, as you remember, in the  <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/setup.c#L842">arch/x86/kernel/setup.c</a> source code file), we see the next call of the time management related function:</p>
<pre><code class="language-C">register_refined_jiffies(CLOCK_TICK_RATE);
</code></pre>
<p>Before we look at the implementation of this function, we must know about <a href="https://en.wikipedia.org/wiki/Jiffy_%28time%29">jiffy</a>. As we can read on wikipedia:</p>
<pre><code>Jiffy is an informal term for any unspecified short period of time
</code></pre>
<p>This definition is very similar to the <code>jiffy</code> in the Linux kernel. There is global variable with the <code>jiffies</code> which holds the number of ticks that have occurred since the system booted. The Linux kernel sets this variable to zero:</p>
<pre><code class="language-C">extern unsigned long volatile __jiffy_data jiffies;
</code></pre>
<p>during initialization process. This global variable will be increased each time during timer interrupt. Besides this, near the <code>jiffies</code> variable we can see the definition of the similar variable</p>
<pre><code class="language-C">extern u64 jiffies_64;
</code></pre>
<p>Actually, only one of these variables is in use in the Linux kernel, and it depends on the processor type. For the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> it will be <code>u64</code> use and for the <a href="https://en.wikipedia.org/wiki/X86">x86</a> it's <code>unsigned long</code>. We see this looking at the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/vmlinux.lds.S">arch/x86/kernel/vmlinux.lds.S</a> linker script:</p>
<pre><code>#ifdef CONFIG_X86_32
...
jiffies = jiffies_64;
...
#else
...
jiffies_64 = jiffies;
...
#endif
</code></pre>
<p>In the case of <code>x86_32</code> the <code>jiffies</code> will be the lower <code>32</code> bits of the <code>jiffies_64</code> variable. Schematically, we can imagine it as follows</p>
<pre><code>                    jiffies_64
+-----------------------------------------------------+
|                       |                             |
|                       |                             |
|                       |       jiffies on `x86_32`   |
|                       |                             |
|                       |                             |
+-----------------------------------------------------+
63                     31                             0
</code></pre>
<p>Now we know a little theory about <code>jiffies</code> and can return to our function. There is no architecture-specific implementation for our function - the <code>register_refined_jiffies</code>. This function is located in the generic kernel code - <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/jiffies.c">kernel/time/jiffies.c</a> source code file. Main point of the <code>register_refined_jiffies</code> is registration of the jiffy <code>clocksource</code>. Before we look on the implementation of the <code>register_refined_jiffies</code> function, we must know what <code>clocksource</code> is. As we can read in the comments:</p>
<pre><code>The `clocksource` is hardware abstraction for a free-running counter.
</code></pre>
<p>I'm not sure about you, but that description didn't give a good understanding about the <code>clocksource</code> concept. Let's try to understand what is it, but we will not go deeper because this topic will be described in a separate part in much more detail. The main point of the <code>clocksource</code> is timekeeping abstraction or in very simple words - it provides a time value to the kernel. We already know about the <code>jiffies</code> interface that represents number of ticks that have occurred since the system booted. It is represented by a global variable in the Linux kernel and increases each timer interrupt. The Linux kernel can use <code>jiffies</code> for time measurement. So why do we need in separate context like the <code>clocksource</code>? Actually, different hardware devices provide different clock sources that are varied in their capabilities. The availability of more precise techniques for time intervals measurement is hardware-dependent.</p>
<p>For example <code>x86</code> has on-chip a 64-bit counter that is called <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp  Counter</a> and its frequency can be equal to processor frequency. Or for example the <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a>, that consists of a <code>64-bit</code> counter of at least <code>10 MHz</code> frequency. Two different timers and they are both for <code>x86</code>. If we will add timers from other architectures, this only makes this problem more complex. The Linux kernel provides the <code>clocksource</code> concept to solve the problem.</p>
<p>The clocksource concept is represented by the <code>clocksource</code> structure in the Linux kernel. This structure is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clocksource.h">include/linux/clocksource.h</a> header file and contains a couple of fields that describe a time counter. For example, it contains - <code>name</code> field which is the name of a counter, <code>flags</code> field that describes different properties of a counter, pointers to the <code>suspend</code> and <code>resume</code> functions, and many more.</p>
<p>Let's look at the <code>clocksource</code> structure for jiffies that is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/jiffies.c">kernel/time/jiffies.c</a> source code file:</p>
<pre><code class="language-C">static struct clocksource clocksource_jiffies = {
	.name		= &quot;jiffies&quot;,
	.rating		= 1,
	.read		= jiffies_read,
	.mask		= 0xffffffff,
	.mult		= NSEC_PER_JIFFY &lt;&lt; JIFFIES_SHIFT,
	.shift		= JIFFIES_SHIFT,
	.max_cycles	= 10,
};
</code></pre>
<p>We can see the definition of the default name here - <code>jiffies</code>. The next is the <code>rating</code> field, which allows the best registered clock source to be chosen by the clock source management code available for the specified hardware. The <code>rating</code> may have following value:</p>
<ul>
<li><code>1-99</code>    - Only available for bootup and testing purposes;</li>
<li><code>100-199</code> - Functional for real use, but not desired.</li>
<li><code>200-299</code> - A correct and usable clocksource.</li>
<li><code>300-399</code> - A reasonably fast and accurate clocksource.</li>
<li><code>400-499</code> - The ideal clocksource. A must-use where available;</li>
</ul>
<p>For example, rating of the <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">time stamp counter</a> is <code>300</code>, but rating of the <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">high precision event timer</a> is <code>250</code>. The next field is <code>read</code> - it is pointer to the function that allows it to read clocksource's cycle value; or in other words, it just returns <code>jiffies</code> variable with <code>cycle_t</code> type:</p>
<pre><code class="language-C">static cycle_t jiffies_read(struct clocksource *cs)
{
        return (cycle_t) jiffies;
}
</code></pre>
<p>that is just 64-bit unsigned type:</p>
<pre><code class="language-C">typedef u64 cycle_t;
</code></pre>
<p>The next field is the <code>mask</code> value, which ensures that subtraction between counters values from non <code>64 bit</code> counters do not need special overflow logic. In our case the mask is <code>0xffffffff</code> and it is <code>32</code> bits. This means that <code>jiffy</code> wraps around to zero after <code>42</code> seconds:</p>
<pre><code class="language-python">&gt;&gt;&gt; 0xffffffff
4294967295
# 42 nanoseconds
&gt;&gt;&gt; 42 * pow(10, -9)
4.2000000000000006e-08
# 43 nanoseconds
&gt;&gt;&gt; 43 * pow(10, -9)
4.3e-08
</code></pre>
<p>The next two fields <code>mult</code> and <code>shift</code> are used to convert the clocksource's period to nanoseconds per cycle. When the kernel calls the <code>clocksource.read</code> function, this function returns a value in <code>machine</code> time units represented with <code>cycle_t</code> data type that we saw just now. To convert this return value to <a href="https://en.wikipedia.org/wiki/Nanosecond">nanoseconds</a> we need these two fields: <code>mult</code> and <code>shift</code>. The <code>clocksource</code> provides the <code>clocksource_cyc2ns</code> function that will do it for us with the following expression:</p>
<pre><code class="language-C">((u64) cycles * mult) &gt;&gt; shift;
</code></pre>
<p>As we can see the <code>mult</code> field is equal:</p>
<pre><code class="language-C">NSEC_PER_JIFFY &lt;&lt; JIFFIES_SHIFT

#define NSEC_PER_JIFFY  ((NSEC_PER_SEC+HZ/2)/HZ)
#define NSEC_PER_SEC    1000000000L
</code></pre>
<p>by default, and the <code>shift</code> is</p>
<pre><code class="language-C">#if HZ &lt; 34
  #define JIFFIES_SHIFT   6
#elif HZ &lt; 67
  #define JIFFIES_SHIFT   7
#else
  #define JIFFIES_SHIFT   8
#endif
</code></pre>
<p>The <code>jiffies</code> clock source uses the <code>NSEC_PER_JIFFY</code> multiplier conversion to specify the nanosecond over cycle ratio. Note that values of the  <code>JIFFIES_SHIFT</code> and <code>NSEC_PER_JIFFY</code> depend on <code>HZ</code> value. The <code>HZ</code> represents the frequency of the system timer. This macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/asm-generic/param.h">include/asm-generic/param.h</a> and depends on the <code>CONFIG_HZ</code> kernel configuration option. The value of <code>HZ</code> differs for each supported architecture, but for <code>x86</code> it's defined like:</p>
<pre><code class="language-C">#define HZ		CONFIG_HZ
</code></pre>
<p>Where <code>CONFIG_HZ</code> can be one of the following values:</p>
<p><img src="Timers/images/HZ.png" alt="HZ" /></p>
<p>This means that in our case the timer interrupt frequency is <code>250 HZ</code> or occurs <code>250</code> times per second or one timer interrupt each <code>4ms</code>.</p>
<p>The last field that we can see in the definition of the <code>clocksource_jiffies</code> structure is the - <code>max_cycles</code> that holds the maximum cycle value that can safely be multiplied without potentially causing an overflow.</p>
<p>Ok, we just saw definition of the <code>clocksource_jiffies</code> structure, also we know a little about <code>jiffies</code> and <code>clocksource</code>, now it is time to get back to the implementation of the our function. In the beginning of this part we have stopped on the call of the:</p>
<pre><code class="language-C">register_refined_jiffies(CLOCK_TICK_RATE);
</code></pre>
<p>function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/setup.c#L842">arch/x86/kernel/setup.c</a> source code file.</p>
<p>As I already wrote, the main purpose of the <code>register_refined_jiffies</code> function is to register <code>refined_jiffies</code> clocksource. We already saw the <code>clocksource_jiffies</code> structure represents standard <code>jiffies</code> clock source. Now, if you look in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/jiffies.c">kernel/time/jiffies.c</a> source code file, you will find yet another clock source definition:</p>
<pre><code class="language-C">struct clocksource refined_jiffies;
</code></pre>
<p>There is one difference between <code>refined_jiffies</code> and <code>clocksource_jiffies</code>: The standard <code>jiffies</code> based clock source is the lowest common denominator clock source which should function on all systems. As we already know, the <code>jiffies</code> global variable will be increased during each timer interrupt. This means the that standard <code>jiffies</code> based clock source has the same resolution as the timer interrupt frequency. From this we can understand that standard <code>jiffies</code> based clock source may suffer from inaccuracies. The <code>refined_jiffies</code> uses <code>CLOCK_TICK_RATE</code> as the base of <code>jiffies</code> shift.</p>
<p>Let's look at the implementation of this function. First of all, we can see that the <code>refined_jiffies</code> clock source based on the <code>clocksource_jiffies</code> structure:</p>
<pre><code class="language-C">int register_refined_jiffies(long cycles_per_second)
{
	u64 nsec_per_tick, shift_hz;
	long cycles_per_tick;

	refined_jiffies = clocksource_jiffies;
	refined_jiffies.name = &quot;refined-jiffies&quot;;
	refined_jiffies.rating++;
	...
	...
	...
</code></pre>
<p>Here we can see that we update the name of the <code>refined_jiffies</code> to <code>refined-jiffies</code> and increase the rating of this structure. As you remember, the <code>clocksource_jiffies</code> has rating - <code>1</code>, so our <code>refined_jiffies</code> clocksource will have rating - <code>2</code>. This means that the <code>refined_jiffies</code> will be the best selection for clock source management code.</p>
<p>In the next step we need to calculate number of cycles per one tick:</p>
<pre><code class="language-C">cycles_per_tick = (cycles_per_second + HZ/2)/HZ;
</code></pre>
<p>Note that we have used <code>NSEC_PER_SEC</code> macro as the base of the standard <code>jiffies</code> multiplier. Here we are using the <code>cycles_per_second</code> which is the first parameter of the <code>register_refined_jiffies</code> function. We've passed the <code>CLOCK_TICK_RATE</code> macro to the <code>register_refined_jiffies</code> function. This macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/timex.h">arch/x86/include/asm/timex.h</a> header file and expands to the:</p>
<pre><code class="language-C">#define CLOCK_TICK_RATE         PIT_TICK_RATE
</code></pre>
<p>where the <code>PIT_TICK_RATE</code> macro expands to the frequency of the [Intel 8253](Programmable interval timer):</p>
<pre><code class="language-C">#define PIT_TICK_RATE 1193182ul
</code></pre>
<p>After this we calculate <code>shift_hz</code> for the <code>register_refined_jiffies</code> that will store <code>hz &lt;&lt; 8</code> or in other words frequency of the system timer. We shift left the <code>cycles_per_second</code> or frequency of the programmable interval timer on <code>8</code> in order to get extra accuracy:</p>
<pre><code class="language-C">shift_hz = (u64)cycles_per_second &lt;&lt; 8;
shift_hz += cycles_per_tick/2;
do_div(shift_hz, cycles_per_tick);
</code></pre>
<p>In the next step we calculate the number of seconds per one tick by shifting left the <code>NSEC_PER_SEC</code> on <code>8</code> too as we did it with the <code>shift_hz</code> and do the same calculation as before:</p>
<pre><code class="language-C">nsec_per_tick = (u64)NSEC_PER_SEC &lt;&lt; 8;
nsec_per_tick += (u32)shift_hz/2;
do_div(nsec_per_tick, (u32)shift_hz);
</code></pre>
<pre><code class="language-C">refined_jiffies.mult = ((u32)nsec_per_tick) &lt;&lt; JIFFIES_SHIFT;
</code></pre>
<p>In the end of the <code>register_refined_jiffies</code> function we register new clock source with the <code>__clocksource_register</code> function that is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clocksource.h">include/linux/clocksource.h</a> header file and return:</p>
<pre><code class="language-C">__clocksource_register(&amp;refined_jiffies);
return 0;
</code></pre>
<p>The clock source management code provides the API for clock source registration and selection. As we can see, clock sources are registered by calling the  <code>__clocksource_register</code> function during kernel initialization or from a kernel module. During registration, the clock source management code will choose the best clock source available in the system using the <code>clocksource.rating</code> field which we already saw when we initialized <code>clocksource</code> structure for <code>jiffies</code>.</p>
<h2 id="using-the-jiffies"><a class="header" href="#using-the-jiffies">Using the jiffies</a></h2>
<p>We just saw initialization of two <code>jiffies</code> based clock sources in the previous paragraph:</p>
<ul>
<li>standard <code>jiffies</code> based clock source;</li>
<li>refined  <code>jiffies</code> based clock source;</li>
</ul>
<p>Don't worry if you don't understand the calculations here. They look frightening at first. Soon, step by step we will learn these things. So, we just saw initialization of <code>jiffies</code> based clock sources and also we know that the Linux kernel has the global variable <code>jiffies</code> that holds the number of ticks that have occurred since the kernel started to work. Now, let's look how to use it. To use <code>jiffies</code> we just can use the <code>jiffies</code> global variable by its name or with the call of the <code>get_jiffies_64</code> function. This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/jiffies.c">kernel/time/jiffies.c</a> source code file and just returns full <code>64-bit</code> value of the <code>jiffies</code>:</p>
<pre><code class="language-C">u64 get_jiffies_64(void)
{
	unsigned long seq;
	u64 ret;

	do {
		seq = read_seqbegin(&amp;jiffies_lock);
		ret = jiffies_64;
	} while (read_seqretry(&amp;jiffies_lock, seq));
	return ret;
}
EXPORT_SYMBOL(get_jiffies_64);
</code></pre>
<p>Note that the <code>get_jiffies_64</code> function is not implemented as <code>jiffies_read</code> for example:</p>
<pre><code class="language-C">static cycle_t jiffies_read(struct clocksource *cs)
{
	return (cycle_t) jiffies;
}
</code></pre>
<p>We can see that implementation of the <code>get_jiffies_64</code> is more complex. The reading of the <code>jiffies_64</code> variable is implemented using <a href="https://en.wikipedia.org/wiki/Seqlock">seqlocks</a>. Actually this is done for machines that cannot atomically read the full 64-bit values.</p>
<p>If we can access the <code>jiffies</code> or the <code>jiffies_64</code> variable we can convert it to <code>human</code> time units. To get one second we can use following expression:</p>
<pre><code class="language-C">jiffies / HZ
</code></pre>
<p>So, if we know this, we can get any time units. For example:</p>
<pre><code class="language-C">/* Thirty seconds from now */
jiffies + 30*HZ

/* Two minutes from now */
jiffies + 120*HZ

/* One millisecond from now */
jiffies + HZ / 1000
</code></pre>
<p>That's all.</p>
<h2 id="conclusion-32"><a class="header" href="#conclusion-32">Conclusion</a></h2>
<p>This concludes the first part covering time and time management related concepts in the Linux kernel. We first met two concepts and their initialization: <code>jiffies</code> and <code>clocksource</code>. In the next part we will continue to dive into this interesting theme, and as I already wrote in this part, we will try to understand the insides of these and other time management concepts in the Linux kernel.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-32"><a class="header" href="#links-32">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/System_call">system call</a></li>
<li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cgroups">cgroups</a></li>
<li><a href="https://en.wikipedia.org/wiki/.bss">bss</a></li>
<li><a href="https://en.wikipedia.org/wiki/Initrd">initrd</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mobile_Internet_device#Intel_MID_platforms">Intel MID</a></li>
<li><a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">TSC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Void_type">void</a></li>
<li><a href="https://en.wikipedia.org/wiki/Simple_Firmware_Interface">Simple Firmware Interface</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://en.wikipedia.org/wiki/Real-time_clock">real time clock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Jiffy_%28time%29">Jiffy</a></li>
<li><a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">high precision event timer</a></li>
<li><a href="https://en.wikipedia.org/wiki/Nanosecond">nanoseconds</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8253">Intel 8253</a></li>
<li><a href="https://en.wikipedia.org/wiki/Seqlock">seqlocks</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/timers/timekeeping.txt">cloksource documentation</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syscall">Previous chapter</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers-and-time-management-in-the-linux-kernel-part-2"><a class="header" href="#timers-and-time-management-in-the-linux-kernel-part-2">Timers and time management in the Linux kernel. Part 2.</a></h1>
<h2 id="introduction-to-the-clocksource-framework"><a class="header" href="#introduction-to-the-clocksource-framework">Introduction to the <code>clocksource</code> framework</a></h2>
<p>The previous <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-1">part</a> was the first part in the current <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> that describes timers and time management related stuff in the Linux kernel. We got acquainted with two concepts in the previous part:</p>
<ul>
<li><code>jiffies</code></li>
<li><code>clocksource</code></li>
</ul>
<p>The first is the global variable that is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/jiffies.h">include/linux/jiffies.h</a> header file and represents the counter that is increased during each timer interrupt. So if we can access this global variable and we know the timer interrupt rate we can convert <code>jiffies</code> to the human time units. As we already know the timer interrupt rate represented by the compile-time constant that is called <code>HZ</code> in the Linux kernel. The value of <code>HZ</code> is equal to the value of the <code>CONFIG_HZ</code> kernel configuration option and if we will look into the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/configs/x86_64_defconfig">arch/x86/configs/x86_64_defconfig</a> kernel configuration file, we will see that:</p>
<pre><code>CONFIG_HZ_1000=y
</code></pre>
<p>kernel configuration option is set. This means that value of <code>CONFIG_HZ</code> will be <code>1000</code> by default for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture. So, if we divide the value of <code>jiffies</code> by the value of <code>HZ</code>:</p>
<pre><code>jiffies / HZ
</code></pre>
<p>we will get the amount of seconds that elapsed since the beginning of the moment the Linux kernel started to work or in other words we will get the system <a href="https://en.wikipedia.org/wiki/Uptime">uptime</a>. Since <code>HZ</code> represents the amount of timer interrupts in a second, we can set a value for some time in the future. For example:</p>
<pre><code class="language-C">/* one minute from now */
unsigned long later = jiffies + 60*HZ;

/* five minutes from now */
unsigned long later = jiffies + 5*60*HZ;
</code></pre>
<p>This is a very common practice in the Linux kernel. For example, if you will look into the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/smpboot.c">arch/x86/kernel/smpboot.c</a> source code file, you will find the <code>do_boot_cpu</code> function. This function boots all processors besides bootstrap processor. You can find a snippet that waits ten seconds for a response from the application processor:</p>
<pre><code class="language-C">if (!boot_error) {
	timeout = jiffies + 10*HZ;
	while (time_before(jiffies, timeout)) {
		...
		...
		...
		udelay(100);
	}
	...
	...
	...
}
</code></pre>
<p>We assign <code>jiffies + 10*HZ</code> value to the <code>timeout</code> variable here. As I think you already understood, this means a ten seconds timeout. After this we are entering a loop where we use the <code>time_before</code> macro to compare the current <code>jiffies</code> value and our timeout.</p>
<p>Or for example if we look into the <a href="https://github.com/torvalds/linux/blob/master/sound/isa/sscape.c">sound/isa/sscape.c</a> source code file which represents the driver for the <a href="https://en.wikipedia.org/wiki/Ensoniq_Soundscape_Elite">Ensoniq Soundscape Elite</a> sound card, we will see the <code>obp_startup_ack</code> function that waits up to a given timeout for the On-Board Processor to return its start-up acknowledgement sequence:</p>
<pre><code class="language-C">static int obp_startup_ack(struct soundscape *s, unsigned timeout)
{
	unsigned long end_time = jiffies + msecs_to_jiffies(timeout);

	do {
		...
		...
		...
		x = host_read_unsafe(s-&gt;io_base);
		...
		...
		...
		if (x == 0xfe || x == 0xff)
			return 1;
		msleep(10);
	} while (time_before(jiffies, end_time));

	return 0;
}
</code></pre>
<p>As you can see, the <code>jiffies</code> variable is very widely used in the Linux kernel <a href="http://lxr.free-electrons.com/ident?i=jiffies">code</a>. As I already wrote, we met yet another new time management related concept in the previous part - <code>clocksource</code>. We have only seen a short description of this concept and the API for a <code>clocksource</code> registration. Let's take a closer look in this part.</p>
<h2 id="introduction-to-clocksource"><a class="header" href="#introduction-to-clocksource">Introduction to <code>clocksource</code></a></h2>
<p>The <code>clocksource</code> concept represents the generic API for clock sources management in the Linux kernel. Why do we need a separate framework for this? Let's go back to the beginning. The <code>time</code> concept is the fundamental concept in the Linux kernel and other operating system kernels. And the timekeeping is one of the necessities to use this concept. For example Linux kernel must know and update the time elapsed since system startup, it must determine how long the current process has been running for every processor and many many more. Where the Linux kernel can get information about time? First of all it is Real Time Clock or <a href="https://en.wikipedia.org/wiki/Real-time_clock">RTC</a> that represents the nonvolatile device. You can find a set of architecture-independent real time clock drivers in the Linux kernel in the <a href="https://github.com/torvalds/linux/tree/master/drivers/rtc">drivers/rtc</a> directory. Besides this, each architecture can provide a driver for the architecture-dependent real time clock, for example - <code>CMOS/RTC</code> - <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/rtc.c">arch/x86/kernel/rtc.c</a> for the <a href="https://en.wikipedia.org/wiki/X86">x86</a> architecture. The second is system timer - timer that excites <a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a> with a periodic rate. For example, for <a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">IBM PC</a> compatibles it was - <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a>.</p>
<p>We already know that for timekeeping purposes we can use <code>jiffies</code> in the Linux kernel. The <code>jiffies</code> can be considered as read only global variable which is updated with <code>HZ</code> frequency. We know that the <code>HZ</code> is a compile-time kernel parameter whose reasonable range is from <code>100</code> to <code>1000</code> <a href="https://en.wikipedia.org/wiki/Hertz">Hz</a>. So, it is guaranteed to have an interface for time measurement  with <code>1</code> - <code>10</code> milliseconds resolution. Besides standard <code>jiffies</code>, we saw the <code>refined_jiffies</code> clock source in the previous part that is based on the <code>i8253/i8254</code> <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a> tick rate which is almost <code>1193182</code> hertz. So we can get something about <code>1</code> microsecond resolution with the <code>refined_jiffies</code>. In this time, <a href="https://en.wikipedia.org/wiki/Nanosecond">nanoseconds</a> are the favorite choice for the time value units of the given <code>clocksource</code>.</p>
<p>The availability of more precise techniques for time intervals measurement is hardware-dependent. We just knew a little about <code>x86</code> dependent timers hardware. But each architecture provides its own timer(s) hardware. Earlier each architecture had own implementation for this purpose. Solution of this problem is an abstraction layer and associated API in a common code framework for managing various clock sources and independent of the timer interrupt. This common code framework became - <code>clocksource</code> framework.</p>
<p>Generic timeofday and <code>clocksource</code> management framework moved a lot of timekeeping code into the architecture independent portion of the code, with the architecture-dependent portion reduced to defining and managing low-level hardware pieces of clocksources. It takes a large amount of funds to measure the time interval on different architectures with different hardware, and it is very complex. Implementation of the each clock related service is strongly associated with an individual hardware device and as you can understand, it results in similar implementations for different architectures.</p>
<p>Within this framework, each clock source is required to maintain a representation of time as a monotonically increasing value. As we can see in the Linux kernel code, nanoseconds are the favorite choice for the time value units of a clock source at this time. One of the main point of the clock source framework is to allow a user to select clock source among a range of available hardware devices supporting clock functions when configuring the system and selecting, accessing and scaling different clock sources.</p>
<h2 id="the-clocksource-structure"><a class="header" href="#the-clocksource-structure">The <code>clocksource</code> structure</a></h2>
<p>The fundamental of the <code>clocksource</code> framework is the <code>clocksource</code> structure that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clocksource.h">include/linux/clocksource.h</a> header file. We already saw some fields that are provided by the <code>clocksource</code> structure in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-1">part</a>. Let's look on the full definition of this structure and try to describe all of its fields:</p>
<pre><code class="language-C">struct clocksource {
	cycle_t (*read)(struct clocksource *cs);
	cycle_t mask;
	u32 mult;
	u32 shift;
	u64 max_idle_ns;
	u32 maxadj;
#ifdef CONFIG_ARCH_CLOCKSOURCE_DATA
	struct arch_clocksource_data archdata;
#endif
	u64 max_cycles;
	const char *name;
	struct list_head list;
	int rating;
	int (*enable)(struct clocksource *cs);
	void (*disable)(struct clocksource *cs);
	unsigned long flags;
	void (*suspend)(struct clocksource *cs);
	void (*resume)(struct clocksource *cs);
#ifdef CONFIG_CLOCKSOURCE_WATCHDOG
	struct list_head wd_list;
	cycle_t cs_last;
	cycle_t wd_last;
#endif
	struct module *owner;
} ____cacheline_aligned;
</code></pre>
<p>We already saw the first field of the <code>clocksource</code> structure in the previous part - it is a pointer to the <code>read</code> function that returns best counter selected by the clocksource framework. For example we use <code>jiffies_read</code> function to read <code>jiffies</code> value:</p>
<pre><code class="language-C">static struct clocksource clocksource_jiffies = {
	...
	.read		= jiffies_read,
	...
}
</code></pre>
<p>where <code>jiffies_read</code> just returns:</p>
<pre><code class="language-C">static cycle_t jiffies_read(struct clocksource *cs)
{
	return (cycle_t) jiffies;
}
</code></pre>
<p>Or the <code>read_tsc</code> function:</p>
<pre><code class="language-C">static struct clocksource clocksource_tsc = {
	...
    .read                   = read_tsc,
	...
};
</code></pre>
<p>for the <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">time stamp counter</a> reading.</p>
<p>The next field is <code>mask</code> that allows to ensure that subtraction between counters values from non <code>64 bit</code> counters do not need special overflow logic. After the <code>mask</code> field, we can see two fields: <code>mult</code> and <code>shift</code>. These are the fields that are base of mathematical functions that are provide ability to convert time values specific to each clock source. In other words these two fields help us to convert an abstract machine time units of a counter to nanoseconds.</p>
<p>After these two fields we can see the <code>64</code> bits <code>max_idle_ns</code> field represents max idle time permitted by the clocksource in nanoseconds. We need in this field for the Linux kernel with enabled <code>CONFIG_NO_HZ</code> kernel configuration option. This kernel configuration option enables the Linux kernel to run without a regular timer tick (we will see full explanation of this in other part). The problem that dynamic tick allows the kernel to sleep for periods longer than a single tick, moreover sleep time could be unlimited. The <code>max_idle_ns</code> field represents this sleeping limit.</p>
<p>The next field after the <code>max_idle_ns</code> is the <code>maxadj</code> field which is the maximum adjustment value to <code>mult</code>. The main formula by which we convert cycles to the nanoseconds:</p>
<pre><code class="language-C">((u64) cycles * mult) &gt;&gt; shift;
</code></pre>
<p>is not <code>100%</code> accurate. Instead the number is taken as close as possible to a nanosecond and <code>maxadj</code> helps to correct this and allows clocksource API to avoid <code>mult</code> values that might overflow when adjusted. The next four fields are pointers to the function:</p>
<ul>
<li><code>enable</code> - optional function to enable clocksource;</li>
<li><code>disable</code> - optional function to disable clocksource;</li>
<li><code>suspend</code> - suspend function for the clocksource;</li>
<li><code>resume</code> - resume function for the clocksource;</li>
</ul>
<p>The next field is the <code>max_cycles</code> and as we can understand from its name, this field represents maximum cycle value before potential overflow. And the last field is <code>owner</code> represents reference to a kernel <a href="https://en.wikipedia.org/wiki/Loadable_kernel_module">module</a> that is owner of a clocksource. This is all. We just went through all the standard fields of the <code>clocksource</code> structure. But you might have noted that we missed some fields of the <code>clocksource</code> structure. We can divide all of missed field on two types: Fields of the first type are already known for us. For example, they are <code>name</code> field that represents name of a <code>clocksource</code>, the <code>rating</code> field that helps to the Linux kernel to select the best clocksource and etc. The second type, fields which are dependent from the different Linux kernel configuration options. Let's look on these fields.</p>
<p>The first field is the <code>archdata</code>. This field has <code>arch_clocksource_data</code> type and depends on the <code>CONFIG_ARCH_CLOCKSOURCE_DATA</code> kernel configuration option. This field is actual only for the <a href="https://en.wikipedia.org/wiki/X86">x86</a> and <a href="https://en.wikipedia.org/wiki/IA-64">IA64</a> architectures for this moment. And again, as we can understand from the field's name, it represents architecture-specific data for a clock source. For example, it represents <code>vDSO</code> clock mode:</p>
<pre><code class="language-C">struct arch_clocksource_data {
    int vclock_mode;
};
</code></pre>
<p>for the <code>x86</code> architectures. Where the <code>vDSO</code> clock mode can be one of the:</p>
<pre><code class="language-C">#define VCLOCK_NONE 0
#define VCLOCK_TSC  1
#define VCLOCK_HPET 2
#define VCLOCK_PVCLOCK 3
</code></pre>
<p>The last three fields are <code>wd_list</code>, <code>cs_last</code> and the <code>wd_last</code> depends on the <code>CONFIG_CLOCKSOURCE_WATCHDOG</code> kernel configuration option. First of all let's try to understand what is <code>watchdog</code>. In a simple words, watchdog is a timer that is used for detection of the computer malfunctions and recovering from it. All of these three fields contain watchdog related data that is used by the <code>clocksource</code> framework. If we will grep the Linux kernel source code, we will see that only <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/Kconfig#L54">arch/x86/KConfig</a> kernel configuration file contains the <code>CONFIG_CLOCKSOURCE_WATCHDOG</code> kernel configuration option. So, why do <code>x86</code> and <code>x86_64</code> need in <a href="https://en.wikipedia.org/wiki/Watchdog_timer">watchdog</a>? You already may know that all <code>x86</code> processors has special 64-bit register - <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">time stamp counter</a>. This register contains number of <a href="https://en.wikipedia.org/wiki/Clock_rate">cycles</a> since the reset. Sometimes the time stamp counter needs to be verified against another clock source. We will not see initialization of the <code>watchdog</code> timer in this part, before this we must learn more about timers.</p>
<p>That's all. From this moment we know all fields of the <code>clocksource</code> structure. This knowledge will help us to learn insides of the <code>clocksource</code> framework.</p>
<h2 id="new-clocksource-registration"><a class="header" href="#new-clocksource-registration">New <code>clocksource</code> registration</a></h2>
<p>We saw only one function from the <code>clocksource</code> framework in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-1">part</a>. This function was - <code>__clocksource_register</code>. This function defined in the <a href="https://github.com/torvalds/linux/tree/master/include/linux/clocksource.h">include/linux/clocksource.h</a> header file and as we can understand from the function's name, main point of this function is to register new clocksource. If we will look on the implementation of the <code>__clocksource_register</code> function, we will see that it just makes call of the <code>__clocksource_register_scale</code> function and returns its result:</p>
<pre><code class="language-C">static inline int __clocksource_register(struct clocksource *cs)
{
	return __clocksource_register_scale(cs, 1, 0);
}
</code></pre>
<p>Before we will see implementation of the <code>__clocksource_register_scale</code> function, we can see that <code>clocksource</code> provides additional API for a new clock source registration:</p>
<pre><code class="language-C">static inline int clocksource_register_hz(struct clocksource *cs, u32 hz)
{
        return __clocksource_register_scale(cs, 1, hz);
}

static inline int clocksource_register_khz(struct clocksource *cs, u32 khz)
{
        return __clocksource_register_scale(cs, 1000, khz);
}
</code></pre>
<p>And all of these functions do the same. They return value of the <code>__clocksource_register_scale</code> function but with different set of parameters. The <code>__clocksource_register_scale</code> function defined in the <a href="https://github.com/torvalds/linux/tree/master/kernel/time/clocksource.c">kernel/time/clocksource.c</a> source code file. To understand difference between these functions, let's look on the parameters of the <code>clocksource_register_khz</code> function. As we can see, this function takes three parameters:</p>
<ul>
<li><code>cs</code> - clocksource to be installed;</li>
<li><code>scale</code> - scale factor of a clock source. In other words, if we will multiply value of this parameter on frequency, we will get <code>hz</code> of a clocksource;</li>
<li><code>freq</code> - clock source frequency divided by scale.</li>
</ul>
<p>Now let's look on the implementation of the <code>__clocksource_register_scale</code> function:</p>
<pre><code class="language-C">int __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)
{
        __clocksource_update_freq_scale(cs, scale, freq);
        mutex_lock(&amp;clocksource_mutex);
        clocksource_enqueue(cs);
        clocksource_enqueue_watchdog(cs);
        clocksource_select();
        mutex_unlock(&amp;clocksource_mutex);
        return 0;
}
</code></pre>
<p>First of all we can see that the <code>__clocksource_register_scale</code> function starts from the call of the <code>__clocksource_update_freq_scale</code> function that defined in the same source code file and updates given clock source with the new frequency. Let's look on the implementation of this function. In the first step we need to check given frequency and if it was not passed as <code>zero</code>, we need to calculate <code>mult</code> and <code>shift</code> parameters for the given clock source. Why do we need to check value of the <code>frequency</code>? Actually it can be zero. If you attentively looked on the implementation of the <code>__clocksource_register</code> function, you may have noticed that we passed <code>frequency</code> as <code>0</code>. We will do it only for some clock sources that have self defined <code>mult</code> and <code>shift</code> parameters. Look in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-1">part</a> and you will see that we saw calculation of the <code>mult</code> and <code>shift</code> for <code>jiffies</code>. The <code>__clocksource_update_freq_scale</code> function will do it for us for other clock sources.</p>
<p>So in the start of the <code>__clocksource_update_freq_scale</code> function we check the value of the <code>frequency</code> parameter and if it is not zero we need to calculate <code>mult</code> and <code>shift</code> for the given clock source. Let's look on the <code>mult</code> and <code>shift</code> calculation:</p>
<pre><code class="language-C">void __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)
{
        u64 sec;

		if (freq) {
             sec = cs-&gt;mask;
             do_div(sec, freq);
             do_div(sec, scale);

             if (!sec)
                   sec = 1;
             else if (sec &gt; 600 &amp;&amp; cs-&gt;mask &gt; UINT_MAX)
                   sec = 600;

             clocks_calc_mult_shift(&amp;cs-&gt;mult, &amp;cs-&gt;shift, freq,
                                    NSEC_PER_SEC / scale, sec * scale);
	    }
	    ...
        ...
        ...
}
</code></pre>
<p>Here we can see calculation of the maximum number of seconds which we can run before a <code>clocksource</code> counter will overflow. First of all we fill the <code>sec</code> variable with the value of a clock source mask. Remember that a clock source's mask represents maximum amount of bits that are valid for the given clock source. After this, we can see two division operations. At first we divide our <code>sec</code> variable on a <code>clocksource</code> frequency and then on scale factor. The <code>freq</code> parameter shows us how many timer interrupts will be occurred in one second. So, we divide <code>mask</code> value that represents maximum number of a counter (for example <code>jiffy</code>) on the frequency of a timer and will get the maximum number of seconds for the certain <code>clocksource</code>. The second division operation will give us maximum number of seconds for the certain <code>clocksource</code>depends on its scale factor which can be <code>1</code> hertz or <code>1</code> kilohertz (10^3 Hz).</p>
<p>After we have got maximum number of seconds, we check this value and set it to <code>1</code> or <code>600</code> depends on the result at the next step. These values is maximum sleeping time for a clocksource in seconds. In the next step we can see call of the <code>clocks_calc_mult_shift</code>. Main point of this function is calculation of the <code>mult</code> and <code>shift</code> values for a given clock source. In the end of the <code>__clocksource_update_freq_scale</code> function we check that just calculated <code>mult</code> value of a given clock source will not cause overflow after adjustment, update the <code>max_idle_ns</code> and <code>max_cycles</code> values of a given clock source with the maximum nanoseconds that can be converted to a clock source counter and print result to the kernel buffer:</p>
<pre><code class="language-C">pr_info(&quot;%s: mask: 0x%llx max_cycles: 0x%llx, max_idle_ns: %lld ns\n&quot;,
	cs-&gt;name, cs-&gt;mask, cs-&gt;max_cycles, cs-&gt;max_idle_ns);
</code></pre>
<p>that we can see in the <a href="https://en.wikipedia.org/wiki/Dmesg">dmesg</a> output:</p>
<pre><code>$ dmesg | grep &quot;clocksource:&quot;
[    0.000000] clocksource: refined-jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1910969940391419 ns
[    0.000000] clocksource: hpet: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 133484882848 ns
[    0.094084] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1911260446275000 ns
[    0.205302] clocksource: acpi_pm: mask: 0xffffff max_cycles: 0xffffff, max_idle_ns: 2085701024 ns
[    1.452979] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x7350b459580, max_idle_ns: 881591204237 ns
</code></pre>
<p>After the <code>__clocksource_update_freq_scale</code> function will finish its work, we can return back to the <code>__clocksource_register_scale</code> function that will register new clock source. We can see the call of the following three functions:</p>
<pre><code class="language-C">mutex_lock(&amp;clocksource_mutex);
clocksource_enqueue(cs);
clocksource_enqueue_watchdog(cs);
clocksource_select();
mutex_unlock(&amp;clocksource_mutex);
</code></pre>
<p>Note that before the first will be called, we lock the <code>clocksource_mutex</code> <a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a>. The point of the <code>clocksource_mutex</code> mutex is to protect <code>curr_clocksource</code> variable which represents currently selected <code>clocksource</code> and <code>clocksource_list</code> variable which represents list that contains registered <code>clocksources</code>. Now, let's look on these three functions.</p>
<p>The first <code>clocksource_enqueue</code> function and other two defined in the same source code <a href="https://github.com/torvalds/linux/tree/master/kernel/time/clocksource.c">file</a>. We go through all already registered <code>clocksources</code> or in other words we go through all elements of the <code>clocksource_list</code> and tries to find best place for a given <code>clocksource</code>:</p>
<pre><code class="language-C">/*
 * Enqueue the clocksource sorted by rating
 */
static void clocksource_enqueue(struct clocksource *cs)
{
	struct list_head *entry = &amp;clocksource_list;
	struct clocksource *tmp;

	list_for_each_entry(tmp, &amp;clocksource_list, list) {
		/* Keep track of the place, where to insert */
		if (tmp-&gt;rating &lt; cs-&gt;rating)
			break;
		entry = &amp;tmp-&gt;list;
	}
	list_add(&amp;cs-&gt;list, entry);
}
</code></pre>
<p>In the end we just insert new clocksource to the <code>clocksource_list</code>. The second function - <code>clocksource_enqueue_watchdog</code> does almost the same that previous function, but it inserts new clock source to the <code>wd_list</code> depends on flags of a clock source and starts new <a href="https://en.wikipedia.org/wiki/Watchdog_timer">watchdog</a> timer. As I already wrote, we will not consider <code>watchdog</code> related stuff in this part but will do it in next parts.</p>
<p>The last function is the <code>clocksource_select</code>. As we can understand from the function's name, main point of this function - select the best <code>clocksource</code> from registered clocksources. This function consists only from the call of the function helper:</p>
<pre><code class="language-C">static void clocksource_select(void)
{
	return __clocksource_select(false);
}
</code></pre>
<p>Note that the <code>__clocksource_select</code> function takes one parameter (<code>false</code> in our case). This <a href="https://en.wikipedia.org/wiki/Boolean_data_type">bool</a> parameter shows how to traverse the <code>clocksource_list</code>. In our case we pass <code>false</code> that is meant that we will go through all entries of the <code>clocksource_list</code>. We already know that <code>clocksource</code> with the best rating will the first in the <code>clocksource_list</code> after the call of the <code>clocksource_enqueue</code> function, so we can easily get it from this list. After we found a clock source with the best rating, we switch to it:</p>
<pre><code class="language-C">if (curr_clocksource != best &amp;&amp; !timekeeping_notify(best)) {
	pr_info(&quot;Switched to clocksource %s\n&quot;, best-&gt;name);
	curr_clocksource = best;
}
</code></pre>
<p>The result of this operation we can see in the <code>dmesg</code> output:</p>
<pre><code>$ dmesg | grep Switched
[    0.199688] clocksource: Switched to clocksource hpet
[    2.452966] clocksource: Switched to clocksource tsc
</code></pre>
<p>Note that we can see two clock sources in the <code>dmesg</code> output (<code>hpet</code> and <code>tsc</code> in our case). Yes, actually there can be many different clock sources on a particular hardware. So the Linux kernel knows about all registered clock sources and switches to a clock source with a better rating each time after registration of a new clock source.</p>
<p>If we will look on the bottom of the <a href="https://github.com/torvalds/linux/tree/master/kernel/time/clocksource.c">kernel/time/clocksource.c</a> source code file, we will see that it has <a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a> interface. Main initialization occurs in the <code>init_clocksource_sysfs</code> function which will be called during device <code>initcalls</code>. Let's look on the implementation of the <code>init_clocksource_sysfs</code> function:</p>
<pre><code class="language-C">static struct bus_type clocksource_subsys = {
	.name = &quot;clocksource&quot;,
	.dev_name = &quot;clocksource&quot;,
};

static int __init init_clocksource_sysfs(void)
{
	int error = subsys_system_register(&amp;clocksource_subsys, NULL);

	if (!error)
		error = device_register(&amp;device_clocksource);
	if (!error)
		error = device_create_file(
				&amp;device_clocksource,
				&amp;dev_attr_current_clocksource);
	if (!error)
		error = device_create_file(&amp;device_clocksource,
					   &amp;dev_attr_unbind_clocksource);
	if (!error)
		error = device_create_file(
				&amp;device_clocksource,
				&amp;dev_attr_available_clocksource);
	return error;
}
device_initcall(init_clocksource_sysfs);
</code></pre>
<p>First of all we can see that it registers a <code>clocksource</code> subsystem with the call of the <code>subsys_system_register</code> function. In other words, after the call of this function, we will have following directory:</p>
<pre><code>$ pwd
/sys/devices/system/clocksource
</code></pre>
<p>After this step, we can see registration of the <code>device_clocksource</code> device which is represented by the following structure:</p>
<pre><code class="language-C">static struct device device_clocksource = {
	.id	= 0,
	.bus	= &amp;clocksource_subsys,
};
</code></pre>
<p>and creation of three files:</p>
<ul>
<li><code>dev_attr_current_clocksource</code>;</li>
<li><code>dev_attr_unbind_clocksource</code>;</li>
<li><code>dev_attr_available_clocksource</code>.</li>
</ul>
<p>These files will provide information about current clock source in the system, available clock sources in the system and interface which allows to unbind the clock source.</p>
<p>After the <code>init_clocksource_sysfs</code> function is executed, we will be able to find some information about available clock sources in the:</p>
<pre><code>$ cat /sys/devices/system/clocksource/clocksource0/available_clocksource
tsc hpet acpi_pm
</code></pre>
<p>Or for example information about current clock source in the system:</p>
<pre><code>$ cat /sys/devices/system/clocksource/clocksource0/current_clocksource
tsc
</code></pre>
<p>In the previous part, we saw API for the registration of the <code>jiffies</code> clock source, but didn't dive into details about the <code>clocksource</code> framework. In this part we did it and saw implementation of the new clock source registration and selection of a clock source with the best rating value in the system. Of course, this is not all API that <code>clocksource</code> framework provides. There a couple additional functions like <code>clocksource_unregister</code> for removing given clock source from the <code>clocksource_list</code> and etc. But I will not describe this functions in this part, because they are not important for us right now. Anyway if you are interested in it, you can find it in the <a href="https://github.com/torvalds/linux/tree/master/kernel/time/clocksource.c">kernel/time/clocksource.c</a>.</p>
<p>That's all.</p>
<h2 id="conclusion-33"><a class="header" href="#conclusion-33">Conclusion</a></h2>
<p>This is the end of the second part of the chapter that describes timers and timer management related stuff in the Linux kernel. In the previous part got acquainted with the following two concepts: <code>jiffies</code> and <code>clocksource</code>. In this part we saw some examples of the <code>jiffies</code> usage and knew more details about the <code>clocksource</code> concept.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-33"><a class="header" href="#links-33">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/X86">x86</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://en.wikipedia.org/wiki/Uptime">uptime</a></li>
<li><a href="https://en.wikipedia.org/wiki/Ensoniq_Soundscape_Elite">Ensoniq Soundscape Elite</a></li>
<li><a href="https://en.wikipedia.org/wiki/Real-time_clock">RTC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a></li>
<li><a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">IBM PC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hertz">Hz</a></li>
<li><a href="https://en.wikipedia.org/wiki/Nanosecond">nanoseconds</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dmesg">dmesg</a></li>
<li><a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">time stamp counter</a></li>
<li><a href="https://en.wikipedia.org/wiki/Loadable_kernel_module">loadable kernel module</a></li>
<li><a href="https://en.wikipedia.org/wiki/IA-64">IA64</a></li>
<li><a href="https://en.wikipedia.org/wiki/Watchdog_timer">watchdog</a></li>
<li><a href="https://en.wikipedia.org/wiki/Clock_rate">clock rate</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-1">previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers-and-time-management-in-the-linux-kernel-part-3"><a class="header" href="#timers-and-time-management-in-the-linux-kernel-part-3">Timers and time management in the Linux kernel. Part 3.</a></h1>
<h2 id="the-tick-broadcast-framework-and-dyntick"><a class="header" href="#the-tick-broadcast-framework-and-dyntick">The tick broadcast framework and dyntick</a></h2>
<p>This is third part of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> which describes timers and time management related stuff in the Linux kernel and we stopped on the <code>clocksource</code> framework in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-2">part</a>. We have started to consider this framework because it is closely related to the special counters which are provided by the Linux kernel. One of these counters which we already saw in the first <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-1.md">part</a> of this chapter is - <code>jiffies</code>. As I already wrote in the first part of this chapter, we will consider time management related stuff step by step during the Linux kernel initialization. Previous step was call of the:</p>
<pre><code class="language-C">register_refined_jiffies(CLOCK_TICK_RATE);
</code></pre>
<p>function which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/jiffies.c">kernel/time/jiffies.c</a> source code file and executes initialization of the <code>refined_jiffies</code> clock source for us. Recall that this function is called from the <code>setup_arch</code> function that is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> source code and executes architecture-specific (<a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> in our case) initialization. Look on the implementation of the <code>setup_arch</code> and you will note that the call of the <code>register_refined_jiffies</code> is the last step before the <code>setup_arch</code> function finishes its work.</p>
<p>There are many different <code>x86_64</code> specific things already configured after the end of the <code>setup_arch</code> execution. For example some early <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a> handlers already able to handle interrupts, memory space reserved for the <a href="https://en.wikipedia.org/wiki/Initrd">initrd</a>, <a href="https://en.wikipedia.org/wiki/Desktop_Management_Interface">DMI</a> scanned, the Linux kernel log buffer is already set and this means that the <a href="https://en.wikipedia.org/wiki/Printk">printk</a> function is able to work, <a href="https://en.wikipedia.org/wiki/E820">e820</a> parsed and the Linux kernel already knows about available memory and and many many other architecture specific things (if you are interested, you can read more about the <code>setup_arch</code> function and Linux kernel initialization process in the second <a href="https://0xax.gitbook.io/linux-insides/summary/initialization">chapter</a> of this book).</p>
<p>Now, the <code>setup_arch</code> finished its work and we can go back to the generic Linux kernel code. Recall that the <code>setup_arch</code> function was called from the <code>start_kernel</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> source code file. So, we shall return to this function. You can see that there are many different functions that are called right after <code>setup_arch</code> function inside of the <code>start_kernel</code> function, but since our chapter is devoted to timers and time management related stuff, we will skip all code which is not related to this topic. The first function which is related to the time management in the Linux kernel is:</p>
<pre><code class="language-C">tick_init();
</code></pre>
<p>in the <code>start_kernel</code>. The <code>tick_init</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/tick-common.c">kernel/time/tick-common.c</a> source code file and does two things:</p>
<ul>
<li>Initialization of <code>tick broadcast</code> framework related data structures;</li>
<li>Initialization of <code>full</code> tickless mode related data structures.</li>
</ul>
<p>We didn't see anything related to the <code>tick broadcast</code> framework in this book and didn't know anything about tickless mode in the Linux kernel. So, the main point of this part is to look on these concepts and to know what they are.</p>
<h2 id="the-idle-process"><a class="header" href="#the-idle-process">The idle process</a></h2>
<p>First of all, let's look on the implementation of the <code>tick_init</code> function. As I already wrote, this function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/tick-common.c">kernel/time/tick-common.c</a> source code file and consists from the two calls of following functions:</p>
<pre><code class="language-C">void __init tick_init(void)
{
	tick_broadcast_init();
	tick_nohz_init();
}
</code></pre>
<p>As you can understand from the paragraph's title, we are interesting only in the <code>tick_broadcast_init</code> function for now. This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/tick-broadcast.c">kernel/time/tick-broadcast.c</a> source code file and executes initialization of the <code>tick broadcast</code> framework related data structures. Before we will look on the implementation of the <code>tick_broadcast_init</code> function and will try to understand what does this function do, we need to know about <code>tick broadcast</code> framework.</p>
<p>Main point of a central processor is to execute programs. But sometimes a processor may be in a special state when it is not being used by any program. This special state is called - <a href="https://en.wikipedia.org/wiki/Idle_%28CPU%29">idle</a>. When the processor has no anything to execute, the Linux kernel launches <code>idle</code> task. We already saw a little about this in the last part of the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-10">Linux kernel initialization process</a>. When the Linux kernel will finish all initialization processes in the <code>start_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> source code file, it will call the <code>rest_init</code> function from the same source code file. Main point of this function is to launch kernel <code>init</code> thread and the <code>kthreadd</code> thread, to call the <code>schedule</code> function to start task scheduling and to go to sleep by calling the <code>cpu_idle_loop</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/sched/idle.c">kernel/sched/idle.c</a> source code file.</p>
<p>The <code>cpu_idle_loop</code> function represents infinite loop which checks the need for rescheduling on each iteration. After the scheduler finds something to execute, the <code>idle</code> process will finish its work and the control will be moved to a new runnable task with the call of the <code>schedule_preempt_disabled</code> function:</p>
<pre><code class="language-C">static void cpu_idle_loop(void)
{
	while (1) {
		while (!need_resched()) {
			...
			...
			...
		    /* the main idle function */
			cpuidle_idle_call();
		}
		...
		...
		...
		schedule_preempt_disabled();
	}
}
</code></pre>
<p>Of course, we will not consider full implementation of the <code>cpu_idle_loop</code> function and details of the <code>idle</code> state in this part, because it is not related to our topic. But there is one interesting moment for us. We know that the processor can execute only one task in one time. How does the Linux kernel decide to reschedule and stop <code>idle</code> process if the processor executes infinite loop in the <code>cpu_idle_loop</code>? The answer is system timer interrupts. When an interrupt occurs, the processor stops the <code>idle</code> thread and transfers control to an interrupt handler. After the system timer interrupt handler will be handled, the <code>need_resched</code> will return true and the Linux kernel will stop <code>idle</code> process and will transfer control to the current runnable task. But handling of the system timer interrupts is not effective for <a href="https://en.wikipedia.org/wiki/Power_management">power management</a>, because if a processor is in <code>idle</code> state,  there is little point in sending it a system timer interrupt.</p>
<p>By default, there is the <code>CONFIG_HZ_PERIODIC</code> kernel configuration option which is enabled in the Linux kernel and tells to handle each interrupt of the system timer. To solve this problem, the Linux kernel provides two additional ways of managing scheduling-clock interrupts:</p>
<p>The first is to omit scheduling-clock ticks on idle processors. To enable this behaviour in the Linux kernel, we need to enable the <code>CONFIG_NO_HZ_IDLE</code> kernel configuration option. This option allows Linux kernel to avoid sending timer interrupts to idle processors. In this case periodic timer interrupts will be replaced with on-demand interrupts. This mode is called - <code>dyntick-idle</code> mode. But if the kernel does not handle interrupts of a system timer, how can the kernel decide if the system has nothing to do?</p>
<p>Whenever the idle task is selected to run, the periodic tick is disabled with the call of the <code>tick_nohz_idle_enter</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/time/tick-sched.c">kernel/time/tick-sched.c</a> source code file and enabled with the call of the <code>tick_nohz_idle_exit</code> function. There is special concept in the Linux kernel which is called - <code>clock event devices</code> that are used to schedule the next interrupt. This concept provides API for devices which can deliver interrupts at a specific time in the future and represented by the <code>clock_event_device</code> structure in the Linux kernel. We will not dive into implementation of the <code>clock_event_device</code> structure now. We will see it in the next part of this chapter. But there is one interesting moment for us right now.</p>
<p>The second way is to omit scheduling-clock ticks on processors that are either in <code>idle</code> state or that have only one runnable task or in other words busy processor. We can enable this feature with the <code>CONFIG_NO_HZ_FULL</code> kernel configuration option and it allows to reduce the number of timer interrupts significantly.</p>
<p>Besides the <code>cpu_idle_loop</code>, idle processor can be in a sleeping state. The Linux kernel provides special <code>cpuidle</code> framework. Main point of this framework is to put an idle processor to sleeping states. The name of the set of these states is - <code>C-states</code>. But how will a processor will be woken if local timer is disabled? The Linux kernel provides <code>tick broadcast</code> framework for this. The main point of this framework is assign a timer which is not affected by the <code>C-states</code>. This timer will wake a sleeping processor.</p>
<p>Now, after some theory we can return to the implementation of our function. Let's recall that the <code>tick_init</code> function just calls two following functions:</p>
<pre><code class="language-C">void __init tick_init(void)
{
	tick_broadcast_init();
	tick_nohz_init();
}
</code></pre>
<p>Let's consider the first function. The first <code>tick_broadcast_init</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/tick-broadcast.c">kernel/time/tick-broadcast.c</a> source code file and executes initialization of the <code>tick broadcast</code> framework related data structures. Let's look on the implementation of the <code>tick_broadcast_init</code> function:</p>
<pre><code class="language-C">void __init tick_broadcast_init(void)
{
        zalloc_cpumask_var(&amp;tick_broadcast_mask, GFP_NOWAIT);
        zalloc_cpumask_var(&amp;tick_broadcast_on, GFP_NOWAIT);
        zalloc_cpumask_var(&amp;tmpmask, GFP_NOWAIT);
#ifdef CONFIG_TICK_ONESHOT
         zalloc_cpumask_var(&amp;tick_broadcast_oneshot_mask, GFP_NOWAIT);
         zalloc_cpumask_var(&amp;tick_broadcast_pending_mask, GFP_NOWAIT);
         zalloc_cpumask_var(&amp;tick_broadcast_force_mask, GFP_NOWAIT);
#endif
}
</code></pre>
<p>As we can see, the <code>tick_broadcast_init</code> function allocates different <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumasks</a> with the help of the <code>zalloc_cpumask_var</code> function. The <code>zalloc_cpumask_var</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/lib/cpumask.c">lib/cpumask.c</a> source code file and expands to the call of the following function:</p>
<pre><code class="language-C">bool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
{
        return alloc_cpumask_var(mask, flags | __GFP_ZERO);
}
</code></pre>
<p>Ultimately, the memory space will be allocated for the given <code>cpumask</code> with the certain flags with the help of the <code>kmalloc_node</code> function:</p>
<pre><code class="language-C">*mask = kmalloc_node(cpumask_size(), flags, node);
</code></pre>
<p>Now let's look on the <code>cpumasks</code> that will be initialized in the <code>tick_broadcast_init</code> function. As we can see, the <code>tick_broadcast_init</code> function will initialize six <code>cpumasks</code>, and moreover, initialization of the last three <code>cpumasks</code> will depend on the <code>CONFIG_TICK_ONESHOT</code> kernel configuration option.</p>
<p>The first three <code>cpumasks</code> are:</p>
<ul>
<li><code>tick_broadcast_mask</code> - the bitmap which represents list of processors that are in a sleeping mode;</li>
<li><code>tick_broadcast_on</code> - the bitmap that stores numbers of processors which are in a periodic broadcast state;</li>
<li><code>tmpmask</code> - this bitmap for temporary usage.</li>
</ul>
<p>As we already know, the next three <code>cpumasks</code> depends on the <code>CONFIG_TICK_ONESHOT</code> kernel configuration option. Actually each clock event devices can be in one of two modes:</p>
<ul>
<li><code>periodic</code> - clock events devices that support periodic events;</li>
<li><code>oneshot</code>  - clock events devices that capable of issuing events that happen only once.</li>
</ul>
<p>The Linux kernel defines two mask for such clock events devices in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clockchips.h">include/linux/clockchips.h</a> header file:</p>
<pre><code class="language-C">#define CLOCK_EVT_FEAT_PERIODIC        0x000001
#define CLOCK_EVT_FEAT_ONESHOT         0x000002
</code></pre>
<p>So, the last three <code>cpumasks</code> are:</p>
<ul>
<li><code>tick_broadcast_oneshot_mask</code> - stores numbers of processors that must be notified;</li>
<li><code>tick_broadcast_pending_mask</code> - stores numbers of processors that pending broadcast;</li>
<li><code>tick_broadcast_force_mask</code>   - stores numbers of processors with enforced broadcast.</li>
</ul>
<p>We have initialized six <code>cpumasks</code> in the <code>tick broadcast</code> framework, and now we can proceed to implementation of this framework.</p>
<h2 id="the-tick-broadcast-framework"><a class="header" href="#the-tick-broadcast-framework">The <code>tick broadcast</code> framework</a></h2>
<p>Hardware may provide some clock source devices. When a processor sleeps and its local timer stopped, there must be additional clock source device that will handle awakening of a processor. The Linux kernel uses these <code>special</code> clock source devices which can raise an interrupt at a specified time. We already know that such timers called <code>clock events</code> devices in the Linux kernel. Besides <code>clock events</code> devices, each processor in the system has its own local timer which is programmed to issue interrupt at the time of the next deferred task. Also these timers can be programmed to do a periodical job, like updating <code>jiffies</code> and etc. These timers represented by the <code>tick_device</code> structure in the Linux kernel. This structure defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/tick-sched.h">kernel/time/tick-sched.h</a> header file and looks:</p>
<pre><code class="language-C">struct tick_device {
        struct clock_event_device *evtdev;
        enum tick_device_mode mode;
};
</code></pre>
<p>Note, that the <code>tick_device</code> structure contains two fields. The first field - <code>evtdev</code> represents pointer to the <code>clock_event_device</code> structure that is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clockchips.h">include/linux/clockchips.h</a> header file and represents descriptor of a clock event device. A <code>clock event</code> device allows to register an event that will happen in the future. As I already wrote, we will not consider <code>clock_event_device</code> structure and related API in this part, but will see it in the next part.</p>
<p>The second field of the <code>tick_device</code> structure represents mode of the <code>tick_device</code>. As we already know, the mode can be one of the:</p>
<pre><code class="language-C">enum tick_device_mode {
        TICKDEV_MODE_PERIODIC,
        TICKDEV_MODE_ONESHOT,
};
</code></pre>
<p>Each <code>clock events</code> device in the system registers itself by the call of the <code>clockevents_register_device</code> function or <code>clockevents_config_and_register</code> function during initialization process of the Linux kernel. During the registration of a new <code>clock events</code> device, the Linux kernel calls the <code>tick_check_new_device</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/time/tick-common.c">kernel/time/tick-common.c</a> source code file and checks the given <code>clock events</code> device should be used by the Linux kernel. After all checks, the <code>tick_check_new_device</code> function executes a call of the:</p>
<pre><code class="language-C">tick_install_broadcast_device(newdev);
</code></pre>
<p>function that checks that the given <code>clock event</code> device can be broadcast device and install it, if the given device can be broadcast device. Let's look on the implementation of the <code>tick_install_broadcast_device</code> function:</p>
<pre><code class="language-C">void tick_install_broadcast_device(struct clock_event_device *dev)
{
	struct clock_event_device *cur = tick_broadcast_device.evtdev;

	if (!tick_check_broadcast_device(cur, dev))
		return;

	if (!try_module_get(dev-&gt;owner))
		return;

	clockevents_exchange_device(cur, dev);

	if (cur)
		cur-&gt;event_handler = clockevents_handle_noop;

	tick_broadcast_device.evtdev = dev;

	if (!cpumask_empty(tick_broadcast_mask))
		tick_broadcast_start_periodic(dev);

	if (dev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT)
		tick_clock_notify();
}
</code></pre>
<p>First of all we get the current <code>clock event</code> device from the <code>tick_broadcast_device</code>. The <code>tick_broadcast_device</code> defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/time/tick-common.c">kernel/time/tick-common.c</a> source code file:</p>
<pre><code class="language-C">static struct tick_device tick_broadcast_device;
</code></pre>
<p>and represents external clock device that keeps track of events for a processor. The first step after we get the current clock device is the call of the <code>tick_check_broadcast_device</code> function which checks that a given clock events device can be utilized as broadcast device. The main point of the <code>tick_check_broadcast_device</code> function is to check value of the <code>features</code> field of the given <code>clock events</code> device. As we can understand from the name of this field, the <code>features</code> field contains a clock event device features. Available values defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clockchips.h">include/linux/clockchips.h</a> header file and can be one of the <code>CLOCK_EVT_FEAT_PERIODIC</code> - which represents a clock events device which supports periodic events and etc. So, the <code>tick_check_broadcast_device</code> function check <code>features</code> flags for <code>CLOCK_EVT_FEAT_ONESHOT</code>, <code>CLOCK_EVT_FEAT_DUMMY</code> and other flags and returns <code>false</code> if the given clock events device has one of these features. In other way the <code>tick_check_broadcast_device</code> function compares <code>ratings</code> of the given clock event device and current clock event device and returns the best.</p>
<p>After the <code>tick_check_broadcast_device</code> function, we can see the call of the <code>try_module_get</code> function that checks module owner of the clock events. We need to do it to be sure that the given <code>clock events</code> device was correctly initialized. The next step is the call of the <code>clockevents_exchange_device</code> function that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/clockevents.c">kernel/time/clockevents.c</a> source code file and will release old clock events device and replace the previous functional handler with a dummy handler.</p>
<p>In the last step of the <code>tick_install_broadcast_device</code> function we check that the <code>tick_broadcast_mask</code> is not empty and start the given <code>clock events</code> device in periodic mode with the call of the <code>tick_broadcast_start_periodic</code> function:</p>
<pre><code class="language-C">if (!cpumask_empty(tick_broadcast_mask))
	tick_broadcast_start_periodic(dev);

if (dev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT)
	tick_clock_notify();
</code></pre>
<p>The <code>tick_broadcast_mask</code> filled in the <code>tick_device_uses_broadcast</code> function that checks a <code>clock events</code> device during registration of this <code>clock events</code> device:</p>
<pre><code class="language-C">int cpu = smp_processor_id();

int tick_device_uses_broadcast(struct clock_event_device *dev, int cpu)
{
	...
	...
	...
	if (!tick_device_is_functional(dev)) {
		...
		cpumask_set_cpu(cpu, tick_broadcast_mask);
		...
	}
	...
	...
	...
}
</code></pre>
<p>More about the <code>smp_processor_id</code> macro you can read in the fourth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">part</a> of the Linux kernel initialization process chapter.</p>
<p>The <code>tick_broadcast_start_periodic</code> function check the given <code>clock event</code> device and call the <code>tick_setup_periodic</code> function:</p>
<pre><code>static void tick_broadcast_start_periodic(struct clock_event_device *bc)
{
	if (bc)
		tick_setup_periodic(bc, 1);
}
</code></pre>
<p>that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/tick-common.c">kernel/time/tick-common.c</a> source code file and sets broadcast handler for the given <code>clock event</code> device by the call of the following function:</p>
<pre><code class="language-C">tick_set_periodic_handler(dev, broadcast);
</code></pre>
<p>This function checks the second parameter which represents broadcast state (<code>on</code> or <code>off</code>) and sets the broadcast handler depends on its value:</p>
<pre><code class="language-C">void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)
{
	if (!broadcast)
		dev-&gt;event_handler = tick_handle_periodic;
	else
		dev-&gt;event_handler = tick_handle_periodic_broadcast;
}
</code></pre>
<p>When an <code>clock event</code> device will issue an interrupt, the <code>dev-&gt;event_handler</code> will be called. For example, let's look on the interrupt handler of the <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">high precision event timer</a> which is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/hpet.c">arch/x86/kernel/hpet.c</a> source code file:</p>
<pre><code class="language-C">static irqreturn_t hpet_interrupt_handler(int irq, void *data)
{
	struct hpet_dev *dev = (struct hpet_dev *)data;
	struct clock_event_device *hevt = &amp;dev-&gt;evt;

	if (!hevt-&gt;event_handler) {
		printk(KERN_INFO &quot;Spurious HPET timer interrupt on HPET timer %d\n&quot;,
				dev-&gt;num);
		return IRQ_HANDLED;
	}

	hevt-&gt;event_handler(hevt);
	return IRQ_HANDLED;
}
</code></pre>
<p>The <code>hpet_interrupt_handler</code> gets the <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> specific data and check the event handler of the <code>clock event</code> device. Recall that we just set in the <code>tick_set_periodic_handler</code> function. So the <code>tick_handler_periodic_broadcast</code> function will be called in the end of the high precision event timer interrupt handler.</p>
<p>The <code>tick_handler_periodic_broadcast</code> function calls the</p>
<pre><code class="language-C">bc_local = tick_do_periodic_broadcast();
</code></pre>
<p>function which stores numbers of processors which have asked to be woken up in the temporary <code>cpumask</code> and call the <code>tick_do_broadcast</code> function:</p>
<pre><code>cpumask_and(tmpmask, cpu_online_mask, tick_broadcast_mask);
return tick_do_broadcast(tmpmask);
</code></pre>
<p>The <code>tick_do_broadcast</code> calls the <code>broadcast</code> function of the given clock events which sends <a href="https://en.wikipedia.org/wiki/Inter-processor_interrupt">IPI</a> interrupt to the set of the processors. In the end we can call the event handler of the given <code>tick_device</code>:</p>
<pre><code class="language-C">if (bc_local)
	td-&gt;evtdev-&gt;event_handler(td-&gt;evtdev);
</code></pre>
<p>which actually represents interrupt handler of the local timer of a processor. After this a processor will wake up. That is all about <code>tick broadcast</code> framework in the Linux kernel. We have missed some aspects of this framework, for example reprogramming of a <code>clock event</code> device and broadcast with the oneshot timer and etc. But the Linux kernel is very big, it is not realistic to cover all aspects of it. I think it will be interesting to dive into it yourself.</p>
<p>If you remember, we have started this part with the call of the <code>tick_init</code> function. We just consider the <code>tick_broadcast_init</code> function and related theory, but the <code>tick_init</code> function contains another call of a function and this function is - <code>tick_nohz_init</code>. Let's look on the implementation of this function.</p>
<h2 id="initialization-of-dyntick-related-data-structures"><a class="header" href="#initialization-of-dyntick-related-data-structures">Initialization of dyntick related data structures</a></h2>
<p>We already saw some information about <code>dyntick</code> concept in this part and we know that this concept allows kernel to disable system timer interrupts in the <code>idle</code> state. The <code>tick_nohz_init</code> function makes initialization of the different data structures which are related to this concept. This function defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/time/tick-sched.c">kernel/time/tick-sched.c</a> source code file and starts from the check of the value of the <code>tick_nohz_full_running</code> variable which represents state of the tick-less mode for the <code>idle</code> state and the state when system timer interrupts are disabled during a processor has only one runnable task:</p>
<pre><code class="language-C">if (!tick_nohz_full_running) {
    if (tick_nohz_init_all() &lt; 0)
    return;
}
</code></pre>
<p>If this mode is not running we call the <code>tick_nohz_init_all</code> function that defined in the same source code file and check its result. The <code>tick_nohz_init_all</code> function tries to allocate the <code>tick_nohz_full_mask</code> with the call of the <code>alloc_cpumask_var</code> that will allocate space for a <code>tick_nohz_full_mask</code>. The <code>tick_nohz_full_mask</code> will store numbers of processors that have enabled full <code>NO_HZ</code>. After successful allocation of the <code>tick_nohz_full_mask</code> we set all bits in the <code>tick_nohz_full_mask</code>, set the <code>tick_nohz_full_running</code> and return result to the <code>tick_nohz_init</code> function:</p>
<pre><code class="language-C">static int tick_nohz_init_all(void)
{
        int err = -1;
#ifdef CONFIG_NO_HZ_FULL_ALL
        if (!alloc_cpumask_var(&amp;tick_nohz_full_mask, GFP_KERNEL)) {
                WARN(1, &quot;NO_HZ: Can't allocate full dynticks cpumask\n&quot;);
                return err;
        }
        err = 0;
        cpumask_setall(tick_nohz_full_mask);
        tick_nohz_full_running = true;
#endif
        return err;
}
</code></pre>
<p>In the next step we try to allocate a memory space for the <code>housekeeping_mask</code>:</p>
<pre><code class="language-C">if (!alloc_cpumask_var(&amp;housekeeping_mask, GFP_KERNEL)) {
	WARN(1, &quot;NO_HZ: Can't allocate not-full dynticks cpumask\n&quot;);
	cpumask_clear(tick_nohz_full_mask);
	tick_nohz_full_running = false;
	return;
}
</code></pre>
<p>This <code>cpumask</code> will store number of processor for <code>housekeeping</code> or in other words we need at least in one processor that will not be in <code>NO_HZ</code> mode, because it will do timekeeping and etc. After this we check the result of the architecture-specific <code>arch_irq_work_has_interrupt</code> function. This function checks ability to send inter-processor interrupt for the certain architecture. We need to check this, because system timer of a processor will be disabled during <code>NO_HZ</code> mode, so there must be at least one online processor which can send inter-processor interrupt to awake offline processor. This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/irq_work.h">arch/x86/include/asm/irq_work.h</a> header file for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> and just checks that a processor has <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a> from the <a href="https://en.wikipedia.org/wiki/CPUID">CPUID</a>:</p>
<pre><code class="language-C">static inline bool arch_irq_work_has_interrupt(void)
{
    return cpu_has_apic;
}
</code></pre>
<p>If a processor has not <code>APIC</code>, the Linux kernel prints warning message, clears the <code>tick_nohz_full_mask</code> cpumask, copies numbers of all possible processors in the system to the <code>housekeeping_mask</code> and resets the value of the <code>tick_nohz_full_running</code> variable:</p>
<pre><code class="language-C">if (!arch_irq_work_has_interrupt()) {
	pr_warning(&quot;NO_HZ: Can't run full dynticks because arch doesn't &quot;
		   &quot;support irq work self-IPIs\n&quot;);
	cpumask_clear(tick_nohz_full_mask);
	cpumask_copy(housekeeping_mask, cpu_possible_mask);
	tick_nohz_full_running = false;
	return;
}
</code></pre>
<p>After this step, we get the number of the current processor by the call of the <code>smp_processor_id</code> and check this processor in the <code>tick_nohz_full_mask</code>. If the <code>tick_nohz_full_mask</code> contains a given processor we clear appropriate bit in the <code>tick_nohz_full_mask</code>:</p>
<pre><code class="language-C">cpu = smp_processor_id();

if (cpumask_test_cpu(cpu, tick_nohz_full_mask)) {
	pr_warning(&quot;NO_HZ: Clearing %d from nohz_full range for timekeeping\n&quot;, cpu);
	cpumask_clear_cpu(cpu, tick_nohz_full_mask);
}
</code></pre>
<p>Because this processor will be used for timekeeping. After this step we put all numbers of processors that are in the <code>cpu_possible_mask</code> and not in the <code>tick_nohz_full_mask</code>:</p>
<pre><code class="language-C">cpumask_andnot(housekeeping_mask,
	       cpu_possible_mask, tick_nohz_full_mask);
</code></pre>
<p>After this operation, the <code>housekeeping_mask</code> will contain all processors of the system except a processor for timekeeping. In the last step of the <code>tick_nohz_init_all</code> function, we are going through all processors that are defined in the <code>tick_nohz_full_mask</code> and call the following function for an each processor:</p>
<pre><code class="language-C">for_each_cpu(cpu, tick_nohz_full_mask)
	context_tracking_cpu_set(cpu);
</code></pre>
<p>The <code>context_tracking_cpu_set</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/context_tracking.c">kernel/context_tracking.c</a> source code file and main point of this function is to set the <code>context_tracking.active</code> <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a> variable to <code>true</code>. When the <code>active</code> field will be set to <code>true</code> for the certain processor, all <a href="https://en.wikipedia.org/wiki/Context_switch">context switches</a> will be ignored by the Linux kernel context tracking subsystem for this processor.</p>
<p>That's all. This is the end of the <code>tick_nohz_init</code> function. After this <code>NO_HZ</code> related data structures will be initialized. We didn't see API of the <code>NO_HZ</code> mode, but will see it soon.</p>
<h2 id="conclusion-34"><a class="header" href="#conclusion-34">Conclusion</a></h2>
<p>This is the end of the third part of the chapter that describes timers and timer management related stuff in the Linux kernel. In the previous part got acquainted with the <code>clocksource</code> concept in the Linux kernel which represents framework for managing different clock source in a interrupt and hardware characteristics independent way. We continued to look on the Linux kernel initialization process in a time management context in this part and got acquainted with two new concepts for us: the <code>tick broadcast</code> framework and <code>tick-less</code> mode. The first concept helps the Linux kernel to deal with processors which are in deep sleep and the second concept represents the mode in which kernel may work to improve power management of <code>idle</code> processors.</p>
<p>In the next part we will continue to dive into timer management related things in the Linux kernel and will see new concept for us - <code>timers</code>.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-34"><a class="header" href="#links-34">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://en.wikipedia.org/wiki/Initrd">initrd</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a></li>
<li><a href="https://en.wikipedia.org/wiki/Desktop_Management_Interface">DMI</a></li>
<li><a href="https://en.wikipedia.org/wiki/Printk">printk</a></li>
<li><a href="https://en.wikipedia.org/wiki/Idle_%28CPU%29">CPU idle</a></li>
<li><a href="https://en.wikipedia.org/wiki/Power_management">power management</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/timers/NO_HZ.txt">NO_HZ documentation</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumasks</a></li>
<li><a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">high precision event timer</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a></li>
<li><a href="https://en.wikipedia.org/wiki/Inter-processor_interrupt">IPI</a></li>
<li><a href="https://en.wikipedia.org/wiki/CPUID">CPUID</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">percpu</a></li>
<li><a href="https://en.wikipedia.org/wiki/Context_switch">context switches</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-2">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers-and-time-management-in-the-linux-kernel-part-4"><a class="header" href="#timers-and-time-management-in-the-linux-kernel-part-4">Timers and time management in the Linux kernel. Part 4.</a></h1>
<h2 id="timers"><a class="header" href="#timers">Timers</a></h2>
<p>This is fourth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> which describes timers and time management related stuff in the Linux kernel and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-3">part</a> we knew about the <code>tick broadcast</code> framework and <code>NO_HZ</code> mode in the Linux kernel. We will continue to dive into the time management related stuff in the Linux kernel in this part and will be acquainted with yet another concept in the Linux kernel - <code>timers</code>. Before we will look at timers in the Linux kernel, we have to learn some theory about this concept. Note that we will consider software timers in this part.</p>
<p>The Linux kernel provides a <code>software timer</code> concept to allow to kernel functions could be invoked at future moment. Timers are widely used in the Linux kernel. For example, look in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/net/netfilter/ipset/ip_set_list_set.c">net/netfilter/ipset/ip_set_list_set.c</a> source code file. This source code file provides implementation of the framework for the managing of groups of <a href="https://en.wikipedia.org/wiki/Internet_Protocol">IP</a> addresses.</p>
<p>We can find the <code>list_set</code> structure that contains <code>gc</code> filed in this source code file:</p>
<pre><code class="language-C">struct list_set {
	...
	struct timer_list gc;
	...
};
</code></pre>
<p>Not that the <code>gc</code> filed has <code>timer_list</code> type. This structure defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/timer.h">include/linux/timer.h</a> header file and main point of this structure is to store <code>dynamic</code> timers in the Linux kernel. Actually, the Linux kernel provides two types of timers called dynamic timers and interval timers. First type of timers is used by the kernel, and the second can be used by user mode. The <code>timer_list</code> structure contains actual <code>dynamic</code> timers. The <code>list_set</code> contains <code>gc</code> timer in our example represents timer for garbage collection. This timer will be initialized in the <code>list_set_gc_init</code> function:</p>
<pre><code class="language-C">static void
list_set_gc_init(struct ip_set *set, void (*gc)(unsigned long ul_set))
{
	struct list_set *map = set-&gt;data;
	...
	...
	...
	map-&gt;gc.function = gc;
	map-&gt;gc.expires = jiffies + IPSET_GC_PERIOD(set-&gt;timeout) * HZ;
	...
	...
	...
}
</code></pre>
<p>A function that is pointed by the <code>gc</code> pointer, will be called after timeout which is equal to the <code>map-&gt;gc.expires</code>.</p>
<p>Ok, we will not dive into this example with the <a href="https://en.wikipedia.org/wiki/Netfilter">netfilter</a>, because this chapter is not about <a href="https://en.wikipedia.org/wiki/Computer_network">network</a> related stuff. But we saw that timers are widely used in the Linux kernel and learned that they represent concept which allows to functions to be called in future.</p>
<p>Now let's continue to research source code of Linux kernel which is related to the timers and time management stuff as we did it in all previous chapters.</p>
<h2 id="introduction-to-dynamic-timers-in-the-linux-kernel"><a class="header" href="#introduction-to-dynamic-timers-in-the-linux-kernel">Introduction to dynamic timers in the Linux kernel</a></h2>
<p>As I already wrote, we knew about the <code>tick broadcast</code> framework and <code>NO_HZ</code> mode in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-3">part</a>. They will be initialized in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> source code file by the call of the <code>tick_init</code> function. If we will look at this source code file, we will see that the next time management related function is:</p>
<pre><code class="language-C">init_timers();
</code></pre>
<p>This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/timer.c">kernel/time/timer.c</a> source code file and contains calls of four functions:</p>
<pre><code class="language-C">void __init init_timers(void)
{
	init_timer_cpus();
	init_timer_stats();
	timer_register_cpu_notifier();
	open_softirq(TIMER_SOFTIRQ, run_timer_softirq);
}
</code></pre>
<p>Let's look on implementation of each function. The first function is <code>init_timer_cpus</code> defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/timer.c">same</a> source code file and just calls the <code>init_timer_cpu</code> function for each possible processor in the system:</p>
<pre><code class="language-C">static void __init init_timer_cpus(void)
{
	int cpu;

	for_each_possible_cpu(cpu)
		init_timer_cpu(cpu);
}
</code></pre>
<p>If you do not know or do not remember what is it a <code>possible</code> cpu, you can read the special <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">part</a> of this book which describes <code>cpumask</code> concept in the Linux kernel. In short words, a <code>possible</code> processor is a processor which can be plugged in anytime during the life of the system.</p>
<p>The <code>init_timer_cpu</code> function does main work for us, namely it executes initialization of the <code>tvec_base</code> structure for each processor. This structure defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/timer.c">kernel/time/timer.c</a> source code file and stores data related to a <code>dynamic</code> timer for a certain processor. Let's look on the definition of this structure:</p>
<pre><code class="language-C">struct tvec_base {
	spinlock_t lock;
	struct timer_list *running_timer;
	unsigned long timer_jiffies;
	unsigned long next_timer;
	unsigned long active_timers;
	unsigned long all_timers;
	int cpu;
	bool migration_enabled;
	bool nohz_active;
	struct tvec_root tv1;
	struct tvec tv2;
	struct tvec tv3;
	struct tvec tv4;
	struct tvec tv5;
} ____cacheline_aligned;
</code></pre>
<p>The <code>thec_base</code> structure contains following fields: The <code>lock</code> for <code>tvec_base</code> protection, the next <code>running_timer</code> field points to the currently running timer for the certain processor, the <code>timer_jiffies</code> fields represents the earliest expiration time (it will be used by the Linux kernel to find already expired timers). The next field - <code>next_timer</code> contains the next pending timer for a next timer <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a> in a case when a processor goes to sleep and the <code>NO_HZ</code> mode is enabled in the Linux kernel. The <code>active_timers</code> field provides accounting of non-deferrable timers or in other words all timers that will not be stopped during a processor will go to sleep. The <code>all_timers</code> field tracks total number of timers or <code>active_timers</code> + deferrable timers. The <code>cpu</code> field represents number of a processor which owns timers. The <code>migration_enabled</code> and <code>nohz_active</code> fields are represent opportunity of timers migration to another processor and status of the <code>NO_HZ</code> mode respectively.</p>
<p>The last five fields of the <code>tvec_base</code> structure represent lists of dynamic timers. The first <code>tv1</code> field has:</p>
<pre><code class="language-C">#define TVR_SIZE (1 &lt;&lt; TVR_BITS)
#define TVR_BITS (CONFIG_BASE_SMALL ? 6 : 8)

...
...
...

struct tvec_root {
	struct hlist_head vec[TVR_SIZE];
};
</code></pre>
<p>type. Note that the value of the <code>TVR_SIZE</code> depends on the <code>CONFIG_BASE_SMALL</code> kernel configuration option:</p>
<p><img src="Timers/images/base_small.png" alt="base small" /></p>
<p>that reduces size of the kernel data structures if disabled. The <code>v1</code> is array that may contain <code>64</code> or <code>256</code> elements where an each element represents a dynamic timer that will decay within the next <code>255</code> system timer interrupts. Next three fields: <code>tv2</code>, <code>tv3</code> and <code>tv4</code> are lists with dynamic timers too, but they store dynamic timers which will decay the next <code>2^14 - 1</code>, <code>2^20 - 1</code> and <code>2^26</code> respectively. The last <code>tv5</code> field represents list which stores dynamic timers with a large expiring period.</p>
<p>So, now we saw the <code>tvec_base</code> structure and description of its fields and we can look on the implementation of the <code>init_timer_cpu</code> function. As I already wrote, this function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/timer.c">kernel/time/timer.c</a> source code file and executes initialization of the <code>tvec_bases</code>:</p>
<pre><code class="language-C">static void __init init_timer_cpu(int cpu)
{
	struct tvec_base *base = per_cpu_ptr(&amp;tvec_bases, cpu);

	base-&gt;cpu = cpu;
	spin_lock_init(&amp;base-&gt;lock);

	base-&gt;timer_jiffies = jiffies;
	base-&gt;next_timer = base-&gt;timer_jiffies;
}
</code></pre>
<p>The <code>tvec_bases</code> represents <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> variable which represents main data structure for a dynamic timer for a given processor. This <code>per-cpu</code> variable defined in the same source code file:</p>
<pre><code class="language-C">static DEFINE_PER_CPU(struct tvec_base, tvec_bases);
</code></pre>
<p>First of all we're getting the address of the <code>tvec_bases</code> for the given processor to <code>base</code> variable and as we got it, we are starting to initialize some of the <code>tvec_base</code> fields in the <code>init_timer_cpu</code> function. After initialization of the <code>per-cpu</code> dynamic timers with the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-1">jiffies</a> and the number of a possible processor, we need to initialize a <code>tstats_lookup_lock</code> <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a> in the <code>init_timer_stats</code> function:</p>
<pre><code class="language-C">void __init init_timer_stats(void)
{
	int cpu;

	for_each_possible_cpu(cpu)
		raw_spin_lock_init(&amp;per_cpu(tstats_lookup_lock, cpu));
}
</code></pre>
<p>The <code>tstats_lookcup_lock</code> variable represents <code>per-cpu</code> raw spinlock:</p>
<pre><code class="language-C">static DEFINE_PER_CPU(raw_spinlock_t, tstats_lookup_lock);
</code></pre>
<p>which will be used for protection of operation with statistics of timers that can be accessed through the <a href="https://en.wikipedia.org/wiki/Procfs">procfs</a>:</p>
<pre><code class="language-C">static int __init init_tstats_procfs(void)
{
	struct proc_dir_entry *pe;

	pe = proc_create(&quot;timer_stats&quot;, 0644, NULL, &amp;tstats_fops);
	if (!pe)
		return -ENOMEM;
	return 0;
}
</code></pre>
<p>For example:</p>
<pre><code>$ cat /proc/timer_stats
Timerstats sample period: 3.888770 s
  12,     0 swapper          hrtimer_stop_sched_tick (hrtimer_sched_tick)
  15,     1 swapper          hcd_submit_urb (rh_timer_func)
   4,   959 kedac            schedule_timeout (process_timeout)
   1,     0 swapper          page_writeback_init (wb_timer_fn)
  28,     0 swapper          hrtimer_stop_sched_tick (hrtimer_sched_tick)
  22,  2948 IRQ 4            tty_flip_buffer_push (delayed_work_timer_fn)
  ...
  ...
  ...
</code></pre>
<p>The next step after initialization of the <code>tstats_lookup_lock</code> spinlock is the call of the <code>timer_register_cpu_notifier</code> function. This function depends on the <code>CONFIG_HOTPLUG_CPU</code> kernel configuration option which enables support for <a href="https://en.wikipedia.org/wiki/Hot_swapping">hotplug</a> processors in the Linux kernel.</p>
<p>When a processor will be logically offlined, a notification will be sent to the Linux kernel with the <code>CPU_DEAD</code> or the <code>CPU_DEAD_FROZEN</code> event by the call of the <code>cpu_notifier</code> macro:</p>
<pre><code class="language-C">#ifdef CONFIG_HOTPLUG_CPU
...
...
static inline void timer_register_cpu_notifier(void)
{
	cpu_notifier(timer_cpu_notify, 0);
}
...
...
#else
...
...
static inline void timer_register_cpu_notifier(void) { }
...
...
#endif /* CONFIG_HOTPLUG_CPU */
</code></pre>
<p>In this case the <code>timer_cpu_notify</code> will be called which checks an event type and will call the <code>migrate_timers</code> function:</p>
<pre><code class="language-C">static int timer_cpu_notify(struct notifier_block *self,
	                        unsigned long action, void *hcpu)
{
	switch (action) {
	case CPU_DEAD:
	case CPU_DEAD_FROZEN:
		migrate_timers((long)hcpu);
		break;
	default:
		break;
	}

	return NOTIFY_OK;
}
</code></pre>
<p>This chapter will not describe <code>hotplug</code> related events in the Linux kernel source code, but if you are interesting in such things, you can find implementation of the <code>migrate_timers</code> function in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/timer.c">kernel/time/timer.c</a> source code file.</p>
<p>The last step in the <code>init_timers</code> function is the call of the:</p>
<pre><code class="language-C">open_softirq(TIMER_SOFTIRQ, run_timer_softirq);
</code></pre>
<p>function. The <code>open_softirq</code> function may be already familiar to you if you have read the ninth <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-9">part</a> about the interrupts and interrupt handling in the Linux kernel. In short words, the <code>open_softirq</code> function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/softirq.c">kernel/softirq.c</a> source code file and executes initialization of the deferred interrupt handler.</p>
<p>In our case the deferred function is the <code>run_timer_softirq</code> function that is will be called after a hardware interrupt in the <code>do_IRQ</code> function which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/irq.c">arch/x86/kernel/irq.c</a> source code file. The main point of this function is to handle a software dynamic timer. The Linux kernel does not do this thing during the hardware timer interrupt handling because this is time consuming operation.</p>
<p>Let's look on the implementation of the <code>run_timer_softirq</code> function:</p>
<pre><code class="language-C">static void run_timer_softirq(struct softirq_action *h)
{
	struct tvec_base *base = this_cpu_ptr(&amp;tvec_bases);

	if (time_after_eq(jiffies, base-&gt;timer_jiffies))
		__run_timers(base);
}
</code></pre>
<p>At the beginning of the <code>run_timer_softirq</code> function we get a <code>dynamic</code> timer for a current processor and compares the current value of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-1">jiffies</a> with the value of the <code>timer_jiffies</code> for the current structure by the call of the <code>time_after_eq</code> macro which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/jiffies.h">include/linux/jiffies.h</a> header file:</p>
<pre><code class="language-C">#define time_after_eq(a,b)          \
    (typecheck(unsigned long, a) &amp;&amp; \
     typecheck(unsigned long, b) &amp;&amp; \
    ((long)((a) - (b)) &gt;= 0))
</code></pre>
<p>Reclaim that the <code>timer_jiffies</code> field of the <code>tvec_base</code> structure represents the relative time when functions delayed by the given timer will be executed. So we compare these two values and if the current time represented by the <code>jiffies</code> is greater than <code>base-&gt;timer_jiffies</code>, we call the <code>__run_timers</code> function that defined in the same source code file. Let's look on the implementation of this function.</p>
<p>As I just wrote, the <code>__run_timers</code> function runs all expired timers for a given processor. This function starts from the acquiring of the <code>tvec_base's</code>  lock to protect the <code>tvec_base</code> structure</p>
<pre><code class="language-C">static inline void __run_timers(struct tvec_base *base)
{
	struct timer_list *timer;

	spin_lock_irq(&amp;base-&gt;lock);
	...
	...
	...
	spin_unlock_irq(&amp;base-&gt;lock);
}
</code></pre>
<p>After this it starts the loop while the <code>timer_jiffies</code> will not be greater than the <code>jiffies</code>:</p>
<pre><code class="language-C">while (time_after_eq(jiffies, base-&gt;timer_jiffies)) {
	...
	...
	...
}
</code></pre>
<p>We can find many different manipulations in the our loop, but the main point is to find expired timers and call delayed functions. First of all we need to calculate the <code>index</code> of the <code>base-&gt;tv1</code> list that stores the next timer to be handled with the following expression:</p>
<pre><code class="language-C">index = base-&gt;timer_jiffies &amp; TVR_MASK;
</code></pre>
<p>where the <code>TVR_MASK</code> is a mask for the getting of the <code>tvec_root-&gt;vec</code> elements. As we got the index with the next timer which must be handled we check its value. If the index is zero, we go through all lists in our cascade table <code>tv2</code>, <code>tv3</code> and etc., and rehashing it with the call of the <code>cascade</code> function:</p>
<pre><code class="language-C">if (!index &amp;&amp;
	(!cascade(base, &amp;base-&gt;tv2, INDEX(0))) &amp;&amp;
		(!cascade(base, &amp;base-&gt;tv3, INDEX(1))) &amp;&amp;
				!cascade(base, &amp;base-&gt;tv4, INDEX(2)))
		cascade(base, &amp;base-&gt;tv5, INDEX(3));
</code></pre>
<p>After this we increase the value of the <code>base-&gt;timer_jiffies</code>:</p>
<pre><code class="language-C">++base-&gt;timer_jiffies;
</code></pre>
<p>In the last step we are executing a corresponding function for each timer from the list in a following loop:</p>
<pre><code class="language-C">hlist_move_list(base-&gt;tv1.vec + index, head);

while (!hlist_empty(head)) {
	...
	...
	...
	timer = hlist_entry(head-&gt;first, struct timer_list, entry);
	fn = timer-&gt;function;
	data = timer-&gt;data;

	spin_unlock(&amp;base-&gt;lock);
	call_timer_fn(timer, fn, data);
	spin_lock(&amp;base-&gt;lock);

	...
	...
	...
}
</code></pre>
<p>where the <code>call_timer_fn</code> just call the given function:</p>
<pre><code class="language-C">static void call_timer_fn(struct timer_list *timer, void (*fn)(unsigned long),
	                      unsigned long data)
{
	...
	...
	...
	fn(data);
	...
	...
	...
}
</code></pre>
<p>That's all. The Linux kernel has infrastructure for <code>dynamic timers</code> from this moment. We will not dive into this interesting theme. As I already wrote the <code>timers</code> is a <a href="http://lxr.free-electrons.com/ident?i=timer_list">widely</a> used concept in the Linux kernel and nor one part, nor two parts will not cover understanding of such things how it implemented and how it works. But now we know about this concept, why does the Linux kernel needs in it and some data structures around it.</p>
<p>Now let's look usage of <code>dynamic timers</code> in the Linux kernel.</p>
<h2 id="usage-of-dynamic-timers"><a class="header" href="#usage-of-dynamic-timers">Usage of dynamic timers</a></h2>
<p>As you already can noted, if the Linux kernel provides a concept, it also provides API for managing of this concept and the <code>dynamic timers</code> concept is not exception here. To use a timer in the Linux kernel code, we must define a variable with a <code>timer_list</code> type. We can initialize our <code>timer_list</code> structure in two ways. The first is to use the <code>init_timer</code> macro that defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/timer.h">include/linux/timer.h</a> header file:</p>
<pre><code class="language-C">#define init_timer(timer)    \
	__init_timer((timer), 0)

#define __init_timer(_timer, _flags)   \
         init_timer_key((_timer), (_flags), NULL, NULL)
</code></pre>
<p>where the <code>init_timer_key</code> function just calls the:</p>
<pre><code class="language-C">do_init_timer(timer, flags, name, key);
</code></pre>
<p>function which fields the given <code>timer</code> with default values. The second way is to use the:</p>
<pre><code class="language-C">#define TIMER_INITIALIZER(_function, _expires, _data)		\
	__TIMER_INITIALIZER((_function), (_expires), (_data), 0)
</code></pre>
<p>macro which will initialize the given <code>timer_list</code> structure too.</p>
<p>After a <code>dynamic timer</code> is initialized we can start this <code>timer</code> with the call of the:</p>
<pre><code class="language-C">void add_timer(struct timer_list * timer);
</code></pre>
<p>function and stop it with the:</p>
<pre><code class="language-C">int del_timer(struct timer_list * timer);
</code></pre>
<p>function.</p>
<p>That's all.</p>
<h2 id="conclusion-35"><a class="header" href="#conclusion-35">Conclusion</a></h2>
<p>This is the end of the fourth part of the chapter that describes timers and timer management related stuff in the Linux kernel. In the previous part we got acquainted with the two new concepts: the <code>tick broadcast</code> framework and the <code>NO_HZ</code> mode. In this part we continued to dive into time management related stuff and got acquainted with the new concept - <code>dynamic timer</code> or software timer. We didn't saw implementation of a <code>dynamic timers</code> management code in details in this part but saw data structures and API around this concept.</p>
<p>In the next part we will continue to dive into timer management related things in the Linux kernel and will see new concept for us - <code>timers</code>.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-35"><a class="header" href="#links-35">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Internet_Protocol">IP</a></li>
<li><a href="https://en.wikipedia.org/wiki/Netfilter">netfilter</a></li>
<li><a href="https://en.wikipedia.org/wiki/Computer_network">network</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumask</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-1">jiffies</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a></li>
<li><a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Procfs">procfs</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-3">previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers-and-time-management-in-the-linux-kernel-part-5"><a class="header" href="#timers-and-time-management-in-the-linux-kernel-part-5">Timers and time management in the Linux kernel. Part 5.</a></h1>
<h2 id="introduction-to-the-clockevents-framework"><a class="header" href="#introduction-to-the-clockevents-framework">Introduction to the <code>clockevents</code> framework</a></h2>
<p>This is fifth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> which describes timers and time management related stuff in the Linux kernel. As you might noted from the title of this part, the <code>clockevents</code> framework will be discussed. We already saw one framework in the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-2">second</a> part of this chapter. It was <code>clocksource</code> framework. Both of these frameworks represent timekeeping abstractions in the Linux kernel.</p>
<p>At first let's refresh your memory and try to remember what is it <code>clocksource</code> framework and and what its purpose. The main goal of the <code>clocksource</code> framework is to provide <code>timeline</code>. As described in the <a href="https://github.com/0xAX/linux/blob/0a07b238e5f488b459b6113a62e06b6aab017f71/Documentation/timers/timekeeping.txt">documentation</a>:</p>
<blockquote>
<p>For example issuing the command 'date' on a Linux system will eventually read the clock source to determine exactly what time it is.</p>
</blockquote>
<p>The Linux kernel supports many different clock sources. You can find some of them in the <a href="https://github.com/torvalds/linux/tree/master/drivers/clocksource">drivers/clocksource</a>. For example old good <a href="https://en.wikipedia.org/wiki/Intel_8253">Intel 8253</a> - <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a> with <code>1193182</code> Hz frequency, yet another one - <a href="http://uefi.org/sites/default/files/resources/ACPI_5.pdf">ACPI PM</a> timer with <code>3579545</code> Hz frequency. Besides the <a href="https://github.com/torvalds/linux/tree/master/drivers/clocksource">drivers/clocksource</a> directory, each architecture may provide own architecture-specific clock sources. For example <a href="https://en.wikipedia.org/wiki/X86">x86</a> architecture provides <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a>, or for example <a href="https://en.wikipedia.org/wiki/PowerPC">powerpc</a> provides access to the processor timer through <code>timebase</code> register.</p>
<p>Each clock source provides monotonic atomic counter. As I already wrote, the Linux kernel supports a huge set of different clock source and each clock source has own parameters like <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>. The main goal of the <code>clocksource</code> framework is to provide <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> to select best available clock source in the system i.e. a clock source with the highest frequency. Additional goal of the <code>clocksource</code> framework is to represent an atomic counter provided by a clock source in human units. In this time, nanoseconds are the favorite choice for the time value units of the given clock source in the Linux kernel.</p>
<p>The <code>clocksource</code> framework represented by the <code>clocksource</code> structure which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clocksource.h">include/linux/clocksource.h</a> header code file which contains <code>name</code> of a clock source, rating of certain clock source in the system (a clock source with the higher frequency has the biggest rating in the system), <code>list</code> of all registered clock source in the system, <code>enable</code> and <code>disable</code> fields to enable and disable a clock source, pointer to the <code>read</code> function which must return an atomic counter of a clock source and etc.</p>
<p>Additionally the <code>clocksource</code> structure provides two fields: <code>mult</code> and <code>shift</code> which are needed for translation of an atomic counter which is provided by a certain clock source to the human units, i.e. <a href="https://en.wikipedia.org/wiki/Nanosecond">nanoseconds</a>. Translation occurs via following formula:</p>
<pre><code>ns ~= (clocksource * mult) &gt;&gt; shift
</code></pre>
<p>As we already know, besides the <code>clocksource</code> structure, the <code>clocksource</code> framework provides an API for registration of clock source with different frequency scale factor:</p>
<pre><code class="language-C">static inline int clocksource_register_hz(struct clocksource *cs, u32 hz)
static inline int clocksource_register_khz(struct clocksource *cs, u32 khz)
</code></pre>
<p>A clock source unregistration:</p>
<pre><code class="language-C">int clocksource_unregister(struct clocksource *cs)
</code></pre>
<p>and etc.</p>
<p>Additionally to the <code>clocksource</code> framework, the Linux kernel provides <code>clockevents</code> framework. As described in the <a href="https://github.com/0xAX/linux/blob/0a07b238e5f488b459b6113a62e06b6aab017f71/Documentation/timers/timekeeping.txt">documentation</a>:</p>
<blockquote>
<p>Clock events are the conceptual reverse of clock sources</p>
</blockquote>
<p>Main goal of the is to manage clock event devices or in other words - to manage devices that allow to register an event or in other words <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a> that is going to happen at a defined point of time in the future.</p>
<p>Now we know a little about the <code>clockevents</code> framework in the Linux kernel, and now time is to see on it <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a>.</p>
<h2 id="api-of-clockevents-framework"><a class="header" href="#api-of-clockevents-framework">API of <code>clockevents</code> framework</a></h2>
<p>The main structure which described a clock event device is <code>clock_event_device</code> structure. This structure is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clockchips.h">include/linux/clockchips.h</a> header file and contains a huge set of fields. as well as the <code>clocksource</code> structure it has <code>name</code> fields which contains human readable name of a clock event device, for example <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">local APIC</a> timer:</p>
<pre><code class="language-C">static struct clock_event_device lapic_clockevent = {
    .name                   = &quot;lapic&quot;,
    ...
    ...
    ...
}
</code></pre>
<p>Addresses of the <code>event_handler</code>, <code>set_next_event</code>, <code>next_event</code> functions for a certain clock event device which are an <a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt handler</a>, setter of next event and local storage for next event respectively. Yet another field of the <code>clock_event_device</code> structure is - <code>features</code> field. Its value maybe on of the following generic features:</p>
<pre><code class="language-C">#define CLOCK_EVT_FEAT_PERIODIC	0x000001
#define CLOCK_EVT_FEAT_ONESHOT		0x000002
</code></pre>
<p>Where the <code>CLOCK_EVT_FEAT_PERIODIC</code> represents device which may be programmed to generate events periodically. The <code>CLOCK_EVT_FEAT_ONESHOT</code> represents device which may generate an event only once. Besides these two features, there are also architecture-specific features. For example <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> supports two additional features:</p>
<pre><code class="language-C">#define CLOCK_EVT_FEAT_C3STOP		0x000008
</code></pre>
<p>The first <code>CLOCK_EVT_FEAT_C3STOP</code> means that a clock event device will be stopped in the <a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface#Device_states">C3</a> state. Additionally the <code>clock_event_device</code> structure has <code>mult</code> and <code>shift</code> fields as well as <code>clocksource</code> structure. The <code>clocksource</code> structure also contains other fields, but we will consider it later.</p>
<p>After we considered part of the <code>clock_event_device</code> structure, time is to look at the <code>API</code> of the <code>clockevents</code> framework. To work with a clock event device, first of all we need to initialize <code>clock_event_device</code> structure and register a clock events device. The <code>clockevents</code> framework provides following <code>API</code> for registration of clock event devices:</p>
<pre><code class="language-C">void clockevents_register_device(struct clock_event_device *dev)
{
   ...
   ...
   ...
}
</code></pre>
<p>This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/clockevents.c">kernel/time/clockevents.c</a> source code file and as we may see, the <code>clockevents_register_device</code> function takes only one parameter:</p>
<ul>
<li>address of a <code>clock_event_device</code> structure which represents a clock event device.</li>
</ul>
<p>So, to register a clock event device, at first we need to initialize <code>clock_event_device</code> structure with parameters of a certain clock event device. Let's take a look at one random clock event device in the Linux kernel source code. We can find one in the <a href="https://github.com/torvalds/linux/tree/master/drivers/clocksource">drivers/clocksource</a> directory or try to take a look at an architecture-specific clock event device. Let's take for example - <a href="http://www.atmel.com/Images/doc6062.pdf">Periodic Interval Timer (PIT) for at91sam926x</a>. You can find its implementation in the <a href="https://github.com/torvalds/linux/tree/master/drivers/clocksource/timer-atmel-pit.c">drivers/clocksource</a>.</p>
<p>First of all let's look at initialization of the <code>clock_event_device</code> structure. This occurs in the <code>at91sam926x_pit_common_init</code> function:</p>
<pre><code class="language-C">struct pit_data {
    ...
    ...
    struct clock_event_device       clkevt;
    ...
    ...
};

static void __init at91sam926x_pit_common_init(struct pit_data *data)
{
    ...
    ...
    ...
    data-&gt;clkevt.name = &quot;pit&quot;;
    data-&gt;clkevt.features = CLOCK_EVT_FEAT_PERIODIC;
    data-&gt;clkevt.shift = 32;
    data-&gt;clkevt.mult = div_sc(pit_rate, NSEC_PER_SEC, data-&gt;clkevt.shift);
    data-&gt;clkevt.rating = 100;
    data-&gt;clkevt.cpumask = cpumask_of(0);

    data-&gt;clkevt.set_state_shutdown = pit_clkevt_shutdown;
    data-&gt;clkevt.set_state_periodic = pit_clkevt_set_periodic;
    data-&gt;clkevt.resume = at91sam926x_pit_resume;
    data-&gt;clkevt.suspend = at91sam926x_pit_suspend;
    ...
}
</code></pre>
<p>Here we can see that <code>at91sam926x_pit_common_init</code> takes one parameter - pointer to the <code>pit_data</code> structure which contains <code>clock_event_device</code> structure which will contain clock event related information of the <code>at91sam926x</code> <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">periodic Interval Timer</a>. At the start we fill <code>name</code> of the timer device and its <code>features</code>. In our case we deal with periodic timer which as we already know may be programmed to generate events periodically.</p>
<p>The next two fields <code>shift</code> and <code>mult</code> are familiar to us. They will be used to translate counter of our timer to nanoseconds. After this we set rating of the timer  to <code>100</code>. This means if there will not be timers with higher rating in the system, this timer will be used for timekeeping. The next field - <code>cpumask</code> indicates for which processors in the system the device will work. In our case, the device will work for the first processor. The <code>cpumask_of</code> macro defined in the <a href="https://github.com/torvalds/linux/tree/master/include/linux/cpumask.h">include/linux/cpumask.h</a> header file and just expands to the call of the:</p>
<pre><code class="language-C">#define cpumask_of(cpu) (get_cpu_mask(cpu))
</code></pre>
<p>Where the <code>get_cpu_mask</code> returns the cpumask containing just a given <code>cpu</code> number. More about <code>cpumasks</code> concept you may read in the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">CPU masks in the Linux kernel</a> part. In the last four lines of code we set callbacks for the clock event device suspend/resume, device shutdown and update of the clock event device state.</p>
<p>After we finished with the initialization of the <code>at91sam926x</code> periodic timer, we can register it by the call of the following functions:</p>
<pre><code class="language-C">clockevents_register_device(&amp;data-&gt;clkevt);
</code></pre>
<p>Now we can consider implementation of the <code>clockevent_register_device</code> function. As I already wrote above, this function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/clockevents.c">kernel/time/clockevents.c</a> source code file and starts from the initialization of the initial event device state:</p>
<pre><code class="language-C">clockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);
</code></pre>
<p>Actually, an event device may be in one of this states:</p>
<pre><code class="language-C">enum clock_event_state {
	CLOCK_EVT_STATE_DETACHED,
	CLOCK_EVT_STATE_SHUTDOWN,
	CLOCK_EVT_STATE_PERIODIC,
	CLOCK_EVT_STATE_ONESHOT,
	CLOCK_EVT_STATE_ONESHOT_STOPPED,
};
</code></pre>
<p>Where:</p>
<ul>
<li><code>CLOCK_EVT_STATE_DETACHED</code> - a clock event device is not not used by <code>clockevents</code> framework. Actually it is initial state of all clock event devices;</li>
<li><code>CLOCK_EVT_STATE_SHUTDOWN</code> - a clock event device is powered-off;</li>
<li><code>CLOCK_EVT_STATE_PERIODIC</code> - a clock event device may be programmed to generate event periodically;</li>
<li><code>CLOCK_EVT_STATE_ONESHOT</code>  - a clock event device may be programmed to generate event only once;</li>
<li><code>CLOCK_EVT_STATE_ONESHOT_STOPPED</code> - a clock event device was programmed to generate event only once and now it is temporary stopped.</li>
</ul>
<p>The implementation of the <code>clock_event_set_state</code> function is pretty easy:</p>
<pre><code class="language-C">static inline void clockevent_set_state(struct clock_event_device *dev,
					enum clock_event_state state)
{
	dev-&gt;state_use_accessors = state;
}
</code></pre>
<p>As we can see, it just fills the <code>state_use_accessors</code> field of the given <code>clock_event_device</code> structure with the given value which is in our case is <code>CLOCK_EVT_STATE_DETACHED</code>. Actually all clock event devices has this initial state during registration. The <code>state_use_accessors</code> field of the <code>clock_event_device</code> structure provides <code>current</code> state of the clock event device.</p>
<p>After we have set initial state of the given <code>clock_event_device</code> structure we check that the <code>cpumask</code> of the given clock event device is not zero:</p>
<pre><code class="language-C">if (!dev-&gt;cpumask) {
	WARN_ON(num_possible_cpus() &gt; 1);
	dev-&gt;cpumask = cpumask_of(smp_processor_id());
}
</code></pre>
<p>Remember that we have set the <code>cpumask</code> of the <code>at91sam926x</code> periodic timer to first processor. If the <code>cpumask</code> field is zero, we check the number of possible processors in the system and print warning message if it is less than on. Additionally we set the <code>cpumask</code> of the given clock event device to the current processor. If you are interested in how the <code>smp_processor_id</code> macro is implemented, you can read more about it in the fourth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">part</a> of the Linux kernel initialization process chapter.</p>
<p>After this check we lock the actual code of the clock event device registration by the call following macros:</p>
<pre><code class="language-C">raw_spin_lock_irqsave(&amp;clockevents_lock, flags);
...
...
...
raw_spin_unlock_irqrestore(&amp;clockevents_lock, flags);
</code></pre>
<p>Additionally the <code>raw_spin_lock_irqsave</code> and the <code>raw_spin_unlock_irqrestore</code> macros disable local interrupts, however interrupts on other processors still may occur. We need to do it to prevent potential <a href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a> if we adding new clock event device to the list of clock event devices and an interrupt occurs from other clock event device.</p>
<p>We can see following code of clock event device registration between the <code>raw_spin_lock_irqsave</code> and <code>raw_spin_unlock_irqrestore</code> macros:</p>
<pre><code class="language-C">list_add(&amp;dev-&gt;list, &amp;clockevent_devices);
tick_check_new_device(dev);
clockevents_notify_released();
</code></pre>
<p>First of all we add the given clock event device to the list of clock event devices which is represented by the <code>clockevent_devices</code>:</p>
<pre><code class="language-C">static LIST_HEAD(clockevent_devices);
</code></pre>
<p>At the next step we call the <code>tick_check_new_device</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/tick-common.c">kernel/time/tick-common.c</a> source code file and checks do the new registered clock event device should be used or not. The <code>tick_check_new_device</code> function checks the given <code>clock_event_device</code> gets the current registered tick device which is represented by the <code>tick_device</code> structure and compares their ratings and features. Actually <code>CLOCK_EVT_STATE_ONESHOT</code> is preferred:</p>
<pre><code class="language-C">static bool tick_check_preferred(struct clock_event_device *curdev,
				 struct clock_event_device *newdev)
{
	if (!(newdev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT)) {
		if (curdev &amp;&amp; (curdev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT))
			return false;
		if (tick_oneshot_mode_active())
			return false;
	}

	return !curdev ||
		newdev-&gt;rating &gt; curdev-&gt;rating ||
	       !cpumask_equal(curdev-&gt;cpumask, newdev-&gt;cpumask);
}
</code></pre>
<p>If the new registered clock event device is more preferred than old tick device, we exchange old and new registered devices and install new device:</p>
<pre><code class="language-C">clockevents_exchange_device(curdev, newdev);
tick_setup_device(td, newdev, cpu, cpumask_of(cpu));
</code></pre>
<p>The <code>clockevents_exchange_device</code> function releases or in other words deleted the old clock event device from the <code>clockevent_devices</code> list. The next function - <code>tick_setup_device</code> as we may understand from its name, setups new tick device. This function check the mode of the new registered clock event device and call the <code>tick_setup_periodic</code> function or the <code>tick_setup_oneshot</code> depends on the tick device mode:</p>
<pre><code class="language-C">if (td-&gt;mode == TICKDEV_MODE_PERIODIC)
	tick_setup_periodic(newdev, 0);
else
	tick_setup_oneshot(newdev, handler, next_event);
</code></pre>
<p>Both of this functions calls the <code>clockevents_switch_state</code> to change state of the clock event device and the <code>clockevents_program_event</code> function to set next event of clock event device based on delta between the maximum and minimum difference current time and time for the next event. The <code>tick_setup_periodic</code>:</p>
<pre><code class="language-C">clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);
clockevents_program_event(dev, next, false))
</code></pre>
<p>and the <code>tick_setup_oneshot_periodic</code>:</p>
<pre><code class="language-C">clockevents_switch_state(newdev, CLOCK_EVT_STATE_ONESHOT);
clockevents_program_event(newdev, next_event, true);
</code></pre>
<p>The <code>clockevents_switch_state</code> function checks that the clock event device is not in the given state and calls the <code>__clockevents_switch_state</code> function from the same source code file:</p>
<pre><code class="language-C">if (clockevent_get_state(dev) != state) {
	if (__clockevents_switch_state(dev, state))
		return;
</code></pre>
<p>The <code>__clockevents_switch_state</code> function just makes a call of the certain callback depends on the given state:</p>
<pre><code class="language-C">static int __clockevents_switch_state(struct clock_event_device *dev,
				      enum clock_event_state state)
{
	if (dev-&gt;features &amp; CLOCK_EVT_FEAT_DUMMY)
		return 0;

	switch (state) {
	case CLOCK_EVT_STATE_DETACHED:
	case CLOCK_EVT_STATE_SHUTDOWN:
		if (dev-&gt;set_state_shutdown)
			return dev-&gt;set_state_shutdown(dev);
		return 0;

	case CLOCK_EVT_STATE_PERIODIC:
		if (!(dev-&gt;features &amp; CLOCK_EVT_FEAT_PERIODIC))
			return -ENOSYS;
		if (dev-&gt;set_state_periodic)
			return dev-&gt;set_state_periodic(dev);
		return 0;
    ...
    ...
    ...
</code></pre>
<p>In our case for <code>at91sam926x</code> periodic timer, the state is the <code>CLOCK_EVT_FEAT_PERIODIC</code>:</p>
<pre><code class="language-C">data-&gt;clkevt.features = CLOCK_EVT_FEAT_PERIODIC;
data-&gt;clkevt.set_state_periodic = pit_clkevt_set_periodic;
</code></pre>
<p>So, for the <code>pit_clkevt_set_periodic</code> callback will be called. If we will read the documentation of the <a href="http://www.atmel.com/Images/doc6062.pdf">Periodic Interval Timer (PIT) for at91sam926x</a>, we will see that there is <code>Periodic Interval Timer Mode Register</code> which allows us to control of periodic interval timer.</p>
<p>It looks like:</p>
<pre><code>31                                                   25        24
+---------------------------------------------------------------+
|                                          |  PITIEN  |  PITEN  |
+---------------------------------------------------------------+
23                            19                               16
+---------------------------------------------------------------+
|                             |               PIV               |
+---------------------------------------------------------------+
15                                                              8
+---------------------------------------------------------------+
|                            PIV                                |
+---------------------------------------------------------------+
7                                                               0
+---------------------------------------------------------------+
|                            PIV                                |
+---------------------------------------------------------------+
</code></pre>
<p>Where <code>PIV</code> or <code>Periodic Interval Value</code> - defines the value compared with the primary <code>20-bit</code> counter of the Periodic Interval Timer. The <code>PITEN</code> or <code>Period Interval Timer Enabled</code> if the bit is <code>1</code> and the <code>PITIEN</code> or <code>Periodic Interval Timer Interrupt Enable</code> if the bit is <code>1</code>. So, to set periodic mode, we need to set <code>24</code>, <code>25</code> bits in the <code>Periodic Interval Timer Mode Register</code>. And we are doing it in the <code>pit_clkevt_set_periodic</code> function:</p>
<pre><code class="language-C">static int pit_clkevt_set_periodic(struct clock_event_device *dev)
{
        struct pit_data *data = clkevt_to_pit_data(dev);
        ...
        ...
        ...
        pit_write(data-&gt;base, AT91_PIT_MR,
                  (data-&gt;cycle - 1) | AT91_PIT_PITEN | AT91_PIT_PITIEN);

        return 0;
}
</code></pre>
<p>Where the <code>AT91_PT_MR</code>, <code>AT91_PT_PITEN</code> and the <code>AT91_PIT_PITIEN</code> are declared as:</p>
<pre><code class="language-C">#define AT91_PIT_MR             0x00
#define AT91_PIT_PITIEN       BIT(25)
#define AT91_PIT_PITEN        BIT(24)
</code></pre>
<p>After the setup of the new clock event device is finished, we can return to the <code>clockevents_register_device</code> function. The last function in the <code>clockevents_register_device</code> function is:</p>
<pre><code class="language-C">clockevents_notify_released();
</code></pre>
<p>This function checks the <code>clockevents_released</code> list which contains released clock event devices (remember that they may occur after the call of the <code> clockevents_exchange_device</code> function). If this list is not empty, we go through clock event devices from the <code>clock_events_released</code> list and delete it from the <code>clockevent_devices</code>:</p>
<pre><code class="language-C">static void clockevents_notify_released(void)
{
	struct clock_event_device *dev;

	while (!list_empty(&amp;clockevents_released)) {
		dev = list_entry(clockevents_released.next,
				 struct clock_event_device, list);
		list_del(&amp;dev-&gt;list);
		list_add(&amp;dev-&gt;list, &amp;clockevent_devices);
		tick_check_new_device(dev);
	}
}
</code></pre>
<p>That's all. From this moment we have registered new clock event device. So the usage of the <code>clockevents</code> framework is simple and clear. Architectures registered their clock event devices, in the clock events core. Users of the clockevents core can get clock event devices for their use. The <code>clockevents</code> framework provides notification mechanisms for various clock related management events like a clock event device registered or unregistered, a processor is offlined in system which supports <a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">CPU hotplug</a> and etc.</p>
<p>We saw implementation only of the <code>clockevents_register_device</code> function. But generally, the clock event layer <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> is small. Besides the <code>API</code> for clock event device registration, the <code>clockevents</code> framework provides functions to schedule the next event interrupt, clock event device notification service and support for suspend and resume for clock event devices.</p>
<p>If you want to know more about <code>clockevents</code> API you can start to research following source code and header files: <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/tick-common.c">kernel/time/tick-common.c</a>, <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/clockevents.c">kernel/time/clockevents.c</a> and <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clockchips.h">include/linux/clockchips.h</a>.</p>
<p>That's all.</p>
<h2 id="conclusion-36"><a class="header" href="#conclusion-36">Conclusion</a></h2>
<p>This is the end of the fifth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> that describes timers and timer management related stuff in the Linux kernel. In the previous part got acquainted with the <code>timers</code> concept. In this part we continued to learn time management related stuff in the Linux kernel and saw a little about yet another framework - <code>clockevents</code>.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-36"><a class="header" href="#links-36">Links</a></h2>
<ul>
<li><a href="https://github.com/0xAX/linux/blob/0a07b238e5f488b459b6113a62e06b6aab017f71/Documentation/timers/timekeeping.txt">timekeeping documentation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8253">Intel 8253</a></li>
<li><a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a></li>
<li><a href="http://uefi.org/sites/default/files/resources/ACPI_5.pdf">ACPI pdf</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86">x86</a></li>
<li><a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a></li>
<li><a href="https://en.wikipedia.org/wiki/PowerPC">powerpc</a></li>
<li><a href="https://en.wikipedia.org/wiki/Frequency">frequency</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a></li>
<li><a href="https://en.wikipedia.org/wiki/Nanosecond">nanoseconds</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt handler</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">local APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface#Device_states">C3 state</a> </li>
<li><a href="http://www.atmel.com/Images/doc6062.pdf">Periodic Interval Timer (PIT) for at91sam926x</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">CPU masks in the Linux kernel</a></li>
<li><a href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">CPU hotplug</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-3">previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers-and-time-management-in-the-linux-kernel-part-6"><a class="header" href="#timers-and-time-management-in-the-linux-kernel-part-6">Timers and time management in the Linux kernel. Part 6.</a></h1>
<h2 id="x86_64-related-clock-sources"><a class="header" href="#x86_64-related-clock-sources">x86_64 related clock sources</a></h2>
<p>This is sixth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> which describes timers and time management related stuff in the Linux kernel. In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-5">part</a> we saw <code>clockevents</code> framework and now we will continue to dive into time management related stuff in the Linux kernel. This part will describe implementation of <a href="https://en.wikipedia.org/wiki/X86">x86</a> architecture related clock sources (more about <code>clocksource</code> concept you can read in the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-2">second part</a> of this chapter).</p>
<p>First of all we must know what clock sources may be used at <code>x86</code> architecture. It is easy to know from the <a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a> or from content of the <code>/sys/devices/system/clocksource/clocksource0/available_clocksource</code>. The <code>/sys/devices/system/clocksource/clocksourceN</code> provides two special files to achieve this:</p>
<ul>
<li><code>available_clocksource</code> - provides information about available clock sources in the system;</li>
<li><code>current_clocksource</code>   - provides information about currently used clock source in the system.</li>
</ul>
<p>So, let's look:</p>
<pre><code>$ cat /sys/devices/system/clocksource/clocksource0/available_clocksource 
tsc hpet acpi_pm 
</code></pre>
<p>We can see that there are three registered clock sources in my system:</p>
<ul>
<li><code>tsc</code> - <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a>;</li>
<li><code>hpet</code> - <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a>;</li>
<li><code>acpi_pm</code> - <a href="http://uefi.org/sites/default/files/resources/ACPI_5.pdf">ACPI Power Management Timer</a>.</li>
</ul>
<p>Now let's look at the second file which provides best clock source (a clock source which has the best rating in the system):</p>
<pre><code>$ cat /sys/devices/system/clocksource/clocksource0/current_clocksource 
tsc
</code></pre>
<p>For me it is <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a>. As we may know from the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-2">second part</a> of this chapter, which describes internals of the <code>clocksource</code> framework in the Linux kernel, the best clock source in a system is a clock source with the best (highest) rating or in other words with the highest <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>.</p>
<p>Frequency of the <a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI</a> power management timer is <code>3.579545 MHz</code>. Frequency of the <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a> is at least <code>10 MHz</code>. And the frequency of the <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a> depends on processor. For example On older processors, the <code>Time Stamp Counter</code> was counting internal processor clock cycles. This means its frequency changed when the processor's frequency scaling changed. The situation has changed for newer processors. Newer processors have an <code>invariant Time Stamp counter</code> that increments at a constant rate in all operational states of processor. Actually we can get its frequency in the output of the <code>/proc/cpuinfo</code>. For example for the first processor in the system:</p>
<pre><code>$ cat /proc/cpuinfo
...
model name	: Intel(R) Core(TM) i7-4790K CPU @ 4.00GHz
...
</code></pre>
<p>And although Intel manual says that the frequency of the <code>Time Stamp Counter</code>, while constant, is not necessarily the maximum qualified frequency of the processor, or the frequency given in the brand string, anyway we may see that it will be much more than frequency of the <code>ACPI PM</code> timer or <code>High Precision Event Timer</code>. And we can see that the clock source with the best rating or highest frequency is current in the system.</p>
<p>You can note that besides these three clock source, we don't see yet another two familiar us clock sources in the output of the <code>/sys/devices/system/clocksource/clocksource0/available_clocksource</code>. These clock sources are <code>jiffy</code> and <code>refined_jiffies</code>. We don't see them because this filed maps only high resolution clock sources or in other words clock sources with the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clocksource.h#L113">CLOCK_SOURCE_VALID_FOR_HRES</a> flag.</p>
<p>As I already wrote above, we will consider all of these three clock sources in this part. We will consider it in order of their initialization or:</p>
<ul>
<li><code>hpet</code>;</li>
<li><code>acpi_pm</code>;</li>
<li><code>tsc</code>.</li>
</ul>
<p>We can make sure that the order is exactly like this in the output of the <a href="https://en.wikipedia.org/wiki/Dmesg">dmesg</a> util:</p>
<pre><code>$ dmesg | grep clocksource
[    0.000000] clocksource: refined-jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1910969940391419 ns
[    0.000000] clocksource: hpet: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 133484882848 ns
[    0.094369] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1911260446275000 ns
[    0.186498] clocksource: Switched to clocksource hpet
[    0.196827] clocksource: acpi_pm: mask: 0xffffff max_cycles: 0xffffff, max_idle_ns: 2085701024 ns
[    1.413685] tsc: Refined TSC clocksource calibration: 3999.981 MHz
[    1.413688] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x73509721780, max_idle_ns: 881591102108 ns
[    2.413748] clocksource: Switched to clocksource tsc
</code></pre>
<p>The first clock source is the <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a>, so let's start from it.</p>
<h2 id="high-precision-event-timer"><a class="header" href="#high-precision-event-timer">High Precision Event Timer</a></h2>
<p>The implementation of the <code>High Precision Event Timer</code> for the <a href="https://en.wikipedia.org/wiki/X86">x86</a> architecture is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/hpet.c">arch/x86/kernel/hpet.c</a> source code file. Its initialization starts from the call of the <code>hpet_enable</code> function. This function is called during Linux kernel initialization. If we will look into <code>start_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> source code file, we will see that after the all architecture-specific stuff initialized, early console is disabled and time management subsystem already ready, call of the following function:</p>
<pre><code class="language-C">if (late_time_init)
	late_time_init();
</code></pre>
<p>which does initialization of the late architecture specific timers after early jiffy counter already initialized. The definition of the <code>late_time_init</code> function for the <code>x86</code> architecture is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/time.c">arch/x86/kernel/time.c</a> source code file. It looks pretty easy:</p>
<pre><code class="language-C">static __init void x86_late_time_init(void)
{
	x86_init.timers.timer_init();
	tsc_init();
}
</code></pre>
<p>As we may see, it does initialization of the <code>x86</code> related timer and initialization of the <code>Time Stamp Counter</code>. The seconds we will see in the next paragraph, but now let's consider the call of the <code>x86_init.timers.timer_init</code> function. The <code>timer_init</code> points to the <code>hpet_time_init</code> function from the same source code file. We can verify this by looking on the definition of the <code>x86_init</code> structure from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/x86_init.c">arch/x86/kernel/x86_init.c</a>:</p>
<pre><code class="language-C">struct x86_init_ops x86_init __initdata = {
   ...
   ...
   ...
   .timers = {
		.setup_percpu_clockev	= setup_boot_APIC_clock,
		.timer_init		= hpet_time_init,
		.wallclock_init		= x86_init_noop,
   },
   ...
   ...
   ...
</code></pre>
<p>The <code>hpet_time_init</code> function does setup of the <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a> if we can not enable <code>High Precision Event Timer</code> and setups default timer <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> for the enabled timer:</p>
<pre><code class="language-C">void __init hpet_time_init(void)
{
	if (!hpet_enable())
		setup_pit_timer();
	setup_default_timer_irq();
}
</code></pre>
<p>First of all the <code>hpet_enable</code> function check we can enable <code>High Precision Event Timer</code> in the system by the call of the <code>is_hpet_capable</code> function and if we can, we map a virtual address space for it:</p>
<pre><code class="language-C">int __init hpet_enable(void)
{
	if (!is_hpet_capable())
		return 0;

    hpet_set_mapping();
}
</code></pre>
<p>The <code>is_hpet_capable</code> function checks that we didn't pass <code>hpet=disable</code> to the kernel command line and the <code>hpet_address</code> is received from the <a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI HPET</a> table. The <code>hpet_set_mapping</code> function just maps the virtual address spaces for the timer registers:</p>
<pre><code class="language-C">hpet_virt_address = ioremap_nocache(hpet_address, HPET_MMAP_SIZE);
</code></pre>
<p>As we can read in the  <a href="http://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/software-developers-hpet-spec-1-0a.pdf">IA-PC HPET (High Precision Event Timers) Specification</a>:</p>
<blockquote>
<p>The timer register space is 1024 bytes</p>
</blockquote>
<p>So, the <code>HPET_MMAP_SIZE</code> is <code>1024</code> bytes too:</p>
<pre><code class="language-C">#define HPET_MMAP_SIZE		1024
</code></pre>
<p>After we mapped virtual space for the <code>High Precision Event Timer</code>, we read <code>HPET_ID</code> register to get number of the timers:</p>
<pre><code class="language-C">id = hpet_readl(HPET_ID);

last = (id &amp; HPET_ID_NUMBER) &gt;&gt; HPET_ID_NUMBER_SHIFT;
</code></pre>
<p>We need to get this number to allocate correct amount of space for the <code>General Configuration Register</code> of the <code>High Precision Event Timer</code>:</p>
<pre><code class="language-C">cfg = hpet_readl(HPET_CFG);

hpet_boot_cfg = kmalloc((last + 2) * sizeof(*hpet_boot_cfg), GFP_KERNEL);
</code></pre>
<p>After the space is allocated for the configuration register of the <code>High Precision Event Timer</code>, we allow to main counter to run, and allow timer interrupts if they are enabled by the setting of <code>HPET_CFG_ENABLE</code> bit in the configuration register for all timers. In the end we just register new clock source by the call of the <code>hpet_clocksource_register</code> function:</p>
<pre><code class="language-C">if (hpet_clocksource_register())
	goto out_nohpet;
</code></pre>
<p>which just calls already familiar</p>
<pre><code class="language-C">clocksource_register_hz(&amp;clocksource_hpet, (u32)hpet_freq);
</code></pre>
<p>function. Where the <code>clocksource_hpet</code> is the <code>clocksource</code> structure with the rating <code>250</code> (remember rating of the previous <code>refined_jiffies</code> clock source was <code>2</code>), name - <code>hpet</code> and <code>read_hpet</code> callback for the reading of atomic counter provided by the <code>High Precision Event Timer</code>:</p>
<pre><code class="language-C">static struct clocksource clocksource_hpet = {
	.name		= &quot;hpet&quot;,
	.rating		= 250,
	.read		= read_hpet,
	.mask		= HPET_MASK,
	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
	.resume		= hpet_resume_counter,
	.archdata	= { .vclock_mode = VCLOCK_HPET },
};
</code></pre>
<p>After the <code>clocksource_hpet</code> is registered, we can return to the <code>hpet_time_init()</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/time.c">arch/x86/kernel/time.c</a> source code file. We can remember that the last step is the call of the:</p>
<pre><code class="language-C">setup_default_timer_irq();
</code></pre>
<p>function in the <code>hpet_time_init()</code>. The <code>setup_default_timer_irq</code> function checks existence of <code>legacy</code> IRQs or in other words support for the <a href="https://en.wikipedia.org/wiki/Intel_8259">i8259</a> and setups <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29#Master_PIC">IRQ0</a> depends on this.</p>
<p>That's all. From this moment the <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a> clock source registered in the Linux kernel <code>clock source</code> framework and may be used from generic kernel code via the <code>read_hpet</code>:</p>
<pre><code class="language-C">static cycle_t read_hpet(struct clocksource *cs)
{
	return (cycle_t)hpet_readl(HPET_COUNTER);
}
</code></pre>
<p>function which just reads and returns atomic counter from the <code>Main Counter Register</code>.</p>
<h2 id="acpi-pm-timer"><a class="header" href="#acpi-pm-timer">ACPI PM timer</a></h2>
<p>The seconds clock source is <a href="http://uefi.org/sites/default/files/resources/ACPI_5.pdf">ACPI Power Management Timer</a>. Implementation of this clock source is located in the <a href="https://github.com/torvalds/linux/blob/master/drivers/clocksource/acpi_pm.c">drivers/clocksource/acpi_pm.c</a> source code file and starts from the call of the <code>init_acpi_pm_clocksource</code> function during <code>fs</code> <a href="https://kernelnewbies.org/Documents/InitcallMechanism">initcall</a>.</p>
<p>If we will look at implementation of the <code>init_acpi_pm_clocksource</code> function, we will see that it starts from the check of the value of <code>pmtmr_ioport</code> variable:</p>
<pre><code class="language-C">static int __init init_acpi_pm_clocksource(void)
{
    ...
    ...
    ...
	if (!pmtmr_ioport)
		return -ENODEV;
    ...
    ...
    ...
</code></pre>
<p>This <code>pmtmr_ioport</code> variable contains extended address of the <code>Power Management Timer Control Register Block</code>. It gets its value in the <code>acpi_parse_fadt</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/acpi/boot.c">arch/x86/kernel/acpi/boot.c</a> source code file. This function parses <code>FADT</code> or <code>Fixed ACPI Description Table</code> <a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI</a> table and tries to get the values of the <code>X_PM_TMR_BLK</code> field which contains extended address of the <code>Power Management Timer Control Register Block</code>, represented in <code>Generic Address Structure</code> format:</p>
<pre><code class="language-C">static int __init acpi_parse_fadt(struct acpi_table_header *table)
{
#ifdef CONFIG_X86_PM_TIMER
        ...
        ...
        ...
		pmtmr_ioport = acpi_gbl_FADT.xpm_timer_block.address;
        ...
        ...
        ...
#endif
	return 0;
}
</code></pre>
<p>So, if the <code>CONFIG_X86_PM_TIMER</code> Linux kernel configuration option is disabled or something going wrong in the <code>acpi_parse_fadt</code> function, we can't access the <code>Power Management Timer</code> register and return from the <code>init_acpi_pm_clocksource</code>. In other way, if the value of the <code>pmtmr_ioport</code> variable is not zero, we check rate of this timer and register this clock source by the call of the:</p>
<pre><code class="language-C">clocksource_register_hz(&amp;clocksource_acpi_pm, PMTMR_TICKS_PER_SEC);
</code></pre>
<p>function. After the call of the <code>clocksource_register_hs</code>, the <code>acpi_pm</code> clock source will be registered in the <code>clocksource</code> framework of the Linux kernel:</p>
<pre><code class="language-C">static struct clocksource clocksource_acpi_pm = {
	.name		= &quot;acpi_pm&quot;,
	.rating		= 200,
	.read		= acpi_pm_read,
	.mask		= (cycle_t)ACPI_PM_MASK,
	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
};
</code></pre>
<p>with the rating - <code>200</code> and the <code>acpi_pm_read</code> callback to read atomic counter provided by the <code>acpi_pm</code> clock source. The <code>acpi_pm_read</code> function just executes <code>read_pmtmr</code> function:</p>
<pre><code class="language-C">static cycle_t acpi_pm_read(struct clocksource *cs)
{
	return (cycle_t)read_pmtmr();
}
</code></pre>
<p>which reads value of the <code>Power Management Timer</code> register. This register has following structure:</p>
<pre><code>+-------------------------------+----------------------------------+
|                               |                                  |
|  upper eight bits of a        |      running count of the        |
| 32-bit power management timer |     power management timer       |
|                               |                                  |
+-------------------------------+----------------------------------+
31          E_TMR_VAL           24               TMR_VAL           0
</code></pre>
<p>Address of this register is stored in the <code>Fixed ACPI Description Table</code> <a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI</a> table and we already have it in the <code>pmtmr_ioport</code>. So, the implementation of the <code>read_pmtmr</code> function is pretty easy:</p>
<pre><code class="language-C">static inline u32 read_pmtmr(void)
{
	return inl(pmtmr_ioport) &amp; ACPI_PM_MASK;
}
</code></pre>
<p>We just read the value of the <code>Power Management Timer</code> register and mask its <code>24</code> bits.</p>
<p>That's all. Now we move to the last clock source in this part - <code>Time Stamp Counter</code>.</p>
<h2 id="time-stamp-counter"><a class="header" href="#time-stamp-counter">Time Stamp Counter</a></h2>
<p>The third and last clock source in this part is - <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a> clock source and its implementation is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/tsc.c">arch/x86/kernel/tsc.c</a> source code file. We already saw the <code>x86_late_time_init</code> function in this part and initialization of the <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a> starts from this place. This function calls the <code>tsc_init()</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/tsc.c">arch/x86/kernel/tsc.c</a> source code file.</p>
<p>At the beginning of the <code>tsc_init</code> function we can see check, which checks that a processor has support of the <code>Time Stamp Counter</code>:</p>
<pre><code class="language-C">void __init tsc_init(void)
{
	u64 lpj;
	int cpu;

	if (!cpu_has_tsc) {
		setup_clear_cpu_cap(X86_FEATURE_TSC_DEADLINE_TIMER);
		return;
	}
    ...
    ...
    ...
</code></pre>
<p>The <code>cpu_has_tsc</code> macro expands to the call of the <code>cpu_has</code> macro:</p>
<pre><code class="language-C">#define cpu_has_tsc		boot_cpu_has(X86_FEATURE_TSC)

#define boot_cpu_has(bit)	cpu_has(&amp;boot_cpu_data, bit)

#define cpu_has(c, bit)							\
	(__builtin_constant_p(bit) &amp;&amp; REQUIRED_MASK_BIT_SET(bit) ? 1 :	\
	 test_cpu_cap(c, bit))
</code></pre>
<p>which check the given bit (the <code>X86_FEATURE_TSC_DEADLINE_TIMER</code> in our case) in the <code>boot_cpu_data</code> array which is filled during early Linux kernel initialization. If the processor has support of the <code>Time Stamp Counter</code>, we get the frequency of the <code>Time Stamp Counter</code> by the call of the <code>calibrate_tsc</code> function from the same source code file which tries to get frequency from the different source like <a href="https://en.wikipedia.org/wiki/Model-specific_register">Model Specific Register</a>, calibrate over <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a> and etc, after this we initialize frequency and scale factor for the all processors in the system:</p>
<pre><code class="language-C">tsc_khz = x86_platform.calibrate_tsc();
cpu_khz = tsc_khz;

for_each_possible_cpu(cpu) {
	cyc2ns_init(cpu);
	set_cyc2ns_scale(cpu_khz, cpu);
}
</code></pre>
<p>because only first bootstrap processor will call the <code>tsc_init</code>. After this we check hat <code>Time Stamp Counter</code> is not disabled:</p>
<pre><code>if (tsc_disabled &gt; 0)
	return;
...
...
...
check_system_tsc_reliable();
</code></pre>
<p>and call the <code>check_system_tsc_reliable</code> function which sets the <code>tsc_clocksource_reliable</code> if bootstrap processor has the <code>X86_FEATURE_TSC_RELIABLE</code> feature. Note that we went through the <code>tsc_init</code> function, but did not register our clock source. Actual registration of the <code>Time Stamp Counter</code> clock source occurs in the:</p>
<pre><code class="language-C">static int __init init_tsc_clocksource(void)
{
	if (!cpu_has_tsc || tsc_disabled &gt; 0 || !tsc_khz)
		return 0;
    ...
    ...
    ...
    if (boot_cpu_has(X86_FEATURE_TSC_RELIABLE)) {
		clocksource_register_khz(&amp;clocksource_tsc, tsc_khz);
		return 0;
	}
</code></pre>
<p>function. This function called during the <code>device</code> <a href="https://kernelnewbies.org/Documents/InitcallMechanism">initcall</a>. We do it to be sure that the <code>Time Stamp Counter</code> clock source will be registered after the  <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a> clock source.</p>
<p>After these all three clock sources will be registered in the <code>clocksource</code> framework and the <code>Time Stamp Counter</code> clock source will be selected as active, because it has the highest rating among other clock sources:</p>
<pre><code class="language-C">static struct clocksource clocksource_tsc = {
	.name                   = &quot;tsc&quot;,
	.rating                 = 300,
	.read                   = read_tsc,
	.mask                   = CLOCKSOURCE_MASK(64),
	.flags                  = CLOCK_SOURCE_IS_CONTINUOUS | CLOCK_SOURCE_MUST_VERIFY,
	.archdata               = { .vclock_mode = VCLOCK_TSC },
};
</code></pre>
<p>That's all.</p>
<h2 id="conclusion-37"><a class="header" href="#conclusion-37">Conclusion</a></h2>
<p>This is the end of the sixth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> that describes timers and timer management related stuff in the Linux kernel. In the previous part got acquainted with the <code>clockevents</code> framework. In this part we continued to learn time management related stuff in the Linux kernel and saw a little about three different clock sources which are used in the <a href="https://en.wikipedia.org/wiki/X86">x86</a> architecture. The next part will be last part of this <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> and we will see some user space related stuff, i.e. how some time related <a href="https://en.wikipedia.org/wiki/System_call">system calls</a> implemented in the Linux kernel.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-37"><a class="header" href="#links-37">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/X86">x86</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a></li>
<li><a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a></li>
<li><a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a></li>
<li><a href="http://uefi.org/sites/default/files/resources/ACPI_5.pdf">ACPI Power Management Timer (PDF)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>.</li>
<li><a href="https://en.wikipedia.org/wiki/Dmesg">dmesg</a></li>
<li><a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> </li>
<li><a href="http://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/software-developers-hpet-spec-1-0a.pdf">IA-PC HPET (High Precision Event Timers) Specification</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29#Master_PIC">IRQ0</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8259">i8259</a></li>
<li><a href="https://kernelnewbies.org/Documents/InitcallMechanism">initcall</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-5">previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timers-and-time-management-in-the-linux-kernel-part-7"><a class="header" href="#timers-and-time-management-in-the-linux-kernel-part-7">Timers and time management in the Linux kernel. Part 7.</a></h1>
<h2 id="time-related-system-calls-in-the-linux-kernel"><a class="header" href="#time-related-system-calls-in-the-linux-kernel">Time related system calls in the Linux kernel</a></h2>
<p>This is the seventh and last part <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a>, which describes timers and time management related stuff in the Linux kernel. In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-6">part</a>, we discussed timers in the context of <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a>: <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a> and <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a>. Internal time management is an interesting part of the Linux kernel, but of course not only the kernel needs the <code>time</code> concept. Our programs also need to know time. In this part, we will consider implementation of some time management related <a href="https://en.wikipedia.org/wiki/System_call">system calls</a>. These system calls are:</p>
<ul>
<li><code>clock_gettime</code>;</li>
<li><code>gettimeofday</code>;</li>
<li><code>nanosleep</code>.</li>
</ul>
<p>We will start from a simple userspace <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> program and see all way from the call of the <a href="https://en.wikipedia.org/wiki/Standard_library">standard library</a> function to the implementation of certain system calls. As each <a href="https://github.com/torvalds/linux/tree/master/arch">architecture</a> provides its own implementation of certain system calls, we will consider only <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> specific implementations of system calls, as this book is related to this architecture.</p>
<p>Additionally, we will not consider the concept of system calls in this part, but only implementations of these three system calls in the Linux kernel. If you are interested in what is a <code>system call</code>, there is a special <a href="https://0xax.gitbook.io/linux-insides/summary/syscall">chapter</a> about this.</p>
<p>So, let's start from the <code>gettimeofday</code> system call.</p>
<h2 id="implementation-of-the-gettimeofday-system-call"><a class="header" href="#implementation-of-the-gettimeofday-system-call">Implementation of the <code>gettimeofday</code> system call</a></h2>
<p>As we can understand from the name <code>gettimeofday</code>, this function returns the current time. First of all, let's look at the following simple example:</p>
<pre><code class="language-C">#include &lt;time.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv)
{
    char buffer[40];
    struct timeval time;
        
    gettimeofday(&amp;time, NULL);

    strftime(buffer, 40, &quot;Current date/time: %m-%d-%Y/%T&quot;, localtime(&amp;time.tv_sec));
    printf(&quot;%s\n&quot;,buffer);

    return 0;
}
</code></pre>
<p>As you can see, here we call the <code>gettimeofday</code> function, which takes two parameters. The first parameter is a pointer to the <code>timeval</code> structure, which represents an elapsed time:</p>
<pre><code class="language-C">struct timeval {
    time_t      tv_sec;     /* seconds */
    suseconds_t tv_usec;    /* microseconds */
};
</code></pre>
<p>The second parameter of the <code>gettimeofday</code> function is a pointer to the <code>timezone</code> structure which represents a timezone. In our example, we pass address of the <code>timeval time</code> to the <code>gettimeofday</code> function, the Linux kernel fills the given <code>timeval</code> structure and returns it back to us. Additionally, we format the time with the <code>strftime</code> function to get something more human readable than elapsed microseconds. Let's see the result:</p>
<pre><code class="language-C">~$ gcc date.c -o date
~$ ./date
Current date/time: 03-26-2016/16:42:02
</code></pre>
<p>As you may already know, a userspace application does not call a system call directly from the kernel space. Before the actual system call entry will be called, we call a function from the standard library. In my case it is <a href="https://en.wikipedia.org/wiki/GNU_C_Library">glibc</a>, so I will consider this case. The implementation of the <code>gettimeofday</code> function is located in the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/x86/gettimeofday.c;h=36f7c26ffb0e818709d032c605fec8c4bd22a14e;hb=HEAD">sysdeps/unix/sysv/linux/x86/gettimeofday.c</a> source code file. As you already may know, the <code>gettimeofday</code> is not a usual system call. It is located in the special area which is called <code>vDSO</code> (you can read more about it in the <a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-3">part</a>, which describes this concept).</p>
<p>The <code>glibc</code> implementation of <code>gettimeofday</code> tries to resolve the given symbol; in our case this symbol is <code>__vdso_gettimeofday</code> by the call of the <code>_dl_vdso_vsym</code> internal function. If the symbol cannot be resolved, it returns <code>NULL</code> and we fallback to the call of the usual system call:</p>
<pre><code class="language-C">return (_dl_vdso_vsym (&quot;__vdso_gettimeofday&quot;, &amp;linux26)
  ?: (void*) (&amp;__gettimeofday_syscall));
</code></pre>
<p>The <code>gettimeofday</code> entry is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/vdso/vclock_gettime.c">arch/x86/entry/vdso/vclock_gettime.c</a> source code file. As we can see the <code>gettimeofday</code> is a weak alias of the <code>__vdso_gettimeofday</code>:</p>
<pre><code class="language-C">int gettimeofday(struct timeval *, struct timezone *)
	__attribute__((weak, alias(&quot;__vdso_gettimeofday&quot;)));
</code></pre>
<p>The <code>__vdso_gettimeofday</code> is defined in the same source code file and calls the <code>do_realtime</code> function if the given <code>timeval</code> is not null:</p>
<pre><code class="language-C">notrace int __vdso_gettimeofday(struct timeval *tv, struct timezone *tz)
{
	if (likely(tv != NULL)) {
		if (unlikely(do_realtime((struct timespec *)tv) == VCLOCK_NONE))
			return vdso_fallback_gtod(tv, tz);
		tv-&gt;tv_usec /= 1000;
	}
	if (unlikely(tz != NULL)) {
		tz-&gt;tz_minuteswest = gtod-&gt;tz_minuteswest;
		tz-&gt;tz_dsttime = gtod-&gt;tz_dsttime;
	}

	return 0;
}
</code></pre>
<p>If the <code>do_realtime</code> will fail, we fallback to the real system call via call the <code>syscall</code> instruction and passing the <code>__NR_gettimeofday</code> system call number and the given <code>timeval</code> and <code>timezone</code>:</p>
<pre><code class="language-C">notrace static long vdso_fallback_gtod(struct timeval *tv, struct timezone *tz)
{
	long ret;

	asm(&quot;syscall&quot; : &quot;=a&quot; (ret) :
	    &quot;0&quot; (__NR_gettimeofday), &quot;D&quot; (tv), &quot;S&quot; (tz) : &quot;memory&quot;);
	return ret;
}
</code></pre>
<p>The <code>do_realtime</code> function gets the time data from the <code>vsyscall_gtod_data</code> structure which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/vgtod.h#L16">arch/x86/include/asm/vgtod.h</a> header file and contains mapping of the <code>timespec</code> structure and a couple of fields which are related to the current clock source in the system. This function fills the given <code>timeval</code> structure with values from the <code>vsyscall_gtod_data</code> which contains a time related data which is updated via timer interrupt.</p>
<p>First of all we try to access the <code>gtod</code> or <code>global time of day</code> the <code>vsyscall_gtod_data</code> structure via the call of the <code>gtod_read_begin</code> and will continue to do it until it will be successful:</p>
<pre><code class="language-C">do {
	seq = gtod_read_begin(gtod);
	mode = gtod-&gt;vclock_mode;
	ts-&gt;tv_sec = gtod-&gt;wall_time_sec;
	ns = gtod-&gt;wall_time_snsec;
	ns += vgetsns(&amp;mode);
	ns &gt;&gt;= gtod-&gt;shift;
} while (unlikely(gtod_read_retry(gtod, seq)));

ts-&gt;tv_sec += __iter_div_u64_rem(ns, NSEC_PER_SEC, &amp;ns);
ts-&gt;tv_nsec = ns;
</code></pre>
<p>As we got access to the <code>gtod</code>, we fill the <code>ts-&gt;tv_sec</code> with the <code>gtod-&gt;wall_time_sec</code> which stores current time in seconds gotten from the <a href="https://en.wikipedia.org/wiki/Real-time_clock">real time clock</a> during initialization of the timekeeping subsystem in the Linux kernel and the same value but in nanoseconds. In the end of this code we just fill the given <code>timespec</code> structure with the resulted values.</p>
<p>That's all about the <code>gettimeofday</code> system call. The next system call in our list is the <code>clock_gettime</code>.</p>
<h2 id="implementation-of-the-clock_gettime-system-call"><a class="header" href="#implementation-of-the-clock_gettime-system-call">Implementation of the clock_gettime system call</a></h2>
<p>The <code>clock_gettime</code> function gets the time which is specified by the second parameter. Generally the <code>clock_gettime</code> function takes two parameters:</p>
<ul>
<li><code>clk_id</code> - clock identifier;</li>
<li><code>timespec</code> - address of the <code>timespec</code> structure which represent elapsed time.</li>
</ul>
<p>Let's look on the following simple example:</p>
<pre><code class="language-C">#include &lt;time.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv)
{
    struct timespec elapsed_from_boot;

    clock_gettime(CLOCK_BOOTTIME, &amp;elapsed_from_boot);

    printf(&quot;%d - seconds elapsed from boot\n&quot;, elapsed_from_boot.tv_sec);
    
    return 0;
}
</code></pre>
<p>which prints <code>uptime</code> information:</p>
<pre><code class="language-C">~$ gcc uptime.c -o uptime
~$ ./uptime
14180 - seconds elapsed from boot
</code></pre>
<p>We can easily check the result with the help of the <a href="https://en.wikipedia.org/wiki/Uptime#Using_uptime">uptime</a> util:</p>
<pre><code>~$ uptime
up  3:56
</code></pre>
<p>The <code>elapsed_from_boot.tv_sec</code> represents elapsed time in seconds, so:</p>
<pre><code class="language-python">&gt;&gt;&gt; 14180 / 60
236
&gt;&gt;&gt; 14180 / 60 / 60
3
&gt;&gt;&gt; 14180 / 60 % 60
56
</code></pre>
<p>The <code>clock_id</code> maybe one of the following:</p>
<ul>
<li><code>CLOCK_REALTIME</code> - system wide clock which measures real or wall-clock time;</li>
<li><code>CLOCK_REALTIME_COARSE</code> - faster version of the <code>CLOCK_REALTIME</code>;</li>
<li><code>CLOCK_MONOTONIC</code> - represents monotonic time since some unspecified starting point; </li>
<li><code>CLOCK_MONOTONIC_COARSE</code> - faster version of the <code>CLOCK_MONOTONIC</code>;</li>
<li><code>CLOCK_MONOTONIC_RAW</code> - the same as the <code>CLOCK_MONOTONIC</code> but provides non <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">NTP</a> adjusted time. </li>
<li><code>CLOCK_BOOTTIME</code> - the same as the <code>CLOCK_MONOTONIC</code> but plus time that the system was suspended;</li>
<li><code>CLOCK_PROCESS_CPUTIME_ID</code> - per-process time consumed by all threads in the process;</li>
<li><code>CLOCK_THREAD_CPUTIME_ID</code> - thread-specific clock.</li>
</ul>
<p>The <code>clock_gettime</code> is not usual syscall too, but as the <code>gettimeofday</code>, this system call is placed in the <code>vDSO</code> area. Entry of this system call is located in the same source code file - <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/vdso/vclock_gettime.c">arch/x86/entry/vdso/vclock_gettime.c</a>) as for <code>gettimeofday</code>.</p>
<p>The Implementation of the <code>clock_gettime</code> depends on the clock id. If we have passed the <code>CLOCK_REALTIME</code> clock id, the <code>do_realtime</code> function will be called:</p>
<pre><code class="language-C">notrace int __vdso_clock_gettime(clockid_t clock, struct timespec *ts)
{
	switch (clock) {
	case CLOCK_REALTIME:
		if (do_realtime(ts) == VCLOCK_NONE)
			goto fallback;
		break;
    ...
    ...
    ...
fallback:
	return vdso_fallback_gettime(clock, ts);
}
</code></pre>
<p>In other cases, the <code>do_{name_of_clock_id}</code> function is called. Implementations of some of them is similar. For example if we will pass the <code>CLOCK_MONOTONIC</code> clock id:</p>
<pre><code class="language-C">...
...
...
case CLOCK_MONOTONIC:
	if (do_monotonic(ts) == VCLOCK_NONE)
		goto fallback;
	break;
...
...
...
</code></pre>
<p>the <code>do_monotonic</code> function will be called which is very similar on the implementation of the <code>do_realtime</code>:</p>
<pre><code class="language-C">notrace static int __always_inline do_monotonic(struct timespec *ts)
{
	do {
		seq = gtod_read_begin(gtod);
		mode = gtod-&gt;vclock_mode;
		ts-&gt;tv_sec = gtod-&gt;monotonic_time_sec;
		ns = gtod-&gt;monotonic_time_snsec;
		ns += vgetsns(&amp;mode);
		ns &gt;&gt;= gtod-&gt;shift;
	} while (unlikely(gtod_read_retry(gtod, seq)));

	ts-&gt;tv_sec += __iter_div_u64_rem(ns, NSEC_PER_SEC, &amp;ns);
	ts-&gt;tv_nsec = ns;

	return mode;
}
</code></pre>
<p>We already saw a little about the implementation of this function in the previous paragraph about the <code>gettimeofday</code>. There is only one difference here, that the <code>sec</code> and <code>nsec</code> of our <code>timespec</code> value will be based on the <code>gtod-&gt;monotonic_time_sec</code> instead of <code>gtod-&gt;wall_time_sec</code> which maps the value of the <code>tk-&gt;tkr_mono.xtime_nsec</code> or number of <a href="https://en.wikipedia.org/wiki/Nanosecond">nanoseconds</a> elapsed.</p>
<p>That's all.</p>
<h2 id="implementation-of-the-nanosleep-system-call"><a class="header" href="#implementation-of-the-nanosleep-system-call">Implementation of the <code>nanosleep</code> system call</a></h2>
<p>The last system call in our list is the <code>nanosleep</code>. As you can understand from its name, this function provides <code>sleeping</code> ability. Let's look on the following simple example:</p>
<pre><code class="language-C">#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main (void)
{    
   struct timespec ts = {5,0};

   printf(&quot;sleep five seconds\n&quot;);
   nanosleep(&amp;ts, NULL);
   printf(&quot;end of sleep\n&quot;);

   return 0;
}
</code></pre>
<p>If we will compile and run it, we will see the first line</p>
<pre><code>~$ gcc sleep_test.c -o sleep
~$ ./sleep
sleep five seconds
end of sleep
</code></pre>
<p>and the second line after five seconds.</p>
<p>The <code>nanosleep</code> is not located in the <code>vDSO</code> area like the <code>gettimeofday</code> and the <code>clock_gettime</code> functions. So, let's look how the <code>real</code> system call which is located in the kernel space will be called by the standard library. The implementation of the <code>nanosleep</code> system call will be called with the help of the <a href="http://www.felixcloutier.com/x86/SYSCALL.html">syscall</a> instruction. Before the execution of the <code>syscall</code> instruction, parameters of the system call must be put in processor <a href="https://en.wikipedia.org/wiki/Processor_register">registers</a> according to order which is described in the <a href="http://www.x86-64.org/documentation/abi.pdf">System V Application Binary Interface</a> or in other words:</p>
<ul>
<li><code>rdi</code> - first parameter;</li>
<li><code>rsi</code> - second parameter;</li>
<li><code>rdx</code> - third parameter;</li>
<li><code>r10</code> - fourth parameter;</li>
<li><code>r8</code> - fifth parameter;</li>
<li><code>r9</code> - sixth parameter.</li>
</ul>
<p>The <code>nanosleep</code> system call has two parameters - two pointers to the <code>timespec</code> structures. The system call suspends the calling thread until the given timeout has elapsed. Additionally it will finish if a signal interrupts its execution. It takes two parameters, the first is <code>timespec</code> which represents timeout for the sleep. The second parameter is the pointer to the <code>timespec</code> structure too and it contains remainder of time if the call of the <code>nanosleep</code> was interrupted.</p>
<p>As <code>nanosleep</code> has two parameters:</p>
<pre><code class="language-C">int nanosleep(const struct timespec *req, struct timespec *rem);
</code></pre>
<p>To call system call, we need put the <code>req</code> to the <code>rdi</code> register, and the <code>rem</code> parameter to the <code>rsi</code> register. The <a href="https://en.wikipedia.org/wiki/GNU_C_Library">glibc</a> does these job in the <code>INTERNAL_SYSCALL</code> macro which is located in the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/x86_64/sysdep.h;h=d023d68174d3dfb4e698160b31ae31ad291802e1;hb=HEAD">sysdeps/unix/sysv/linux/x86_64/sysdep.h</a> header file.</p>
<pre><code class="language-C"># define INTERNAL_SYSCALL(name, err, nr, args...) \
  INTERNAL_SYSCALL_NCS (__NR_##name, err, nr, ##args)
</code></pre>
<p>which takes the name of the system call, storage for possible error during execution of system call, number of the system call (all <code>x86_64</code> system calls you can find in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl">system calls table</a>) and arguments of certain system call. The <code>INTERNAL_SYSCALL</code> macro just expands to the call of the <code>INTERNAL_SYSCALL_NCS</code> macro, which prepares arguments of system call (puts them into the processor registers in correct order), executes <code>syscall</code> instruction and returns the result:</p>
<pre><code class="language-C"># define INTERNAL_SYSCALL_NCS(name, err, nr, args...)      \
  ({									                                      \
    unsigned long int resultvar;					                          \
    LOAD_ARGS_##nr (args)						                              \
    LOAD_REGS_##nr							                                  \
    asm volatile (							                                  \
    &quot;syscall\n\t&quot;							                                  \
    : &quot;=a&quot; (resultvar)							                              \
    : &quot;0&quot; (name) ASM_ARGS_##nr : &quot;memory&quot;, REGISTERS_CLOBBERED_BY_SYSCALL);   \
    (long int) resultvar; })
</code></pre>
<p>The <code>LOAD_ARGS_##nr</code> macro calls the <code>LOAD_ARGS_N</code> macro where the <code>N</code> is number of arguments of the system call. In our case, it will be the <code>LOAD_ARGS_2</code> macro. Ultimately all of these macros will be expanded to the following:</p>
<pre><code class="language-C"># define LOAD_REGS_TYPES_1(t1, a1)					   \
  register t1 _a1 asm (&quot;rdi&quot;) = __arg1;					   \
  LOAD_REGS_0

# define LOAD_REGS_TYPES_2(t1, a1, t2, a2)				   \
  register t2 _a2 asm (&quot;rsi&quot;) = __arg2;					   \
  LOAD_REGS_TYPES_1(t1, a1)
...
...
...
</code></pre>
<p>After the <code>syscall</code> instruction will be executed, the <a href="https://en.wikipedia.org/wiki/Context_switch">context switch</a> will occur and the kernel will transfer execution to the system call handler. The system call handler for the <code>nanosleep</code> system call is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/hrtimer.c">kernel/time/hrtimer.c</a> source code file and defined with the <code>SYSCALL_DEFINE2</code> macro helper:</p>
<pre><code class="language-C">SYSCALL_DEFINE2(nanosleep, struct timespec __user *, rqtp,
		struct timespec __user *, rmtp)
{
	struct timespec tu;

	if (copy_from_user(&amp;tu, rqtp, sizeof(tu)))
		return -EFAULT;

	if (!timespec_valid(&amp;tu))
		return -EINVAL;

	return hrtimer_nanosleep(&amp;tu, rmtp, HRTIMER_MODE_REL, CLOCK_MONOTONIC);
}
</code></pre>
<p>More about the <code>SYSCALL_DEFINE2</code> macro you may read in the <a href="https://0xax.gitbook.io/linux-insides/summary/syscall">chapter</a> about system calls. If we look at the implementation of the <code>nanosleep</code> system call, first of all we will see that it starts from the call of the <code>copy_from_user</code> function. This function copies the given data from the userspace to kernelspace. In our case we copy timeout value to sleep to the kernelspace <code>timespec</code> structure and check that the given <code>timespec</code> is valid by the call of the <code>timesc_valid</code> function:</p>
<pre><code class="language-C">static inline bool timespec_valid(const struct timespec *ts)
{
	if (ts-&gt;tv_sec &lt; 0)
		return false;
	if ((unsigned long)ts-&gt;tv_nsec &gt;= NSEC_PER_SEC)
		return false;
	return true;
}
</code></pre>
<p>which just checks that the given <code>timespec</code> does not represent date before <code>1970</code> and nanoseconds does not overflow <code>1</code> second. The <code>nanosleep</code> function ends with the call of the <code>hrtimer_nanosleep</code> function from the same source code file. The <code>hrtimer_nanosleep</code> function creates a <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-4">timer</a> and calls the <code>do_nanosleep</code> function. The <code>do_nanosleep</code> does main job for us. This function provides loop:</p>
<pre><code class="language-C">do {
	set_current_state(TASK_INTERRUPTIBLE);
	hrtimer_start_expires(&amp;t-&gt;timer, mode);

	if (likely(t-&gt;task))
		freezable_schedule();
    
} while (t-&gt;task &amp;&amp; !signal_pending(current));

__set_current_state(TASK_RUNNING);
return t-&gt;task == NULL;
</code></pre>
<p>Which freezes current task during sleep. After we set <code>TASK_INTERRUPTIBLE</code> flag for the current task, the <code>hrtimer_start_expires</code> function starts the give high-resolution timer on the current processor. As the given high resolution timer will expire, the task will be again running.</p>
<p>That's all.</p>
<h2 id="conclusion-38"><a class="header" href="#conclusion-38">Conclusion</a></h2>
<p>This is the end of the seventh part of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> that describes timers and timer management related stuff in the Linux kernel. In the previous part we saw <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> specific clock sources. As I wrote in the beginning, this part is the last part of this chapter. We saw important time management related concepts like <code>clocksource</code> and <code>clockevents</code> frameworks, <code>jiffies</code> counter and etc., in this chpater. Of course this does not cover all of the time management in the Linux kernel. Many parts of this mostly related to the scheduling which we will see in other chapter. </p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-38"><a class="header" href="#links-38">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/System_call">system call</a></li>
<li><a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C programming language</a></li>
<li><a href="https://en.wikipedia.org/wiki/Standard_library">standard library</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_C_Library">glibc</a></li>
<li><a href="https://en.wikipedia.org/wiki/Real-time_clock">real time clock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">NTP</a></li>
<li><a href="https://en.wikipedia.org/wiki/Nanosecond">nanoseconds</a></li>
<li><a href="https://en.wikipedia.org/wiki/Processor_register">register</a></li>
<li><a href="http://www.x86-64.org/documentation/abi.pdf">System V Application Binary Interface</a></li>
<li><a href="https://en.wikipedia.org/wiki/Context_switch">context switch</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-4">Introduction to timers in the Linux kernel</a></li>
<li><a href="https://en.wikipedia.org/wiki/Uptime#Using_uptime">uptime</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/entry/syscalls/syscall_64.tbl">system calls table for x86_64</a></li>
<li><a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a></li>
<li><a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-6">previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronization-primitives-in-the-linux-kernel"><a class="header" href="#synchronization-primitives-in-the-linux-kernel">Synchronization primitives in the Linux kernel.</a></h1>
<p>This chapter describes synchronization primitives in the Linux kernel.</p>
<ul>
<li><a href="SyncPrim/linux-sync-1.html">Introduction to spinlocks</a> - the first part of this chapter describes implementation of spinlock mechanism in the Linux kernel.</li>
<li><a href="SyncPrim/linux-sync-2.html">Queued spinlocks</a> - the second part describes another type of spinlocks - queued spinlocks.</li>
<li><a href="SyncPrim/linux-sync-3.html">Semaphores</a> - this part describes implementation of <code>semaphore</code> synchronization primitive in the Linux kernel.</li>
<li><a href="SyncPrim/linux-sync-4.html">Mutual exclusion</a> - this part describes - <code>mutex</code> in the Linux kernel.</li>
<li><a href="SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a> - this part describes special type of semaphores - <code>reader/writer</code> semaphores.</li>
<li><a href="SyncPrim/linux-sync-6.html">Sequential locks</a> - this part describes sequential locks in the Linux kernel.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronization-primitives-in-the-linux-kernel-part-1"><a class="header" href="#synchronization-primitives-in-the-linux-kernel-part-1">Synchronization primitives in the Linux kernel. Part 1.</a></h1>
<h2 id="introduction-5"><a class="header" href="#introduction-5">Introduction</a></h2>
<p>This part opens a new chapter in the <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">linux-insides</a> book. Timers and time management related stuff was described in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a>. Now it's time to move on to the next topic. As you probably recognized from the title, this chapter will describe the <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization</a> primitives in the Linux kernel.</p>
<p>As always, we will try to know what a <code>synchronization primitive</code> in general is before we deal with any synchronization-related issues. Actually, a synchronization primitive is a software mechanism, that ensures that two or more <a href="https://en.wikipedia.org/wiki/Parallel_computing">parallel</a> processes or threads are not running simultaneously on the same code segment. For example, let's look at the following piece of code:</p>
<pre><code class="language-C">mutex_lock(&amp;clocksource_mutex);
...
...
...
clocksource_enqueue(cs);
clocksource_enqueue_watchdog(cs);
clocksource_select();
...
...
...
mutex_unlock(&amp;clocksource_mutex);
</code></pre>
<p>from the <a href="https://github.com/torvalds/linux/blob/master/kernel/time/clocksource.c">kernel/time/clocksource.c</a> source code file. This code is from the <code>__clocksource_register_scale</code> function which adds the given <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-2">clocksource</a> to the clock sources list. This function produces different operations on a list with registered clock sources. For example, the <code>clocksource_enqueue</code> function adds the given clock source to the list with registered clocksources - <code>clocksource_list</code>. Note that these lines of code wrapped to two functions: <code>mutex_lock</code> and <code>mutex_unlock</code> which takes one parameter - the <code>clocksource_mutex</code> in our case.</p>
<p>These functions represent locking and unlocking based on <a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a> synchronization primitive. As <code>mutex_lock</code> will be executed, it allows us to prevent the situation when two or more threads will execute this code while the <code>mutex_unlock</code> will not be executed by process-owner of the mutex. In other words, we prevent parallel operations on a <code>clocksource_list</code>. Why do we need <code>mutex</code> here? What if two parallel processes will try to register a clock source. As we already know, the <code>clocksource_enqueue</code> function adds the given clock source to the <code>clocksource_list</code> list right after a clock source in the list which has the biggest rating (a registered clock source which has the highest frequency in the system):</p>
<pre><code class="language-C">static void clocksource_enqueue(struct clocksource *cs)
{
	struct list_head *entry = &amp;clocksource_list;
	struct clocksource *tmp;

	list_for_each_entry(tmp, &amp;clocksource_list, list) {
		if (tmp-&gt;rating &lt; cs-&gt;rating)
			break;
		entry = &amp;tmp-&gt;list;
	}
	list_add(&amp;cs-&gt;list, entry);
}
</code></pre>
<p>If two parallel processes will try to do it simultaneously, both process may found the same <code>entry</code> may occur <a href="https://en.wikipedia.org/wiki/Race_condition">race condition</a> or in other words, the second process which will execute <code>list_add</code>, will overwrite a clock source from the first thread.</p>
<p>Besides this simple example, synchronization primitives are ubiquitous in the Linux kernel. If we will go through the previous <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> or other chapters again or if we will look at the Linux kernel source code in general, we will meet many places like this. We will not consider how <code>mutex</code> is implemented in the Linux kernel. Actually, the Linux kernel provides a set of different synchronization primitives like:</p>
<ul>
<li><code>mutex</code>;</li>
<li><code>semaphores</code>; </li>
<li><code>seqlocks</code>;</li>
<li><code>atomic operations</code>;</li>
<li>etc.</li>
</ul>
<p>We will start this chapter from the <code>spinlock</code>.</p>
<h2 id="spinlocks-in-the-linux-kernel"><a class="header" href="#spinlocks-in-the-linux-kernel">Spinlocks in the Linux kernel.</a></h2>
<p>The <code>spinlock</code> is a low-level synchronization mechanism which in simple words, represents a variable which can be in two states:</p>
<ul>
<li><code>acquired</code>;</li>
<li><code>released</code>.</li>
</ul>
<p>Each process which wants to acquire a <code>spinlock</code>, must write a value which represents <code>spinlock acquired</code> state to this variable and write <code>spinlock released</code> state to the variable. If a process tries to execute code which is protected by a <code>spinlock</code>, it will be locked while a process which holds this lock will release it. In this case all related operations must be <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a> to prevent <a href="https://en.wikipedia.org/wiki/Race_condition">race conditions</a> state. The <code>spinlock</code> is represented by the <code>spinlock_t</code> type in the Linux kernel. If we will look at the Linux kernel code, we will see that this type is <a href="http://lxr.free-electrons.com/ident?i=spinlock_t">widely</a> used. The <code>spinlock_t</code> is defined as:</p>
<pre><code class="language-C">typedef struct spinlock {
        union {
              struct raw_spinlock rlock;
 
#ifdef CONFIG_DEBUG_LOCK_ALLOC
# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))
                struct {
                        u8 __padding[LOCK_PADSIZE];
                        struct lockdep_map dep_map;
                };
#endif
        };
} spinlock_t;
</code></pre>
<p>and located in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/spinlock_types.h">include/linux/spinlock_types.h</a> header file. We may see that its implementation depends on the state of the <code>CONFIG_DEBUG_LOCK_ALLOC</code> kernel configuration option. We will skip this now, because all debugging related stuff will be in the end of this part. So, if the <code>CONFIG_DEBUG_LOCK_ALLOC</code> kernel configuration option is disabled, the <code>spinlock_t</code> contains <a href="https://en.wikipedia.org/wiki/Union_type#C.2FC.2B.2B">union</a> with one field which is - <code>raw_spinlock</code>:</p>
<pre><code class="language-C">typedef struct spinlock {
        union {
              struct raw_spinlock rlock;
        };
} spinlock_t;
</code></pre>
<p>The <code>raw_spinlock</code> structure defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/spinlock_types.h">same</a> header file represents the implementation of <code>normal</code> spinlock. Let's look how the <code>raw_spinlock</code> structure is defined:</p>
<pre><code class="language-C">typedef struct raw_spinlock {
        arch_spinlock_t raw_lock;
#ifdef CONFIG_DEBUG_SPINLOCK
	unsigned int magic, owner_cpu;
	void *owner;
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	struct lockdep_map dep_map;
#endif
} raw_spinlock_t;
</code></pre>
<p>where the <code>arch_spinlock_t</code> represents architecture-specific <code>spinlock</code> implementation. As we mentioned above, we will skip debugging kernel configuration options. As we focus on <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture in this book, the <code>arch_spinlock_t</code> that we will consider is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/asm-generic/qspinlock_types.h">include/asm-generic/qspinlock_types.h</a> header file and looks:</p>
<pre><code class="language-C">typedef struct qspinlock {
        union {
		atomic_t val;
		struct {
			u8	locked;
			u8	pending;
		};
		struct {
			u16	locked_pending;
			u16	tail;
		};
        };
} arch_spinlock_t;
</code></pre>
<p>We will not stop on this structures for now. Let's look at the operations on a <code>spinlock</code>. The Linux kernel provides following main operations on a <code>spinlock</code>:</p>
<ul>
<li><code>spin_lock_init</code> - produces initialization of the given <code>spinlock</code>;</li>
<li><code>spin_lock</code> - acquires given <code>spinlock</code>;</li>
<li><code>spin_lock_bh</code> - disables software <a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a> and acquire given <code>spinlock</code>;</li>
<li><code>spin_lock_irqsave</code> and <code>spin_lock_irq</code> - disable interrupts on local processor, preserve/not preserve previous interrupt state in the <code>flags</code> and acquire given <code>spinlock</code>;</li>
<li><code>spin_unlock</code> - releases given <code>spinlock</code>;</li>
<li><code>spin_unlock_bh</code> - releases given <code>spinlock</code> and enables software interrupts;</li>
<li><code>spin_is_locked</code> - returns the state of the given <code>spinlock</code>;</li>
<li>and etc.</li>
</ul>
<p>Let's look on the implementation of the <code>spin_lock_init</code> macro. As I already wrote, this and other macro are defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/spinlock.h">include/linux/spinlock.h</a> header file and the <code>spin_lock_init</code> macro looks:</p>
<pre><code class="language-C">#define spin_lock_init(_lock)			\
do {						\
	spinlock_check(_lock);		        \
	raw_spin_lock_init(&amp;(_lock)-&gt;rlock);	\
} while (0)
</code></pre>
<p>As we may see, the <code>spin_lock_init</code> macro takes a <code>spinlock</code> and executes two operations: check the given <code>spinlock</code> and execute the <code>raw_spin_lock_init</code>. The implementation of the <code>spinlock_check</code> is pretty easy, this function just returns the <code>raw_spinlock_t</code> of the given <code>spinlock</code> to be sure that we got exactly <code>normal</code> raw spinlock:</p>
<pre><code class="language-C">static __always_inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
	return &amp;lock-&gt;rlock;
}
</code></pre>
<p>The <code>raw_spin_lock_init</code> macro:</p>
<pre><code class="language-C"># define raw_spin_lock_init(lock)		\
do {						\
    *(lock) = __RAW_SPIN_LOCK_UNLOCKED(lock);	\
} while (0)					\
</code></pre>
<p>assigns the value of the <code>__RAW_SPIN_LOCK_UNLOCKED</code> with the given <code>spinlock</code> to the given <code>raw_spinlock_t</code>. As we may understand from the name of the <code>__RAW_SPIN_LOCK_UNLOCKED</code> macro, this macro does initialization of the given <code>spinlock</code> and set it to <code>released</code> state. This macro is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/spinlock_types.h">include/linux/spinlock_types.h</a> header file and expands to the following macros:</p>
<pre><code class="language-C">#define __RAW_SPIN_LOCK_UNLOCKED(lockname)      \
         (raw_spinlock_t) __RAW_SPIN_LOCK_INITIALIZER(lockname)

#define __RAW_SPIN_LOCK_INITIALIZER(lockname)			\
         {                                                      \
             .raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,             \
             SPIN_DEBUG_INIT(lockname)                          \
             SPIN_DEP_MAP_INIT(lockname)                        \
         }
</code></pre>
<p>As I already wrote above, we will not consider stuff which is related to debugging of synchronization primitives. In this case we will not consider the <code>SPIN_DEBUG_INIT</code> and the <code>SPIN_DEP_MAP_INIT</code> macros. So the <code>__RAW_SPINLOCK_UNLOCKED</code> macro will be expanded to the:</p>
<pre><code class="language-C">*(&amp;(_lock)-&gt;rlock) = __ARCH_SPIN_LOCK_UNLOCKED;
</code></pre>
<p>where the <code>__ARCH_SPIN_LOCK_UNLOCKED</code> is:</p>
<pre><code class="language-C">#define __ARCH_SPIN_LOCK_UNLOCKED       { { .val = ATOMIC_INIT(0) } }
</code></pre>
<p>for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture. So, after the expansion of the <code>spin_lock_init</code> macro, a given <code>spinlock</code> will be initialized and its state will be - <code>unlocked</code>.</p>
<p>From this moment we know how to initialize a <code>spinlock</code>, now let's consider <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> which Linux kernel provides for manipulations of <code>spinlocks</code>. The first is:</p>
<pre><code class="language-C">static __always_inline void spin_lock(spinlock_t *lock)
{
	raw_spin_lock(&amp;lock-&gt;rlock);
}
</code></pre>
<p>function which allows us to <code>acquire</code> a <code>spinlock</code>. The <code>raw_spin_lock</code> macro is defined in the same header file and expands to the call of <code>_raw_spin_lock</code>:</p>
<pre><code class="language-C">#define raw_spin_lock(lock)	_raw_spin_lock(lock)
</code></pre>
<p>Where <code>_raw_spin_lock</code> is defined depends on whether <code>CONFIG_SMP</code> option is set and <code>CONFIG_INLINE_SPIN_LOCK</code> option is set. If the <a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a> is disabled, <code>_raw_spin_lock</code> is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/spinlock_api_up.h">include/linux/spinlock_api_up.h</a> header file as a macro and looks like:</p>
<pre><code class="language-C">#define _raw_spin_lock(lock)	__LOCK(lock)
</code></pre>
<p>If the SMP is enabled and <code>CONFIG_INLINE_SPIN_LOCK</code> is set, it is defined in <a href="https://github.com/torvalds/linux/blob/master/include/linux/spinlock_api_smp.h">include/linux/spinlock_api_smp.h</a> header file as the following:</p>
<pre><code class="language-C">#define _raw_spin_lock(lock) __raw_spin_lock(lock)
</code></pre>
<p>If the SMP is enabled and <code>CONFIG_INLINE_SPIN_LOCK</code> is not set, it is defined in <a href="https://github.com/torvalds/linux/blob/master/kernel/locking/spinlock.c">kernel/locking/spinlock.c</a> source code file as the following:</p>
<pre><code class="language-C">void __lockfunc _raw_spin_lock(raw_spinlock_t *lock)
{
	__raw_spin_lock(lock);
}
</code></pre>
<p>Here we will consider the latter form of <code>_raw_spin_lock</code>. The <code>__raw_spin_lock</code> function looks:</p>
<pre><code class="language-C">static inline void __raw_spin_lock(raw_spinlock_t *lock)
{
        preempt_disable();
        spin_acquire(&amp;lock-&gt;dep_map, 0, 0, _RET_IP_);
        LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);
}
</code></pre>
<p>As you may see, first of all we disable <a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29">preemption</a> by the call of the <code>preempt_disable</code> macro from the <a href="https://github.com/torvalds/linux/blob/master/include/linux/preempt.h">include/linux/preempt.h</a> (more about this you may read in the ninth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-9">part</a> of the Linux kernel initialization process chapter). When we unlock the given <code>spinlock</code>, preemption will be enabled again:</p>
<pre><code class="language-C">static inline void __raw_spin_unlock(raw_spinlock_t *lock)
{
        ...
        ...
        ...
        preempt_enable();
}
</code></pre>
<p>We need to do this to prevent the process from other processes to preempt it while it is spinning on a lock. The <code>spin_acquire</code> macro which through a chain of other macros expands to the call of the:</p>
<pre><code class="language-C">#define spin_acquire(l, s, t, i)                lock_acquire_exclusive(l, s, t, NULL, i)
#define lock_acquire_exclusive(l, s, t, n, i)           lock_acquire(l, s, t, 0, 1, n, i)
</code></pre>
<p>The <code>lock_acquire</code> function:</p>
<pre><code class="language-C">void lock_acquire(struct lockdep_map *lock, unsigned int subclass,
                  int trylock, int read, int check,
                  struct lockdep_map *nest_lock, unsigned long ip)
{
         unsigned long flags;

         if (unlikely(current-&gt;lockdep_recursion))
                return;
 
         raw_local_irq_save(flags);
         check_flags(flags);
 
         current-&gt;lockdep_recursion = 1;
         trace_lock_acquire(lock, subclass, trylock, read, check, nest_lock, ip);
         __lock_acquire(lock, subclass, trylock, read, check,
                        irqs_disabled_flags(flags), nest_lock, ip, 0, 0);
         current-&gt;lockdep_recursion = 0;
         raw_local_irq_restore(flags);
}
</code></pre>
<p>As I wrote above, we will not consider stuff here which is related to debugging or tracing. The main point of the <code>lock_acquire</code> function is to disable hardware interrupts by the call of the <code>raw_local_irq_save</code> macro, because the given spinlock might be acquired with enabled hardware interrupts. In this way the process will not be preempted. Note that in the end of the <code>lock_acquire</code> function we will enable hardware interrupts again with the help of the <code>raw_local_irq_restore</code> macro. As you already may guess, the main work will be in the <code>__lock_acquire</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/locking/lockdep.c">kernel/locking/lockdep.c</a> source code file.</p>
<p>The <code>__lock_acquire</code> function looks big. We will try to understand what this function does, but not in this part. Actually this function is mostly related to the Linux kernel <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a> and it is not topic of this part. If we will return to the definition of the <code>__raw_spin_lock</code> function, we will see that it contains the following definition in the end:</p>
<pre><code class="language-C">LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);
</code></pre>
<p>The <code>LOCK_CONTENDED</code> macro is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/lockdep.h">include/linux/lockdep.h</a> header file and just calls the given function with the given <code>spinlock</code>:</p>
<pre><code class="language-C">#define LOCK_CONTENDED(_lock, try, lock) \
         lock(_lock)
</code></pre>
<p>In our case, the <code>lock</code> is <code>do_raw_spin_lock</code> function from the <a href="https://github.com/torvalds/linux/blob/master/include/linux/spnlock.h">include/linux/spinlock.h</a> header file and the <code>_lock</code> is the given <code>raw_spinlock_t</code>:</p>
<pre><code class="language-C">static inline void do_raw_spin_lock(raw_spinlock_t *lock) __acquires(lock)
{
        __acquire(lock);
         arch_spin_lock(&amp;lock-&gt;raw_lock);
}
</code></pre>
<p>The <code>__acquire</code> here is just <a href="https://en.wikipedia.org/wiki/Sparse">Sparse</a> related macro and we are not interested in it in this moment. The <code>arch_spin_lock</code> macro is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/asm-generic/qspinlocks.h">include/asm-generic/qspinlock.h</a> header file as the following:</p>
<pre><code class="language-C">#define arch_spin_lock(l)               queued_spin_lock(l)
</code></pre>
<p>We stop here for this part. In the next part, we'll dive into how queued spinlocks works and related concepts.</p>
<h2 id="conclusion-39"><a class="header" href="#conclusion-39">Conclusion</a></h2>
<p>This concludes the first part covering synchronization primitives in the Linux kernel. In this part, we met first synchronization primitive <code>spinlock</code> provided by the Linux kernel. In the next part we will continue to dive into this interesting theme and will see other <code>synchronization</code> related stuff.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-39"><a class="header" href="#links-39">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Concurrent_computing">Concurrent computing</a></li>
<li><a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">Synchronization</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-2">Clocksource framework</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mutual_exclusion">Mutex</a></li>
<li><a href="https://en.wikipedia.org/wiki/Race_condition">Race condition</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linearizability">Atomic operations</a></li>
<li><a href="https://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> </li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt">Interrupts</a></li>
<li><a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29">Preemption</a> </li>
<li><a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">Linux kernel lock validator</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sparse">Sparse</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_327.html">xadd instruction</a></li>
<li><a href="https://en.wikipedia.org/wiki/NOP">NOP</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt">Memory barriers</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/">Previous chapter</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronization-primitives-in-the-linux-kernel-part-2"><a class="header" href="#synchronization-primitives-in-the-linux-kernel-part-2">Synchronization primitives in the Linux kernel. Part 2.</a></h1>
<h2 id="queued-spinlocks"><a class="header" href="#queued-spinlocks">Queued Spinlocks</a></h2>
<p>This is the second part of the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim">chapter</a> which describes synchronization primitives in the Linux kernel.  In the first <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">part</a> of this chapter we meet the first <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a>. We will continue to learn about this synchronization primitive here. If you have read the previous part, you may remember that besides normal spinlocks, the Linux kernel provides a special type of <code>spinlocks</code> - <code>queued spinlocks</code>. Here we will try to understand what this concept represents.</p>
<p>We saw the <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> of <code>spinlock</code> in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">part</a>:</p>
<ul>
<li><code>spin_lock_init</code> - produces initialization of the given <code>spinlock</code>;</li>
<li><code>spin_lock</code> - acquires given <code>spinlock</code>;</li>
<li><code>spin_lock_bh</code> - disables software <a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a> and acquire given <code>spinlock</code>;</li>
<li><code>spin_lock_irqsave</code> and <code>spin_lock_irq</code> - disable interrupts on local processor and preserve/not preserve previous interrupt state in the <code>flags</code>;</li>
<li><code>spin_unlock</code> - releases given <code>spinlock</code> and acquire given <code>spinlock</code>;</li>
<li><code>spin_unlock_bh</code> - releases given <code>spinlock</code> and enables software interrupts;</li>
<li><code>spin_is_locked</code> - returns the state of the given <code>spinlock</code>;</li>
<li>and etc.</li>
</ul>
<p>And we know that all of these macros with the <code>arch_*</code> prefix which are defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/spinlock.h">include/linux/spinlock.h</a> header file will be expanded to the call of the functions  from the <a href="https://github.com/torvalds/linux/blob/master/include/asm-generic/qspinlock.h">include/asm-generic/qspinlock.h</a>:</p>
<pre><code class="language-C">#define arch_spin_is_locked(l)          queued_spin_is_locked(l)
#define arch_spin_is_contended(l)       queued_spin_is_contended(l)
#define arch_spin_value_unlocked(l)     queued_spin_value_unlocked(l)
#define arch_spin_lock(l)               queued_spin_lock(l)
#define arch_spin_trylock(l)            queued_spin_trylock(l)
#define arch_spin_unlock(l)             queued_spin_unlock(l)
</code></pre>
<p>Before we consider how queued spinlocks and their <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> are implemented, let's first take a look at the theory.</p>
<h2 id="introduction-to-queued-spinlocks"><a class="header" href="#introduction-to-queued-spinlocks">Introduction to queued spinlocks</a></h2>
<p>Queued spinlocks is a <a href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29">locking mechanism</a> in the Linux kernel which is replacement for the standard <code>spinlocks</code>. At least this is true for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture. If we will look at the following kernel configuration file - <a href="https://github.com/torvalds/linux/blob/master/kernel/Kconfig.locks">kernel/Kconfig.locks</a>, we will see following configuration entries:</p>
<pre><code>config ARCH_USE_QUEUED_SPINLOCKS
	bool

config QUEUED_SPINLOCKS
	def_bool y if ARCH_USE_QUEUED_SPINLOCKS
	depends on SMP
</code></pre>
<p>This means that the <code>CONFIG_QUEUED_SPINLOCKS</code> kernel configuration option will be enabled by default if the <code>ARCH_USE_QUEUED_SPINLOCKS</code> is enabled. We may see that the <code>ARCH_USE_QUEUED_SPINLOCKS</code> is enabled by default in the <code>x86_64</code> specific kernel configuration file - <a href="https://github.com/torvalds/linux/blob/master/arch/x86/Kconfig">arch/x86/Kconfig</a>:</p>
<pre><code>config X86
    ...
    ...
    ...
    select ARCH_USE_QUEUED_SPINLOCKS
    ...
    ...
    ...
</code></pre>
<p>Before we start to consider what queued spinlock concept is, let's look on other types of <code>spinlocks</code>. For the start let's consider how a <code>normal</code> spinlock is implemented. Usually, the implementation of a <code>normal</code> spinlock is based on the <a href="https://en.wikipedia.org/wiki/Test-and-set">test and set</a> instruction. The principle of how this instruction works is pretty simple. It writes a value to the memory location and returns the old value from it. Together these instructions are atomic i.e. non-interruptible instructions. So if the first thread starts to execute this instruction, second thread will wait until the first processor has finished its instruction. A basic lock can be built on top of this mechanism. Schematically it may look like this:</p>
<pre><code class="language-C">int lock(lock)
{
    while (test_and_set(lock) == 1)
        ;
    return 0;
}

int unlock(lock)
{
    lock=0;

    return lock;
}
</code></pre>
<p>The first thread will execute the <code>test_and_set</code> which will set the <code>lock</code> to <code>1</code>. When the second thread calls the <code>lock</code> function, it will spin in the <code>while</code> loop, until the first thread calls the <code>unlock</code> function and the <code>lock</code> will be equal to <code>0</code>. This implementation is not very good for performance reasons, due to (at least) two problems. The first problem is that this implementation may be unfair since other threads which arrived later at the lock may acquire it first. The second problem is that all threads which want to acquire a lock must execute many <code>atomic</code> operations like <code>test_and_set</code> on a variable which is in shared memory. This leads to the cache invalidation as the cache of the processor will store <code>lock=1</code>, but the value of the <code>lock</code> in memory may not be <code>1</code> after a thread will release this lock.</p>
<p>The topic of this part is <code>queued spinlocks</code>. This approach may help to solve both of these problems. The <code>queued spinlocks</code> allows each processor to spin while checking its own memory location. The basic principle of a queue-based spinlock can best be understood by studying a classic queue-based spinlock implementation called the <a href="http://www.cs.rochester.edu/%7Escott/papers/1991_TOCS_synch.pdf">MCS</a> lock. Before we look at implementation of the <code>queued spinlocks</code> in the Linux kernel, we will try to understand how <code>MCS</code> lock works.</p>
<p>The basic idea of the <code>MCS</code> lock is that a thread spins on a local variable and each processor in the system has its own copy of this variable (see the previous paragraph). In other words this concept is built on top of the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> variables concept in the Linux kernel.</p>
<p>When the first thread wants to acquire a lock, it registers itself in the <code>queue</code>. In other words it will be added to the special <code>queue</code> and will acquire lock, because it is free for now. When the second thread wants to acquire the same lock before the first thread releases it, this thread adds its own copy of the lock variable into this <code>queue</code>. In this case the first thread will contain a <code>next</code> field which will point to the second thread. From this moment, the second thread will wait until the first thread releases its lock and notifies <code>next</code> thread about this event. The first thread will be deleted from the <code>queue</code> and the second thread will be owner of a lock.</p>
<p>Schematically we can represent it like:</p>
<p>Empty queue:</p>
<pre><code>+---------+
|         |
|  Queue  |
|         |
+---------+
</code></pre>
<p>First thread tries to acquire a lock:</p>
<pre><code>+---------+     +----------------------------+
|         |     |                            |
|  Queue  |----&gt;| First thread acquired lock |
|         |     |                            |
+---------+     +----------------------------+
</code></pre>
<p>Second thread tries to acquire a lock:</p>
<pre><code>+---------+     +----------------------------------------+     +-------------------------+
|         |     |                                        |     |                         |
|  Queue  |----&gt;|  Second thread waits for first thread  |&lt;----| First thread holds lock |
|         |     |                                        |     |                         |
+---------+     +----------------------------------------+     +-------------------------+
</code></pre>
<p>Or the pseudocode:</p>
<pre><code class="language-C">void lock(...)
{
    lock.next = NULL;
    ancestor = put_lock_to_queue_and_return_ancestor(queue, lock);

    // if we have ancestor, the lock is already acquired and we
    // need to wait until it is released
    if (ancestor)
    {
        lock.is_locked = 1;
        ancestor.next = lock;

        while (lock.is_locked == true)
            ;
    }

    // otherwise we are owner of the lock and may exit
}

void unlock(...)
{
    // do we need to notify somebody or we are alone in the
    // queue?
    if (lock.next != NULL) {
        // the while loop from the lock() function will be
        // finished
        lock.next.is_locked = false;
    }

    // So, we have no next threads in the queue to notify about
    // lock releasing event. Let's just put `0` to the lock, will
    // delete ourself from the queue and exit.
}
</code></pre>
<p>That's all we'll say about the theory of the <code>queued spinlocks</code>.  Now let's consider how this mechanism is implemented in the Linux kernel. Unlike above pseudocode, the implementation of the <code>queued spinlocks</code> looks complex and tangled. But the study with attention will lead to success.</p>
<h2 id="api-of-queued-spinlocks"><a class="header" href="#api-of-queued-spinlocks">API of queued spinlocks</a></h2>
<p>Now that we know a little about <code>queued spinlocks</code> from the theoretical side, it's time to see the implementation of this mechanism in the Linux kernel. As we saw above, the <a href="https://github.com/torvalds/linux/blob/master/include/asm-generic/qspinlock.h">include/asm-generic/qspinlock.h</a> header file provides a set of macros which represents the API for a spinlock acquiring, releasing, etc:</p>
<pre><code class="language-C">#define arch_spin_is_locked(l)          queued_spin_is_locked(l)
#define arch_spin_is_contended(l)       queued_spin_is_contended(l)
#define arch_spin_value_unlocked(l)     queued_spin_value_unlocked(l)
#define arch_spin_lock(l)               queued_spin_lock(l)
#define arch_spin_trylock(l)            queued_spin_trylock(l)
#define arch_spin_unlock(l)             queued_spin_unlock(l)
</code></pre>
<p>All of these macros expand to the call of functions from the same header file. Additionally, we saw the <code>qspinlock</code> structure from the <a href="https://github.com/torvalds/linux/blob/master/include/asm-generic/qspinlock_types.h">include/asm-generic/qspinlock_types.h</a> header file which represents a queued spinlock in the Linux kernel:</p>
<pre><code class="language-C">typedef struct qspinlock {
	union {
		atomic_t val;

		struct {
			u8	locked;
			u8	pending;
		};
		struct {
			u16	locked_pending;
			u16	tail;
		};
	};
} arch_spinlock_t;
</code></pre>
<p>The <code>val</code> field represents the state of a given <code>spinlock</code>. This <code>4</code> bytes field consists from following parts:</p>
<ul>
<li><code>0-7</code> - locked byte;</li>
<li><code>8</code> - pending bit;</li>
<li><code>9-15</code> - not used;</li>
<li><code>16-17</code> - two bit index which represents entry of the <code>per-cpu</code> array of the <code>MCS</code> lock (will see it soon);</li>
<li><code>18-31</code> - contains number of processor which indicates tail of the queue.</li>
</ul>
<p>Before we move on to consider the <code>API</code> of <code>queued spinlocks</code>, notice the <code>val</code> field of the <code>qspinlock</code> structure has type - <code>atomic_t</code> which represents atomic variable aka a &quot;one operation at a time&quot; variable. So, all operations with this field will be <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a>. For example let's look at the reading value of the <code>val</code> API:</p>
<pre><code class="language-C">static __always_inline int queued_spin_is_locked(struct qspinlock *lock)
{
	return atomic_read(&amp;lock-&gt;val);
}
</code></pre>
<p>Ok, now we know data structures which represents queued spinlock in the Linux kernel and now is the time to look at the implementation of the main function from the <code>queued spinlocks</code> <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a>:</p>
<pre><code class="language-C">#define arch_spin_lock(l)               queued_spin_lock(l)
</code></pre>
<p>Yes, this function is - <code>queued_spin_lock</code>. As we may understand from the function's name, it allows a thread to acquire a lock. This function is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/asm-generic/qspinlock_types.h">include/asm-generic/qspinlock_types.h</a> header file and its implementation is:</p>
<pre><code class="language-C">static __always_inline void queued_spin_lock(struct qspinlock *lock)
{
        u32 val;

        val = atomic_cmpxchg_acquire(&amp;lock-&gt;val, 0, _Q_LOCKED_VAL);
        if (likely(val == 0))
                 return;
        queued_spin_lock_slowpath(lock, val);
}
</code></pre>
<p>Looks pretty easy, except for the <code>queued_spin_lock_slowpath</code> function. We see that it takes only one parameter. In our case this parameter represents <code>queued spinlock</code>, which will be locked. Let's consider the situation where <code>queue</code> with locks is empty for now and the first thread wanted to acquire lock. As we may see the <code>queued_spin_lock</code> function starts from the call of the <code>atomic_cmpxchg_acquire</code> macro. As you may guess from its name, it executes atomic <a href="http://x86.renejeschke.de/html/file_module_x86_id_41.html">CMPXCHG</a> instruction. Ultimately, the <code>atomic_cmpxchg_acquire</code> macro expands to the call of the <code>__raw_cmpxchg</code> macro almost like the following:</p>
<pre><code class="language-C">#define __raw_cmpxchg(ptr, old, new, size, lock)		\
({								\
	__typeof__(*(ptr)) __ret;				\
	__typeof__(*(ptr)) __old = (old);			\
	__typeof__(*(ptr)) __new = (new);			\
								\
	volatile u32 *__ptr = (volatile u32 *)(ptr);		\
	asm volatile(lock &quot;cmpxchgl %2,%1&quot;			\
		     : &quot;=a&quot; (__ret), &quot;+m&quot; (*__ptr)		\
		     : &quot;r&quot; (__new), &quot;0&quot; (__old)			\
		     : &quot;memory&quot;);				\
								\
	__ret;							\
})
</code></pre>
<p>which compares the <code>old</code> with the value pointed to by <code>ptr</code>.  If they are equal, it stores the <code>new</code> in the memory location which is pointed by the <code>ptr</code> and returns the initial value in this memory location.</p>
<p>Let's back to the <code>queued_spin_lock</code> function. Assuming that we are the first one who tried to acquire the lock, the <code>val</code> will be zero and we will return from the <code>queued_spin_lock</code> function:</p>
<pre><code class="language-C">	val = atomic_cmpxchg_acquire(&amp;lock-&gt;val, 0, _Q_LOCKED_VAL);
	if (likely(val == 0))
		return;
</code></pre>
<p>So far, we've only considered uncontended case (i.e. fast-path). Now let's consider contended case (i.e. slow-path). Suppose that one thread tried to acquire a lock, but the lock is already held, then <code>queued_spin_lock_slowpath</code> will be called. The <code>queued_spin_lock_slowpath</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/locking/qspinlock.c">kernel/locking/qspinlock.c</a> source code file:</p>
<pre><code class="language-C">void queued_spin_lock_slowpath(struct qspinlock *lock, u32 val)
{
	...
	...
	...
	if (val == _Q_PENDING_VAL) {
		int cnt = _Q_PENDING_LOOPS;
		val = atomic_cond_read_relaxed(&amp;lock-&gt;val,
					       (VAL != _Q_PENDING_VAL) || !cnt--);
	}
	...
	...
	...
}
</code></pre>
<p>which waits for in-progress lock acquisition to be done with a bounded number of spins so that we guarantee forward progress. Above, we saw that the lock contains - pending bit. This bit represents thread which wanted to acquire lock, but it is already acquired by the other thread and <code>queue</code> is empty at the same time. In this case, the pending bit will be set and the <code>queue</code> will not be touched. This is done for optimization, because there are no need in unnecessary latency which will be caused by the cache invalidation in a touching of own <code>mcs_spinlock</code> array.</p>
<p>If we observe contention, then we have no choice other than queueing, so jump to <code>queue</code> label that we'll see later:</p>
<pre><code class="language-C">	if (val &amp; ~_Q_LOCKED_MASK)
		goto queue;
</code></pre>
<p>So, the lock is already held. That is, we set the pending bit of the lock:</p>
<pre><code class="language-C">	val = queued_fetch_set_pending_acquire(lock);
</code></pre>
<p>Again if we observe contention, undo the pending and queue.</p>
<pre><code class="language-C">	if (unlikely(val &amp; ~_Q_LOCKED_MASK)) {
		if (!(val &amp; _Q_PENDING_MASK))
			clear_pending(lock);
		goto queue;
	}
</code></pre>
<p>Now, we're pending, wait for the lock owner to release it.</p>
<pre><code class="language-C">	if (val &amp; _Q_LOCKED_MASK)
		atomic_cond_read_acquire(&amp;)
</code></pre>
<p>We are allowed to take the lock. So, we clear the pending bit and set the locked bit. Now we have nothing to do with the <code>queued_spin_lock_slowpath</code> function, return from it.</p>
<pre><code class="language-C">	clear_pending_set_locked(lock);
	return;
</code></pre>
<p>Before diving into queueing, we'll see about <code>MCS</code> lock mechanism first. As we already know, each processor in the system has own copy of the lock. The lock is represented by the following structure:</p>
<pre><code class="language-C">struct mcs_spinlock {
       struct mcs_spinlock *next;
       int locked;
       int count;
};
</code></pre>
<p>from the <a href="https://github.com/torvalds/linux/blob/master/kernel/locking/mcs_spinlock.h">kernel/locking/mcs_spinlock.h</a> header file. The first field represents a pointer to the next thread in the <code>queue</code>. The second field represents the state of the current thread in the <code>queue</code>, where <code>1</code> is <code>lock</code> already acquired and <code>0</code> in other way. And the last field of the <code>mcs_spinlock</code> structure represents nested locks. To understand what nested lock is, imagine situation when a thread acquired lock, but was interrupted by the hardware <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a> and an <a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt handler</a> tries to take a lock too. For this case, each processor has not just copy of the <code>mcs_spinlock</code> structure but array of these structures:</p>
<pre><code class="language-C">static DEFINE_PER_CPU_ALIGNED(struct qnode, qnodes[MAX_NODES]);
</code></pre>
<p>This array allows to make four attempts of a lock acquisition for the four events in following contexts:</p>
<ul>
<li>normal task context;</li>
<li>hardware interrupt context;</li>
<li>software interrupt context;</li>
<li>non-maskable interrupt context.</li>
</ul>
<p>Notice that we did not touch <code>queue</code> yet. We do not need it, because for two threads it just leads to unnecessary latency for memory access. In other case, the first thread may release it lock before this moment. In this case the <code>lock-&gt;val</code> will contain <code>_Q_LOCKED_VAL | _Q_PENDING_VAL</code> and we will start to build <code>queue</code>. We start to build <code>queue</code> by the getting the local copy of the <code>qnodes</code> array of the processor which executes thread and calculate <code>tail</code> which will indicate the tail of the <code>queue</code> and <code>idx</code> which represents an index of the <code>qnodes</code> array:</p>
<pre><code class="language-C">queue:
	node = this_cpu_ptr(&amp;qnodes[0].mcs);
	idx = node-&gt;count++;
	tail = encode_tail(smp_processer_id(), idx);

	node = grab_mcs_node(node, idx);
</code></pre>
<p>After this, we set <code>locked</code> to zero because this thread didn't acquire lock yet and <code>next</code> to <code>NULL</code> because we don't know anything about other <code>queue</code> entries:</p>
<pre><code class="language-C">	node-&gt;locked = 0;
	node-&gt;next = NULL;
</code></pre>
<p>We already touched <code>per-cpu</code> copy of the queue for the processor which executes current thread which wants to acquire lock, this means that owner of the lock may released it before this moment. So we may try to acquire lock again by the call of the <code>queued_spin_trylock</code> function:</p>
<pre><code class="language-C">	if (queued_spin_trylock(lock))
		goto release;
</code></pre>
<p>It does the almost same thing <code>queued_spin_lock</code> function does.</p>
<p>If the lock was successfully acquired we jump to the <code>release</code> label to release a node of the <code>queue</code>:</p>
<pre><code class="language-C">release:
	__this_cpu_dec(qnodes[0].mcs.count);
</code></pre>
<p>because we no need in it anymore as lock is acquired. If the <code>queued_spin_trylock</code> was unsuccessful, we update tail of the queue:</p>
<pre><code class="language-C">	old = xchg_tail(lock, tail);
	next = NULL;
</code></pre>
<p>and retrieve previous tail. The next step is to check that <code>queue</code> is not empty. In this case we need to link previous entry with the new. While waiting for the MCS lock, the next pointer may have been set by another lock waiter. We optimistically load the next pointer &amp; prefetch the cacheline for writing to reduce latency in the upcoming MCS unlock operation:</p>
<pre><code class="language-C">	if (old &amp; _Q_TAIL_MASK) {
		prev = decode_tail(old);
		WRITE_ONCE(prev-&gt;next, node);

		arch_mcs_spin_lock_contended(&amp;node-&gt;locked);

		next = READ_ONCE(node-&gt;next);
		if (next)
			prefetchw(next);
	}
</code></pre>
<p>If the new node was added, we prefetch cache line from memory pointed by the next queue entry with the <a href="http://www.felixcloutier.com/x86/PREFETCHW.html">PREFETCHW</a> instruction. We preload this pointer now for optimization purpose. We just became a head of queue and this means that there is upcoming <code>MCS</code> unlock operation and the next entry will be touched.</p>
<p>Yes, from this moment we are in the head of the <code>queue</code>. But before we are able to acquire a lock, we need to wait at least two events: current owner of a lock will release it and the second thread with <code>pending</code> bit will acquire a lock too:</p>
<pre><code class="language-C">	val = atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_PENDING_MASK));
</code></pre>
<p>After both threads will release a lock, the head of the <code>queue</code> will hold a lock. In the end we just need to update the tail of the <code>queue</code> and remove current head from it.</p>
<p>That's all.</p>
<h2 id="conclusion-40"><a class="header" href="#conclusion-40">Conclusion</a></h2>
<p>This is the end of the second part of the <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitives</a> chapter in the Linux kernel. In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">part</a> we already met the first synchronization primitive <code>spinlock</code> provided by the Linux kernel which is implemented as <code>ticket spinlock</code>. In this part we saw another implementation of the <code>spinlock</code> mechanism - <code>queued spinlock</code>. In the next part we will continue to dive into synchronization primitives in the Linux kernel.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-40"><a class="header" href="#links-40">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt handler</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a></li>
<li><a href="https://en.wikipedia.org/wiki/Test-and-set">Test and Set</a></li>
<li><a href="http://www.cs.rochester.edu/%7Escott/papers/1991_TOCS_synch.pdf">MCS</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu variables</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linearizability">atomic instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_41.html">CMPXCHG instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">LOCK instruction</a></li>
<li><a href="https://en.wikipedia.org/wiki/NOP">NOP instruction</a></li>
<li><a href="http://www.felixcloutier.com/x86/PREFETCHW.html">PREFETCHW instruction</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronization-primitives-in-the-linux-kernel-part-3"><a class="header" href="#synchronization-primitives-in-the-linux-kernel-part-3">Synchronization primitives in the Linux kernel. Part 3.</a></h1>
<h2 id="semaphores"><a class="header" href="#semaphores">Semaphores</a></h2>
<p>This is the third part of the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim">chapter</a> which describes synchronization primitives in the Linux kernel and in the previous part we saw special type of <a href="https://en.wikipedia.org/wiki/Spinlock">spinlocks</a> - <code>queued spinlocks</code>. The previous <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-2">part</a> was the last part which describes <code>spinlocks</code> related stuff. So we need to go ahead.</p>
<p>The next <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitive</a> after <code>spinlock</code> which we will see in this part is <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a>. We will start from theoretical side and will learn what is it <code>semaphore</code> and only after this, we will see how it is implemented in the Linux kernel as we did in the previous part.</p>
<p>So, let's start.</p>
<h2 id="introduction-to-the-semaphores-in-the-linux-kernel"><a class="header" href="#introduction-to-the-semaphores-in-the-linux-kernel">Introduction to the semaphores in the Linux kernel</a></h2>
<p>So, what is it <code>semaphore</code>? As you may guess - <code>semaphore</code> is yet another mechanism for support of thread or process synchronization. The Linux kernel already provides implementation of one synchronization mechanism - <code>spinlocks</code>, why do we need in yet another one? To answer on this question we need to know details of both of these mechanisms. We already familiar with the <code>spinlocks</code>, so let's start from this mechanism.</p>
<p><code>spinlock</code> creates a lock which will be acquired to protect a shared resource from being modified by more than one process. As a result, other processes that try to acquire the current lock get stopped (aka &quot;spin-in-place&quot; or busy waiting). <a href="https://en.wikipedia.org/wiki/Context_switch">Context switch</a> is not allowed because <a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29">preemption</a> is disabled to avoid <a href="https://en.wikipedia.org/wiki/Deadlock">deadlocks</a>. As a result, <code>spinlock</code> should only be used if the lock will only be acquired for a very short period of time, otherwise amount of busy waiting accumulated by other processes results in extremely inefficient operation. For locks that need to be acquired for a relatively long period of time, we turn to <code>semaphore</code>.</p>
<p><a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphores</a> is a good solution for locks which may be acquired for a long time. In other way this mechanism is not optimal for locks that acquired for a short time. To understand this, we need to know what is <code>semaphore</code>.</p>
<p>As usual synchronization primitive, a <code>semaphore</code> is based on a variable. This variable may be incremented or decremented and it's state will represent ability to acquire lock. Notice that value of the variable is not limited to <code>0</code> and <code>1</code>. There are two types of <code>semaphores</code>:</p>
<ul>
<li><code>binary semaphore</code>;</li>
<li><code>normal semaphore</code>.</li>
</ul>
<p>In the first case, value of <code>semaphore</code> may be only <code>1</code> or <code>0</code>. In the second case value of <code>semaphore</code> any non-negative number. If the value of <code>semaphore</code> is greater than <code>1</code> it is called as <code>counting semaphore</code> and it allows to acquire a lock to more than <code>1</code> process. This allows us to keep records of available resources, when <code>spinlock</code> allows to hold a lock only on one task. Besides all of this, one more important thing that <code>semaphore</code> allows to sleep. Moreover when processes waits for a lock which is acquired by other process, the <a href="https://en.wikipedia.org/wiki/Scheduling_%28computing%29">scheduler</a> may switch on another process.</p>
<h2 id="semaphore-api"><a class="header" href="#semaphore-api">Semaphore API</a></h2>
<p>So, we know a little about <code>semaphores</code> from theoretical side, let's look on its implementation in the Linux kernel. All <code>semaphore</code> <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/semaphore.h">include/linux/semaphore.h</a> header file.</p>
<p>We may see that the <code>semaphore</code> mechanism is represented by the following structure:</p>
<pre><code class="language-C">struct semaphore {
	raw_spinlock_t		lock;
	unsigned int		count;
	struct list_head	wait_list;
};
</code></pre>
<p>in the Linux kernel. The <code>semaphore</code> structure consists of three fields:</p>
<ul>
<li><code>lock</code> - <code>spinlock</code> for a <code>semaphore</code> data protection;</li>
<li><code>count</code> - amount available resources;</li>
<li><code>wait_list</code> - list of processes which are waiting to acquire a lock.</li>
</ul>
<p>Before we will consider an <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> of the <code>semaphore</code> mechanism in the Linux kernel, we need to know how to initialize a <code>semaphore</code>. Actually the Linux kernel provides two approaches to execute initialization of the given <code>semaphore</code> structure. These methods allows to initialize a <code>semaphore</code> in a:</p>
<ul>
<li><code>statically</code>;</li>
<li><code>dynamically</code>.</li>
</ul>
<p>ways. Let's look at the first approach. We are able to initialize a <code>semaphore</code> statically with the <code>DEFINE_SEMAPHORE</code> macro:</p>
<pre><code class="language-C">#define DEFINE_SEMAPHORE(name)  \
         struct semaphore name = __SEMAPHORE_INITIALIZER(name, 1)
</code></pre>
<p>as we may see, the <code>DEFINE_SEMAPHORE</code> macro provides ability to initialize only <code>binary</code> semaphore. The <code>DEFINE_SEMAPHORE</code> macro expands to the definition of the <code>semaphore</code> structure which is initialized with the <code>__SEMAPHORE_INITIALIZER</code> macro. Let's look at the implementation of this macro:</p>
<pre><code class="language-C">#define __SEMAPHORE_INITIALIZER(name, n)              \
{                                                                       \
        .lock           = __RAW_SPIN_LOCK_UNLOCKED((name).lock),        \
        .count          = n,                                            \
        .wait_list      = LIST_HEAD_INIT((name).wait_list),             \
}
</code></pre>
<p>The <code>__SEMAPHORE_INITIALIZER</code> macro takes the name of the future <code>semaphore</code> structure and does initialization of the fields of this structure. First of all we initialize a <code>spinlock</code> of the given <code>semaphore</code> with the <code>__RAW_SPIN_LOCK_UNLOCKED</code> macro. As you may remember from the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">previous</a> parts, the <code>__RAW_SPIN_LOCK_UNLOCKED</code> is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/spinlock_types.h">include/linux/spinlock_types.h</a> header file and expands to the <code>__ARCH_SPIN_LOCK_UNLOCKED</code> macro which just expands to zero or unlocked state:</p>
<pre><code class="language-C">#define __ARCH_SPIN_LOCK_UNLOCKED       { { 0 } }
</code></pre>
<p>The last two fields of the <code>semaphore</code> structure <code>count</code> and <code>wait_list</code> are initialized with the given value which represents count of available resources and empty <a href="https://0xax.gitbook.io/linux-insides/summary/datastructures/linux-datastructures-1">list</a>.</p>
<p>The second way to initialize a <code>semaphore</code> structure is to pass the <code>semaphore</code> and number of available resources to the <code>sema_init</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/semaphore.h">include/linux/semaphore.h</a> header file:</p>
<pre><code class="language-C">static inline void sema_init(struct semaphore *sem, int val)
{
       static struct lock_class_key __key;
       *sem = (struct semaphore) __SEMAPHORE_INITIALIZER(*sem, val);
       lockdep_init_map(&amp;sem-&gt;lock.dep_map, &quot;semaphore-&gt;lock&quot;, &amp;__key, 0);
}
</code></pre>
<p>Let's consider implementation of this function. It looks pretty easy and actually it does almost the same. Thus function executes initialization of the given <code>semaphore</code> with the <code>__SEMAPHORE_INITIALIZER</code> macro which we just saw. As I already wrote in the previous parts of this <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim">chapter</a>, we will skip the stuff which is related to the <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a> of the Linux kernel.</p>
<p>So, from now we are able to initialize a <code>semaphore</code> let's look at how to lock and unlock. The Linux kernel provides following <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> to manipulate <code>semaphores</code>:</p>
<pre><code>void down(struct semaphore *sem);
void up(struct semaphore *sem);
int  down_interruptible(struct semaphore *sem);
int  down_killable(struct semaphore *sem);
int  down_trylock(struct semaphore *sem);
int  down_timeout(struct semaphore *sem, long jiffies);
</code></pre>
<p>The first two functions: <code>down</code> and <code>up</code> are for acquiring and releasing of the given <code>semaphore</code>. The <code>down_interruptible</code> function tries to acquire a <code>semaphore</code>. If this try was successful, the <code>count</code> field of the given <code>semaphore</code> will be decremented and lock will be acquired, in other way the task will be switched to the blocked state or in other words the <code>TASK_INTERRUPTIBLE</code> flag will be set. This <code>TASK_INTERRUPTIBLE</code> flag means that the process may returned to ruined state by <a href="https://en.wikipedia.org/wiki/Unix_signal">signal</a>.</p>
<p>The <code>down_killable</code> function does the same as the <code>down_interruptible</code> function, but set the <code>TASK_KILLABLE</code> flag for the current process. This means that the waiting process may be interrupted by the kill signal.</p>
<p>The <code>down_trylock</code> function is similar on the <code>spin_trylock</code> function. This function tries to acquire a lock and exit if this operation was unsuccessful. In this case the process which wants to acquire a lock, will not wait. The last <code>down_timeout</code> function tries to acquire a lock. It will be interrupted in a waiting state when the given timeout will be expired. Additionally, you may notice that the timeout is in <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-1">jiffies</a></p>
<p>We just saw definitions of the <code>semaphore</code> <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a>. We will start from the <code>down</code> function. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/locking/semaphore.c">kernel/locking/semaphore.c</a> source code file. Let's look on the implementation function:</p>
<pre><code class="language-C">void down(struct semaphore *sem)
{
        unsigned long flags;

        raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);
        if (likely(sem-&gt;count &gt; 0))
                sem-&gt;count--;
        else
                __down(sem);
        raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);
}
EXPORT_SYMBOL(down);
</code></pre>
<p>We may see the definition of the <code>flags</code> variable at the beginning of the <code>down</code> function. This variable will be passed to the <code>raw_spin_lock_irqsave</code> and <code>raw_spin_lock_irqrestore</code> macros which are defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/spinlock.h">include/linux/spinlock.h</a> header file and protect a counter of the given <code>semaphore</code> here. Actually both of these macro do the same that <code>spin_lock</code> and <code>spin_unlock</code> macros, but additionally they save/restore current value of interrupt flags and disables <a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a>.</p>
<p>As you already may guess, the main work is done between the <code>raw_spin_lock_irqsave</code> and <code>raw_spin_unlock_irqrestore</code> macros in the <code>down</code> function. We compare the value of the <code>semaphore</code> counter with zero and if it is bigger than zero, we may decrement this counter. This means that we already acquired the lock. In other way counter is zero. This means that all available resources already finished and we need to wait to acquire this lock. As we may see, the <code>__down</code> function will be called in this case.</p>
<p>The <code>__down</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/locking/semaphore.c">same</a> source code file and its implementation looks:</p>
<pre><code class="language-C">static noinline void __sched __down(struct semaphore *sem)
{
        __down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
}
</code></pre>
<p>The <code>__down</code> function just calls the <code>__down_common</code> function with three parameters:</p>
<ul>
<li><code>semaphore</code>;</li>
<li><code>flag</code> - for the task;</li>
<li><code>timeout</code> - maximum timeout to wait <code>semaphore</code>.</li>
</ul>
<p>Before we will consider implementation of the <code>__down_common</code> function, notice that implementation of the <code>down_trylock</code>, <code>down_timeout</code> and <code>down_killable</code> functions based on the <code>__down_common</code> too:</p>
<pre><code class="language-C">static noinline int __sched __down_interruptible(struct semaphore *sem)
{
        return __down_common(sem, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);
}
</code></pre>
<p>The <code>__down_killable</code>:</p>
<pre><code class="language-C">static noinline int __sched __down_killable(struct semaphore *sem)
{
        return __down_common(sem, TASK_KILLABLE, MAX_SCHEDULE_TIMEOUT);
}
</code></pre>
<p>And the <code>__down_timeout</code>:</p>
<pre><code class="language-C">static noinline int __sched __down_timeout(struct semaphore *sem, long timeout)
{
        return __down_common(sem, TASK_UNINTERRUPTIBLE, timeout);
}
</code></pre>
<p>Now let's look at the implementation of the <code>__down_common</code> function. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/locking/semaphore.c">kernel/locking/semaphore.c</a> source code file too and starts from the definition of the two following local variables:</p>
<pre><code class="language-C">struct task_struct *task = current;
struct semaphore_waiter waiter;
</code></pre>
<p>The first represents current task for the local processor which wants to acquire a lock. The <code>current</code> is a macro which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/current.h">arch/x86/include/asm/current.h</a> header file:</p>
<pre><code class="language-C">#define current get_current()
</code></pre>
<p>Where the <code>get_current</code> function returns value of the <code>current_task</code> <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> variable:</p>
<pre><code class="language-C">DECLARE_PER_CPU(struct task_struct *, current_task);

static __always_inline struct task_struct *get_current(void)
{
        return this_cpu_read_stable(current_task);
}
</code></pre>
<p>The second variable is <code>waiter</code> represents an entry of a <code>semaphore.wait_list</code> list:</p>
<pre><code class="language-C">struct semaphore_waiter {
        struct list_head list;
        struct task_struct *task;
        bool up;
};
</code></pre>
<p>Next we add current task to the <code>wait_list</code> and fill <code>waiter</code> fields after definition of these variables:</p>
<pre><code class="language-C">list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list);
waiter.task = task;
waiter.up = false;
</code></pre>
<p>In the next step we join into the following infinite loop:</p>
<pre><code class="language-C">for (;;) {
        if (signal_pending_state(state, task))
            goto interrupted;

        if (unlikely(timeout &lt;= 0))
            goto timed_out;

        __set_task_state(task, state);

        raw_spin_unlock_irq(&amp;sem-&gt;lock);
        timeout = schedule_timeout(timeout);
        raw_spin_lock_irq(&amp;sem-&gt;lock);

        if (waiter.up)
            return 0;
}
</code></pre>
<p>In the previous piece of code we set <code>waiter.up</code> to <code>false</code>. So, a task will spin in this loop while <code>up</code> will not be set to <code>true</code>. This loop starts from the check that the current task is in the <code>pending</code> state or in other words flags of this task contains <code>TASK_INTERRUPTIBLE</code> or <code>TASK_WAKEKILL</code> flag. As I already wrote above a task may be interrupted by <a href="https://en.wikipedia.org/wiki/Unix_signal">signal</a> during wait of ability to acquire a lock. The <code>signal_pending_state</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/sched.h">include/linux/sched.h</a> source code file and looks:</p>
<pre><code class="language-C">static inline int signal_pending_state(long state, struct task_struct *p)
{
         if (!(state &amp; (TASK_INTERRUPTIBLE | TASK_WAKEKILL)))
                 return 0;
         if (!signal_pending(p))
                 return 0;

         return (state &amp; TASK_INTERRUPTIBLE) || __fatal_signal_pending(p);
}
</code></pre>
<p>We check that the <code>state</code> <a href="https://en.wikipedia.org/wiki/Mask_%28computing%29">bitmask</a> contains <code>TASK_INTERRUPTIBLE</code> or <code>TASK_WAKEKILL</code> bits and if the bitmask does not contain this bit we exit. At the next step we check that the given task has a pending signal and exit if there is not. In the end we just check <code>TASK_INTERRUPTIBLE</code> bit in the <code>state</code> bitmask again or the <a href="https://en.wikipedia.org/wiki/Unix_signal#SIGKILL">SIGKILL</a> signal. So, if our task has a pending signal, we will jump at the <code>interrupted</code> label:</p>
<pre><code class="language-C">interrupted:
    list_del(&amp;waiter.list);
    return -EINTR;
</code></pre>
<p>where we delete task from the list of lock waiters and return the <code>-EINTR</code> <a href="https://en.wikipedia.org/wiki/Errno.h">error code</a>. If a task has no pending signal, we check the given timeout and if it is less or equal zero:</p>
<pre><code class="language-C">if (unlikely(timeout &lt;= 0))
    goto timed_out;
</code></pre>
<p>we jump at the <code>timed_out</code> label:</p>
<pre><code class="language-C">timed_out:
    list_del(&amp;waiter.list);
    return -ETIME;
</code></pre>
<p>Where we do almost the same that we did in the <code>interrupted</code> label. We delete task from the list of lock waiters, but return the <code>-ETIME</code> error code. If a task has no pending signal and the given timeout is not expired yet, the given <code>state</code> will be set in the given task:</p>
<pre><code class="language-C">__set_task_state(task, state);
</code></pre>
<p>and call the <code>schedule_timeout</code> function:</p>
<pre><code class="language-C">raw_spin_unlock_irq(&amp;sem-&gt;lock);
timeout = schedule_timeout(timeout);
raw_spin_lock_irq(&amp;sem-&gt;lock);
</code></pre>
<p>which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/timer.c">kernel/time/timer.c</a> source code file. The <code>schedule_timeout</code> function makes the current task sleep until the given timeout.</p>
<p>That is all about the <code>__down_common</code> function. A task which wants to acquire a lock which is already acquired by another task will be spun in the infinite loop while it will not be interrupted by a signal, the given timeout will not be expired or the task which holds a lock will not release it. Now let's look at the implementation of the <code>up</code> function.</p>
<p>The <code>up</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/locking/semaphore.c">same</a> source code file as <code>down</code> function. As we already know, the main purpose of this function is to release a lock. This function looks:</p>
<pre><code class="language-C">void up(struct semaphore *sem)
{
        unsigned long flags;

        raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);
        if (likely(list_empty(&amp;sem-&gt;wait_list)))
                sem-&gt;count++;
        else
                __up(sem);
        raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);
}
EXPORT_SYMBOL(up);
</code></pre>
<p>It looks almost the same as the <code>down</code> function. There are only two differences here. First of all we increment a counter of a <code>semaphore</code> if the list of waiters is empty. In other way we call the <code>__up</code> function from the same source code file. If the list of waiters is not empty we need to allow the first task from the list to acquire a lock:</p>
<pre><code class="language-C">static noinline void __sched __up(struct semaphore *sem)
{
        struct semaphore_waiter *waiter = list_first_entry(&amp;sem-&gt;wait_list,
                                                struct semaphore_waiter, list);
        list_del(&amp;waiter-&gt;list);
        waiter-&gt;up = true;
        wake_up_process(waiter-&gt;task);
}
</code></pre>
<p>Here we takes the first task from the list of waiters, delete it from the list, set its <code>waiter-up</code> to true. From this point the infinite loop from the <code>__down_common</code> function will be stopped. The <code>wake_up_process</code> function will be called in the end of the <code>__up</code> function. As you remember we called the <code>schedule_timeout</code> function in the infinite loop from the <code>__down_common</code> this function. The <code>schedule_timeout</code> function makes the current task sleep until the given timeout will not be expired. So, as our process may sleep right now, we need to wake it up. That's why we call the <code>wake_up_process</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/sched/core.c">kernel/sched/core.c</a> source code file.</p>
<p>That's all.</p>
<h2 id="conclusion-41"><a class="header" href="#conclusion-41">Conclusion</a></h2>
<p>This is the end of the third part of the <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitives</a> chapter in the Linux kernel. In the two previous parts we already met the first synchronization primitive <code>spinlock</code> provided by the Linux kernel which is implemented as <code>ticket spinlock</code> and used for a very short time locks. In this part we saw yet another synchronization primitive - <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a> which is used for long time locks as it leads to <a href="https://en.wikipedia.org/wiki/Context_switch">context switch</a>. In the next part we will continue to dive into synchronization primitives in the Linux kernel and will see next synchronization primitive - <a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a>.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-41"><a class="header" href="#links-41">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Spinlock">spinlocks</a></li>
<li><a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitive</a></li>
<li><a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a></li>
<li><a href="https://en.wikipedia.org/wiki/Context_switch">context switch</a></li>
<li><a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29">preemption</a></li>
<li><a href="https://en.wikipedia.org/wiki/Deadlock">deadlocks</a></li>
<li><a href="https://en.wikipedia.org/wiki/Scheduling_%28computing%29">scheduler</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/datastructures/linux-datastructures-1">Doubly linked list in the Linux kernel</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-1">jiffies</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt">interrupts</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mask_%28computing%29">bitmask</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unix_signal#SIGKILL">SIGKILL</a></li>
<li><a href="https://en.wikipedia.org/wiki/Errno.h">errno</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-2">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronization-primitives-in-the-linux-kernel-part-4"><a class="header" href="#synchronization-primitives-in-the-linux-kernel-part-4">Synchronization primitives in the Linux kernel. Part 4.</a></h1>
<h2 id="introduction-6"><a class="header" href="#introduction-6">Introduction</a></h2>
<p>This is the fourth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim">chapter</a> which describes synchronization primitives in the Linux kernel and in the previous parts we finished to consider different types <a href="https://en.wikipedia.org/wiki/Spinlock">spinlocks</a> and <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a> synchronization primitives. We will continue to learn <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitives</a> in this part and consider yet another one which is called - <a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a> which is stands for <code>MUTual EXclusion</code>.</p>
<p>As in all previous parts of this <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">book</a>, we will try to consider this synchronization primitive from the theoretical side and only than we will consider <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> provided by the Linux kernel to manipulate with <code>mutexes</code>.</p>
<p>So, let's start.</p>
<h2 id="concept-of-mutex"><a class="header" href="#concept-of-mutex">Concept of <code>mutex</code></a></h2>
<p>We already familiar with the <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a> synchronization primitive from the previous <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-3">part</a>. It represented by the:</p>
<pre><code class="language-C">struct semaphore {
	raw_spinlock_t		lock;
	unsigned int		count;
	struct list_head	wait_list;
};
</code></pre>
<p>structure which holds information about state of a <a href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29">lock</a> and list of a lock waiters. Depending on the value of the <code>count</code> field, a <code>semaphore</code> can provide access to a resource to more than one processes wishing to access this resource. The <a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a> concept is very similar to a <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a> concept. But it has some differences. The main difference between <code>semaphore</code> and <code>mutex</code> synchronization primitive is that <code>mutex</code> has more strict semantic. Unlike a <code>semaphore</code>, only one <a href="https://en.wikipedia.org/wiki/Process_%28computing%29">process</a> may hold <code>mutex</code> at one time and only the <code>owner</code> of a <code>mutex</code> may release or unlock it. Additional difference in implementation of <code>lock</code> <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a>. The <code>semaphore</code> synchronization primitive forces rescheduling of processes which are in waiters list. The implementation of <code>mutex</code> lock <code>API</code> allows to avoid this situation and has expensive <a href="https://en.wikipedia.org/wiki/Context_switch">context switches</a>.</p>
<p>The <code>mutex</code> synchronization primitive represented by the following:</p>
<pre><code class="language-C">struct mutex {
        atomic_t                count;
        spinlock_t              wait_lock;
        struct list_head        wait_list;
#if defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_MUTEX_SPIN_ON_OWNER)
        struct task_struct      *owner;
#endif
#ifdef CONFIG_MUTEX_SPIN_ON_OWNER
        struct optimistic_spin_queue osq;
#endif
#ifdef CONFIG_DEBUG_MUTEXES
        void                    *magic;
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
        struct lockdep_map      dep_map;
#endif
};
</code></pre>
<p>structure in the Linux kernel. This structure is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/mutex.h">include/linux/mutex.h</a> header file and contains a set of fields similar to the <code>semaphore</code> structure. The first field of the <code>mutex</code> structure is - <code>count</code>. Value of this field represents state of a <code>mutex</code>. In a case when the value of the <code>count</code> field is <code>1</code>, a <code>mutex</code> is in <code>unlocked</code> state. When the value of the <code>count</code> field is <code>zero</code>, a <code>mutex</code> is in the <code>locked</code> state. Additionally value of the <code>count</code> field may be <code>negative</code>. In this case a <code>mutex</code> is in the <code>locked</code> state and has possible waiters.</p>
<p>The next two fields of the <code>mutex</code> structure - <code>wait_lock</code> and <code>wait_list</code> are <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/mutex.h">spinlock</a> for the protection of a <code>wait queue</code> and list of waiters which represents this <code>wait queue</code> for a certain lock. As you may notice, the similarity of the <code>mutex</code> and <code>semaphore</code> structures ends. Remaining fields of the <code>mutex</code> structure, as we may see depends on different configuration options of the Linux kernel.</p>
<p>The first field - <code>owner</code> represents <a href="https://en.wikipedia.org/wiki/Process_%28computing%29">process</a> which acquired a lock. As we may see, existence of this field in the <code>mutex</code> structure depends on the <code>CONFIG_DEBUG_MUTEXES</code> or <code>CONFIG_MUTEX_SPIN_ON_OWNER</code> kernel configuration options. Main point of this field and the next <code>osq</code> fields is support of <code>optimistic spinning</code> which we will see later. The last two fields - <code>magic</code> and <code>dep_map</code> are used only in <a href="https://en.wikipedia.org/wiki/Debugging">debugging</a> mode. The <code>magic</code> field is to storing a <code>mutex</code> related information for debugging and the second field - <code>lockdep_map</code> is for <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a> of the Linux kernel.</p>
<p>Now, after we have considered the <code>mutex</code> structure, we may consider how this synchronization primitive works in the Linux kernel. As you may guess, a process who wants to acquire a lock, must to decrease value of the <code>mutex-&gt;count</code> if possible. And if a process wants to release a lock, it must to increase the same value. That's true. But as you may also guess, it is not so simple in the Linux kernel.</p>
<p>Actually, when a process try to acquire a <code>mutex</code>, there three possible paths:</p>
<ul>
<li><code>fastpath</code>;</li>
<li><code>midpath</code>;</li>
<li><code>slowpath</code>.</li>
</ul>
<p>which may be taken, depending on the current state of the <code>mutex</code>. The first path or <code>fastpath</code> is the fastest as you may understand from its name. Everything is easy in this case. Nobody acquired a <code>mutex</code>, so the value of the <code>count</code> field of the <code>mutex</code> structure may be directly decremented. In a case of unlocking of a <code>mutex</code>, the algorithm is the same. A process just increments the value of the <code>count</code> field of the <code>mutex</code> structure. Of course, all of these operations must be <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a>.</p>
<p>Yes, this looks pretty easy. But what happens if a process wants to acquire a <code>mutex</code> which is already acquired by other process? In this case, the control will be transferred to the second path - <code>midpath</code>. The <code>midpath</code> or <code>optimistic spinning</code> tries to <a href="https://en.wikipedia.org/wiki/Spinlock">spin</a> with already familiar for us <a href="http://www.cs.rochester.edu/%7Escott/papers/1991_TOCS_synch.pdf">MCS lock</a> while the lock owner is running. This path will be executed only if there are no other processes ready to run that have higher priority. This path is called <code>optimistic</code> because the waiting task will not sleep and be rescheduled. This allows to avoid expensive <a href="https://en.wikipedia.org/wiki/Context_switch">context switch</a>.</p>
<p>In the last case, when the <code>fastpath</code> and <code>midpath</code> may not be executed, the last path - <code>slowpath</code> will be executed. This path acts like a <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a> lock. If the lock is unable to be acquired by a process, this process will be added to <code>wait queue</code> which is represented by the following:</p>
<pre><code class="language-C">struct mutex_waiter {
        struct list_head        list;
        struct task_struct      *task;
#ifdef CONFIG_DEBUG_MUTEXES
        void                    *magic;
#endif
};
</code></pre>
<p>structure from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/mutex.h">include/linux/mutex.h</a> header file and will sleep. Before we will consider <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> which is provided by the Linux kernel for manipulation of <code>mutexes</code>, let's consider the <code>mutex_waiter</code> structure. If you have read the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-3">previous part</a> of this chapter, you may notice that the <code>mutex_waiter</code> structure is similar to the <code>semaphore_waiter</code> structure from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/locking/semaphore.c">kernel/locking/semaphore.c</a> source code file:</p>
<pre><code class="language-C">struct semaphore_waiter {
        struct list_head list;
        struct task_struct *task;
        bool up;
};
</code></pre>
<p>It also contains <code>list</code> and <code>task</code> fields which represent entry of the mutex wait queue. The one difference here that the <code>mutex_waiter</code> does not contains <code>up</code> field, but contains the <code>magic</code> field which depends on the <code>CONFIG_DEBUG_MUTEXES</code> kernel configuration option and used to store a <code>mutex</code> related information for debugging purpose.</p>
<p>Now we know what is a <code>mutex</code> and how it is represented the Linux kernel. In this case, we may go ahead and start to look at the <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> which the Linux kernel provides for manipulation of <code>mutexes</code>.</p>
<h2 id="mutex-api"><a class="header" href="#mutex-api">Mutex API</a></h2>
<p>Ok, in the previous paragraph we knew what is a <code>mutex</code> synchronization primitive and saw the <code>mutex</code> structure which represents <code>mutex</code> in the Linux kernel. Now it's time to consider <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> for manipulation of mutexes. Description of the <code>mutex</code> API is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/mutex.h">include/linux/mutex.h</a> header file. As always, before we will consider how to acquire and release a <code>mutex</code>, we need to know how to initialize it.</p>
<p>There are two approaches to initializing a <code>mutex</code>. The first is to do it statically. For this purpose the Linux kernel provides following:</p>
<pre><code class="language-C">#define DEFINE_MUTEX(mutexname) \
        struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)
</code></pre>
<p>macro. Let's consider implementation of this macro. As we may see, the <code>DEFINE_MUTEX</code> macro takes name for the <code>mutex</code> and expands to the definition of the new <code>mutex</code> structure. Additionally new <code>mutex</code> structure get initialized with the <code>__MUTEX_INITIALIZER</code> macro. Let's look at the implementation of the <code>__MUTEX_INITIALIZER</code>:</p>
<pre><code class="language-C">#define __MUTEX_INITIALIZER(lockname)         \
{                                                             \
       .count = ATOMIC_INIT(1),                               \
       .wait_lock = __SPIN_LOCK_UNLOCKED(lockname.wait_lock), \
       .wait_list = LIST_HEAD_INIT(lockname.wait_list)        \
}
</code></pre>
<p>This macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/mutex.h">same</a> header file and as we may understand it initializes fields of the <code>mutex</code> structure to their initial values. The <code>count</code> field get initialized with the <code>1</code> which represents <code>unlocked</code> state of a mutex. The <code>wait_lock</code> <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a> get initialized to the unlocked state and the last field <code>wait_list</code> to empty <a href="https://0xax.gitbook.io/linux-insides/summary/datastructures/linux-datastructures-1">doubly linked list</a>.</p>
<p>The second approach allows us to initialize a <code>mutex</code> dynamically. To do this we need to call the <code>__mutex_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/locking/mutex.c">kernel/locking/mutex.c</a> source code file. Actually, the <code>__mutex_init</code> function is rarely called directly. Instead of the <code>__mutex_init</code>, the:</p>
<pre><code class="language-C"># define mutex_init(mutex)                \
do {                                                    \
        static struct lock_class_key __key;             \
                                                        \
        __mutex_init((mutex), #mutex, &amp;__key);          \
} while (0)
</code></pre>
<p>macro is used. We may see that the <code>mutex_init</code> macro just defines the <code>lock_class_key</code> and call the <code>__mutex_init</code> function. Let's look at the implementation of this function:</p>
<pre><code class="language-C">void
__mutex_init(struct mutex *lock, const char *name, struct lock_class_key *key)
{
        atomic_set(&amp;lock-&gt;count, 1);
        spin_lock_init(&amp;lock-&gt;wait_lock);
        INIT_LIST_HEAD(&amp;lock-&gt;wait_list);
        mutex_clear_owner(lock);
#ifdef CONFIG_MUTEX_SPIN_ON_OWNER
        osq_lock_init(&amp;lock-&gt;osq);
#endif
        debug_mutex_init(lock, name, key);
}
</code></pre>
<p>As we may see the <code>__mutex_init</code> function takes three arguments:</p>
<ul>
<li><code>lock</code> - a mutex itself;</li>
<li><code>name</code> - name of mutex for debugging purpose;</li>
<li><code>key</code>  - key for <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a>.</li>
</ul>
<p>At the beginning of the <code>__mutex_init</code> function, we may see initialization of the <code>mutex</code> state. We set it to <code>unlocked</code> state with the <code>atomic_set</code> function which atomically sets the variable to the given value. After this we may see initialization of the <code>spinlock</code> to the unlocked state which will protect <code>wait queue</code> of the <code>mutex</code> and initialization of the <code>wait queue</code> of the <code>mutex</code>. After this we clear owner of the <code>lock</code> and initialize optimistic queue by the call of the <code>osq_lock_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/osq_lock.h">include/linux/osq_lock.h</a> header file. This function just sets the tail of the optimistic queue to the unlocked state:</p>
<pre><code class="language-C">static inline bool osq_is_locked(struct optimistic_spin_queue *lock)
{
        return atomic_read(&amp;lock-&gt;tail) != OSQ_UNLOCKED_VAL;
}
</code></pre>
<p>In the end of the <code>__mutex_init</code> function we may see the call of the <code>debug_mutex_init</code> function, but as I already wrote in previous parts of this <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim">chapter</a>, we will not consider debugging related stuff in this chapter.</p>
<p>After the <code>mutex</code> structure is initialized, we may go ahead and will look at the <code>lock</code> and <code>unlock</code> API of <code>mutex</code> synchronization primitive. Implementation of <code>mutex_lock</code> and <code>mutex_unlock</code> functions is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/locking/mutex.c">kernel/locking/mutex.c</a> source code file. First of all let's start from the implementation of the <code>mutex_lock</code>. It looks:</p>
<pre><code class="language-C">void __sched mutex_lock(struct mutex *lock)
{
        might_sleep();
        __mutex_fastpath_lock(&amp;lock-&gt;count, __mutex_lock_slowpath);
        mutex_set_owner(lock);
}
</code></pre>
<p>We may see the call of the <code>might_sleep</code> macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/kernel.h">include/linux/kernel.h</a> header file at the beginning of the <code>mutex_lock</code> function. Implementation of this macro depends on the <code>CONFIG_DEBUG_ATOMIC_SLEEP</code> kernel configuration option and if this option is enabled, this macro just prints a stack trace if it was executed in <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a> context. This macro is helper for debugging purposes. In other way this macro does nothing.</p>
<p>After the <code>might_sleep</code> macro, we may see the call of the <code>__mutex_fastpath_lock</code> function. This function is architecture-specific and as we consider <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture in this book, the implementation of the <code>__mutex_fastpath_lock</code> is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/mutex_64.h">arch/x86/include/asm/mutex_64.h</a> header file. As we may understand from the name of the <code>__mutex_fastpath_lock</code> function, this function will try to acquire lock in a fast path or in other words this function will try to decrement the value of the <code>count</code> of the given mutex.</p>
<p>Implementation of the <code>__mutex_fastpath_lock</code> function consists of two parts. The first part is <a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-3">inline assembly</a> statement. Let's look at it:</p>
<pre><code class="language-C">asm_volatile_goto(LOCK_PREFIX &quot;   decl %0\n&quot;
                              &quot;   jns %l[exit]\n&quot;
                              : : &quot;m&quot; (v-&gt;counter)
                              : &quot;memory&quot;, &quot;cc&quot;
                              : exit);
</code></pre>
<p>First of all, let's pay attention to the <code>asm_volatile_goto</code>. This macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/compiler-gcc.h">include/linux/compiler-gcc.h</a> header file and just expands to the two inline assembly statements:</p>
<pre><code class="language-C">#define asm_volatile_goto(x...) do { asm goto(x); asm (&quot;&quot;); } while (0)
</code></pre>
<p>The first assembly statement contains <code>goto</code> specificator and the second empty inline assembly statement is <a href="https://en.wikipedia.org/wiki/Memory_barrier">barrier</a>. Now let's return to the our inline assembly statement. As we may see it starts from the definition of the <code>LOCK_PREFIX</code> macro which just expands to the <a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">lock</a> instruction:</p>
<pre><code class="language-C">#define LOCK_PREFIX LOCK_PREFIX_HERE &quot;\n\tlock; &quot;
</code></pre>
<p>As we already know from the previous parts, this instruction allows to execute prefixed instruction <a href="https://en.wikipedia.org/wiki/Linearizability">atomically</a>. So, at the first step in the our assembly statement we try decrement value of the given <code>mutex-&gt;counter</code>. At the next step the <a href="http://unixwiz.net/techtips/x86-jumps.html">jns</a> instruction will execute jump at the <code>exit</code> label if the value of the decremented <code>mutex-&gt;counter</code> is not negative. The <code>exit</code> label is the second part of the <code>__mutex_fastpath_lock</code> function and it just points to the exit from this function:</p>
<pre><code class="language-C">exit:
        return;
</code></pre>
<p>For this moment the implementation of the <code>__mutex_fastpath_lock</code> function looks pretty easy. But the value of the <code>mutex-&gt;counter</code> may be negative after decrement. In this case the: </p>
<pre><code class="language-C">fail_fn(v);
</code></pre>
<p>will be called after our inline assembly statement. The <code>fail_fn</code> is the second parameter of the <code>__mutex_fastpath_lock</code> function and represents pointer to function which represents <code>midpath/slowpath</code> paths to acquire the given lock. In our case the <code>fail_fn</code> is the <code>__mutex_lock_slowpath</code> function. Before we look at the implementation of the <code>__mutex_lock_slowpath</code> function, let's finish with the implementation of the <code>mutex_lock</code> function. In the simplest way, the lock will be acquired successfully by a process and the <code>__mutex_fastpath_lock</code> will be finished. In this case, we just call the</p>
<pre><code class="language-C">mutex_set_owner(lock);
</code></pre>
<p>in the end of the <code>mutex_lock</code>. The <code>mutex_set_owner</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/mutex.h">kernel/locking/mutex.h</a> header file and just sets owner of a lock to the current process:</p>
<pre><code class="language-C">static inline void mutex_set_owner(struct mutex *lock)
{
        lock-&gt;owner = current;
}
</code></pre>
<p>In other way, let's consider situation when a process which wants to acquire a lock is unable to do it, because another process already acquired the same lock. We already know that the <code>__mutex_lock_slowpath</code> function will be called in this case. Let's consider implementation of this function. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/locking/mutex.c">kernel/locking/mutex.c</a> source code file and starts from the obtaining of the proper mutex by the mutex state given from the <code>__mutex_fastpath_lock</code> with the <code>container_of</code> macro:</p>
<pre><code class="language-C">__visible void __sched
__mutex_lock_slowpath(atomic_t *lock_count)
{
        struct mutex *lock = container_of(lock_count, struct mutex, count);

        __mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0,
                            NULL, _RET_IP_, NULL, 0);
}
</code></pre>
<p>and call the <code>__mutex_lock_common</code> function with the obtained <code>mutex</code>. The <code>__mutex_lock_common</code> function starts from <a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29">preemption</a> disabling until rescheduling:</p>
<pre><code class="language-C">preempt_disable();
</code></pre>
<p>After this comes the stage of optimistic spinning. As we already know this stage depends on the <code>CONFIG_MUTEX_SPIN_ON_OWNER</code> kernel configuration option. If this option is disabled, we skip this stage and move at the last path - <code>slowpath</code> of a <code>mutex</code> acquisition:</p>
<pre><code class="language-C">if (mutex_optimistic_spin(lock, ww_ctx, use_ww_ctx)) {
        preempt_enable();
        return 0;
}
</code></pre>
<p>First of all, <code>mutex_optimistic_spin</code> checks that we don't need to reschedule or in other words there are no other tasks ready to run that have higher priority. If this check was successful we need to update <code>MCS</code> lock wait queue with the current spin. In this way only one spinner can complete for the mutex at one time:</p>
<pre><code class="language-C">osq_lock(&amp;lock-&gt;osq)
</code></pre>
<p>At the next step we start to spin in the next loop:</p>
<pre><code class="language-C">while (true) {
    owner = READ_ONCE(lock-&gt;owner);

    if (owner &amp;&amp; !mutex_spin_on_owner(lock, owner))
        break;

    if (mutex_try_to_acquire(lock)) {
        lock_acquired(&amp;lock-&gt;dep_map, ip);

        mutex_set_owner(lock);
        osq_unlock(&amp;lock-&gt;osq);
        return true;
    }
}
</code></pre>
<p>and try to acquire a lock. First of all we try to take current owner and if the owner exists (it may not exist in a case when a process already released a mutex) and we wait for it in the <code>mutex_spin_on_owner</code> function before the owner will release a lock. If new task with higher priority have appeared during wait of the lock owner, we break the loop and go to sleep. In other case, the process already may release a lock, so we try to acquire a lock with the <code>mutex_try_to_acquired</code>. If this operation finished successfully, we set new owner for the given mutex, removes ourself from the <code>MCS</code> wait queue and exit from the <code>mutex_optimistic_spin</code> function. At this stage, a lock will be acquired by a process and we enable <a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29">preemption</a> and exit from the <code>__mutex_lock_common</code> function:</p>
<pre><code class="language-C">if (mutex_optimistic_spin(lock, ww_ctx, use_ww_ctx)) {
    preempt_enable();
    return 0;
}

</code></pre>
<p>That's all for this case.</p>
<p>In other case all may not be so successful. For example new task may occur during we spinning in the loop from the <code>mutex_optimistic_spin</code> or even we may not get to this loop from the <code>mutex_optimistic_spin</code> in a case when there were task(s) with higher priority before this loop. Or finally the <code>CONFIG_MUTEX_SPIN_ON_OWNER</code> kernel configuration option disabled. In this case the <code>mutex_optimistic_spin</code> will do nothing:</p>
<pre><code class="language-C">#ifndef CONFIG_MUTEX_SPIN_ON_OWNER
static bool mutex_optimistic_spin(struct mutex *lock,
                                  struct ww_acquire_ctx *ww_ctx, const bool use_ww_ctx)
{
    return false;
}
#endif
</code></pre>
<p>In all of these cases, the <code>__mutex_lock_common</code> function will act like a <code>semaphore</code>. We try to acquire a lock again because the owner of a lock might already release a lock before this time:</p>
<pre><code class="language-C">if (!mutex_is_locked(lock) &amp;&amp;
   (atomic_xchg_acquire(&amp;lock-&gt;count, 0) == 1))
      goto skip_wait;
</code></pre>
<p>In a failure case the process which wants to acquire a lock will be added to the waiters list</p>
<pre><code class="language-C">list_add_tail(&amp;waiter.list, &amp;lock-&gt;wait_list);
waiter.task = task;
</code></pre>
<p>In a successful case we update the owner of a lock, enable preemption and exit from the <code>__mutex_lock_common</code> function:</p>
<pre><code class="language-C">skip_wait:
        mutex_set_owner(lock);
        preempt_enable();
        return 0;
</code></pre>
<p>In this case a lock will be acquired. If can't acquire a lock for now, we enter into the following loop:</p>
<pre><code class="language-C">for (;;) {

    if (atomic_read(&amp;lock-&gt;count) &gt;= 0 &amp;&amp; (atomic_xchg_acquire(&amp;lock-&gt;count, -1) == 1))
        break;

    if (unlikely(signal_pending_state(state, task))) {
        ret = -EINTR;
        goto err;
    }

    __set_task_state(task, state);

     schedule_preempt_disabled();
}
</code></pre>
<p>where try to acquire a lock again and exit if this operation was successful. Yes, we try to acquire a lock again right after unsuccessful try  before the loop. We need to do it to make sure that we get a wakeup once a lock will be unlocked. Besides this, it allows us to acquire a lock after sleep.  In other case we check the current process for pending <a href="https://en.wikipedia.org/wiki/Unix_signal">signals</a> and exit if the process was interrupted by a <code>signal</code> during wait for a lock acquisition. In the end of loop we didn't acquire a lock, so we set the task state for <code>TASK_UNINTERRUPTIBLE</code> and go to sleep with call of the <code>schedule_preempt_disabled</code> function.</p>
<p>That's all. We have considered all three possible paths through which a process may pass when it will want to acquire a lock. Now let's consider how <code>mutex_unlock</code> is implemented. When the <code>mutex_unlock</code> is called by a process which wants to release a lock, the <code>__mutex_fastpath_unlock</code> will be called from the  <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/mutex_64.h">arch/x86/include/asm/mutex_64.h</a>  header file:</p>
<pre><code class="language-C">void __sched mutex_unlock(struct mutex *lock)
{
    __mutex_fastpath_unlock(&amp;lock-&gt;count, __mutex_unlock_slowpath);
}
</code></pre>
<p>Implementation of the <code>__mutex_fastpath_unlock</code> function is very similar to the implementation of the <code>__mutex_fastpath_lock</code> function:</p>
<pre><code class="language-C">static inline void __mutex_fastpath_unlock(atomic_t *v,
                                           void (*fail_fn)(atomic_t *))
{
       asm_volatile_goto(LOCK_PREFIX &quot;   incl %0\n&quot;
                         &quot;   jg %l[exit]\n&quot;
                         : : &quot;m&quot; (v-&gt;counter)
                         : &quot;memory&quot;, &quot;cc&quot;
                         : exit);
       fail_fn(v);
exit:
       return;
}
</code></pre>
<p>Actually, there is only one difference. We increment value if the <code>mutex-&gt;count</code>. So it will represent <code>unlocked</code> state after this operation. As <code>mutex</code> released, but we have something in the <code>wait queue</code> we need to update it. In this case the <code>fail_fn</code> function will be called which is <code>__mutex_unlock_slowpath</code>. The <code>__mutex_unlock_slowpath</code> function just gets the correct <code>mutex</code> instance by the given <code>mutex-&gt;count</code> and calls the <code>__mutex_unlock_common_slowpath</code> function:</p>
<pre><code class="language-C">__mutex_unlock_slowpath(atomic_t *lock_count)
{
      struct mutex *lock = container_of(lock_count, struct mutex, count);

      __mutex_unlock_common_slowpath(lock, 1);
}
</code></pre>
<p>In the <code>__mutex_unlock_common_slowpath</code> function we will get the first entry from the wait queue if the wait queue is not empty and wake up related process:</p>
<pre><code class="language-C">if (!list_empty(&amp;lock-&gt;wait_list)) {
    struct mutex_waiter *waiter =
           list_entry(lock-&gt;wait_list.next, struct mutex_waiter, list);
                wake_up_process(waiter-&gt;task);
}
</code></pre>
<p>After this, a mutex will be released by previous process and will be acquired by another process from a wait queue.</p>
<p>That's all. We have considered main <code>API</code> for manipulation with <code>mutexes</code>: <code>mutex_lock</code> and <code>mutex_unlock</code>. Besides this the Linux kernel provides following API:</p>
<ul>
<li><code>mutex_lock_interruptible</code>;</li>
<li><code>mutex_lock_killable</code>;</li>
<li><code>mutex_trylock</code>.</li>
</ul>
<p>and corresponding versions of <code>unlock</code> prefixed functions. This part will not describe this <code>API</code>, because it is similar to corresponding <code>API</code> of <code>semaphores</code>. More about it you may read in the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-3">previous part</a>.</p>
<p>That's all.</p>
<h2 id="conclusion-42"><a class="header" href="#conclusion-42">Conclusion</a></h2>
<p>This is the end of the fourth part of the <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitives</a> chapter in the Linux kernel. In this part we met with new synchronization primitive which is called - <code>mutex</code>. From the theoretical side, this synchronization primitive very similar on a <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a>. Actually, <code>mutex</code> represents binary semaphore. But its implementation differs from the implementation of <code>semaphore</code> in the Linux kernel. In the next part we will continue to dive into synchronization primitives in the Linux kernel.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-42"><a class="header" href="#links-42">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Mutual_exclusion">Mutex</a></li>
<li><a href="https://en.wikipedia.org/wiki/Spinlock">Spinlock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">Semaphore</a></li>
<li><a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">Synchronization primitives</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lock_%28computer_science%29">Locking mechanism</a></li>
<li><a href="https://en.wikipedia.org/wiki/Context_switch">Context switches</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linearizability">Atomic</a></li>
<li><a href="http://www.cs.rochester.edu/%7Escott/papers/1991_TOCS_synch.pdf">MCS lock</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/datastructures/linux-datastructures-1">Doubly linked list</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-3">Inline assembly</a></li>
<li><a href="https://en.wikipedia.org/wiki/Memory_barrier">Memory barrier</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">Lock instruction</a></li>
<li><a href="http://unixwiz.net/techtips/x86-jumps.html">JNS instruction</a></li>
<li><a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29">preemption</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unix_signal">Unix signals</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-3">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronization-primitives-in-the-linux-kernel-part-5"><a class="header" href="#synchronization-primitives-in-the-linux-kernel-part-5">Synchronization primitives in the Linux kernel. Part 5.</a></h1>
<h2 id="introduction-7"><a class="header" href="#introduction-7">Introduction</a></h2>
<p>This is the fifth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim">chapter</a> which describes synchronization primitives in the Linux kernel and in the previous parts we finished to consider different types <a href="https://en.wikipedia.org/wiki/Spinlock">spinlocks</a>, <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a> and <a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a> synchronization primitives. We will continue to learn <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitives</a> in this part and start to consider special type of synchronization primitives - <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">readers–writer lock</a>.</p>
<p>The first synchronization primitive of this type will be already familiar for us - <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a>. As in all previous parts of this <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">book</a>, before we will consider implementation of the <code>reader/writer semaphores</code> in the Linux kernel, we will start from the theoretical side and will try to understand what is the difference between <code>reader/writer semaphores</code> and <code>normal semaphores</code>.</p>
<p>So, let's start.</p>
<h2 id="readerwriter-semaphore"><a class="header" href="#readerwriter-semaphore">Reader/Writer semaphore</a></h2>
<p>Actually there are two types of operations may be performed on the data. We may read data and make changes in data. Two fundamental operations - <code>read</code> and <code>write</code>. Usually (but not always), <code>read</code> operation is performed more often than <code>write</code> operation. In this case, it would be logical to lock data in such way, that some processes may read locked data in one time, on condition that no one will not change the data. The <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">readers/writer lock</a> allows us to get this lock.</p>
<p>When a process which wants to write something into data, all other <code>writer</code> and <code>reader</code> processes will be blocked until the process which acquired a lock, will not release it. When a process reads data, other processes which want to read the same data too, will not be locked and will be able to do this. As you may guess, implementation of the <code>reader/writer semaphore</code> is based on the implementation of the <code>normal semaphore</code>. We already familiar with the <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a> synchronization primitive from the third <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-4">part</a> of this chapter. From the theoretical side everything looks pretty simple. Let's look how <code>reader/writer semaphore</code> is represented in the Linux kernel.</p>
<p>The <code>semaphore</code> is represented by the:</p>
<pre><code class="language-C">struct semaphore {
	raw_spinlock_t		lock;
	unsigned int		count;
	struct list_head	wait_list;
};
</code></pre>
<p>structure. If you will look in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/rwsem.h">include/linux/rwsem.h</a> header file, you will find definition of the <code>rw_semaphore</code> structure which represents <code>reader/writer semaphore</code> in the Linux kernel. Let's look at the definition of this structure:</p>
<pre><code class="language-C">#ifdef CONFIG_RWSEM_GENERIC_SPINLOCK
#include &lt;linux/rwsem-spinlock.h&gt;
#else
struct rw_semaphore {
        long count;
        struct list_head wait_list;
        raw_spinlock_t wait_lock;
#ifdef CONFIG_RWSEM_SPIN_ON_OWNER
        struct optimistic_spin_queue osq;
        struct task_struct *owner;
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
        struct lockdep_map      dep_map;
#endif
};
</code></pre>
<p>Before we will consider fields of the <code>rw_semaphore</code> structure, we may notice, that declaration of the <code>rw_semaphore</code> structure depends on the <code>CONFIG_RWSEM_GENERIC_SPINLOCK</code> kernel configuration option. This option is disabled for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture by default. We can be sure in this by looking at the corresponding kernel configuration file. In our case, this configuration file is - <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/um/Kconfig">arch/x86/um/Kconfig</a>:</p>
<pre><code>config RWSEM_XCHGADD_ALGORITHM
	def_bool 64BIT

config RWSEM_GENERIC_SPINLOCK
	def_bool !RWSEM_XCHGADD_ALGORITHM
</code></pre>
<p>So, as this <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">book</a> describes only <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture related stuff, we will skip the case when the <code>CONFIG_RWSEM_GENERIC_SPINLOCK</code> kernel configuration is enabled and consider definition of the <code>rw_semaphore</code> structure only from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/rwsem.h">include/linux/rwsem.h</a> header file.</p>
<p>If we will take a look at the definition of the <code>rw_semaphore</code> structure, we will notice that first three fields are the same that in the <code>semaphore</code> structure. It contains <code>count</code> field which represents amount of available resources, the <code>wait_list</code> field which represents <a href="https://0xax.gitbook.io/linux-insides/summary/datastructures/linux-datastructures-1">doubly linked list</a> of processes which are waiting to acquire a lock and <code>wait_lock</code> <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a> for protection of this list. Notice that <code>rw_semaphore.count</code> field is <code>long</code> type unlike the same field in the <code>semaphore</code> structure.</p>
<p>The <code>count</code> field of a <code>rw_semaphore</code> structure may have following values:</p>
<ul>
<li><code>0x0000000000000000</code> - <code>reader/writer semaphore</code> is in unlocked state and no one is waiting for a lock;</li>
<li><code>0x000000000000000X</code> - <code>X</code> readers are active or attempting to acquire a lock and no writer waiting;</li>
<li><code>0xffffffff0000000X</code> - may represent different cases. The first is - <code>X</code> readers are active or attempting to acquire a lock with waiters for the lock. The second is - one writer attempting a lock, no waiters for the lock. And the last - one writer is active and no waiters for the lock;</li>
<li><code>0xffffffff00000001</code> - may represented two different cases. The first is - one reader is active or attempting to acquire a lock and exist waiters for the lock. The second case is one writer is active or attempting to acquire a lock and no waiters for the lock;</li>
<li><code>0xffffffff00000000</code> - represents situation when there are readers or writers are queued, but no one is active or is in the process of acquire of a lock;</li>
<li><code>0xfffffffe00000001</code> - a writer is active or attempting to acquire a lock and waiters are in queue.</li>
</ul>
<p>So, besides the <code>count</code> field, all of these fields are similar to fields of the <code>semaphore</code> structure. Last three fields depend on the two configuration options of the Linux kernel: the <code>CONFIG_RWSEM_SPIN_ON_OWNER</code> and <code>CONFIG_DEBUG_LOCK_ALLOC</code>. The first two fields may be familiar us by declaration of the <a href="https://en.wikipedia.org/wiki/Mutual_exclusion">mutex</a> structure from the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-4">previous part</a>. The first <code>osq</code> field represents <a href="http://www.cs.rochester.edu/%7Escott/papers/1991_TOCS_synch.pdf">MCS lock</a> spinner for <code>optimistic spinning</code> and the second represents process which is current owner of a lock.</p>
<p>The last field of the <code>rw_semaphore</code> structure is - <code>dep_map</code> - debugging related, and as I already wrote in previous parts, we will skip debugging related stuff in this chapter.</p>
<p>That's all. Now we know a little about what is it <code>reader/writer lock</code> in general and <code>reader/writer semaphore</code> in particular. Additionally we saw how a <code>reader/writer semaphore</code> is represented in the Linux kernel. In this case, we may go ahead and start to look at the <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> which the Linux kernel provides for manipulation of <code>reader/writer semaphores</code>.</p>
<h2 id="readerwriter-semaphore-api"><a class="header" href="#readerwriter-semaphore-api">Reader/Writer semaphore API</a></h2>
<p>So, we know a little about <code>reader/writer semaphores</code> from theoretical side, let's look on its implementation in the Linux kernel. All <code>reader/writer semaphores</code> related <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/rwsem.h">include/linux/rwsem.h</a> header file.</p>
<p>As always, before we consider an <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> of the <code>reader/writer semaphore</code> mechanism in the Linux kernel, we need to know how to initialize the <code>rw_semaphore</code> structure. As we already saw in previous parts of this <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim">chapter</a>, all <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitives</a> may be initialized in two ways:</p>
<ul>
<li><code>statically</code>;</li>
<li><code>dynamically</code>.</li>
</ul>
<p>And <code>reader/writer semaphore</code> is not an exception. First of all, let's take a look at the first approach. We may initialize <code>rw_semaphore</code> structure with the help of the <code>DECLARE_RWSEM</code> macro in compile time. This macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/rwsem.h">include/linux/rwsem.h</a> header file and looks:</p>
<pre><code class="language-C">#define DECLARE_RWSEM(name) \
        struct rw_semaphore name = __RWSEM_INITIALIZER(name)
</code></pre>
<p>As we may see, the <code>DECLARE_RWSEM</code> macro just expands to the definition of the <code>rw_semaphore</code> structure with the given name. Additionally new <code>rw_semaphore</code> structure is initialized with the value of the <code>__RWSEM_INITIALIZER</code> macro:</p>
<pre><code class="language-C">#define __RWSEM_INITIALIZER(name)              \
{                                                              \
        .count = RWSEM_UNLOCKED_VALUE,                         \
        .wait_list = LIST_HEAD_INIT((name).wait_list),         \
        .wait_lock = __RAW_SPIN_LOCK_UNLOCKED(name.wait_lock)  \
         __RWSEM_OPT_INIT(name)                                \
         __RWSEM_DEP_MAP_INIT(name)
}
</code></pre>
<p>and expands to the initialization of fields of <code>rw_semaphore</code> structure. First of all we initialize <code>count</code> field of the <code>rw_semaphore</code> structure to the <code>unlocked</code> state with <code>RWSEM_UNLOCKED_VALUE</code> macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/rwsem.h">arch/x86/include/asm/rwsem.h</a> architecture specific header file:</p>
<pre><code class="language-C">#define RWSEM_UNLOCKED_VALUE            0x00000000L
</code></pre>
<p>After this we initialize list of a lock waiters with the empty linked list and <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a> for protection of this list with the <code>unlocked</code> state too. The <code>__RWSEM_OPT_INIT</code> macro depends on the state of the <code>CONFIG_RWSEM_SPIN_ON_OWNER</code> kernel configuration option and if this option is enabled it expands to the initialization of the <code>osq</code> and <code>owner</code> fields of the <code>rw_semaphore</code> structure. As we already saw above, the <code>CONFIG_RWSEM_SPIN_ON_OWNER</code> kernel configuration option is enabled by default for <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture, so let's take a look at the definition of the <code>__RWSEM_OPT_INIT</code> macro:</p>
<pre><code class="language-C">#ifdef CONFIG_RWSEM_SPIN_ON_OWNER
    #define __RWSEM_OPT_INIT(lockname) , .osq = OSQ_LOCK_UNLOCKED, .owner = NULL
#else
    #define __RWSEM_OPT_INIT(lockname)
#endif
</code></pre>
<p>As we may see, the <code>__RWSEM_OPT_INIT</code> macro initializes the <a href="http://www.cs.rochester.edu/%7Escott/papers/1991_TOCS_synch.pdf">MCS lock</a> lock with <code>unlocked</code> state and initial <code>owner</code> of a lock with <code>NULL</code>. From this moment, a <code>rw_semaphore</code> structure will be initialized in a compile time and may be used for data protection.</p>
<p>The second way to initialize a <code>rw_semaphore</code> structure is <code>dynamically</code> or use the <code>init_rwsem</code> macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/rwsem.h">include/linux/rwsem.h</a> header file. This macro declares an instance of the <code>lock_class_key</code> which is related to the <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a> of the Linux kernel and to the call of the <code>__init_rwsem</code> function with the given <code>reader/writer semaphore</code>:</p>
<pre><code class="language-C">#define init_rwsem(sem)                         \
do {                                                            \
        static struct lock_class_key __key;                     \
                                                                \
        __init_rwsem((sem), #sem, &amp;__key);                      \
} while (0)
</code></pre>
<p>If you will start definition of the <code>__init_rwsem</code> function, you will notice that there are couple of source code files which contain it. As you may guess, sometimes we need to initialize additional fields of the <code>rw_semaphore</code> structure, like the <code>osq</code> and <code>owner</code>. But sometimes not. All of this depends on some kernel configuration options. If we will look at the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/locking/Makefile">kernel/locking/Makefile</a> makefile, we will see following lines:</p>
<pre><code class="language-Makefile">obj-$(CONFIG_RWSEM_GENERIC_SPINLOCK) += rwsem-spinlock.o
obj-$(CONFIG_RWSEM_XCHGADD_ALGORITHM) += rwsem-xadd.o
</code></pre>
<p>As we already know, the Linux kernel for <code>x86_64</code> architecture has enabled <code>CONFIG_RWSEM_XCHGADD_ALGORITHM</code> kernel configuration option by default:</p>
<pre><code>config RWSEM_XCHGADD_ALGORITHM
	def_bool 64BIT
</code></pre>
<p>in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/um/Kconfig">arch/x86/um/Kconfig</a> kernel configuration file. In this case, implementation of the <code>__init_rwsem</code> function will be located in the <a href="https://github.com/torvalds/linux/blob/master/kernel/locking/rwsem.c">kernel/locking/rwsem.c</a> source code file for us. Let's take a look at this function:</p>
<pre><code class="language-C">void __init_rwsem(struct rw_semaphore *sem, const char *name,
                    struct lock_class_key *key)
{
#ifdef CONFIG_DEBUG_LOCK_ALLOC
        debug_check_no_locks_freed((void *)sem, sizeof(*sem));
        lockdep_init_map(&amp;sem-&gt;dep_map, name, key, 0);
#endif
        sem-&gt;count = RWSEM_UNLOCKED_VALUE;
        raw_spin_lock_init(&amp;sem-&gt;wait_lock);
        INIT_LIST_HEAD(&amp;sem-&gt;wait_list);
#ifdef CONFIG_RWSEM_SPIN_ON_OWNER
        sem-&gt;owner = NULL;
        osq_lock_init(&amp;sem-&gt;osq);
#endif
}
</code></pre>
<p>We may see here almost the same as in <code>__RWSEM_INITIALIZER</code> macro with difference that all of this will be executed in <a href="https://en.wikipedia.org/wiki/Run_time_%28program_lifecycle_phase%29">runtime</a>.</p>
<p>So, from now we are able to initialize a <code>reader/writer semaphore</code> let's look at the <code>lock</code> and <code>unlock</code> API. The Linux kernel provides following primary <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> to manipulate <code>reader/writer semaphores</code>:</p>
<ul>
<li><code>void down_read(struct rw_semaphore *sem)</code> - lock for reading;</li>
<li><code>int down_read_trylock(struct rw_semaphore *sem)</code> - try lock for reading;</li>
<li><code>void down_write(struct rw_semaphore *sem)</code> - lock for writing;</li>
<li><code>int down_write_trylock(struct rw_semaphore *sem)</code> - try lock for writing;</li>
<li><code>void up_read(struct rw_semaphore *sem)</code> - release a read lock;</li>
<li><code>void up_write(struct rw_semaphore *sem)</code> - release a write lock;</li>
</ul>
<p>Let's start as always from the locking. First of all let's consider implementation of the <code>down_write</code> function which executes a try of acquiring of a lock for <code>write</code>. This function is <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/locking/rwsem.c">kernel/locking/rwsem.c</a> source code file and starts from the call of the macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/kernel.h">include/linux/kernel.h</a> header file:</p>
<pre><code class="language-C">void __sched down_write(struct rw_semaphore *sem)
{
        might_sleep();
        rwsem_acquire(&amp;sem-&gt;dep_map, 0, 0, _RET_IP_);

        LOCK_CONTENDED(sem, __down_write_trylock, __down_write);
        rwsem_set_owner(sem);
}
</code></pre>
<p>We already met the <code>might_sleep</code> macro in the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-4">previous part</a>. In short, implementation of the <code>might_sleep</code> macro depends on the <code>CONFIG_DEBUG_ATOMIC_SLEEP</code> kernel configuration option and if this option is enabled, this macro just prints a stack trace if it was executed in <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a> context. As this macro is mostly for debugging purpose we will skip it and will go ahead. Additionally we will skip the next macro from the <code>down_read</code> function - <code>rwsem_acquire</code> which is related to the <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a> of the Linux kernel, because this is topic of other part.</p>
<p>The only two things that remained in the <code>down_write</code> function is the call of the <code>LOCK_CONTENDED</code> macro which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/lockdep.h">include/linux/lockdep.h</a> header file and setting of owner of a lock with the <code>rwsem_set_owner</code> function which sets owner to currently running process:</p>
<pre><code class="language-C">static inline void rwsem_set_owner(struct rw_semaphore *sem)
{
        sem-&gt;owner = current;
}
</code></pre>
<p>As you already may guess, the <code>LOCK_CONTENDED</code> macro does all job for us. Let's look at the implementation of the <code>LOCK_CONTENDED</code> macro:</p>
<pre><code class="language-C">#define LOCK_CONTENDED(_lock, try, lock) \
        lock(_lock)
</code></pre>
<p>As we may see it just calls the <code>lock</code> function which is third parameter of the <code>LOCK_CONTENDED</code> macro with the given <code>rw_semaphore</code>. In our case the third parameter of the <code>LOCK_CONTENDED</code> macro is the <code>__down_write</code> function which is architecture specific function and located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/rwsem.h">arch/x86/include/asm/rwsem.h</a> header file. Let's look at the implementation of the <code>__down_write</code> function:</p>
<pre><code class="language-C">static inline void __down_write(struct rw_semaphore *sem)
{
        __down_write_nested(sem, 0);
}
</code></pre>
<p>which just executes a call of the <code>__down_write_nested</code> function from the same source code file. Let's take a look at the implementation of the <code>__down_write_nested</code> function:</p>
<pre><code class="language-C">static inline void __down_write_nested(struct rw_semaphore *sem, int subclass)
{
        long tmp;

        asm volatile(&quot;# beginning down_write\n\t&quot;
                     LOCK_PREFIX &quot;  xadd      %1,(%2)\n\t&quot;
                     &quot;  test &quot; __ASM_SEL(%w1,%k1) &quot;,&quot; __ASM_SEL(%w1,%k1) &quot;\n\t&quot;
                     &quot;  jz        1f\n&quot;
                     &quot;  call call_rwsem_down_write_failed\n&quot;
                     &quot;1:\n&quot;
                     &quot;# ending down_write&quot;
                     : &quot;+m&quot; (sem-&gt;count), &quot;=d&quot; (tmp)
                     : &quot;a&quot; (sem), &quot;1&quot; (RWSEM_ACTIVE_WRITE_BIAS)
                     : &quot;memory&quot;, &quot;cc&quot;);
}
</code></pre>
<p>As for other synchronization primitives which we saw in this chapter, usually <code>lock/unlock</code> functions consists only from an <a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-3">inline assembly</a> statement. As we may see, in our case the same for <code>__down_write_nested</code> function. Let's try to understand what does this function do. The first line of our assembly statement is just a comment, let's skip it. The second like contains <code>LOCK_PREFIX</code> which will be expanded to the <a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">LOCK</a> instruction as we already know. The next <a href="http://x86.renejeschke.de/html/file_module_x86_id_327.html">xadd</a> instruction executes <code>add</code> and <code>exchange</code> operations. In other words, <code>xadd</code> instruction adds value of the <code>RWSEM_ACTIVE_WRITE_BIAS</code>:</p>
<pre><code class="language-C">#define RWSEM_ACTIVE_WRITE_BIAS         (RWSEM_WAITING_BIAS + RWSEM_ACTIVE_BIAS)

#define RWSEM_WAITING_BIAS              (-RWSEM_ACTIVE_MASK-1)
#define RWSEM_ACTIVE_BIAS               0x00000001L
</code></pre>
<p>or <code>0xffffffff00000001</code> to the <code>count</code> of the given <code>reader/writer semaphore</code> and returns previous value of it. After this we check the active mask in the <code>rw_semaphore-&gt;count</code>. If it was zero before, this means that there were no-one writer before, so we acquired a lock. In other way we call the <code>call_rwsem_down_write_failed</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/lib/rwsem.S">arch/x86/lib/rwsem.S</a> assembly file. The <code>call_rwsem_down_write_failed</code> function just calls the <code>rwsem_down_write_failed</code> function from the <a href="https://github.com/torvalds/linux/blob/master/kernel/locking/rwsem.c">kernel/locking/rwsem-xadd.c</a> source code file anticipatorily save general purpose registers:</p>
<pre><code class="language-assembly">ENTRY(call_rwsem_down_write_failed)
	FRAME_BEGIN
	save_common_regs
	movq %rax,%rdi
	call rwsem_down_write_failed
	restore_common_regs
	FRAME_END
	ret
    ENDPROC(call_rwsem_down_write_failed)
</code></pre>
<p>The <code>rwsem_down_write_failed</code> function starts from the <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a> update of the <code>count</code> value:</p>
<pre><code class="language-C"> __visible
struct rw_semaphore __sched *rwsem_down_write_failed(struct rw_semaphore *sem)
{
    count = rwsem_atomic_update(-RWSEM_ACTIVE_WRITE_BIAS, sem);
    ...
    ...
    ...
}
</code></pre>
<p>with the <code>-RWSEM_ACTIVE_WRITE_BIAS</code> value. The <code>rwsem_atomic_update</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/rwsem.h">arch/x86/include/asm/rwsem.h</a> header file and implement exchange and add logic:</p>
<pre><code class="language-C">static inline long rwsem_atomic_update(long delta, struct rw_semaphore *sem)
{
        return delta + xadd(&amp;sem-&gt;count, delta);
}
</code></pre>
<p>This function atomically adds the given delta to the <code>count</code> and returns old value of the count. After this it just returns sum of the given <code>delta</code> and old value of the <code>count</code> field. In our case we undo write bias from the <code>count</code> as we didn't acquire a lock. After this step we try to do <code>optimistic spinning</code> by the call of the <code>rwsem_optimistic_spin</code> function:</p>
<pre><code class="language-C">if (rwsem_optimistic_spin(sem))
      return sem;
</code></pre>
<p>We will skip implementation of the <code>rwsem_optimistic_spin</code> function, as it is similar on the <code>mutex_optimistic_spin</code> function which we saw in the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-4">previous part</a>. In short words we check existence other tasks ready to run that have higher priority in the <code>rwsem_optimistic_spin</code> function. If there are such tasks, the process will be added to the <a href="http://www.cs.rochester.edu/%7Escott/papers/1991_TOCS_synch.pdf">MCS</a> <code>waitqueue</code> and start to spin in the loop until a lock will be able to be acquired. If <code>optimistic spinning</code> is disabled, a process will be added to the <code>wait_list</code> and marked as waiting for write:</p>
<pre><code class="language-C">waiter.task = current;
waiter.type = RWSEM_WAITING_FOR_WRITE;

if (list_empty(&amp;sem-&gt;wait_list))
    waiting = false;

list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list);
</code></pre>
<p>waiters list and start to wait until it will successfully acquire the lock. After we have added a process to the waiters list which was empty before this moment, we update the value of the <code>rw_semaphore-&gt;count</code> with the <code>RWSEM_WAITING_BIAS</code>:</p>
<pre><code class="language-C">count = rwsem_atomic_update(RWSEM_WAITING_BIAS, sem);
</code></pre>
<p>with this we mark <code>rw_semaphore-&gt;counter</code> that it is already locked and exists/waits one <code>writer</code> which wants to acquire the lock. In other way we try to wake <code>reader</code> processes from the <code>wait queue</code> that were queued before this <code>writer</code> process and there are no active readers. In the end of the <code>rwsem_down_write_failed</code> a <code>writer</code> process will go to sleep which didn't acquire a lock in the following loop:</p>
<pre><code class="language-C">while (true) {
    if (rwsem_try_write_lock(count, sem))
        break;
    raw_spin_unlock_irq(&amp;sem-&gt;wait_lock);
    do {
        schedule();
        set_current_state(TASK_UNINTERRUPTIBLE);
    } while ((count = sem-&gt;count) &amp; RWSEM_ACTIVE_MASK);
    raw_spin_lock_irq(&amp;sem-&gt;wait_lock);
}
</code></pre>
<p>I will skip explanation of this loop as we already met similar functional in the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-4">previous part</a>.</p>
<p>That's all. From this moment, our <code>writer</code> process will acquire or not acquire a lock depends on the value of the <code>rw_semaphore-&gt;count</code> field. Now if we will look at the implementation of the <code>down_read</code> function which executes a try of acquiring of a lock. We will see similar actions which we saw in the <code>down_write</code> function. This function calls different debugging and lock validator related functions/macros:</p>
<pre><code class="language-C">void __sched down_read(struct rw_semaphore *sem)
{
        might_sleep();
        rwsem_acquire_read(&amp;sem-&gt;dep_map, 0, 0, _RET_IP_);

        LOCK_CONTENDED(sem, __down_read_trylock, __down_read);
}
</code></pre>
<p>and does all job in the <code>__down_read</code> function. The <code>__down_read</code> consists of inline assembly statement:</p>
<pre><code class="language-C">static inline void __down_read(struct rw_semaphore *sem)
{
         asm volatile(&quot;# beginning down_read\n\t&quot;
                     LOCK_PREFIX _ASM_INC &quot;(%1)\n\t&quot;
                     &quot;  jns        1f\n&quot;
                     &quot;  call call_rwsem_down_read_failed\n&quot;
                     &quot;1:\n\t&quot;
                     &quot;# ending down_read\n\t&quot;
                     : &quot;+m&quot; (sem-&gt;count)
                     : &quot;a&quot; (sem)
                     : &quot;memory&quot;, &quot;cc&quot;);
}
</code></pre>
<p>which increments value of the given <code>rw_semaphore-&gt;count</code> and calls the <code>call_rwsem_down_read_failed</code> if this value is negative. In other way we jump at the label <code>1:</code> and exit. After this <code>read</code> lock will be successfully acquired. Notice that we check a sign of the <code>count</code> value as it may be negative, because as you may remember most significant <a href="https://en.wikipedia.org/wiki/Word_%28computer_architecture%29">word</a> of the <code>rw_semaphore-&gt;count</code> contains negated number of active writers.</p>
<p>Let's consider case when a process wants to acquire a lock for <code>read</code> operation, but it is already locked. In this case the <code>call_rwsem_down_read_failed</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/lib/rwsem.S">arch/x86/lib/rwsem.S</a>  assembly file will be called. If you will look at the implementation of this function, you will notice that it does the same that <code>call_rwsem_down_write_failed</code> function does. Except it calls the <code>rwsem_down_read_failed</code> function instead of <code>rwsem_down_write_failed</code>. Now let's consider implementation of the <code>rwsem_down_read_failed</code> function. It starts from the adding a process to the <code>wait queue</code> and updating of value of the <code>rw_semaphore-&gt;counter</code>:</p>
<pre><code class="language-C">long adjustment = -RWSEM_ACTIVE_READ_BIAS;

waiter.task = tsk;
waiter.type = RWSEM_WAITING_FOR_READ;

if (list_empty(&amp;sem-&gt;wait_list))
    adjustment += RWSEM_WAITING_BIAS;
list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list);

count = rwsem_atomic_update(adjustment, sem);
</code></pre>
<p>Notice that if the <code>wait queue</code> was empty before we clear the <code>rw_semaphore-&gt;counter</code> and undo <code>read</code> bias in other way. At the next step we check that there are no active locks and we are first in the <code>wait queue</code> we need to join currently active <code>reader</code> processes. In other way we go to sleep until a lock will not be able to acquired.</p>
<p>That's all. Now we know how <code>reader</code> and <code>writer</code> processes will behave in different cases during a lock acquisition. Now let's take a short look at <code>unlock</code> operations. The <code>up_read</code> and <code>up_write</code> functions allows us to unlock a <code>reader</code> or <code>writer</code> lock. First of all let's take a look at the implementation of the <code>up_write</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/locking/rwsem.c">kernel/locking/rwsem.c</a> source code file:</p>
<pre><code class="language-C">void up_write(struct rw_semaphore *sem)
{
        rwsem_release(&amp;sem-&gt;dep_map, 1, _RET_IP_);

        rwsem_clear_owner(sem);
        __up_write(sem);
}
</code></pre>
<p>First of all it calls the <code>rwsem_release</code> macro which is related to the lock validator of the Linux kernel, so we will skip it now. And at the next line the <code>rwsem_clear_owner</code> function which as you may understand from the name of this function, just clears the <code>owner</code> field of the given <code>rw_semaphore</code>:</p>
<pre><code class="language-C">static inline void rwsem_clear_owner(struct rw_semaphore *sem)
{
	sem-&gt;owner = NULL;
}
</code></pre>
<p>The <code>__up_write</code> function does all job of unlocking of the lock. The <code>_up_write</code> is architecture-specific function, so for our case it will be located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/rwsem.h">arch/x86/include/asm/rwsem.h</a> source code file. If we will take a look at the implementation of this function, we will see that it does almost the same that <code>__down_write</code> function, but conversely. Instead of adding of the <code>RWSEM_ACTIVE_WRITE_BIAS</code> to the <code>count</code>, we subtract the same value and check the <code>sign</code> of the previous value.</p>
<p>If the previous value of the <code>rw_semaphore-&gt;count</code> is not negative, a writer process released a lock and now it may be acquired by someone else. In other case, the <code>rw_semaphore-&gt;count</code> will contain negative values. This means that there is at least one <code>writer</code> in a wait queue. In this case the <code>call_rwsem_wake</code> function will be called. This function acts like similar functions which we already saw above. It store general purpose registers at the stack for preserving and call the <code>rwsem_wake</code> function.</p>
<p>First of all the <code>rwsem_wake</code> function checks if a spinner is present. In this case it will just acquire a lock which is just released by lock owner. In other case there must be someone in the <code>wait queue</code> and we need to wake or writer process if it exists at the top of the <code>wait queue</code> or all <code>reader</code> processes. The <code>up_read</code> function which release a <code>reader</code> lock acts in similar way like <code>up_write</code>, but with a little difference. Instead of subtracting of <code>RWSEM_ACTIVE_WRITE_BIAS</code> from the <code>rw_semaphore-&gt;count</code>, it subtracts <code>1</code> from it, because less significant word of the <code>count</code> contains number active locks. After this it checks <code>sign</code> of the <code>count</code> and calls the <code>rwsem_wake</code> like <code>__up_write</code> if the <code>count</code> is negative or in other way lock will be successfully released.</p>
<p>That's all. We have considered API for manipulation with <code>reader/writer semaphore</code>: <code>up_read/up_write</code> and <code>down_read/down_write</code>. We saw that the Linux kernel provides additional API, besides this functions, like the <code>, </code> and etc. But I will not consider implementation of these function in this part because it must be similar on that we have seen in this part of except few subtleties.</p>
<h2 id="conclusion-43"><a class="header" href="#conclusion-43">Conclusion</a></h2>
<p>This is the end of the fifth part of the <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitives</a> chapter in the Linux kernel. In this part we met with special type of <code>semaphore</code> - <code>readers/writer</code> semaphore which provides access to data for multiply process to read or for one process to writer. In the next part we will continue to dive into synchronization primitives in the Linux kernel.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-43"><a class="header" href="#links-43">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">Synchronization primitives</a></li>
<li><a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">Readers/Writer lock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Spinlock">Spinlocks</a></li>
<li><a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">Semaphore</a></li>
<li><a href="https://en.wikipedia.org/wiki/Mutual_exclusion">Mutex</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64 architecture</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/datastructures/linux-datastructures-1">Doubly linked list</a></li>
<li><a href="http://www.cs.rochester.edu/%7Escott/papers/1991_TOCS_synch.pdf">MCS lock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">Linux kernel lock validator</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linearizability">Atomic operations</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-3">Inline assembly</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_327.html">XADD instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">LOCK instruction</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-4">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronization-primitives-in-the-linux-kernel-part-6"><a class="header" href="#synchronization-primitives-in-the-linux-kernel-part-6">Synchronization primitives in the Linux kernel. Part 6.</a></h1>
<h2 id="introduction-8"><a class="header" href="#introduction-8">Introduction</a></h2>
<p>This is the sixth part of the chapter which describes <a href="https://en.wikipedia.org/wiki/Synchronization_(computer_science)">synchronization primitives</a> in the Linux kernel and in the previous parts we finished to consider different <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">readers-writer lock</a> synchronization primitives. We will continue to learn synchronization primitives in this part and start to consider a similar synchronization primitive which can be used to avoid the <code>writer starvation</code> problem. The name of this synchronization primitive is - <code>seqlock</code> or <code>sequential locks</code>.</p>
<p>We know from the previous <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-5">part</a> that <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">readers-writer lock</a> is a special lock mechanism which allows concurrent access for read-only operations, but an exclusive lock is needed for writing or modifying data. As we may guess, it may lead to a problem which is called <code>writer starvation</code>. In other words, a writer process can't acquire a lock as long as at least one reader process which acquired a lock holds it. So, in the situation when contention is high, it will lead to situation when a writer process which wants to acquire a lock will wait for it for a long time.</p>
<p>The <code>seqlock</code> synchronization primitive can help solve this problem.</p>
<p>As in all previous parts of this <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">book</a>, we will try to consider this synchronization primitive from the theoretical side and only than we will consider <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> provided by the Linux kernel to manipulate the <code>seqlocks</code>.</p>
<p>So, let's start.</p>
<h2 id="sequential-lock"><a class="header" href="#sequential-lock">Sequential lock</a></h2>
<p>So, what is a <code>seqlock</code> synchronization primitive and how does it work? Let's try to answer these questions in this paragraph. Actually <code>sequential locks</code> were introduced in the Linux kernel 2.6.x. Main point of this synchronization primitive is to provide fast and lock-free access to shared resources. Since the heart of <code>sequential lock</code> synchronization primitive is <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">spinlock</a> synchronization primitive, <code>sequential locks</code> work in situations where the protected resources are small and simple. Additionally write access must be rare and also should be fast.</p>
<p>Work of this synchronization primitive is based on the sequence of events counter. Actually a <code>sequential lock</code> allows free access to a resource for readers, but each reader must check existence of conflicts with a writer. This synchronization primitive introduces a special counter. The main algorithm of work of <code>sequential locks</code> is simple: Each writer which acquired a sequential lock increments this counter and additionally acquires a <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">spinlock</a>. When this writer finishes, it will release the acquired spinlock to give access to other writers and increment the counter of a sequential lock again.</p>
<p>Read only access works on the following principle, it gets the value of a <code>sequential lock</code> counter before it will enter into <a href="https://en.wikipedia.org/wiki/Critical_section">critical section</a> and compares it with the value of the same <code>sequential lock</code> counter at the exit of critical section. If their values are equal, this means that there weren't writers for this period. If their values are not equal, this means that a writer has incremented the counter during the <a href="https://en.wikipedia.org/wiki/Critical_section">critical section</a>. This conflict means that reading of protected data must be repeated.</p>
<p>That's all. As we may see principle of work of <code>sequential locks</code> is simple.</p>
<pre><code class="language-C">unsigned int seq_counter_value;

do {
    seq_counter_value = get_seq_counter_val(&amp;the_lock);
    //
    // do as we want here
    //
} while (__retry__);
</code></pre>
<p>Actually the Linux kernel does not provide <code>get_seq_counter_val()</code> function. Here it is just a stub. Like a <code>__retry__</code> too. As I already wrote above, we will see actual the <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> for this in the next paragraph of this part.</p>
<p>Ok, now we know what a <code>seqlock</code> synchronization primitive is and how it is represented in the Linux kernel. In this case, we may go ahead and start to look at the <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> which the Linux kernel provides for manipulation of synchronization primitives of this type.</p>
<h2 id="sequential-lock-api"><a class="header" href="#sequential-lock-api">Sequential lock API</a></h2>
<p>So, now we know a little about <code>sequential lock</code> synchronization primitive from theoretical side, let's look at its implementation in the Linux kernel. All <code>sequential locks</code> <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> are located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/seqlock.h">include/linux/seqlock.h</a> header file.</p>
<p>First of all we may see that the a <code>sequential lock</code> mechanism is represented by the following type:</p>
<pre><code class="language-C">typedef struct {
	struct seqcount seqcount;
	spinlock_t lock;
} seqlock_t;
</code></pre>
<p>As we may see the <code>seqlock_t</code> provides two fields. These fields represent a sequential lock counter, description of which we saw above and also a <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">spinlock</a> which will protect data from other writers. Note that the <code>seqcount</code> counter represented as <code>seqcount</code> type. The <code>seqcount</code> is structure:</p>
<pre><code class="language-C">typedef struct seqcount {
	unsigned sequence;
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	struct lockdep_map dep_map;
#endif
} seqcount_t;
</code></pre>
<p>which holds counter of a sequential lock and <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a> related field.</p>
<p>As always in previous parts of this <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim">chapter</a>, before we will consider an <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> of <code>sequential lock</code> mechanism in the Linux kernel, we need to know how to initialize an instance of <code>seqlock_t</code>.</p>
<p>We saw in the previous parts that often the Linux kernel provides two approaches to execute initialization of the given synchronization primitive. The same situation with the <code>seqlock_t</code> structure. These approaches allows to initialize a <code>seqlock_t</code> in two following:</p>
<ul>
<li><code>statically</code>;</li>
<li><code>dynamically</code>.</li>
</ul>
<p>ways. Let's look at the first approach. We are able to initialize a <code>seqlock_t</code> statically with the <code>DEFINE_SEQLOCK</code> macro:</p>
<pre><code class="language-C">#define DEFINE_SEQLOCK(x) \
		seqlock_t x = __SEQLOCK_UNLOCKED(x)
</code></pre>
<p>which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/seqlock.h">include/linux/seqlock.h</a> header file. As we may see, the <code>DEFINE_SEQLOCK</code> macro takes one argument and expands to the definition and initialization of the <code>seqlock_t</code> structure. Initialization occurs with the help of the <code>__SEQLOCK_UNLOCKED</code> macro which is defined in the same source code file. Let's look at the implementation of this macro:</p>
<pre><code class="language-C">#define __SEQLOCK_UNLOCKED(lockname)			\
	{						\
		.seqcount = SEQCNT_ZERO(lockname),	\
		.lock =	__SPIN_LOCK_UNLOCKED(lockname)	\
	}
</code></pre>
<p>As we may see the, <code>__SEQLOCK_UNLOCKED</code> macro executes initialization of fields of the given <code>seqlock_t</code> structure. The first field is <code>seqcount</code> initialized with the <code>SEQCNT_ZERO</code> macro which expands to the:</p>
<pre><code class="language-C">#define SEQCNT_ZERO(lockname) { .sequence = 0, SEQCOUNT_DEP_MAP_INIT(lockname)}
</code></pre>
<p>So we just initialize counter of the given sequential lock to zero and additionally we can see <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a> related initialization which depends on the state of the <code>CONFIG_DEBUG_LOCK_ALLOC</code> kernel configuration option:</p>
<pre><code class="language-C">#ifdef CONFIG_DEBUG_LOCK_ALLOC
# define SEQCOUNT_DEP_MAP_INIT(lockname) \
    .dep_map = { .name = #lockname } \
    ...
    ...
    ...
#else
# define SEQCOUNT_DEP_MAP_INIT(lockname)
    ...
    ...
    ...
#endif
</code></pre>
<p>As I already wrote in previous parts of this <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim">chapter</a> we will not consider <a href="https://en.wikipedia.org/wiki/Debugging">debugging</a> and <a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a> related stuff in this part. So for now we just skip the <code>SEQCOUNT_DEP_MAP_INIT</code> macro. The second field of the given <code>seqlock_t</code> is <code>lock</code> initialized with the <code>__SPIN_LOCK_UNLOCKED</code> macro which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/spinlock_types.h">include/linux/spinlock_types.h</a> header file. We will not consider implementation of this macro here as it just initializes <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">rawspinlock</a> with architecture-specific methods (More about spinlocks you may read in first parts of this <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim">chapter</a>).</p>
<p>We have considered the first way to initialize a sequential lock. Let's consider second way to do the same, but do it dynamically. We can initialize a sequential lock with the <code>seqlock_init</code> macro which is defined in the same  <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/seqlock.h">include/linux/seqlock.h</a> header file.</p>
<p>Let's look at the implementation of this macro:</p>
<pre><code class="language-C">#define seqlock_init(x)					\
	do {						\
		seqcount_init(&amp;(x)-&gt;seqcount);		\
		spin_lock_init(&amp;(x)-&gt;lock);		\
	} while (0)
</code></pre>
<p>As we may see, the <code>seqlock_init</code> expands into two macros. The first macro <code>seqcount_init</code> takes counter of the given sequential lock and expands to the call of the <code>__seqcount_init</code> function:</p>
<pre><code class="language-C"># define seqcount_init(s)				\
	do {						\
		static struct lock_class_key __key;	\
		__seqcount_init((s), #s, &amp;__key);	\
	} while (0)
</code></pre>
<p>from the same header file. This function</p>
<pre><code class="language-C">static inline void __seqcount_init(seqcount_t *s, const char *name,
					  struct lock_class_key *key)
{
    lockdep_init_map(&amp;s-&gt;dep_map, name, key, 0);
    s-&gt;sequence = 0;
}
</code></pre>
<p>just initializes counter of the given <code>seqcount_t</code> with zero. The second call from the <code>seqlock_init</code> macro is the call of the <code>spin_lock_init</code> macro which we saw in the <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">first part</a> of this chapter.</p>
<p>So, now we know how to initialize a <code>sequential lock</code>, now let's look at how to use it. The Linux kernel provides following <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> to manipulate <code>sequential locks</code>:</p>
<pre><code class="language-C">static inline unsigned read_seqbegin(const seqlock_t *sl);
static inline unsigned read_seqretry(const seqlock_t *sl, unsigned start);
static inline void write_seqlock(seqlock_t *sl);
static inline void write_sequnlock(seqlock_t *sl);
static inline void write_seqlock_irq(seqlock_t *sl);
static inline void write_sequnlock_irq(seqlock_t *sl);
static inline void read_seqlock_excl(seqlock_t *sl)
static inline void read_sequnlock_excl(seqlock_t *sl)
</code></pre>
<p>and others. Before we move on to considering the implementation of this <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a>, we must know that there actually are two types of readers. The first type of reader never blocks a writer process. In this case writer will not wait for readers. The second type of reader which can lock. In this case, the locking reader will block the writer as it will wait while reader will not release its lock.</p>
<p>First of all let's consider the first type of readers. The <code>read_seqbegin</code> function begins a seq-read <a href="https://en.wikipedia.org/wiki/Critical_section">critical section</a>.</p>
<p>As we may see this function just returns value of the <code>read_seqcount_begin</code> function:</p>
<pre><code class="language-C">static inline unsigned read_seqbegin(const seqlock_t *sl)
{
	return read_seqcount_begin(&amp;sl-&gt;seqcount);
}
</code></pre>
<p>In its turn the <code>read_seqcount_begin</code> function calls the <code>raw_read_seqcount_begin</code> function:</p>
<pre><code class="language-C">static inline unsigned read_seqcount_begin(const seqcount_t *s)
{
	return raw_read_seqcount_begin(s);
}
</code></pre>
<p>which just returns value of the <code>sequential lock</code> counter:</p>
<pre><code class="language-C">static inline unsigned raw_read_seqcount(const seqcount_t *s)
{
	unsigned ret = READ_ONCE(s-&gt;sequence);
	smp_rmb();
	return ret;
}
</code></pre>
<p>After we have the initial value of the given <code>sequential lock</code> counter and did some stuff, we know from the previous paragraph of this function, that we need to compare it with the current value of the counter the same <code>sequential lock</code> before we will exit from the critical section. We can achieve this by the call of the <code>read_seqretry</code> function. This function takes a <code>sequential lock</code>, start value of the counter and through a chain of functions:</p>
<pre><code class="language-C">static inline unsigned read_seqretry(const seqlock_t *sl, unsigned start)
{
	return read_seqcount_retry(&amp;sl-&gt;seqcount, start);
}

static inline int read_seqcount_retry(const seqcount_t *s, unsigned start)
{
	smp_rmb();
	return __read_seqcount_retry(s, start);
}
</code></pre>
<p>it calls the <code>__read_seqcount_retry</code> function:</p>
<pre><code class="language-C">static inline int __read_seqcount_retry(const seqcount_t *s, unsigned start)
{
	return unlikely(s-&gt;sequence != start);
}
</code></pre>
<p>which just compares value of the counter of the given <code>sequential lock</code> with the initial value of this counter. If the initial value of the counter which is obtained from <code>read_seqbegin()</code> function is odd, this means that a writer was in the middle of updating the data when our reader began to act. In this case the value of the data can be in inconsistent state, so we need to try to read it again.</p>
<p>This is a common pattern in the Linux kernel. For example, you may remember the <code>jiffies</code> concept from the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-1">first part</a> of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">timers and time management in the Linux kernel</a> chapter. The sequential lock is used to obtain value of <code>jiffies</code> at <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture:</p>
<pre><code class="language-C">u64 get_jiffies_64(void)
{
	unsigned long seq;
	u64 ret;

	do {
		seq = read_seqbegin(&amp;jiffies_lock);
		ret = jiffies_64;
	} while (read_seqretry(&amp;jiffies_lock, seq));
	return ret;
}
</code></pre>
<p>Here we just read the value of the counter of the <code>jiffies_lock</code> sequential lock and then we write value of the <code>jiffies_64</code> system variable to the <code>ret</code>. As here we may see <code>do/while</code> loop, the body of the loop will be executed at least one time. So, as the body of loop was executed, we read and compare the current value of the counter of the <code>jiffies_lock</code> with the initial value. If these values are not equal, execution of the loop will be repeated, else <code>get_jiffies_64</code> will return its value in <code>ret</code>.</p>
<p>We just saw the first type of readers which do not block writer and other readers. Let's consider second type. It does not update value of a <code>sequential lock</code> counter, but just locks <code>spinlock</code>:</p>
<pre><code class="language-C">static inline void read_seqlock_excl(seqlock_t *sl)
{
	spin_lock(&amp;sl-&gt;lock);
}
</code></pre>
<p>So, no one reader or writer can't access protected data. When a reader finishes, the lock must be unlocked with the:</p>
<pre><code class="language-C">static inline void read_sequnlock_excl(seqlock_t *sl)
{
	spin_unlock(&amp;sl-&gt;lock);
}
</code></pre>
<p>function.</p>
<p>Now we know how <code>sequential lock</code> work for readers. Let's consider how does writer act when it wants to acquire a <code>sequential lock</code> to modify data. To acquire a <code>sequential lock</code>, writer should use <code>write_seqlock</code> function. If we look at the implementation of this function:</p>
<pre><code class="language-C">static inline void write_seqlock(seqlock_t *sl)
{
	spin_lock(&amp;sl-&gt;lock);
	write_seqcount_begin(&amp;sl-&gt;seqcount);
}
</code></pre>
<p>We will see that it acquires <code>spinlock</code> to prevent access from other writers and calls the <code>write_seqcount_begin</code> function. This function just increments value of the <code>sequential lock</code> counter:</p>
<pre><code class="language-C">static inline void raw_write_seqcount_begin(seqcount_t *s)
{
	s-&gt;sequence++;
	smp_wmb();
}
</code></pre>
<p>When a writer process will finish to modify data, the <code>write_sequnlock</code> function must be called to release a lock and give access to other writers or readers. Let's consider the implementation of the <code>write_sequnlock</code> function. It looks pretty simple:</p>
<pre><code class="language-C">static inline void write_sequnlock(seqlock_t *sl)
{
	write_seqcount_end(&amp;sl-&gt;seqcount);
	spin_unlock(&amp;sl-&gt;lock);
}
</code></pre>
<p>First of all it just calls <code>write_seqcount_end</code> function to increase value of the counter of the <code>sequential</code> lock again:</p>
<pre><code class="language-C">static inline void raw_write_seqcount_end(seqcount_t *s)
{
	smp_wmb();
	s-&gt;sequence++;
}
</code></pre>
<p>and in the end we just call the <code>spin_unlock</code> macro to give access for other readers or writers.</p>
<p>That's all about <code>sequential lock</code> mechanism in the Linux kernel. Of course we did not consider full <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> of this mechanism in this part. But all other functions are based on these which we described here. For example, Linux kernel also provides some safe macros/functions to use <code>sequential lock</code> mechanism in <a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt handlers</a> of <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-9">softirq</a>: <code>write_seqclock_irq</code> and <code>write_sequnlock_irq</code>:</p>
<pre><code class="language-C">static inline void write_seqlock_irq(seqlock_t *sl)
{
	spin_lock_irq(&amp;sl-&gt;lock);
	write_seqcount_begin(&amp;sl-&gt;seqcount);
}

static inline void write_sequnlock_irq(seqlock_t *sl)
{
	write_seqcount_end(&amp;sl-&gt;seqcount);
	spin_unlock_irq(&amp;sl-&gt;lock);
}
</code></pre>
<p>As we may see, these functions differ only in the initialization of spinlock. They call <code>spin_lock_irq</code> and <code>spin_unlock_irq</code> instead of <code>spin_lock</code> and <code>spin_unlock</code>.</p>
<p>Or for example <code>write_seqlock_irqsave</code> and <code>write_sequnlock_irqrestore</code> functions which are the same but used <code>spin_lock_irqsave</code> and <code>spin_unlock_irqsave</code> macro to use in <a href="https://en.wikipedia.org/wiki/Interrupt_request_(PC_architecture)">IRQ</a> handlers.</p>
<p>That's all.</p>
<h2 id="conclusion-44"><a class="header" href="#conclusion-44">Conclusion</a></h2>
<p>This is the end of the sixth part of the <a href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29">synchronization primitives</a> chapter in the Linux kernel. In this part we met with new synchronization primitive which is called - <code>sequential lock</code>. From the theoretical side, this synchronization primitive very similar on a <a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">readers-writer lock</a> synchronization primitive, but allows to avoid <code>writer-starving</code> issue.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-44"><a class="header" href="#links-44">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Synchronization_(computer_science)">synchronization primitives</a></li>
<li><a href="https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock">readers-writer lock</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">spinlock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Critical_section">critical section</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">lock validator</a></li>
<li><a href="https://en.wikipedia.org/wiki/Debugging">debugging</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/">Timers and time management in the Linux kernel</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt handlers</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-9">softirq</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_(PC_architecture)">IRQ</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-5">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-kernel-memory-management"><a class="header" href="#linux-kernel-memory-management">Linux kernel memory management</a></h1>
<p>This chapter describes memory management in the Linux kernel. You will see here a
couple of posts which describe different parts of the Linux memory management framework:</p>
<ul>
<li><a href="MM/linux-mm-1.html">Memblock</a> - describes early <code>memblock</code> allocator.</li>
<li><a href="MM/linux-mm-2.html">Fix-Mapped Addresses and ioremap</a> - describes <code>fix-mapped</code> addresses and early <code>ioremap</code>.</li>
<li><a href="MM/linux-mm-3.html">kmemcheck</a> - third part describes <code>kmemcheck</code> tool.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-kernel-memory-management-part-1"><a class="header" href="#linux-kernel-memory-management-part-1">Linux kernel memory management Part 1.</a></h1>
<h2 id="introduction-9"><a class="header" href="#introduction-9">Introduction</a></h2>
<p>Memory management is one of the most complex (and I think that it is the most complex) part of the operating system kernel. In the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-3">last preparations before the kernel entry point</a> part we stopped right before call of the <code>start_kernel</code> function. This function initializes all the kernel features (including architecture-dependent features) before the kernel runs the first <code>init</code> process. You may remember as we built early page tables, identity page tables and fixmap page tables in the boot time. No complicated memory management is working yet. When the <code>start_kernel</code> function is called we will see the transition to more complex data structures and techniques for memory management. For a good understanding of the initialization process in the Linux kernel we need to have a clear understanding of these techniques. This chapter will provide an overview of the different parts of the linux kernel memory management framework and its API, starting from the <code>memblock</code>.</p>
<h2 id="memblock"><a class="header" href="#memblock">Memblock</a></h2>
<p>Memblock is one of the methods of managing memory regions during the early bootstrap period while the usual kernel memory allocators are not up and
running yet. Previously it was called <code>Logical Memory Block</code>, but with the <a href="https://lkml.org/lkml/2010/7/13/68">patch</a> by Yinghai Lu, it was renamed to the <code>memblock</code>. As Linux kernel for <code>x86_64</code> architecture uses this method. We already met <code>memblock</code> in the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-3">Last preparations before the kernel entry point</a> part. And now it's time to get acquainted with it closer. We will see how it is implemented.</p>
<p>We will start to learn <code>memblock</code> from the data structures. Definitions of all logical-memory-block-related data structures can be found in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/memblock.h">include/linux/memblock.h</a> header file.</p>
<p>The first structure has the same name as this part and it is:</p>
<pre><code class="language-C">struct memblock {
         bool bottom_up;
         phys_addr_t current_limit;
         struct memblock_type memory;   --&gt; array of memblock_region
         struct memblock_type reserved; --&gt; array of memblock_region
#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP
         struct memblock_type physmem;
#endif
};
</code></pre>
<p>This structure contains five fields. First is <code>bottom_up</code> which allows allocating memory in bottom-up mode when it is <code>true</code>. Next field is <code>current_limit</code>. This field describes the limit size of the memory block. The next three fields describe the type of the memory block. It can be: reserved, memory and physical memory (physical memory is available if the <code>CONFIG_HAVE_MEMBLOCK_PHYS_MAP</code> configuration option is enabled). Now we see yet another data structure - <code>memblock_type</code>. Let's look at its definition:</p>
<pre><code class="language-C">struct memblock_type {
	unsigned long cnt;
	unsigned long max;
	phys_addr_t total_size;
	struct memblock_region *regions;
};
</code></pre>
<p>This structure provides information about the memory type. It contains fields which describe the number of memory regions inside the current memory block, the size of all memory regions, the size of the allocated array of the memory regions, and a pointer to the array of the <code>memblock_region</code> structures. <code>memblock_region</code> is a structure which describes a memory region. Its definition is:</p>
<pre><code class="language-C">struct memblock_region {
        phys_addr_t base;
        phys_addr_t size;
        unsigned long flags;
#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP
        int nid;
#endif
};
</code></pre>
<p><code>memblock_region</code> provides the base address and size of the memory region as well as a flags field which can have the following values:</p>
<pre><code class="language-C">enum {
    MEMBLOCK_NONE	= 0x0,	/* No special request */
    MEMBLOCK_HOTPLUG	= 0x1,	/* hotpluggable region */
    MEMBLOCK_MIRROR	= 0x2,	/* mirrored region */
    MEMBLOCK_NOMAP	= 0x4,	/* don't add to kernel direct mapping */
};
</code></pre>
<p>Also <code>memblock_region</code> provides an integer field - <a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access">numa</a> node selector, if the <code>CONFIG_HAVE_MEMBLOCK_NODE_MAP</code> configuration option is enabled.</p>
<p>Schematically we can imagine it as:</p>
<pre><code>+---------------------------+   +---------------------------+
|         memblock          |   |                           |
|  _______________________  |   |                           |
| |        memory         | |   |       Array of the        |
| |      memblock_type    |-|--&gt;|      memblock_region      |
| |_______________________| |   |                           |
|                           |   +---------------------------+
|  _______________________  |   +---------------------------+
| |       reserved        | |   |                           |
| |      memblock_type    |-|--&gt;|       Array of the        |
| |_______________________| |   |      memblock_region      |
|                           |   |                           |
+---------------------------+   +---------------------------+
</code></pre>
<p>These three structures: <code>memblock</code>, <code>memblock_type</code> and <code>memblock_region</code> are main in the <code>Memblock</code>. Now we know about it and can look at Memblock initialization process.</p>
<h2 id="memblock-initialization"><a class="header" href="#memblock-initialization">Memblock initialization</a></h2>
<p>As all API of the <code>memblock</code> are described in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/memblock.h">include/linux/memblock.h</a> header file, all implementations of these functions are in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/memblock.c">mm/memblock.c</a> source code file. Let's look at the top of the source code file and we will see the initialization of the <code>memblock</code> structure:</p>
<pre><code class="language-C">struct memblock memblock __initdata_memblock = {
	.memory.regions		= memblock_memory_init_regions,
	.memory.cnt		    = 1,
	.memory.max		    = INIT_MEMBLOCK_REGIONS,

	.reserved.regions	= memblock_reserved_init_regions,
	.reserved.cnt		= 1,
	.reserved.max		= INIT_MEMBLOCK_REGIONS,

#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP
	.physmem.regions	= memblock_physmem_init_regions,
	.physmem.cnt		= 1,
	.physmem.max		= INIT_PHYSMEM_REGIONS,
#endif
	.bottom_up		    = false,
	.current_limit		= MEMBLOCK_ALLOC_ANYWHERE,
};
</code></pre>
<p>Here we can see initialization of the <code>memblock</code> structure which has the same name as structure - <code>memblock</code>. First of all note the <code>__initdata_memblock</code>. Definition of this macro looks like:</p>
<pre><code class="language-C">#ifdef CONFIG_ARCH_DISCARD_MEMBLOCK
    #define __init_memblock __meminit
    #define __initdata_memblock __meminitdata
#else
    #define __init_memblock
    #define __initdata_memblock
#endif
</code></pre>
<p>You can see that it depends on <code>CONFIG_ARCH_DISCARD_MEMBLOCK</code>. If this configuration option is enabled, memblock code will be put into the <code>.init</code> section and will be released after the kernel is booted up.</p>
<p>Next we can see the initialization of the <code>memblock_type memory</code>, <code>memblock_type reserved</code> and <code>memblock_type physmem</code> fields of the <code>memblock</code> structure. Here we are interested only in the <code>memblock_type.regions</code> initialization process. Note that every <code>memblock_type</code> field is initialized by and array of <code>memblock_region</code>s:</p>
<pre><code class="language-C">static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP
static struct memblock_region memblock_physmem_init_regions[INIT_PHYSMEM_REGIONS] __initdata_memblock;
#endif
</code></pre>
<p>Every array contains 128 memory regions. We can see it in the <code>INIT_MEMBLOCK_REGIONS</code> macro definition:</p>
<pre><code class="language-C">#define INIT_MEMBLOCK_REGIONS   128
</code></pre>
<p>Note that all arrays are also defined with the <code>__initdata_memblock</code> macro which we already saw in the <code>memblock</code> structure initialization (read above if you've forgotten).</p>
<p>The last two fields describe that <code>bottom_up</code> allocation is disabled and the limit of the current Memblock is:</p>
<pre><code class="language-C">#define MEMBLOCK_ALLOC_ANYWHERE (~(phys_addr_t)0)
</code></pre>
<p>which is <code>0xffffffffffffffff</code>.</p>
<p>On this step the initialization of the <code>memblock</code> structure has been finished and we can have a look at the Memblock API.</p>
<h2 id="memblock-api"><a class="header" href="#memblock-api">Memblock API</a></h2>
<p>Ok we have finished with the initialization of the <code>memblock</code> structure and now we can look at the Memblock API and its implementation. As I said above, the implementation of <code>memblock</code> is taking place fully in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/memblock.c">mm/memblock.c</a>. To understand how <code>memblock</code> works and how it is implemented, let's look at its usage first. There are a couple of <a href="http://lxr.free-electrons.com/ident?i=memblock">places</a> in the Linux kernel where memblock is used. For example let's take <code>memblock_x86_fill</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/e820.c#L1061">arch/x86/kernel/e820.c</a>. This function goes through the memory map provided by the <a href="http://en.wikipedia.org/wiki/E820">e820</a> and adds memory regions reserved by the kernel to the <code>memblock</code> with the <code>memblock_add</code> function. Since we have met the <code>memblock_add</code> function first, let's start from it.</p>
<p>This function takes a physical base address and the size of the memory region as arguments and add them to the <code>memblock</code>. The <code>memblock_add</code> function does not do anything special in its body, but just calls the:</p>
<pre><code class="language-C">memblock_add_range(&amp;memblock.memory, base, size, MAX_NUMNODES, 0);
</code></pre>
<p>function. We pass the memory block type - <code>memory</code>, the physical base address and the size of the memory region, the maximum number of nodes which is 1 if <code>CONFIG_NODES_SHIFT</code> is not set in the configuration file or <code>1 &lt;&lt; CONFIG_NODES_SHIFT</code> if it is set, and the flags. The <code>memblock_add_range</code> function adds a new memory region to the memory block. It starts by checking the size of the given region and if it is zero it just returns. After this, <code>memblock_add_range</code> checks the existence of the memory regions in the <code>memblock</code> structure with the given <code>memblock_type</code>. If there are no memory regions, we just fill a new <code>memory_region</code> with the given values and return (we already saw the implementation of this in the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-3">First touch of the Linux kernel memory manager framework</a>). If <code>memblock_type</code> is not empty, we start to add a new memory region to the <code>memblock</code> with the given <code>memblock_type</code>.</p>
<p>First of all we get the end of the memory region with the:</p>
<pre><code class="language-C">phys_addr_t end = base + memblock_cap_size(base, &amp;size);
</code></pre>
<p><code>memblock_cap_size</code> adjusts <code>size</code> so that <code>base + size</code> will not overflow. Its implementation is pretty easy:</p>
<pre><code class="language-C">static inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)
{
	return *size = min(*size, (phys_addr_t)ULLONG_MAX - base);
}
</code></pre>
<p><code>memblock_cap_size</code> returns the new size which is the smallest value between the given size and <code>ULLONG_MAX - base</code>.</p>
<p>After that we have the end address of the new memory region, <code>memblock_add_range</code> checks for overlap and merge conditions with memory regions that have been added before. Insertion of the new memory region to the <code>memblock</code> consists of two steps:</p>
<ul>
<li>Adding of non-overlapping parts of the new memory area as separate regions;</li>
<li>Merging of all neighboring regions.</li>
</ul>
<p>We are going through all the already stored memory regions and checking for overlap with the new region:</p>
<pre><code class="language-C">	for (i = 0; i &lt; type-&gt;cnt; i++) {
		struct memblock_region *rgn = &amp;type-&gt;regions[i];
		phys_addr_t rbase = rgn-&gt;base;
		phys_addr_t rend = rbase + rgn-&gt;size;

		if (rbase &gt;= end)
			break;
		if (rend &lt;= base)
			continue;
        ...
		...
		...
	}
</code></pre>
<p>If the new memory region does not overlap with regions which are already stored in the <code>memblock</code>, insert this region into the memblock with and this is first step, we check if the new region can fit into the memory block and call <code>memblock_double_array</code> in another way:</p>
<pre><code class="language-C">while (type-&gt;cnt + nr_new &gt; type-&gt;max)
	if (memblock_double_array(type, obase, size) &lt; 0)
		return -ENOMEM;
	insert = true;
	goto repeat;
</code></pre>
<p><code>memblock_double_array</code> doubles the size of the given regions array. Then we set <code>insert</code> to <code>true</code> and go to the <code>repeat</code> label. In the second step, starting from the <code>repeat</code> label we go through the same loop and insert the current memory region into the memory block with the <code>memblock_insert_region</code> function:</p>
<pre><code class="language-C">	if (base &lt; end) {
		nr_new++;
		if (insert)
			memblock_insert_region(type, i, base, end - base,
					       nid, flags);
	}
</code></pre>
<p>Since we set <code>insert</code> to <code>true</code> in the first step, now <code>memblock_insert_region</code> will be called. <code>memblock_insert_region</code> has almost the same implementation that we saw when we inserted a new region to the empty <code>memblock_type</code> (see above). This function gets the last memory region:</p>
<pre><code class="language-C">struct memblock_region *rgn = &amp;type-&gt;regions[idx];
</code></pre>
<p>and copies the memory area with <code>memmove</code>:</p>
<pre><code class="language-C">memmove(rgn + 1, rgn, (type-&gt;cnt - idx) * sizeof(*rgn));
</code></pre>
<p>After this fills <code>memblock_region</code> fields of the new memory region base, size, etc. and increases size of the <code>memblock_type</code>. In the end of the execution, <code>memblock_add_range</code> calls <code>memblock_merge_regions</code> which merges neighboring compatible regions in the second step.</p>
<p>In the second case the new memory region can overlap already stored regions. For example we already have <code>region1</code> in the <code>memblock</code>:</p>
<pre><code>0                    0x1000
+-----------------------+
|                       |
|                       |
|        region1        |
|                       |
|                       |
+-----------------------+
</code></pre>
<p>And now we want to add <code>region2</code> to the <code>memblock</code> with the following base address and size:</p>
<pre><code>0x100                 0x2000
+-----------------------+
|                       |
|                       |
|        region2        |
|                       |
|                       |
+-----------------------+
</code></pre>
<p>In this case set the base address of the new memory region as the end address of the overlapped region with:</p>
<pre><code class="language-C">base = min(rend, end);
</code></pre>
<p>So it will be <code>0x1000</code> in our case. And insert it as we did it already in the second step with:</p>
<pre><code>if (base &lt; end) {
	nr_new++;
	if (insert)
		memblock_insert_region(type, i, base, end - base, nid, flags);
}
</code></pre>
<p>In this case we insert <code>overlapping portion</code> (we insert only the higher portion, because the lower portion is already in the overlapped memory region), then the remaining portion and merge these portions with <code>memblock_merge_regions</code>. As I said above <code>memblock_merge_regions</code> function merges neighboring compatible regions. It goes through all memory regions from the given <code>memblock_type</code>, takes two neighboring memory regions - <code>type-&gt;regions[i]</code> and <code>type-&gt;regions[i + 1]</code> and checks that these regions have the same flags, belong to the same node and that the end address of the first regions is not equal to the base address of the second region:</p>
<pre><code class="language-C">while (i &lt; type-&gt;cnt - 1) {
	struct memblock_region *this = &amp;type-&gt;regions[i];
	struct memblock_region *next = &amp;type-&gt;regions[i + 1];
	if (this-&gt;base + this-&gt;size != next-&gt;base ||
	    memblock_get_region_node(this) !=
	    memblock_get_region_node(next) ||
	    this-&gt;flags != next-&gt;flags) {
		BUG_ON(this-&gt;base + this-&gt;size &gt; next-&gt;base);
		i++;
		continue;
	}
</code></pre>
<p>If none of these conditions are true, we update the size of the first region with the size of the next region:</p>
<pre><code class="language-C">this-&gt;size += next-&gt;size;
</code></pre>
<p>As we update the size of the first memory region with the size of the next memory region, we move all memory regions which are after the (<code>next</code>) memory region one index backwards with the <code>memmove</code> function:</p>
<pre><code class="language-C">memmove(next, next + 1, (type-&gt;cnt - (i + 2)) * sizeof(*next));
</code></pre>
<p>The <code>memmove</code> here moves all regions which are located after the <code>next</code> region to the base address of the <code>next</code> region. In the end we just decrease the count of the memory regions which belong to the <code>memblock_type</code>:</p>
<pre><code class="language-C">type-&gt;cnt--;
</code></pre>
<p>After this we will get two memory regions merged into one:</p>
<pre><code>0                                             0x2000
+------------------------------------------------+
|                                                |
|                                                |
|                   region1                      |
|                                                |
|                                                |
+------------------------------------------------+
</code></pre>
<p>As we decreased counts of regions in a memblock with certain type, increased size of the <code>this</code> region and shifted all regions which are located after <code>next</code> region to its place.</p>
<p>That's all. This is the whole principle of the work of the <code>memblock_add_range</code> function.</p>
<p>There is also <code>memblock_reserve</code> function which does the same as <code>memblock_add</code>, but with one difference. It stores <code>memblock_type.reserved</code> in the memblock instead of <code>memblock_type.memory</code>.</p>
<p>Of course this is not the full API. Memblock provides APIs not only for adding <code>memory</code> and <code>reserved</code> memory regions, but also:</p>
<ul>
<li><code>memblock_remove</code> - removes memory region from memblock;</li>
<li><code>memblock_find_in_range</code> - finds free area in given range;</li>
<li><code>memblock_free</code> - releases memory region in memblock;</li>
<li><code>for_each_mem_range</code> - iterates through memblock areas.</li>
</ul>
<p>and many more....</p>
<h2 id="getting-info-about-memory-regions"><a class="header" href="#getting-info-about-memory-regions">Getting info about memory regions</a></h2>
<p>Memblock also provides an API for getting information about allocated memory regions in the <code>memblock</code>. It is split in two parts:</p>
<ul>
<li><code>get_allocated_memblock_memory_regions_info</code> - getting info about memory regions;</li>
<li><code>get_allocated_memblock_reserved_regions_info</code> - getting info about reserved regions.</li>
</ul>
<p>Implementation of these functions is easy. Let's look at <code>get_allocated_memblock_reserved_regions_info</code> for example:</p>
<pre><code class="language-C">phys_addr_t __init_memblock get_allocated_memblock_reserved_regions_info(
					phys_addr_t *addr)
{
	if (memblock.reserved.regions == memblock_reserved_init_regions)
		return 0;

	*addr = __pa(memblock.reserved.regions);

	return PAGE_ALIGN(sizeof(struct memblock_region) *
			  memblock.reserved.max);
}
</code></pre>
<p>First of all this function checks that <code>memblock</code> contains reserved memory regions. If <code>memblock</code> does not contain reserved memory regions we just return zero. Otherwise we write the physical address of the reserved memory regions array to the given address and return aligned size of the allocated array. Note that there is <code>PAGE_ALIGN</code> macro used for align. Actually it depends on size of page:</p>
<pre><code class="language-C">#define PAGE_ALIGN(addr) ALIGN(addr, PAGE_SIZE)
</code></pre>
<p>Implementation of the <code>get_allocated_memblock_memory_regions_info</code> function is the same. It has only one difference, <code>memblock_type.memory</code> used instead of <code>memblock_type.reserved</code>.</p>
<h2 id="memblock-debugging"><a class="header" href="#memblock-debugging">Memblock debugging</a></h2>
<p>There are many calls to <code>memblock_dbg</code> in the memblock implementation. If you pass the <code>memblock=debug</code> option to the kernel command line, this function will be called. Actually <code>memblock_dbg</code> is just a macro which expands to <code>printk</code>:</p>
<pre><code class="language-C">#define memblock_dbg(fmt, ...) \
         if (memblock_debug) printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
</code></pre>
<p>For example you can see a call of this macro in the <code>memblock_reserve</code> function:</p>
<pre><code class="language-C">memblock_dbg(&quot;memblock_reserve: [%#016llx-%#016llx] flags %#02lx %pF\n&quot;,
		     (unsigned long long)base,
		     (unsigned long long)base + size - 1,
		     flags, (void *)_RET_IP_);
</code></pre>
<p>And you will see something like this:</p>
<p><img src="MM/images/memblock.png" alt="Memblock" /></p>
<p>Memblock also has support in <a href="http://en.wikipedia.org/wiki/Debugfs">debugfs</a>. If you run the kernel on another architecture than <code>X86</code> you can access:</p>
<ul>
<li><code>/sys/kernel/debug/memblock/memory</code></li>
<li><code>/sys/kernel/debug/memblock/reserved</code></li>
<li><code>/sys/kernel/debug/memblock/physmem</code></li>
</ul>
<p>to get a dump of the <code>memblock</code> contents.</p>
<h2 id="conclusion-45"><a class="header" href="#conclusion-45">Conclusion</a></h2>
<p>This is the end of the first part about Linux kernel memory management. If you have questions or suggestions, ping me on twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-45"><a class="header" href="#links-45">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/E820">e820</a></li>
<li><a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access">numa</a></li>
<li><a href="http://en.wikipedia.org/wiki/Debugfs">debugfs</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-3">First touch of the Linux kernel memory manager framework</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-kernel-memory-management-part-2"><a class="header" href="#linux-kernel-memory-management-part-2">Linux kernel memory management Part 2.</a></h1>
<h2 id="fix-mapped-addresses-and-ioremap"><a class="header" href="#fix-mapped-addresses-and-ioremap">Fix-Mapped Addresses and ioremap</a></h2>
<p><code>Fix-Mapped</code> addresses are a set of special compile-time addresses whose corresponding physical addresses do not have to be a linear address minus <code>__START_KERNEL_map</code>. Each fix-mapped address maps one page frame and the kernel uses them as pointers that never change their address. That is the main point of these addresses. As the comment says: <code>to have a constant address at compile time, but to set the physical address only in the boot process</code>. You can remember that in the earliest <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">part</a>, we already set the <code>level2_fixmap_pgt</code>:</p>
<pre><code class="language-assembly">NEXT_PAGE(level2_fixmap_pgt)
	.fill	506,8,0
	.quad	level1_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE
	.fill	5,8,0

NEXT_PAGE(level1_fixmap_pgt)
	.fill	512,8,0
</code></pre>
<p>As you can see <code>level2_fixmap_pgt</code> is right after the <code>level2_kernel_pgt</code> which is kernel code+data+bss. Every fix-mapped address is represented by an integer index which is defined in the <code>fixed_addresses</code> enum from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/fixmap.h">arch/x86/include/asm/fixmap.h</a>. For example it contains entries for <code>VSYSCALL_PAGE</code> - if emulation of legacy vsyscall page is enabled, <code>FIX_APIC_BASE</code> for local <a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">apic</a>, etc. In virtual memory fix-mapped area is placed in the modules area:</p>
<pre><code>       +-----------+-----------------+---------------+------------------+
       |           |                 |               |                  |
       |kernel text|      kernel     |               |    vsyscalls     |
       | mapping   |       text      |    Modules    |    fix-mapped    |
       |from phys 0|       data      |               |    addresses     |
       |           |                 |               |                  |
       +-----------+-----------------+---------------+------------------+
__START_KERNEL_map   __START_KERNEL    MODULES_VADDR            0xffffffffffffffff
</code></pre>
<p>Base virtual address and size of the <code>fix-mapped</code> area are presented by the two following macro:</p>
<pre><code class="language-C">#define FIXADDR_SIZE	(__end_of_permanent_fixed_addresses &lt;&lt; PAGE_SHIFT)
#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)
</code></pre>
<p>Here <code>__end_of_permanent_fixed_addresses</code> is an element of the <code>fixed_addresses</code> enum and as I wrote above, every fix-mapped address is represented by an integer index which is defined in the <code>fixed_addresses</code>. <code>PAGE_SHIFT</code> determines the size of a page. For example size of the one page we can get with the <code>1 &lt;&lt; PAGE_SHIFT</code> expression.</p>
<p>In our case we need to get the size of the fix-mapped area, but not only of one page, that's why we are using <code>__end_of_permanent_fixed_addresses</code> for getting the size of the fix-mapped area. The <code>__end_of_permanent_fixed_addresses</code> is the last index of the <code>fixed_addresses</code> enum or in other words the <code>__end_of_permanent_fixed_addresses</code> contains amount of pages in a fixed-mapped area. So if we multiply the value of the <code>__end_of_permanent_fixed_addresses</code> on a page size value we will get size of fix-mapped area. In my case it's a little more than <code>536</code> kilobytes. In your case it might be a different number, because the size depends on amount of the fix-mapped addresses which depends on your kernel configuration.</p>
<p>The second <code>FIXADDR_START</code> macro just subtracts the fix-mapped area size from the last address of the fix-mapped area to get its base virtual address. <code>FIXADDR_TOP</code> is a rounded up address from the base address of the <a href="https://lwn.net/Articles/446528/">vsyscall</a> space:</p>
<pre><code class="language-C">#define FIXADDR_TOP     (round_up(VSYSCALL_ADDR + PAGE_SIZE, 1&lt;&lt;PMD_SHIFT) - PAGE_SIZE)
</code></pre>
<p>The <code>fixed_addresses</code> enums are used as indexes to get the virtual addresses by the <code>fix_to_virt</code> function. Implementation of this function is easy:</p>
<pre><code class="language-C">static __always_inline unsigned long fix_to_virt(const unsigned int idx)
{
        BUILD_BUG_ON(idx &gt;= __end_of_fixed_addresses);
        return __fix_to_virt(idx);
}
</code></pre>
<p>first of all it checks that the index given for the <code>fixed_addresses</code> enum is not greater or equal than <code>__end_of_fixed_addresses</code> with the <code>BUILD_BUG_ON</code> macro and then returns the result of the <code>__fix_to_virt</code> macro:</p>
<pre><code class="language-C">#define __fix_to_virt(x)        (FIXADDR_TOP - ((x) &lt;&lt; PAGE_SHIFT))
</code></pre>
<p>Here we shift left the given index of a <code>fix-mapped</code> area on the <code>PAGE_SHIFT</code> which determines size of a page as I wrote above and subtract it from the <code>FIXADDR_TOP</code> which is the highest address of the <code>fix-mapped</code> area:</p>
<pre><code>+-----------------+
|    PAGE 1       | FIXADDR_TOP (virt address)
|    PAGE 2       |
|    PAGE 3       |
|    PAGE 4 (idx) | x - 4
|    PAGE 5       |
+-----------------+
</code></pre>
<p>There is an inverse function for getting an index of a fix-mapped area corresponding to the given virtual address:</p>
<pre><code class="language-C">static inline unsigned long virt_to_fix(const unsigned long vaddr)
{
        BUG_ON(vaddr &gt;= FIXADDR_TOP || vaddr &lt; FIXADDR_START);
        return __virt_to_fix(vaddr);
}
</code></pre>
<p>The <code>virt_to_fix</code> takes a virtual address, checks that this address is between <code>FIXADDR_START</code> and <code>FIXADDR_TOP</code> and calls the <code>__virt_to_fix</code> macro which implemented as:</p>
<pre><code class="language-C">#define __virt_to_fix(x)        ((FIXADDR_TOP - ((x)&amp;PAGE_MASK)) &gt;&gt; PAGE_SHIFT)
</code></pre>
<p>As we may see, the <code>__virt_to_fix</code> macro clears the first <code>12</code> bits in the given virtual address, subtracts it from the last address the of <code>fix-mapped</code> area (<code>FIXADDR_TOP</code>) and shifts the result right on <code>PAGE_SHIFT</code> which is <code>12</code>. Let me explain how it works.</p>
<p>As in previous example (in <code>__fix_to_virt</code> macro), we start from the top of the fix-mapped area. We also go back to bottom from the top to search an index of a fix-mapped area corresponding to the given virtual address. As you may see, first of all we will clear the first <code>12</code> bits in the given virtual address with <code>x &amp; PAGE_MASK</code> expression. This allows us to get base address of page. We need to do this for case when the given virtual address points somewhere in a beginning/middle or end of a page, but not to the base address of it. At the next step subtract this from the <code>FIXADDR_TOP</code> and this gives us virtual address of a corresponding page in a fix-mapped area. In the end we just divide value of this address on <code>PAGE_SHIFT</code>. This gives us index of a fix-mapped area corresponding to the given virtual address. It may looks hard, but if you will go through this step by step, you will be sure that the <code>__virt_to_fix</code> macro is pretty easy.</p>
<p>That's all. For this moment we know a little about <code>fix-mapped</code> addresses, but this is enough to go next.</p>
<p><code>Fix-mapped</code> addresses are used in different <a href="http://lxr.free-electrons.com/ident?i=fix_to_virt">places</a> in the Linux kernel. <code>IDT</code> descriptor stored there, <a href="http://en.wikipedia.org/wiki/Trusted_Execution_Technology">Intel Trusted Execution Technology</a> UUID stored in the <code>fix-mapped</code> area started from <code>FIX_TBOOT_BASE</code> index, <a href="http://en.wikipedia.org/wiki/Xen">Xen</a> bootmap and many more... We already saw a little about <code>fix-mapped</code> addresses in the fifth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">part</a> about of the linux kernel initialization. We use <code>fix-mapped</code> area in the early <code>ioremap</code> initialization. Let's look at it more closely and try to understand what <code>ioremap</code> is, how it is implemented in the kernel and how it is related to the <code>fix-mapped</code> addresses.</p>
<h2 id="ioremap"><a class="header" href="#ioremap">ioremap</a></h2>
<p>The Linux kernel provides many different primitives to manage memory. For this moment we will touch <code>I/O memory</code>. Every device is controlled by reading/writing from/to its registers. For example a driver can turn off/on a device by writing to its registers or get the state of a device by reading from its registers. Besides registers, many devices have buffers where a driver can write something or read from there. As we know for this moment there are two ways to access device's registers and data buffers:</p>
<ul>
<li>through the I/O ports;</li>
<li>mapping of all the registers to the memory address space;</li>
</ul>
<p>In the first case every control register of a device has a number of input and output port. A device driver can read from a port and write to it with two <code>in</code> and <code>out</code> instructions which we already saw. If you want to know about currently registered port regions, you can learn about them by accessing <code>/proc/ioports</code>:</p>
<pre><code>$ cat /proc/ioports
0000-0cf7 : PCI Bus 0000:00
  0000-001f : dma1
  0020-0021 : pic1
  0040-0043 : timer0
  0050-0053 : timer1
  0060-0060 : keyboard
  0064-0064 : keyboard
  0070-0077 : rtc0
  0080-008f : dma page reg
  00a0-00a1 : pic2
  00c0-00df : dma2
  00f0-00ff : fpu
    00f0-00f0 : PNP0C04:00
  03c0-03df : vesafb
  03f8-03ff : serial
  04d0-04d1 : pnp 00:06
  0800-087f : pnp 00:01
  0a00-0a0f : pnp 00:04
  0a20-0a2f : pnp 00:04
  0a30-0a3f : pnp 00:04
0cf8-0cff : PCI conf1
0d00-ffff : PCI Bus 0000:00
...
...
...
</code></pre>
<p><code>/proc/ioports</code> provides information about which driver uses which address of a <code>I/O</code> port region. All of these memory regions, for example <code>0000-0cf7</code>, were claimed with the <code>request_region</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/ioport.h">include/linux/ioport.h</a>. Actually <code>request_region</code> is a macro which is defined as:</p>
<pre><code class="language-C">#define request_region(start,n,name)   __request_region(&amp;ioport_resource, (start), (n), (name), 0)
</code></pre>
<p>As we can see it takes three parameters:</p>
<ul>
<li><code>start</code> -  begin of region;</li>
<li><code>n</code>     -  length of region;</li>
<li><code>name</code>  -  name of requester.</li>
</ul>
<p><code>request_region</code> allocates an <code>I/O</code> port region. Very often the <code>check_region</code> function is called before the <code>request_region</code> to check that the given address range is available and the <code>release_region</code> function to release the memory region. <code>request_region</code> returns a pointer to the <code>resource</code> structure. The <code>resource</code> structure represents an abstraction for a tree-like subset of system resources. We already saw the <code>resource</code> structure in the fifth part of the kernel <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">initialization</a> process and it looks as follows:</p>
<pre><code class="language-C">struct resource {
        resource_size_t start;
        resource_size_t end;
        const char *name;
        unsigned long flags;
        struct resource *parent, *sibling, *child;
};
</code></pre>
<p>and contains start and end addresses of the resource, the name, etc. Every <code>resource</code> structure contains pointers to the <code>parent</code>, <code>sibling</code> and <code>child</code> resources. As it has a parent and a child, it means that every subset of resources has root <code>resource</code> structure. For example, for <code>I/O</code> ports it is the <code>ioport_resource</code> structure:</p>
<pre><code class="language-C">struct resource ioport_resource = {
         .name   = &quot;PCI IO&quot;,
         .start  = 0,
         .end    = IO_SPACE_LIMIT,
        .flags  = IORESOURCE_IO,
};
EXPORT_SYMBOL(ioport_resource);
</code></pre>
<p>Or for <code>iomem</code>, it is the <code>iomem_resource</code> structure:</p>
<pre><code class="language-C">struct resource iomem_resource = {
        .name   = &quot;PCI mem&quot;,
        .start  = 0,
        .end    = -1,
        .flags  = IORESOURCE_MEM,
};
</code></pre>
<p>As I have mentioned before, <code>request_regions</code> is used to register I/O port regions and this macro is used in many <a href="http://lxr.free-electrons.com/ident?i=request_region">places</a> in the kernel. For example let's look at <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/drivers/char/rtc.c">drivers/char/rtc.c</a>. This source code file provides the <a href="http://en.wikipedia.org/wiki/Real-time_clock">Real Time Clock</a> interface in the Linux kernel. As every kernel module, <code>rtc</code> module contains <code>module_init</code> definition:</p>
<pre><code class="language-C">module_init(rtc_init);
</code></pre>
<p>where <code>rtc_init</code> is the <code>rtc</code> initialization function. This function is defined in the same <code>rtc.c</code> source code file. In the <code>rtc_init</code> function we can see a couple of calls to the <code>rtc_request_region</code> functions, which wrap <code>request_region</code> for example:</p>
<pre><code class="language-C">r = rtc_request_region(RTC_IO_EXTENT);
</code></pre>
<p>where <code>rtc_request_region</code> calls:</p>
<pre><code class="language-C">r = request_region(RTC_PORT(0), size, &quot;rtc&quot;);
</code></pre>
<p>Here <code>RTC_IO_EXTENT</code> is the size of the memory region and it is <code>0x8</code>, <code>&quot;rtc&quot;</code> is the name of the region and <code>RTC_PORT</code> is:</p>
<pre><code class="language-C">#define RTC_PORT(x)     (0x70 + (x))
</code></pre>
<p>So with the <code>request_region(RTC_PORT(0), size, &quot;rtc&quot;)</code> we register a memory region that starts at <code>0x70</code> and has a size of <code>0x8</code>. Let's look at <code>/proc/ioports</code>:</p>
<pre><code>~$ sudo cat /proc/ioports | grep rtc
0070-0077 : rtc0
</code></pre>
<p>So, we got it! Ok, that was it for the I/O ports. The second way to communicate with drivers is through the use of <code>I/O</code> memory. As I have mentioned above this works by mapping the control registers and the memory of a device to the memory address space. <code>I/O</code> memory is a set of contiguous addresses which are provided by a device to the CPU through a bus. None of the memory-mapped I/O addresses are used by the kernel directly. There is a special <code>ioremap</code> function which allows us to convert the physical address on a bus to a kernel virtual address. In other words, <code>ioremap</code> maps I/O physical memory regions to make them accessible from the kernel. The <code>ioremap</code> function takes two parameters:</p>
<ul>
<li>start of the memory region;</li>
<li>size of the memory region;</li>
</ul>
<p>The I/O memory mapping API provides functions to check, request and release memory regions as I/O memory. There are three functions for that:</p>
<ul>
<li><code>request_mem_region</code></li>
<li><code>release_mem_region</code></li>
<li><code>check_mem_region</code></li>
</ul>
<pre><code>~$ sudo cat /proc/iomem
...
...
...
be826000-be82cfff : ACPI Non-volatile Storage
be82d000-bf744fff : System RAM
bf745000-bfff4fff : reserved
bfff5000-dc041fff : System RAM
dc042000-dc0d2fff : reserved
dc0d3000-dc138fff : System RAM
dc139000-dc27dfff : ACPI Non-volatile Storage
dc27e000-deffefff : reserved
defff000-deffffff : System RAM
df000000-dfffffff : RAM buffer
e0000000-feafffff : PCI Bus 0000:00
  e0000000-efffffff : PCI Bus 0000:01
    e0000000-efffffff : 0000:01:00.0
  f7c00000-f7cfffff : PCI Bus 0000:06
    f7c00000-f7c0ffff : 0000:06:00.0
    f7c10000-f7c101ff : 0000:06:00.0
      f7c10000-f7c101ff : ahci
  f7d00000-f7dfffff : PCI Bus 0000:03
    f7d00000-f7d3ffff : 0000:03:00.0
      f7d00000-f7d3ffff : alx
...
...
...
</code></pre>
<p>Part of these addresses are from the call of the <code>e820_reserve_resources</code> function. We can find a call to this function in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> and the function itself is defined in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/e820.c">arch/x86/kernel/e820.c</a>. <code>e820_reserve_resources</code> goes through the <a href="http://en.wikipedia.org/wiki/E820">e820</a> map and inserts memory regions into the root <code>iomem</code> resource structure. All <code>e820</code> memory regions which are inserted into the <code>iomem</code> resource have the following types:</p>
<pre><code class="language-C">static inline const char *e820_type_to_string(int e820_type)
{
	switch (e820_type) {
	case E820_RESERVED_KERN:
	case E820_RAM:	return &quot;System RAM&quot;;
	case E820_ACPI:	return &quot;ACPI Tables&quot;;
	case E820_NVS:	return &quot;ACPI Non-volatile Storage&quot;;
	case E820_UNUSABLE:	return &quot;Unusable memory&quot;;
	default:	return &quot;reserved&quot;;
	}
}
</code></pre>
<p>and we can see them in the <code>/proc/iomem</code> (read above).</p>
<p>Now let's try to understand how <code>ioremap</code> works. We already know a little about <code>ioremap</code>, we saw it in the fifth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">part</a> about Linux kernel initialization. If you have read this part, you can remember the call of the <code>early_ioremap_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/ioremap.c">arch/x86/mm/ioremap.c</a>. Initialization of the <code>ioremap</code> is split into two parts: there is the early part which we can use before the normal <code>ioremap</code> is available and the normal <code>ioremap</code> which is available after <code>vmalloc</code> initialization and the call of <code>paging_init</code>. We do not know anything about <code>vmalloc</code> for now, so let's consider early initialization of the <code>ioremap</code>. First of all <code>early_ioremap_init</code> checks that <code>fixmap</code> is aligned on page middle directory boundary:</p>
<pre><code class="language-C">BUILD_BUG_ON((fix_to_virt(0) + PAGE_SIZE) &amp; ((1 &lt;&lt; PMD_SHIFT) - 1));
</code></pre>
<p>more about <code>BUILD_BUG_ON</code> you can read in the first part about <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">Linux Kernel initialization</a>. So <code>BUILD_BUG_ON</code> macro raises a compilation error if the given expression is true. In the next step after this check, we can see call of the <code>early_ioremap_setup</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/early_ioremap.c">mm/early_ioremap.c</a>. This function presents generic initialization of the <code>ioremap</code>. <code>early_ioremap_setup</code> function fills the <code>slot_virt</code> array with the virtual addresses of the early fixmaps. All early fixmaps are after <code>__end_of_permanent_fixed_addresses</code> in memory. They start at <code>FIX_BITMAP_BEGIN</code> (top) and end with <code>FIX_BITMAP_END</code> (down). Actually there are <code>512</code> temporary boot-time mappings, used by early <code>ioremap</code>:</p>
<pre><code>#define NR_FIX_BTMAPS		64
#define FIX_BTMAPS_SLOTS	8
#define TOTAL_FIX_BTMAPS	(NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)
</code></pre>
<p>and <code>early_ioremap_setup</code>:</p>
<pre><code class="language-C">void __init early_ioremap_setup(void)
{
        int i;

        for (i = 0; i &lt; FIX_BTMAPS_SLOTS; i++)
                if (WARN_ON(prev_map[i]))
                        break;

        for (i = 0; i &lt; FIX_BTMAPS_SLOTS; i++)
                slot_virt[i] = __fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i);
}
</code></pre>
<p>the <code>slot_virt</code> and other arrays are defined in the same source code file:</p>
<pre><code class="language-C">static void __iomem *prev_map[FIX_BTMAPS_SLOTS] __initdata;
static unsigned long prev_size[FIX_BTMAPS_SLOTS] __initdata;
static unsigned long slot_virt[FIX_BTMAPS_SLOTS] __initdata;
</code></pre>
<p><code>slot_virt</code> contains the virtual addresses of the <code>fix-mapped</code> areas, <code>prev_map</code> array contains addresses of the early ioremap areas. Note that I wrote above: <code>Actually there are 512 temporary boot-time mappings, used by early ioremap</code> and you can see that all arrays are defined with the <code>__initdata</code> attribute which means that this memory will be released after the kernel initialization process. After <code>early_ioremap_setup</code> has finished its work, we're getting page middle directory where early ioremap begins with the <code>early_ioremap_pmd</code> function which just gets the base address of the page global directory and calculates the page middle directory for the given address:</p>
<pre><code class="language-C">static inline pmd_t * __init early_ioremap_pmd(unsigned long addr)
{
	pgd_t *base = __va(read_cr3_pa());
	pgd_t *pgd = &amp;base[pgd_index(addr)];
	pud_t *pud = pud_offset(pgd, addr);
	pmd_t *pmd = pmd_offset(pud, addr);
	return pmd;
}
</code></pre>
<p>After this we fill <code>bm_pte</code> (early ioremap page table entries) with zeros and call the <code>pmd_populate_kernel</code> function:</p>
<pre><code class="language-C">pmd = early_ioremap_pmd(fix_to_virt(FIX_BTMAP_BEGIN));
memset(bm_pte, 0, sizeof(bm_pte));
pmd_populate_kernel(&amp;init_mm, pmd, bm_pte);
</code></pre>
<p><code>pmd_populate_kernel</code> takes three parameters:</p>
<ul>
<li><code>init_mm</code> - memory descriptor of the <code>init</code> process (you can read about it in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">part</a>);</li>
<li><code>pmd</code>     - page middle directory of the beginning of the <code>ioremap</code> fixmaps;</li>
<li><code>bm_pte</code>  - early <code>ioremap</code> page table entries array which defined as:</li>
</ul>
<pre><code class="language-C">static pte_t bm_pte[PAGE_SIZE/sizeof(pte_t)] __page_aligned_bss;
</code></pre>
<p>The <code>pmd_populate_kernel</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/pgalloc.h">arch/x86/include/asm/pgalloc.h</a> and populates the page middle directory (<code>pmd</code>) provided as an argument with the given page table entries (<code>bm_pte</code>):</p>
<pre><code class="language-C">static inline void pmd_populate_kernel(struct mm_struct *mm,
                                       pmd_t *pmd, pte_t *pte)
{
        paravirt_alloc_pte(mm, __pa(pte) &gt;&gt; PAGE_SHIFT);
        set_pmd(pmd, __pmd(__pa(pte) | _PAGE_TABLE));
}
</code></pre>
<p>where <code>set_pmd</code> is:</p>
<pre><code class="language-C">#define set_pmd(pmdp, pmd)              native_set_pmd(pmdp, pmd)
</code></pre>
<p>and <code>native_set_pmd</code> is:</p>
<pre><code class="language-C">static inline void native_set_pmd(pmd_t *pmdp, pmd_t pmd)
{
        *pmdp = pmd;
}
</code></pre>
<p>That's all. Early <code>ioremap</code> is ready to use. There are a couple of checks in the <code>early_ioremap_init</code> function, but they are not so important, anyway initialization of the <code>ioremap</code> is finished.</p>
<h2 id="use-of-early-ioremap"><a class="header" href="#use-of-early-ioremap">Use of early ioremap</a></h2>
<p>As soon as early <code>ioremap</code> has been setup successfully, we can use it. It provides two functions:</p>
<ul>
<li>early_ioremap</li>
<li>early_iounmap</li>
</ul>
<p>for mapping/unmapping of I/O physical address to virtual address. Both functions depend on the <code>CONFIG_MMU</code> configuration option. <a href="http://en.wikipedia.org/wiki/Memory_management_unit">Memory management unit</a> is a special block of memory management. The main purpose of this block is the translation of physical addresses to virtual addresses. The memory management unit knows about the high-level page table addresses (<code>pgd</code>) from the <code>cr3</code> control register. If <code>CONFIG_MMU</code> options is set to <code>n</code>, <code>early_ioremap</code> just returns the given physical address and <code>early_iounmap</code> does nothing. If <code>CONFIG_MMU</code> option is set to <code>y</code>, <code>early_ioremap</code> calls <code>__early_ioremap</code> which takes three parameters:</p>
<ul>
<li><code>phys_addr</code> - base physical address of the <code>I/O</code> memory region to map on virtual addresses;</li>
<li><code>size</code>      - size of the <code>I/O</code> memory region;</li>
<li><code>prot</code>      - page table entry bits.</li>
</ul>
<p>First of all in the <code>__early_ioremap</code>, we go through all early ioremap fixmap slots and search for the first free one in the <code>prev_map</code> array. When we found it we remember its number in the <code>slot</code> variable and set up size:</p>
<pre><code class="language-C">slot = -1;
for (i = 0; i &lt; FIX_BTMAPS_SLOTS; i++) {
	if (!prev_map[i]) {
		slot = i;
		break;
	}
}
...
...
...
prev_size[slot] = size;
last_addr = phys_addr + size - 1;
</code></pre>
<p>In the next spte we can see the following code:</p>
<pre><code class="language-C">offset = phys_addr &amp; ~PAGE_MASK;
phys_addr &amp;= PAGE_MASK;
size = PAGE_ALIGN(last_addr + 1) - phys_addr;
</code></pre>
<p>Here we are using <code>PAGE_MASK</code> for clearing all bits in the <code>phys_addr</code> except the first 12 bits. <code>PAGE_MASK</code> macro is defined as:</p>
<pre><code class="language-C">#define PAGE_MASK       (~(PAGE_SIZE-1))
</code></pre>
<p>We know that size of a page is 4096 bytes or <code>1000000000000</code> in binary. <code>PAGE_SIZE - 1</code> will be <code>111111111111</code>, but with <code>~</code>, we will get <code>000000000000</code>, but as we use <code>~PAGE_MASK</code> we will get <code>111111111111</code> again. On the second line we do the same but clear the first 12 bits and getting page-aligned size of the area on the third line. We getting aligned area and now we need to get the number of pages which are occupied by the new <code>ioremap</code> area and calculate the fix-mapped index from <code>fixed_addresses</code> in the next steps:</p>
<pre><code class="language-C">nrpages = size &gt;&gt; PAGE_SHIFT;
idx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;
</code></pre>
<p>Now we can fill <code>fix-mapped</code> area with the given physical addresses. On every iteration in the loop, we call the <code>__early_set_fixmap</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/ioremap.c">arch/x86/mm/ioremap.c</a>, increase the given physical address by the page size which is <code>4096</code> bytes and update the <code>addresses</code> index and the number of pages:</p>
<pre><code class="language-C">while (nrpages &gt; 0) {
	__early_set_fixmap(idx, phys_addr, prot);
	phys_addr += PAGE_SIZE;
	--idx;
    --nrpages;
}
</code></pre>
<p>The <code>__early_set_fixmap</code> function gets the page table entry (stored in the <code>bm_pte</code>, see above) for the given physical address with:</p>
<pre><code class="language-C">pte = early_ioremap_pte(addr);
</code></pre>
<p>In the next step of <code>early_ioremap_pte</code> we check the given page flags with the <code>pgprot_val</code> macro and call <code>set_pte</code> or <code>pte_clear</code> depending on the flags given:</p>
<pre><code class="language-C">if (pgprot_val(flags))
		set_pte(pte, pfn_pte(phys &gt;&gt; PAGE_SHIFT, flags));
	else
		pte_clear(&amp;init_mm, addr, pte);
</code></pre>
<p>As you can see above, we passed <code>FIXMAP_PAGE_IO</code> as flags to the <code>__early_ioremap</code>. <code>FIXMPA_PAGE_IO</code> expands to the:</p>
<pre><code class="language-C">(__PAGE_KERNEL_EXEC | _PAGE_NX)
</code></pre>
<p>flags, so we call <code>set_pte</code> function to set the page table entry which works in the same manner as <code>set_pmd</code> but for PTEs (read above about it). As we have set all <code>PTEs</code> in the loop, we can now take a look at the call of the <code>__flush_tlb_one</code> function:</p>
<pre><code class="language-C">__flush_tlb_one(addr);
</code></pre>
<p>This function is defined in <a href="https://github.com/torvalds/linux">arch/x86/include/asm/tlbflush.h</a> and calls <code>__flush_tlb_single</code> or <code>__flush_tlb</code> depending on the value of <code>cpu_has_invlpg</code>:</p>
<pre><code class="language-C">static inline void __flush_tlb_one(unsigned long addr)
{
        if (cpu_has_invlpg)
                __flush_tlb_single(addr);
        else
                __flush_tlb();
}
</code></pre>
<p>The <code>__flush_tlb_one</code> function invalidates the given address in the <a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a>. As you just saw we updated the paging structure, but <code>TLB</code> is not informed of the changes, that's why we need to do it manually. There are two ways to do it. The first is to update the <code>cr3</code> control register and the <code>__flush_tlb</code> function does this:</p>
<pre><code class="language-C">native_write_cr3(__native_read_cr3());
</code></pre>
<p>The second method is to use the <code>invlpg</code> instruction to invalidate the <code>TLB</code> entry. Let's look at the <code>__flush_tlb_one</code> implementation. As you can see, first of all the function checks <code>cpu_has_invlpg</code> which is defined as:</p>
<pre><code class="language-C">#if defined(CONFIG_X86_INVLPG) || defined(CONFIG_X86_64)
# define cpu_has_invlpg         1
#else
# define cpu_has_invlpg         (boot_cpu_data.x86 &gt; 3)
#endif
</code></pre>
<p>If a CPU supports the <code>invlpg</code> instruction, we call the <code>__flush_tlb_single</code> macro which expands to the call of <code>__native_flush_tlb_single</code>:</p>
<pre><code class="language-C">static inline void __native_flush_tlb_single(unsigned long addr)
{
        asm volatile(&quot;invlpg (%0)&quot; ::&quot;r&quot; (addr) : &quot;memory&quot;);
}
</code></pre>
<p>or call <code>__flush_tlb</code> which just updates the <code>cr3</code> register as we have seen. After this step execution of the <code>__early_set_fixmap</code> function is finished and we can go back to the <code>__early_ioremap</code> implementation. When we have set up the fixmap area for the given address, we need to save the base virtual address of the I/O remapped area in the <code>prev_map</code> using the <code>slot</code> index:</p>
<pre><code class="language-C">prev_map[slot] = (void __iomem *)(offset + slot_virt[slot]);
</code></pre>
<p>and return it.</p>
<p>The second function, <code>early_iounmap</code>, unmaps an <code>I/O</code> memory region. This function takes two parameters: base address and size of a <code>I/O</code> region and generally looks very similar to <code>early_ioremap</code>. It also goes through fixmap slots and looks for a slot with the given address. After that, it gets the index of the fixmap slot and calls <code>__late_clear_fixmap</code> or <code>__early_set_fixmap</code> depending on the <code>after_paging_init</code> value. It calls <code>__early_set_fixmap</code> with one difference to how <code>early_ioremap</code> does it: <code>early_iounmap</code> passes <code>zero</code> as physical address. And in the end it sets the address of the I/O memory region to <code>NULL</code>:</p>
<pre><code class="language-C">prev_map[slot] = NULL;
</code></pre>
<p>That's all about <code>fixmaps</code> and <code>ioremap</code>. Of course this part does not cover all features of <code>ioremap</code>, only early ioremap but there is also normal ioremap. But we need to know more things before we study that in more detail.</p>
<p>So, this is the end!</p>
<h2 id="conclusion-46"><a class="header" href="#conclusion-46">Conclusion</a></h2>
<p>This is the end of the second part about Linux kernel memory management. If you have questions or suggestions, ping me on twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-46"><a class="header" href="#links-46">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">apic</a></li>
<li><a href="https://lwn.net/Articles/446528/">vsyscall</a></li>
<li><a href="http://en.wikipedia.org/wiki/Trusted_Execution_Technology">Intel Trusted Execution Technology</a></li>
<li><a href="http://en.wikipedia.org/wiki/Xen">Xen</a></li>
<li><a href="http://en.wikipedia.org/wiki/Real-time_clock">Real Time Clock</a></li>
<li><a href="http://en.wikipedia.org/wiki/E820">e820</a></li>
<li><a href="http://en.wikipedia.org/wiki/Memory_management_unit">Memory management unit</a></li>
<li><a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-1">Paging</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-1">Linux kernel memory management Part 1.</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-kernel-memory-management-part-3"><a class="header" href="#linux-kernel-memory-management-part-3">Linux kernel memory management Part 3.</a></h1>
<h2 id="introduction-to-the-kmemcheck-in-the-linux-kernel"><a class="header" href="#introduction-to-the-kmemcheck-in-the-linux-kernel">Introduction to the kmemcheck in the Linux kernel</a></h2>
<p>This is the third part of the <a href="https://0xax.gitbook.io/linux-insides/summary/mm">chapter</a> which describes <a href="https://en.wikipedia.org/wiki/Memory_management">memory management</a> in the Linux kernel and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-2">part</a> of this chapter we met two memory management related concepts:</p>
<ul>
<li><code>Fix-Mapped Addresses</code>;</li>
<li><code>ioremap</code>.</li>
</ul>
<p>The first concept represents special area in <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual memory</a>, whose corresponding physical mapping is calculated in <a href="https://en.wikipedia.org/wiki/Compile_time">compile-time</a>. The second concept provides ability to map input/output related memory to virtual memory.</p>
<p>For example if you will look at the output of the <code>/proc/iomem</code>:</p>
<pre><code>$ sudo cat /proc/iomem

00000000-00000fff : reserved
00001000-0009d7ff : System RAM
0009d800-0009ffff : reserved
000a0000-000bffff : PCI Bus 0000:00
000c0000-000cffff : Video ROM
000d0000-000d3fff : PCI Bus 0000:00
000d4000-000d7fff : PCI Bus 0000:00
000d8000-000dbfff : PCI Bus 0000:00
000dc000-000dffff : PCI Bus 0000:00
000e0000-000fffff : reserved
...
...
...
</code></pre>
<p>you will see map of the system's memory for each physical device. Here the first column displays the memory registers used by each of the different types of memory. The second column lists the kind of memory located within those registers. Or for example:</p>
<pre><code>$ sudo cat /proc/ioports

0000-0cf7 : PCI Bus 0000:00
  0000-001f : dma1
  0020-0021 : pic1
  0040-0043 : timer0
  0050-0053 : timer1
  0060-0060 : keyboard
  0064-0064 : keyboard
  0070-0077 : rtc0
  0080-008f : dma page reg
  00a0-00a1 : pic2
  00c0-00df : dma2
  00f0-00ff : fpu
    00f0-00f0 : PNP0C04:00
  03c0-03df : vga+
  03f8-03ff : serial
  04d0-04d1 : pnp 00:06
  0800-087f : pnp 00:01
  0a00-0a0f : pnp 00:04
  0a20-0a2f : pnp 00:04
  0a30-0a3f : pnp 00:04
...
...
...
</code></pre>
<p>can show us lists of currently registered port regions used for input or output communication with a device. All memory-mapped I/O addresses are not used by the kernel directly. So, before the Linux kernel can use such memory, it must map it to the virtual memory space which is the main purpose of the <code>ioremap</code> mechanism. Note that we saw only early <code>ioremap</code> in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-2">part</a>. Soon we will look at the implementation of the non-early <code>ioremap</code> function. But before this we must learn other things, like different types of memory allocators and etc., because otherwise it will be very difficult to understand it.</p>
<p>So, before we will move on to the non-early <a href="https://en.wikipedia.org/wiki/Memory_management">memory management</a> of the Linux kernel, we will see some mechanisms which provide special abilities for <a href="https://en.wikipedia.org/wiki/Debugging">debugging</a>, check of <a href="https://en.wikipedia.org/wiki/Memory_leak">memory leaks</a>, memory control and etc. It will be easier to understand how memory management arranged in the Linux kernel after learning of all of these things.</p>
<p>As you already may guess from the title of this part, we will start to consider memory mechanisms from the <a href="https://www.kernel.org/doc/Documentation/kmemcheck.txt">kmemcheck</a>. As we always did in other <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">chapters</a>, we will start to consider from theoretical side and will learn what is <code>kmemcheck</code> mechanism in general and only after this, we will see how it is implemented in the Linux kernel.</p>
<p>So let's start. What is it <code>kmemcheck</code> in the Linux kernel? As you may guess from the name of this mechanism, the <code>kmemcheck</code> checks memory. That's true. Main point of the <code>kmemcheck</code> mechanism is to check that some kernel code accesses <code>uninitialized memory</code>. Let's take following simple <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> program:</p>
<pre><code class="language-C">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

struct A {
        int a;
};

int main(int argc, char **argv) {
        struct A *a = malloc(sizeof(struct A));
        printf(&quot;a-&gt;a = %d\n&quot;, a-&gt;a);
        return 0;
}
</code></pre>
<p>Here we allocate memory for the <code>A</code> structure and tries to print value of the <code>a</code> field. If we will compile this program without additional options:</p>
<pre><code>gcc test.c -o test
</code></pre>
<p>The <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">compiler</a> will not show us warning that <code>a</code> field is not uninitialized. But if we will run this program with <a href="https://en.wikipedia.org/wiki/Valgrind">valgrind</a> tool, we will see the following output:</p>
<pre><code>~$   valgrind --leak-check=yes ./test
==28469== Memcheck, a memory error detector
==28469== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==28469== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==28469== Command: ./test
==28469==
==28469== Conditional jump or move depends on uninitialised value(s)
==28469==    at 0x4E820EA: vfprintf (in /usr/lib64/libc-2.22.so)
==28469==    by 0x4E88D48: printf (in /usr/lib64/libc-2.22.so)
==28469==    by 0x4005B9: main (in /home/alex/test)
==28469==
==28469== Use of uninitialised value of size 8
==28469==    at 0x4E7E0BB: _itoa_word (in /usr/lib64/libc-2.22.so)
==28469==    by 0x4E8262F: vfprintf (in /usr/lib64/libc-2.22.so)
==28469==    by 0x4E88D48: printf (in /usr/lib64/libc-2.22.so)
==28469==    by 0x4005B9: main (in /home/alex/test)
...
...
...
</code></pre>
<p>Actually the <code>kmemcheck</code> mechanism does the same for the kernel, what the <code>valgrind</code> does for userspace programs. It check uninitialized memory.</p>
<p>To enable this mechanism in the Linux kernel, you need to enable the <code>CONFIG_KMEMCHECK</code> kernel configuration option in the:</p>
<pre><code>Kernel hacking
  -&gt; Memory Debugging
</code></pre>
<p>menu of the Linux kernel configuration:</p>
<p><img src="MM/images/kernel_configuration_menu1.png" alt="kernel configuration menu" /></p>
<p>We may not only enable support of the <code>kmemcheck</code> mechanism in the Linux kernel, but it also provides some configuration options for us. We will see all of these options in the next paragraph of this part. Last note before we will consider how does the <code>kmemcheck</code> check memory. Now this mechanism is implemented only for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture. You can be sure if you will look in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/Kconfig">arch/x86/Kconfig</a> <code>x86</code> related kernel configuration file, you will see following lines:</p>
<pre><code>config X86
  ...
  ...
  ...
  select HAVE_ARCH_KMEMCHECK
  ...
  ...
  ...
</code></pre>
<p>So, there isn't anything which is specific for other architectures.</p>
<p>Ok, so we know that <code>kmemcheck</code> provides mechanism to check usage of <code>uninitialized memory</code> in the Linux kernel and how to enable it. How it does these checks? When the Linux kernel tries to allocate some memory i.e. something is called like this:</p>
<pre><code class="language-C">struct my_struct *my_struct = kmalloc(sizeof(struct my_struct), GFP_KERNEL);
</code></pre>
<p>or in other words somebody wants to access a <a href="https://en.wikipedia.org/wiki/Page_%28computer_memory%29">page</a>, a <a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a> exception is generated. This is achieved by the fact that the <code>kmemcheck</code> marks memory pages as <code>non-present</code> (more about this you can read in the special part which is devoted to <a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-1">Paging</a>). If a <code>page fault</code> exception occurred, the exception handler knows about it and in a case when the <code>kmemcheck</code> is enabled it transfers control to it. After the <code>kmemcheck</code> will finish its checks, the page will be marked as <code>present</code> and the interrupted code will be able to continue execution. There is little subtlety in this chain. When the first instruction of interrupted code will be executed, the <code>kmemcheck</code> will mark the page as <code>non-present</code> again. In this way next access to memory will be caught again.</p>
<p>We just considered the <code>kmemcheck</code> mechanism from theoretical side. Now let's consider how it is implemented in the Linux kernel.</p>
<h2 id="implementation-of-the-kmemcheck-mechanism-in-the-linux-kernel"><a class="header" href="#implementation-of-the-kmemcheck-mechanism-in-the-linux-kernel">Implementation of the <code>kmemcheck</code> mechanism in the Linux kernel</a></h2>
<p>So, now we know what is it <code>kmemcheck</code> and what it does in the Linux kernel. Time to see at its implementation in the Linux kernel. Implementation of the <code>kmemcheck</code> is split in two parts. The first is generic part is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/kmemcheck.c">mm/kmemcheck.c</a> source code file and the second <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture-specific part is located in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/mm/kmemcheck">arch/x86/mm/kmemcheck</a> directory.</p>
<p>Let's start from the initialization of this mechanism. We already know that to enable the <code>kmemcheck</code> mechanism in the Linux kernel, we must enable the <code>CONFIG_KMEMCHECK</code> kernel configuration option. But besides this, we need to pass one of following parameters:</p>
<ul>
<li>kmemcheck=0 (disabled)</li>
<li>kmemcheck=1 (enabled)</li>
<li>kmemcheck=2 (one-shot mode)</li>
</ul>
<p>to the Linux kernel command line. The first two are clear, but the last needs a little explanation. This option switches the <code>kmemcheck</code> in a special mode when it will be turned off after detecting the first use of uninitialized memory. Actually this mode is enabled by default in the Linux kernel:</p>
<p><img src="MM/images/kernel_configuration_menu2.png" alt="kernel configuration menu" /></p>
<p>We know from the seventh <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-7">part</a> of the chapter which describes initialization of the Linux kernel that the kernel command line is parsed during initialization of the Linux kernel in <code>do_initcall_level</code>, <code>do_early_param</code> functions. Actually the <code>kmemcheck</code> subsystem consists from two stages. The first stage is early. If we will look at the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/kmemcheck.c">mm/kmemcheck.c</a> source code file, we will see the <code>param_kmemcheck</code> function which is will be called during early command line parsing:</p>
<pre><code class="language-C">static int __init param_kmemcheck(char *str)
{
	int val;
	int ret;

	if (!str)
		return -EINVAL;

	ret = kstrtoint(str, 0, &amp;val);
	if (ret)
		return ret;
	kmemcheck_enabled = val;
	return 0;
}

early_param(&quot;kmemcheck&quot;, param_kmemcheck);
</code></pre>
<p>As we already saw, the <code>param_kmemcheck</code> may have one of the following values: <code>0</code> (enabled), <code>1</code> (disabled) or <code>2</code> (one-shot). The implementation of the <code>param_kmemcheck</code> is pretty simple. We just convert string value of the <code>kmemcheck</code> command line option to integer representation and set it to the <code>kmemcheck_enabled</code> variable.</p>
<p>The second stage will be executed during initialization of the Linux kernel, rather during initialization of early <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-3">initcalls</a>. The second stage is represented by the <code>kmemcheck_init</code>:</p>
<pre><code class="language-C">int __init kmemcheck_init(void)
{
    ...
    ...
    ...
}

early_initcall(kmemcheck_init);
</code></pre>
<p>Main goal of the <code>kmemcheck_init</code> function is to call the <code>kmemcheck_selftest</code> function and check its result:</p>
<pre><code class="language-C">if (!kmemcheck_selftest()) {
	printk(KERN_INFO &quot;kmemcheck: self-tests failed; disabling\n&quot;);
	kmemcheck_enabled = 0;
	return -EINVAL;
}

printk(KERN_INFO &quot;kmemcheck: Initialized\n&quot;);
</code></pre>
<p>and return with the <code>EINVAL</code> if this check is failed. The <code>kmemcheck_selftest</code> function checks sizes of different memory access related <a href="https://en.wikipedia.org/wiki/Opcode">opcodes</a> like <code>rep movsb</code>, <code>movzwq</code> and etc. If sizes of opcodes are equal to expected sizes, the <code>kmemcheck_selftest</code> will return <code>true</code> and <code>false</code> otherwise.</p>
<p>So when somebody calls:</p>
<pre><code class="language-C">struct my_struct *my_struct = kmalloc(sizeof(struct my_struct), GFP_KERNEL);
</code></pre>
<p>through a series of different function calls the <code>kmem_getpages</code> function will be called. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/slab.c">mm/slab.c</a> source code file and main goal of this function tries to allocate <a href="https://en.wikipedia.org/wiki/Paging">pages</a> with the given flags. In the end of this function we can see following code:</p>
<pre><code class="language-C">if (kmemcheck_enabled &amp;&amp; !(cachep-&gt;flags &amp; SLAB_NOTRACK)) {
	kmemcheck_alloc_shadow(page, cachep-&gt;gfporder, flags, nodeid);

    if (cachep-&gt;ctor)
		kmemcheck_mark_uninitialized_pages(page, nr_pages);
	else
		kmemcheck_mark_unallocated_pages(page, nr_pages);
}
</code></pre>
<p>So, here we check that the if <code>kmemcheck</code> is enabled and the <code>SLAB_NOTRACK</code> bit is not set in flags we set <code>non-present</code> bit for the just allocated page. The <code>SLAB_NOTRACK</code> bit tell us to not track uninitialized memory. Additionally we check if a cache object has constructor (details will be considered in next parts) we mark allocated page as uninitialized or unallocated otherwise. The <code>kmemcheck_alloc_shadow</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/kmemcheck.c">mm/kmemcheck.c</a> source code file and does following things:</p>
<pre><code class="language-C">void kmemcheck_alloc_shadow(struct page *page, int order, gfp_t flags, int node)
{
    struct page *shadow;

   	shadow = alloc_pages_node(node, flags | __GFP_NOTRACK, order);

   	for(i = 0; i &lt; pages; ++i)
		page[i].shadow = page_address(&amp;shadow[i]);

   	kmemcheck_hide_pages(page, pages);
}
</code></pre>
<p>First of all it allocates memory space for the shadow bits. If this bit is set in a page, this means that this page is tracked by the <code>kmemcheck</code>. After we allocated space for the shadow bit, we fill all allocated pages with this bit. In the end we just call the <code>kmemcheck_hide_pages</code> function with the pointer to the allocated page and number of these pages. The <code>kmemcheck_hide_pages</code> is architecture-specific function, so its implementation is located in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/mm/kmemcheck/kmemcheck.c">arch/x86/mm/kmemcheck/kmemcheck.c</a> source code file. The main goal of this function is to set <code>non-present</code> bit in given pages. Let's look at the implementation of this function:</p>
<pre><code class="language-C">void kmemcheck_hide_pages(struct page *p, unsigned int n)
{
	unsigned int i;

	for (i = 0; i &lt; n; ++i) {
		unsigned long address;
		pte_t *pte;
		unsigned int level;

		address = (unsigned long) page_address(&amp;p[i]);
		pte = lookup_address(address, &amp;level);
		BUG_ON(!pte);
		BUG_ON(level != PG_LEVEL_4K);

		set_pte(pte, __pte(pte_val(*pte) &amp; ~_PAGE_PRESENT));
		set_pte(pte, __pte(pte_val(*pte) | _PAGE_HIDDEN));
		__flush_tlb_one(address);
	}
}
</code></pre>
<p>Here we go through all pages and try to get <code>page table entry</code> for each page. If this operation was successful, we unset present bit and set hidden bit in each page. In the end we flush <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">translation lookaside buffer</a>, because some pages was changed. From this point allocated pages are tracked by the <code>kmemcheck</code>. Now, as <code>present</code> bit is unset, the <a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a> execution will be occurred right after the <code>kmalloc</code> will return pointer to allocated space and a code will try to access this memory.</p>
<p>As you may remember from the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-2">second part</a> of the Linux kernel initialization chapter, the <code>page fault</code> handler is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/fault.c">arch/x86/mm/fault.c</a> source code file and represented by the <code>do_page_fault</code> function. We can see following check from the beginning of the <code>do_page_fault</code> function:</p>
<pre><code class="language-C">static noinline void
__do_page_fault(struct pt_regs *regs, unsigned long error_code,
		unsigned long address)
{
    ...
    ...
    ...
	if (kmemcheck_active(regs))
		kmemcheck_hide(regs);
    ...
    ...
    ...
}
</code></pre>
<p>The <code>kmemcheck_active</code> gets <code>kmemcheck_context</code> <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> structure and returns the result of comparison of the <code>balance</code> field of this structure with zero:</p>
<pre><code>bool kmemcheck_active(struct pt_regs *regs)
{
	struct kmemcheck_context *data = this_cpu_ptr(&amp;kmemcheck_context);

	return data-&gt;balance &gt; 0;
}
</code></pre>
<p>The <code>kmemcheck_context</code> is structure which describes current state of the <code>kmemcheck</code> mechanism. It stored uninitialized addresses, number of such addresses and etc. The <code>balance</code> field of this structure represents current state of the <code>kmemcheck</code> or in other words it can tell us did <code>kmemcheck</code> already hid pages or not yet. If the <code>data-&gt;balance</code> is greater than zero, the <code>kmemcheck_hide</code> function will be called. This means than <code>kmemecheck</code> already set <code>present</code> bit for given pages and now we need to hide pages again to cause next step to page fault. This function will hide addresses of pages again by unsetting of <code>present</code> bit. This means that one session of <code>kmemcheck</code> already finished and new page fault occurred. At the first step the <code>kmemcheck_active</code> will return false as the <code>data-&gt;balance</code> is zero for the start and the <code>kmemcheck_hide</code> will not be called. Next, we may see following line of code in the <code>do_page_fault</code>:</p>
<pre><code class="language-C">if (kmemcheck_fault(regs, address, error_code))
		return;
</code></pre>
<p>First of all the <code>kmemcheck_fault</code> function checks that the fault occurred by the correct reason. At first we check the <a href="https://en.wikipedia.org/wiki/FLAGS_register">flags register</a> and check that we are in normal kernel mode:</p>
<pre><code class="language-C">if (regs-&gt;flags &amp; X86_VM_MASK)
		return false;
if (regs-&gt;cs != __KERNEL_CS)
		return false;
</code></pre>
<p>If these checks weren't successful we return from the <code>kmemcheck_fault</code> function as it was not <code>kmemcheck</code> related page fault. After this we try to lookup a <code>page table entry</code> related to the faulted address and if we can't find it we return:</p>
<pre><code class="language-C">pte = kmemcheck_pte_lookup(address);
if (!pte)
	return false;
</code></pre>
<p>Last two steps of the <code>kmemcheck_fault</code> function is to call the <code>kmemcheck_access</code> function which check access to the given page and show addresses again by setting present bit in the given page. The <code>kmemcheck_access</code> function does all main job. It checks current instruction which caused a page fault. If it finds an error, the context of this error will be saved by <code>kmemcheck</code> to the ring queue:</p>
<pre><code class="language-C">static struct kmemcheck_error error_fifo[CONFIG_KMEMCHECK_QUEUE_SIZE];
</code></pre>
<p>The <code>kmemcheck</code> mechanism declares special <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-9">tasklet</a>:</p>
<pre><code class="language-C">static DECLARE_TASKLET(kmemcheck_tasklet, &amp;do_wakeup, 0);
</code></pre>
<p>which runs the <code>do_wakeup</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/kmemcheck/error.c">arch/x86/mm/kmemcheck/error.c</a> source code file when it is scheduled to run.</p>
<p>The <code>do_wakeup</code> function will call the <code>kmemcheck_error_recall</code> function which will print errors collected by <code>kmemcheck</code>. As we already saw the:</p>
<pre><code class="language-C">kmemcheck_show(regs);
</code></pre>
<p>function will be called in the end of the <code>kmemcheck_fault</code> function. This function will set present bit for the given pages again:</p>
<pre><code class="language-C">if (unlikely(data-&gt;balance != 0)) {
	kmemcheck_show_all();
	kmemcheck_error_save_bug(regs);
	data-&gt;balance = 0;
	return;
}
</code></pre>
<p>Where the <code>kmemcheck_show_all</code> function calls the <code>kmemcheck_show_addr</code> for each address:</p>
<pre><code class="language-C">static unsigned int kmemcheck_show_all(void)
{
	struct kmemcheck_context *data = this_cpu_ptr(&amp;kmemcheck_context);
	unsigned int i;
	unsigned int n;

	n = 0;
	for (i = 0; i &lt; data-&gt;n_addrs; ++i)
		n += kmemcheck_show_addr(data-&gt;addr[i]);

	return n;
}
</code></pre>
<p>by the call of the <code>kmemcheck_show_addr</code>:</p>
<pre><code class="language-C">int kmemcheck_show_addr(unsigned long address)
{
	pte_t *pte;

	pte = kmemcheck_pte_lookup(address);
	if (!pte)
		return 0;

	set_pte(pte, __pte(pte_val(*pte) | _PAGE_PRESENT));
	__flush_tlb_one(address);
	return 1;
}
</code></pre>
<p>In the end of the <code>kmemcheck_show</code> function we set the <a href="https://en.wikipedia.org/wiki/Trap_flag">TF</a> flag if it wasn't set:</p>
<pre><code class="language-C">if (!(regs-&gt;flags &amp; X86_EFLAGS_TF))
	data-&gt;flags = regs-&gt;flags;
</code></pre>
<p>We need to do it because we need to hide pages again after first executed instruction after a page fault will be handled. In a case when the <code>TF</code> flag, so the processor will switch into single-step mode after the first instruction will be executed. In this case <code>debug</code> exception will occurred. From this moment pages will be hidden again and execution will be continued. As pages hidden from this moment, page fault exception will occur again and <code>kmemcheck</code> continue to check/collect errors again and print them from time to time.</p>
<p>That's all.</p>
<h2 id="conclusion-47"><a class="header" href="#conclusion-47">Conclusion</a></h2>
<p>This is the end of the third part about Linux kernel <a href="https://en.wikipedia.org/wiki/Memory_management">memory management</a>. If you have questions or suggestions, ping me on twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>. In the next part we will see yet another memory debugging related tool - <code>kmemleak</code>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-47"><a class="header" href="#links-47">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Memory_management">memory management</a></li>
<li><a href="https://en.wikipedia.org/wiki/Debugging">debugging</a></li>
<li><a href="https://en.wikipedia.org/wiki/Memory_leak">memory leaks</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/kmemcheck.txt">kmemcheck documentation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Valgrind">valgrind</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-1">Paging</a></li>
<li><a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-3">initcalls</a></li>
<li><a href="https://en.wikipedia.org/wiki/Opcode">opcode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">translation lookaside buffer</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu variables</a></li>
<li><a href="https://en.wikipedia.org/wiki/FLAGS_register">flags register</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-9">tasklet</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-2">Previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cgroups"><a class="header" href="#cgroups">Cgroups</a></h1>
<p>This chapter describes <code>control groups</code> mechanism in the Linux kernel.</p>
<ul>
<li><a href="Cgroups/linux-cgroups-1.html">Introduction</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-groups"><a class="header" href="#control-groups">Control Groups</a></h1>
<h2 id="introduction-10"><a class="header" href="#introduction-10">Introduction</a></h2>
<p>This is the first part of the new chapter of the <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">linux insides</a> book and as you may guess by part's name - this part will cover <a href="https://en.wikipedia.org/wiki/Cgroups">control groups</a> or <code>cgroups</code> mechanism in the Linux kernel.</p>
<p><code>Cgroups</code> are special mechanism provided by the Linux kernel which allows us to allocate kind of <code>resources</code> like processor time, number of processes per group, amount of memory per control group or combination of such resources for a process or set of processes. <code>Cgroups</code> are organized hierarchically and here this mechanism is similar to usual processes as they are hierarchical too and child <code>cgroups</code> inherit set of certain parameters from their parents. But actually they are not the same. The main difference between <code>cgroups</code> and normal processes is that many different hierarchies of control groups may exist simultaneously in one time while normal process tree is always single. This was not a casual step because each control group hierarchy is attached to set of control group <code>subsystems</code>.</p>
<p>One <code>control group subsystem</code> represents one kind of resources like a processor time or number of <a href="https://en.wikipedia.org/wiki/Process_identifier">pids</a> or in other words number of processes for a <code>control group</code>. Linux kernel provides support for following twelve <code>control group subsystems</code>:</p>
<ul>
<li><code>cpuset</code> - assigns individual processor(s) and memory nodes to task(s) in a group;</li>
<li><code>cpu</code> - uses the scheduler to provide cgroup tasks access to the processor resources;</li>
<li><code>cpuacct</code> - generates reports about processor usage by a group;</li>
<li><code>io</code> - sets limit to read/write from/to <a href="https://en.wikipedia.org/wiki/Device_file">block devices</a>;</li>
<li><code>memory</code> - sets limit on memory usage by a task(s) from a group;</li>
<li><code>devices</code> - allows access to devices by a task(s) from a group;</li>
<li><code>freezer</code> - allows to suspend/resume for a task(s) from a group;</li>
<li><code>net_cls</code> - allows to mark network packets from task(s) from a group;</li>
<li><code>net_prio</code> - provides a way to dynamically set the priority of network traffic per network interface for a group;</li>
<li><code>perf_event</code> - provides access to <a href="https://en.wikipedia.org/wiki/Perf_(Linux)">perf events</a> to a group;</li>
<li><code>hugetlb</code> - activates support for <a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">huge pages</a> for a group;</li>
<li><code>pid</code> - sets limit to number of processes in a group.</li>
</ul>
<p>Each of these control group subsystems depends on related configuration option. For example the <code>cpuset</code> subsystem should be enabled via <code>CONFIG_CPUSETS</code> kernel configuration option, the <code>io</code> subsystem via <code>CONFIG_BLK_CGROUP</code> kernel configuration option and etc. All of these kernel configuration options may be found in the <code>General setup → Control Group support</code> menu:</p>
<p><img src="Cgroups/images/menuconfig.png" alt="menuconfig" /></p>
<p>You may see enabled control groups on your computer via <a href="https://en.wikipedia.org/wiki/Procfs">proc</a> filesystem:</p>
<pre><code>$ cat /proc/cgroups
#subsys_name	hierarchy	num_cgroups	enabled
cpuset	8	1	1
cpu	7	66	1
cpuacct	7	66	1
blkio	11	66	1
memory	9	94	1
devices	6	66	1
freezer	2	1	1
net_cls	4	1	1
perf_event	3	1	1
net_prio	4	1	1
hugetlb	10	1	1
pids	5	69	1
</code></pre>
<p>or via <a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a>:</p>
<pre><code>$ ls -l /sys/fs/cgroup/
total 0
dr-xr-xr-x 5 root root  0 Dec  2 22:37 blkio
lrwxrwxrwx 1 root root 11 Dec  2 22:37 cpu -&gt; cpu,cpuacct
lrwxrwxrwx 1 root root 11 Dec  2 22:37 cpuacct -&gt; cpu,cpuacct
dr-xr-xr-x 5 root root  0 Dec  2 22:37 cpu,cpuacct
dr-xr-xr-x 2 root root  0 Dec  2 22:37 cpuset
dr-xr-xr-x 5 root root  0 Dec  2 22:37 devices
dr-xr-xr-x 2 root root  0 Dec  2 22:37 freezer
dr-xr-xr-x 2 root root  0 Dec  2 22:37 hugetlb
dr-xr-xr-x 5 root root  0 Dec  2 22:37 memory
lrwxrwxrwx 1 root root 16 Dec  2 22:37 net_cls -&gt; net_cls,net_prio
dr-xr-xr-x 2 root root  0 Dec  2 22:37 net_cls,net_prio
lrwxrwxrwx 1 root root 16 Dec  2 22:37 net_prio -&gt; net_cls,net_prio
dr-xr-xr-x 2 root root  0 Dec  2 22:37 perf_event
dr-xr-xr-x 5 root root  0 Dec  2 22:37 pids
dr-xr-xr-x 5 root root  0 Dec  2 22:37 systemd
</code></pre>
<p>As you already may guess that <code>control groups</code> mechanism is not such mechanism which was invented only directly to the needs of the Linux kernel, but mostly for userspace needs. To use a <code>control group</code>, we should create it at first. We may create a <code>cgroup</code> via two ways.</p>
<p>The first way is to create subdirectory in any subsystem from <code>/sys/fs/cgroup</code> and add a pid of a task to a <code>tasks</code> file which will be created automatically right after we will create the subdirectory.</p>
<p>The second way is to create/destroy/manage <code>cgroups</code> with utils from <code>libcgroup</code> library (<code>libcgroup-tools</code> in Fedora).</p>
<p>Let's consider a simple example. Following <a href="https://www.gnu.org/software/bash/">bash</a> script will print a line to <code>/dev/tty</code> device which represents control terminal for the current process:</p>
<pre><code class="language-shell">#!/bin/bash

while :
do
    echo &quot;print line&quot; &gt; /dev/tty
    sleep 5
done
</code></pre>
<p>So, if we will run this script we will see following result:</p>
<pre><code>$ sudo chmod +x cgroup_test_script.sh
~$ ./cgroup_test_script.sh
print line
print line
print line
...
...
...
</code></pre>
<p>Now let's go to the place where <code>cgroupfs</code> is mounted on our computer. As we just saw, this is <code>/sys/fs/cgroup</code> directory, but you may mount it everywhere you want.</p>
<pre><code>$ cd /sys/fs/cgroup
</code></pre>
<p>And now let's go to the <code>devices</code> subdirectory which represents kind of resources that allows or denies access to devices by tasks in a <code>cgroup</code>:</p>
<pre><code># cd devices
</code></pre>
<p>and create <code>cgroup_test_group</code> directory there:</p>
<pre><code># mkdir cgroup_test_group
</code></pre>
<p>After creation of the <code>cgroup_test_group</code> directory, following files will be generated there:</p>
<pre><code>/sys/fs/cgroup/devices/cgroup_test_group$ ls -l
total 0
-rw-r--r-- 1 root root 0 Dec  3 22:55 cgroup.clone_children
-rw-r--r-- 1 root root 0 Dec  3 22:55 cgroup.procs
--w------- 1 root root 0 Dec  3 22:55 devices.allow
--w------- 1 root root 0 Dec  3 22:55 devices.deny
-r--r--r-- 1 root root 0 Dec  3 22:55 devices.list
-rw-r--r-- 1 root root 0 Dec  3 22:55 notify_on_release
-rw-r--r-- 1 root root 0 Dec  3 22:55 tasks
</code></pre>
<p>For this moment we are interested in <code>tasks</code> and <code>devices.deny</code> files. The first <code>tasks</code> files should contain pid(s) of processes which will be attached to the <code>cgroup_test_group</code>. The second <code>devices.deny</code> file contain list of denied devices. By default a newly created group has no any limits for devices access. To forbid a device (in our case it is <code>/dev/tty</code>) we should write to the <code>devices.deny</code> following line:</p>
<pre><code># echo &quot;c 5:0 w&quot; &gt; devices.deny
</code></pre>
<p>Let's go step by step through this line. The first <code>c</code> letter represents type of a device. In our case the <code>/dev/tty</code> is <code>char device</code>. We can verify this from output of <code>ls</code> command:</p>
<pre><code>~$ ls -l /dev/tty
crw-rw-rw- 1 root tty 5, 0 Dec  3 22:48 /dev/tty
</code></pre>
<p>see the first <code>c</code> letter in a permissions list. The second part is <code>5:0</code> is major and minor numbers of the device. You can see these numbers in the output of <code>ls</code> too. And the last <code>w</code> letter forbids tasks to write to the specified device. So let's start the <code>cgroup_test_script.sh</code> script:</p>
<pre><code>~$ ./cgroup_test_script.sh
print line
print line
print line
...
...
</code></pre>
<p>and add pid of this process to the <code>devices/tasks</code> file of our group:</p>
<pre><code># echo $(pidof -x cgroup_test_script.sh) &gt; /sys/fs/cgroup/devices/cgroup_test_group/tasks
</code></pre>
<p>The result of this action will be as expected:</p>
<pre><code>~$ ./cgroup_test_script.sh
print line
print line
print line
print line
print line
print line
./cgroup_test_script.sh: line 5: /dev/tty: Operation not permitted
</code></pre>
<p>Similar situation will be when you will run you <a href="https://en.wikipedia.org/wiki/Docker_(software)">docker</a> containers for example:</p>
<pre><code>~$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
fa2d2085cd1c        mariadb:10          &quot;docker-entrypoint...&quot;   12 days ago         Up 4 minutes        0.0.0.0:3306-&gt;3306/tcp   mysql-work

~$ cat /sys/fs/cgroup/devices/docker/fa2d2085cd1c8d797002c77387d2061f56fefb470892f140d0dc511bd4d9bb61/tasks | head -3
5501
5584
5585
...
...
...
</code></pre>
<p>So, during startup of a <code>docker</code> container, <code>docker</code> will create a <code>cgroup</code> for processes in this container:</p>
<pre><code>$ docker exec -it mysql-work /bin/bash
$ top
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                   1 mysql     20   0  963996 101268  15744 S   0.0  0.6   0:00.46 mysqld
   71 root      20   0   20248   3028   2732 S   0.0  0.0   0:00.01 bash
   77 root      20   0   21948   2424   2056 R   0.0  0.0   0:00.00 top
</code></pre>
<p>And we may see this <code>cgroup</code> on host machine:</p>
<pre><code class="language-C">$ systemd-cgls

Control group /:
-.slice
├─docker
│ └─fa2d2085cd1c8d797002c77387d2061f56fefb470892f140d0dc511bd4d9bb61
│   ├─5501 mysqld
│   └─6404 /bin/bash
</code></pre>
<p>Now we know a little about <code>control groups</code> mechanism, how to use it manually and what's the purpose of this mechanism. It's time to look inside of the Linux kernel source code and start to dive into implementation of this mechanism.</p>
<h2 id="early-initialization-of-control-groups"><a class="header" href="#early-initialization-of-control-groups">Early initialization of control groups</a></h2>
<p>Now after we just saw a little theory about <code>control groups</code> Linux kernel mechanism, we may start to dive into the source code of Linux kernel to get better acquainted with this mechanism. As always we will start from the initialization of <code>control groups</code>. Initialization of <code>cgroups</code> is divided into two parts in the Linux kernel: early and late. In this part we will consider only <code>early</code> part and <code>late</code> part will be considered in next parts.</p>
<p>Early initialization of <code>cgroups</code> starts from the call of the:</p>
<pre><code class="language-C">cgroup_init_early();
</code></pre>
<p>function in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> during early initialization of the Linux kernel. This function is defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/cgroup/cgroup.c">kernel/cgroup/cgroup.c</a> source code file and starts from the definition of two following local variables:</p>
<pre><code class="language-C">int __init cgroup_init_early(void)
{
	static struct cgroup_sb_opts __initdata opts;
	struct cgroup_subsys *ss;
    ...
    ...
    ...
}
</code></pre>
<p>The <code>cgroup_sb_opts</code> structure defined in the same source code file and looks:</p>
<pre><code class="language-C">struct cgroup_sb_opts {
	u16 subsys_mask;
	unsigned int flags;
	char *release_agent;
	bool cpuset_clone_children;
	char *name;
	bool none;
};
</code></pre>
<p>which represents mount options of <code>cgroupfs</code>. For example we may create named cgroup hierarchy (with name <code>my_cgrp</code>) with the <code>name=</code> option and without any subsystems:</p>
<pre><code>$ mount -t cgroup -oname=my_cgrp,none /mnt/cgroups
</code></pre>
<p>The second variable - <code>ss</code> has type - <code>cgroup_subsys</code> structure which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/cgroup-defs.h">include/linux/cgroup-defs.h</a> header file and as you may guess from the name of the type, it represents a <code>cgroup</code> subsystem. This structure contains various fields and callback functions like:</p>
<pre><code class="language-C">struct cgroup_subsys {
    int (*css_online)(struct cgroup_subsys_state *css);
    void (*css_offline)(struct cgroup_subsys_state *css);
    ...
    ...
    ...
    bool early_init:1;
    int id;
    const char *name;
    struct cgroup_root *root;
    ...
    ...
    ...
}
</code></pre>
<p>Where for example <code>css_online</code> and <code>css_offline</code> callbacks are called after a cgroup successfully will complete all allocations and a cgroup will be before releasing respectively. The <code>early_init</code> flags marks subsystems which may/should be initialized early. The <code>id</code> and <code>name</code> fields represents unique identifier in the array of registered subsystems for a cgroup and <code>name</code> of a subsystem respectively. The last - <code>root</code> fields represents pointer to the root of of a cgroup hierarchy.</p>
<p>Of course the <code>cgroup_subsys</code> structure is bigger and has other fields, but it is enough for now. Now as we got to know important structures related to <code>cgroups</code> mechanism, let's return to the <code>cgroup_init_early</code> function. Main purpose of this function is to do early initialization of some subsystems. As you already may guess, these <code>early</code> subsystems should have <code>cgroup_subsys-&gt;early_init = 1</code>. Let's look what subsystems may be initialized early.</p>
<p>After the definition of the two local variables we may see following lines of code:</p>
<pre><code class="language-C">init_cgroup_root(&amp;cgrp_dfl_root, &amp;opts);
cgrp_dfl_root.cgrp.self.flags |= CSS_NO_REF;
</code></pre>
<p>Here we may see call of the <code>init_cgroup_root</code> function which will execute initialization of the default unified hierarchy and after this we set <code>CSS_NO_REF</code> flag in state of this default <code>cgroup</code> to disable reference counting for this css. The <code>cgrp_dfl_root</code> is defined in the same source code file:</p>
<pre><code class="language-C">struct cgroup_root cgrp_dfl_root;
</code></pre>
<p>Its <code>cgrp</code> field represented by the <code>cgroup</code> structure which represents a <code>cgroup</code> as you already may guess and defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/cgroup-defs.h">include/linux/cgroup-defs.h</a> header file. We already know that a process is represented by the <code>task_struct</code> in the Linux kernel. The <code>task_struct</code> does not contain direct link to a <code>cgroup</code> where this task is attached. But it may be reached via <code>css_set</code> field of the <code>task_struct</code>. This <code>css_set</code> structure holds pointer to the array of subsystem states:</p>
<pre><code class="language-C">struct css_set {
    ...
    ...
    ....
    struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT];
    ...
    ...
    ...
}
</code></pre>
<p>And via the <code>cgroup_subsys_state</code>, a process may get a <code>cgroup</code> that this process is attached to:</p>
<pre><code class="language-C">struct cgroup_subsys_state {
    ...
    ...
    ...
    struct cgroup *cgroup;
    ...
    ...
    ...
}
</code></pre>
<p>So, the overall picture of <code>cgroups</code> related data structure is following:</p>
<pre><code>+-------------+         +---------------------+    +-------------&gt;+---------------------+          +----------------+
| task_struct |         |       css_set       |    |              | cgroup_subsys_state |          |     cgroup     |
+-------------+         |                     |    |              +---------------------+          +----------------+
|             |         |                     |    |              |                     |          |     flags      |
|             |         |                     |    |              +---------------------+          |  cgroup.procs  |
|             |         |                     |    |              |        cgroup       |---------&gt;|       id       |
|             |         |                     |    |              +---------------------+          |      ....      |
|-------------+         |---------------------+----+                                               +----------------+
|   cgroups   | ------&gt; | cgroup_subsys_state | array of cgroup_subsys_state
|-------------+         +---------------------+------------------&gt;+---------------------+          +----------------+
|             |         |                     |                   | cgroup_subsys_state |          |      cgroup    |
+-------------+         +---------------------+                   +---------------------+          +----------------+
                                                                  |                     |          |      flags     |
                                                                  +---------------------+          |   cgroup.procs |
                                                                  |        cgroup       |---------&gt;|        id      |
                                                                  +---------------------+          |       ....     |
                                                                  |    cgroup_subsys    |          +----------------+
                                                                  +---------------------+
                                                                             |
                                                                             |
                                                                             ↓
                                                                  +---------------------+
                                                                  |    cgroup_subsys    |
                                                                  +---------------------+
                                                                  |         id          |
                                                                  |        name         |
                                                                  |      css_online     |
                                                                  |      css_ofline     |
                                                                  |        attach       |
                                                                  |         ....        |
                                                                  +---------------------+
</code></pre>
<p>So, the <code>init_cgroup_root</code> fills the <code>cgrp_dfl_root</code> with the default values. The next thing is assigning initial <code>css_set</code> to the <code>init_task</code> which represents first process in the system:</p>
<pre><code class="language-C">RCU_INIT_POINTER(init_task.cgroups, &amp;init_css_set);
</code></pre>
<p>And the last big thing in the <code>cgroup_init_early</code> function is initialization of <code>early cgroups</code>. Here we go over all registered subsystems and assign unique identity number, name of a subsystem and call the <code>cgroup_init_subsys</code> function for subsystems which are marked as early:</p>
<pre><code class="language-C">for_each_subsys(ss, i) {
		ss-&gt;id = i;
		ss-&gt;name = cgroup_subsys_name[i];

        if (ss-&gt;early_init)
			cgroup_init_subsys(ss, true);
}
</code></pre>
<p>The <code>for_each_subsys</code> here is a macro which is defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/cgroup/cgroup.c">kernel/cgroup/cgroup.c</a> source code file and just expands to the <code>for</code> loop over <code>cgroup_subsys</code> array. Definition of this array may be found in the same source code file and it looks in a little unusual way:</p>
<pre><code class="language-C">#define SUBSYS(_x) [_x ## _cgrp_id] = &amp;_x ## _cgrp_subsys,
    static struct cgroup_subsys *cgroup_subsys[] = {
        #include &lt;linux/cgroup_subsys.h&gt;
};
#undef SUBSYS
</code></pre>
<p>It is defined as <code>SUBSYS</code> macro which takes one argument (name of a subsystem) and defines <code>cgroup_subsys</code> array of cgroup subsystems. Additionally we may see that the array is initialized with content of the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/cgroup_subsys.h">linux/cgroup_subsys.h</a> header file. If we will look inside of this header file we will see again set of the <code>SUBSYS</code> macros with the given subsystems names:</p>
<pre><code class="language-C">#if IS_ENABLED(CONFIG_CPUSETS)
SUBSYS(cpuset)
#endif

#if IS_ENABLED(CONFIG_CGROUP_SCHED)
SUBSYS(cpu)
#endif
...
...
...
</code></pre>
<p>This works because of <code>#undef</code> statement after first definition of the <code>SUBSYS</code> macro. Look at the <code>&amp;_x ## _cgrp_subsys</code> expression. The <code>##</code> operator concatenates right and left expression in a <code>C</code> macro. So as we passed <code>cpuset</code>, <code>cpu</code> and etc., to the <code>SUBSYS</code> macro, somewhere <code>cpuset_cgrp_subsys</code>, <code>cpu_cgrp_subsys</code> should be defined. And that's true. If you will look in the <a href="https://github.com/torvalds/linux/blob/master/kernel/cgroup/cpuset.c">kernel/cgroup/cpuset.c</a> source code file, you will see this definition:</p>
<pre><code class="language-C">struct cgroup_subsys cpuset_cgrp_subsys = {
    ...
    ...
    ...
	.early_init	= true,
};
</code></pre>
<p>So the last step in the <code>cgroup_init_early</code> function is initialization of early subsystems with the call of the <code>cgroup_init_subsys</code> function. Following early subsystems will be initialized:</p>
<ul>
<li><code>cpuset</code>;</li>
<li><code>cpu</code>;</li>
<li><code>cpuacct</code>.</li>
</ul>
<p>The <code>cgroup_init_subsys</code> function does initialization of the given subsystem with the default values. For example sets root of hierarchy, allocates space for the given subsystem with the call of the <code>css_alloc</code> callback function, link a subsystem with a parent if it exists, add allocated subsystem to the initial process and etc.</p>
<p>That's all. From this moment early subsystems are initialized.</p>
<h2 id="conclusion-48"><a class="header" href="#conclusion-48">Conclusion</a></h2>
<p>It is the end of the first part which describes introduction into <code>Control groups</code> mechanism in the Linux kernel. We covered some theory and the first steps of initialization of stuffs related to <code>control groups</code> mechanism. In the next part we will continue to dive into the more practical aspects of <code>control groups</code>.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-48"><a class="header" href="#links-48">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Cgroups">control groups</a></li>
<li><a href="https://en.wikipedia.org/wiki/Process_identifier">PID</a></li>
<li><a href="http://man7.org/linux/man-pages/man7/cpuset.7.html">cpuset</a></li>
<li><a href="https://en.wikipedia.org/wiki/Device_file">block devices</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">huge pages</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a></li>
<li><a href="https://en.wikipedia.org/wiki/Procfs">proc</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt">cgroups kernel documentation</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cgroup-v2.txt">cgroups v2</a></li>
<li><a href="https://www.gnu.org/software/bash/">bash</a></li>
<li><a href="https://en.wikipedia.org/wiki/Docker_(software)">docker</a></li>
<li><a href="https://en.wikipedia.org/wiki/Perf_(Linux)">perf events</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-1">Previous chapter</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-kernel-concepts"><a class="header" href="#linux-kernel-concepts">Linux kernel concepts</a></h1>
<p>This chapter describes various concepts which are used in the Linux kernel.</p>
<ul>
<li><a href="Concepts/linux-cpu-1.html">Per-CPU variables</a></li>
<li><a href="Concepts/linux-cpu-2.html">CPU masks</a></li>
<li><a href="Concepts/linux-cpu-3.html">The initcall mechanism</a></li>
<li><a href="Concepts/linux-cpu-4.html">Notification Chains</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="per-cpu-variables"><a class="header" href="#per-cpu-variables">Per-CPU variables</a></h1>
<p>Per-CPU variables are one of the kernel features. You can understand the meaning of this feature by reading its name. We can create a variable and each processor core will have its own copy of this variable. In this part, we take a closer look at this feature and try to understand how it is implemented and how it works.</p>
<p>The kernel provides an API for creating per-cpu variables - the <code>DEFINE_PER_CPU</code> macro:</p>
<pre><code class="language-C">#define DEFINE_PER_CPU(type, name) \
        DEFINE_PER_CPU_SECTION(type, name, &quot;&quot;)
</code></pre>
<p>This macro defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/percpu-defs.h">include/linux/percpu-defs.h</a> as many other macros for work with per-cpu variables. Now we will see how this feature is implemented.</p>
<p>Take a look at the <code>DEFINE_PER_CPU</code> definition. We see that it takes 2 parameters: <code>type</code> and <code>name</code>, so we can use it to create per-cpu variables, for example like this:</p>
<pre><code class="language-C">DEFINE_PER_CPU(int, per_cpu_n)
</code></pre>
<p>We pass the type and the name of our variable. <code>DEFINE_PER_CPU</code> calls the <code>DEFINE_PER_CPU_SECTION</code> macro and passes the same two parameters and empty string to it. Let's look at the definition of the <code>DEFINE_PER_CPU_SECTION</code>:</p>
<pre><code class="language-C">#define DEFINE_PER_CPU_SECTION(type, name, sec)    \
         __PCPU_ATTRS(sec) PER_CPU_DEF_ATTRIBUTES  \
         __typeof__(type) name
</code></pre>
<pre><code class="language-C">#define __PCPU_ATTRS(sec)                                                \
         __percpu __attribute__((section(PER_CPU_BASE_SECTION sec)))     \
         PER_CPU_ATTRIBUTES
</code></pre>
<p>where <code>section</code> is:</p>
<pre><code class="language-C">#define PER_CPU_BASE_SECTION &quot;.data..percpu&quot;
</code></pre>
<p>After all macros are expanded we will get a global per-cpu variable:</p>
<pre><code class="language-C">__attribute__((section(&quot;.data..percpu&quot;))) int per_cpu_n
</code></pre>
<p>It means that we will have a <code>per_cpu_n</code> variable in the <code>.data..percpu</code> section. We can find this section in the <code>vmlinux</code>:</p>
<pre><code>.data..percpu 00013a58  0000000000000000  0000000001a5c000  00e00000  2**12
              CONTENTS, ALLOC, LOAD, DATA
</code></pre>
<p>Ok, now we know that when we use the <code>DEFINE_PER_CPU</code> macro, a per-cpu variable in the <code>.data..percpu</code> section will be created. When the kernel initializes it calls the <code>setup_per_cpu_areas</code> function which loads the <code>.data..percpu</code> section multiple times, one section per CPU.</p>
<p>Let's look at the per-CPU areas initialization process. It starts in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> from the call of the <code>setup_per_cpu_areas</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/setup_percpu.c">arch/x86/kernel/setup_percpu.c</a>.</p>
<pre><code class="language-C">pr_info(&quot;NR_CPUS:%d nr_cpumask_bits:%d nr_cpu_ids:%d nr_node_ids:%d\n&quot;,
        NR_CPUS, nr_cpumask_bits, nr_cpu_ids, nr_node_ids);
</code></pre>
<p>The <code>setup_per_cpu_areas</code> starts from the output information about the maximum number of CPUs set during kernel configuration with the <code>CONFIG_NR_CPUS</code> configuration option, actual number of CPUs, <code>nr_cpumask_bits</code> is the same that <code>NR_CPUS</code> bit for the new <code>cpumask</code> operators and number of <code>NUMA</code> nodes.</p>
<p>We can see this output in the dmesg:</p>
<pre><code>$ dmesg | grep percpu
[    0.000000] setup_percpu: NR_CPUS:8 nr_cpumask_bits:8 nr_cpu_ids:8 nr_node_ids:1
</code></pre>
<p>In the next step we check the <code>percpu</code> first chunk allocator. All percpu areas are allocated in chunks. The first chunk is used for the static percpu variables. The Linux kernel has <code>percpu_alloc</code> command line parameters which provides the type of the first chunk allocator. We can read about it in the kernel documentation:</p>
<pre><code>percpu_alloc=	Select which percpu first chunk allocator to use.
		Currently supported values are &quot;embed&quot; and &quot;page&quot;.
		Archs may support subset or none of the	selections.
		See comments in mm/percpu.c for details on each
		allocator.  This parameter is primarily	for debugging
		and performance comparison.
</code></pre>
<p>The <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/percpu.c">mm/percpu.c</a> contains the handler of this command line option:</p>
<pre><code class="language-C">early_param(&quot;percpu_alloc&quot;, percpu_alloc_setup);
</code></pre>
<p>Where the <code>percpu_alloc_setup</code> function sets the <code>pcpu_chosen_fc</code> variable depends on the <code>percpu_alloc</code> parameter value. By default the first chunk allocator is <code>auto</code>:</p>
<pre><code class="language-C">enum pcpu_fc pcpu_chosen_fc __initdata = PCPU_FC_AUTO;
</code></pre>
<p>If the <code>percpu_alloc</code> parameter is not given to the kernel command line, the <code>embed</code> allocator will be used which embeds the first percpu chunk into bootmem with the <a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-1">memblock</a>. The last allocator is the first chunk <code>page</code> allocator which maps the first chunk with <code>PAGE_SIZE</code> pages.</p>
<p>As I wrote above, first of all we make a check of the first chunk allocator type in the <code>setup_per_cpu_areas</code>. We check that first chunk allocator is not page:</p>
<pre><code class="language-C">if (pcpu_chosen_fc != PCPU_FC_PAGE) {
    ...
    ...
    ...
}
</code></pre>
<p>If it is not <code>PCPU_FC_PAGE</code>, we will use the <code>embed</code> allocator and allocate space for the first chunk with the <code>pcpu_embed_first_chunk</code> function:</p>
<pre><code class="language-C">rc = pcpu_embed_first_chunk(PERCPU_FIRST_CHUNK_RESERVE,
					    dyn_size, atom_size,
					    pcpu_cpu_distance,
					    pcpu_fc_alloc, pcpu_fc_free);
</code></pre>
<p>As shown above, the <code>pcpu_embed_first_chunk</code> function embeds the first percpu chunk into bootmem then we pass a couple of parameters to the <code>pcup_embed_first_chunk</code>. They are as follows:</p>
<ul>
<li><code>PERCPU_FIRST_CHUNK_RESERVE</code> - the size of the reserved space for the static <code>percpu</code> variables;</li>
<li><code>dyn_size</code> - minimum free size for dynamic allocation in bytes;</li>
<li><code>atom_size</code> - all allocations are whole multiples of this and aligned to this parameter;</li>
<li><code>pcpu_cpu_distance</code> - callback to determine distance between cpus;</li>
<li><code>pcpu_fc_alloc</code> - function to allocate <code>percpu</code> page;</li>
<li><code>pcpu_fc_free</code> - function to release <code>percpu</code> page.</li>
</ul>
<p>We calculate all of these parameters before the call of the <code>pcpu_embed_first_chunk</code>:</p>
<pre><code class="language-C">const size_t dyn_size = PERCPU_MODULE_RESERVE + PERCPU_DYNAMIC_RESERVE - PERCPU_FIRST_CHUNK_RESERVE;
size_t atom_size;
#ifdef CONFIG_X86_64
		atom_size = PMD_SIZE;
#else
		atom_size = PAGE_SIZE;
#endif
</code></pre>
<p>If the first chunk allocator is <code>PCPU_FC_PAGE</code>, we will use the <code>pcpu_page_first_chunk</code> instead of the <code>pcpu_embed_first_chunk</code>. After that <code>percpu</code> areas up, we setup <code>percpu</code> offset and its segment for every CPU with the <code>setup_percpu_segment</code> function (only for <code>x86</code> systems) and move some early data from the arrays to the <code>percpu</code> variables (<code>x86_cpu_to_apicid</code>, <code>irq_stack_ptr</code> and etc...). After the kernel finishes the initialization process, we will have loaded N <code>.data..percpu</code> sections, where N is the number of CPUs, and the section used by the bootstrap processor will contain an uninitialized variable created with the <code>DEFINE_PER_CPU</code> macro.</p>
<p>The kernel provides an API for per-cpu variables manipulating:</p>
<ul>
<li>get_cpu_var(var)</li>
<li>put_cpu_var(var)</li>
</ul>
<p>Let's look at the <code>get_cpu_var</code> implementation:</p>
<pre><code class="language-C">#define get_cpu_var(var)     \
(*({                         \
         preempt_disable();  \
         this_cpu_ptr(&amp;var); \
}))
</code></pre>
<p>The Linux kernel is preemptible and accessing a per-cpu variable requires us to know which processor the kernel is running on. So, current code must not be preempted and moved to the another CPU while accessing a per-cpu variable. That's why, first of all we can see a call of the <code>preempt_disable</code> function then a call of the <code>this_cpu_ptr</code> macro, which looks like:</p>
<pre><code class="language-C">#define this_cpu_ptr(ptr) raw_cpu_ptr(ptr)
</code></pre>
<p>and</p>
<pre><code class="language-C">#define raw_cpu_ptr(ptr)        per_cpu_ptr(ptr, 0)
</code></pre>
<p>where <code>per_cpu_ptr</code> returns a pointer to the per-cpu variable for the given cpu (second parameter). After we've created a per-cpu variable and made modifications to it, we must call the <code>put_cpu_var</code> macro which enables preemption with a call of <code>preempt_enable</code> function. So the typical usage of a per-cpu variable is as follows:</p>
<pre><code class="language-C">get_cpu_var(var);
...
//Do something with the 'var'
...
put_cpu_var(var);
</code></pre>
<p>Let's look at the <code>per_cpu_ptr</code> macro:</p>
<pre><code class="language-C">#define per_cpu_ptr(ptr, cpu)                             \
({                                                        \
        __verify_pcpu_ptr(ptr);                           \
         SHIFT_PERCPU_PTR((ptr), per_cpu_offset((cpu)));  \
})
</code></pre>
<p>As I wrote above, this macro returns a per-cpu variable for the given cpu. First of all it calls <code>__verify_pcpu_ptr</code>:</p>
<pre><code class="language-C">#define __verify_pcpu_ptr(ptr)
do {
	const void __percpu *__vpp_verify = (typeof((ptr) + 0))NULL;
	(void)__vpp_verify;
} while (0)
</code></pre>
<p>which makes the given <code>ptr</code> type of <code>const void __percpu *</code>,</p>
<p>After this we can see the call of the <code>SHIFT_PERCPU_PTR</code> macro with two parameters. As first parameter we pass our ptr and for second parameter we pass the cpu number to the <code>per_cpu_offset</code> macro:</p>
<pre><code class="language-C">#define per_cpu_offset(x) (__per_cpu_offset[x])
</code></pre>
<p>which expands to getting the <code>x</code> element from the <code>__per_cpu_offset</code> array:</p>
<pre><code class="language-C">extern unsigned long __per_cpu_offset[NR_CPUS];
</code></pre>
<p>where <code>NR_CPUS</code> is the number of CPUs. The <code>__per_cpu_offset</code> array is filled with the distances between cpu-variable copies. For example all per-cpu data is <code>X</code> bytes in size, so if we access <code>__per_cpu_offset[Y]</code>, <code>X*Y</code> will be accessed. Let's look at the <code>SHIFT_PERCPU_PTR</code> implementation:</p>
<pre><code class="language-C">#define SHIFT_PERCPU_PTR(__p, __offset)                                 \
         RELOC_HIDE((typeof(*(__p)) __kernel __force *)(__p), (__offset))
</code></pre>
<p><code>RELOC_HIDE</code> just returns offset <code>(typeof(ptr)) (__ptr + (off))</code> and it will return a pointer to the variable.</p>
<p>That's all! Of course it is not the full API, but a general overview. It can be hard to start with, but to understand per-cpu variables you mainly need to understand the  <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/percpu-defs.h">include/linux/percpu-defs.h</a> magic.</p>
<p>Let's again look at the algorithm of getting a pointer to a per-cpu variable:</p>
<ul>
<li>The kernel creates multiple <code>.data..percpu</code> sections (one per-cpu) during initialization process;</li>
<li>All variables created with the <code>DEFINE_PER_CPU</code> macro will be relocated to the first section or for CPU0;</li>
<li><code>__per_cpu_offset</code> array filled with the distance (<code>BOOT_PERCPU_OFFSET</code>) between <code>.data..percpu</code> sections;</li>
<li>When the <code>per_cpu_ptr</code> is called, for example for getting a pointer on a certain per-cpu variable for the third CPU, the <code>__per_cpu_offset</code> array will be accessed, where every index points to the required CPU.</li>
</ul>
<p>That's all.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cpu-masks"><a class="header" href="#cpu-masks">CPU masks</a></h1>
<h2 id="introduction-11"><a class="header" href="#introduction-11">Introduction</a></h2>
<p><code>Cpumasks</code> is a special way provided by the Linux kernel to store information about CPUs in the system. The relevant source code and header files which contains API for <code>Cpumasks</code> manipulation:</p>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/cpumask.h">include/linux/cpumask.h</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/lib/cpumask.c">lib/cpumask.c</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/cpu.c">kernel/cpu.c</a></li>
</ul>
<p>As comment says from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/cpumask.h">include/linux/cpumask.h</a>: Cpumasks provide a bitmap suitable for representing the set of CPU's in a system, one bit position per CPU number. We already saw a bit about cpumask in the <code>boot_cpu_init</code> function from the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">Kernel entry point</a> part. This function makes first boot cpu online, active and etc...:</p>
<pre><code class="language-C">set_cpu_online(cpu, true);
set_cpu_active(cpu, true);
set_cpu_present(cpu, true);
set_cpu_possible(cpu, true);
</code></pre>
<p>Before we consider implementation of these functions, let's consider all of these masks.</p>
<p>The <code>cpu_possible</code> is a set of cpu ID's which can be plugged in anytime during the life of that system boot or in other words mask of possible CPUs contains maximum number of CPUs which are possible in the system. It will be equal to value of the <code>NR_CPUS</code> which is set statically via the <code>CONFIG_NR_CPUS</code> kernel configuration option.</p>
<p>The <code>cpu_present</code> mask represents which CPUs are currently plugged in.</p>
<p>The <code>cpu_online</code> represents a subset of the <code>cpu_present</code> and indicates CPUs which are available for scheduling or in other words a bit from this mask tells the kernel if a processor may be utilized by the Linux kernel.</p>
<p>The last mask is <code>cpu_active</code>. Bits of this mask tells to Linux kernel is a task may be moved to a certain processor.</p>
<p>All of these masks depend on the <code>CONFIG_HOTPLUG_CPU</code> configuration option and if this option is disabled <code>possible == present</code> and <code>active == online</code>. The implementations of all of these functions are very similar. Every function checks the second parameter. If it is <code>true</code>, it calls <code>cpumask_set_cpu</code> otherwise it calls <code>cpumask_clear_cpu</code> .</p>
<p>There are two ways for a <code>cpumask</code> creation. First is to use <code>cpumask_t</code>. It is defined as:</p>
<pre><code class="language-C">typedef struct cpumask { DECLARE_BITMAP(bits, NR_CPUS); } cpumask_t;
</code></pre>
<p>It wraps the <code>cpumask</code> structure which contains one bitmask <code>bits</code> field. The <code>DECLARE_BITMAP</code> macro gets two parameters:</p>
<ul>
<li>bitmap name;</li>
<li>number of bits.</li>
</ul>
<p>and creates an array of <code>unsigned long</code> with the given name. Its implementation is pretty easy:</p>
<pre><code class="language-C">#define DECLARE_BITMAP(name,bits) \
        unsigned long name[BITS_TO_LONGS(bits)]
</code></pre>
<p>where <code>BITS_TO_LONGS</code>:</p>
<pre><code class="language-C">#define BITS_TO_LONGS(nr)       DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
</code></pre>
<p>As we are focusing on the <code>x86_64</code> architecture, <code>unsigned long</code> is 8-bytes size and our array will contain only one element:</p>
<pre><code>(((8) + (64) - 1) / (64)) = 1
</code></pre>
<p><code>NR_CPUS</code> macro represents the number of CPUs in the system and depends on the <code>CONFIG_NR_CPUS</code> macro which is defined in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/threads.h">include/linux/threads.h</a> and looks like this:</p>
<pre><code class="language-C">#ifndef CONFIG_NR_CPUS
        #define CONFIG_NR_CPUS  1
#endif

#define NR_CPUS         CONFIG_NR_CPUS
</code></pre>
<p>The second way to define cpumask is to use the <code>DECLARE_BITMAP</code> macro directly and the <code>to_cpumask</code> macro which converts the given bitmap to <code>struct cpumask *</code>:</p>
<pre><code class="language-C">#define to_cpumask(bitmap)                                              \
        ((struct cpumask *)(1 ? (bitmap)                                \
                            : (void *)sizeof(__check_is_bitmap(bitmap))))
</code></pre>
<p>We can see the ternary operator operator here which is <code>true</code> every time. <code>__check_is_bitmap</code> inline function is defined as:</p>
<pre><code class="language-C">static inline int __check_is_bitmap(const unsigned long *bitmap)
{
        return 1;
}
</code></pre>
<p>And returns <code>1</code> every time. We need it here for only one purpose: at compile time it checks that a given <code>bitmap</code> is a bitmap, or in other words it checks that a given <code>bitmap</code> has type - <code>unsigned long *</code>. So we just pass <code>cpu_possible_bits</code> to the <code>to_cpumask</code> macro for converting an array of <code>unsigned long</code> to the <code>struct cpumask *</code>.</p>
<h2 id="cpumask-api"><a class="header" href="#cpumask-api">cpumask API</a></h2>
<p>As we can define cpumask with one of the methods, Linux kernel provides API for manipulating a cpumask. Let's consider one of the function which presented above. For example <code>set_cpu_online</code>. This function takes two parameters:</p>
<ul>
<li>Index of CPU;</li>
<li>CPU status;</li>
</ul>
<p>Implementation of this function looks as:</p>
<pre><code class="language-C">void set_cpu_online(unsigned int cpu, bool online)
{
	if (online) {
		cpumask_set_cpu(cpu, to_cpumask(cpu_online_bits));
		cpumask_set_cpu(cpu, to_cpumask(cpu_active_bits));
	} else {
		cpumask_clear_cpu(cpu, to_cpumask(cpu_online_bits));
	}
}
</code></pre>
<p>First of all it checks the second <code>state</code> parameter and calls <code>cpumask_set_cpu</code> or <code>cpumask_clear_cpu</code> depending on it. Here we can see casting to the <code>struct cpumask *</code> of the second parameter in the <code>cpumask_set_cpu</code>. In our case it is <code>cpu_online_bits</code> which is a bitmap and defined as:</p>
<pre><code class="language-C">static DECLARE_BITMAP(cpu_online_bits, CONFIG_NR_CPUS) __read_mostly;
</code></pre>
<p>The <code>cpumask_set_cpu</code> function makes only one call to the <code>set_bit</code> function:</p>
<pre><code class="language-C">static inline void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
{
        set_bit(cpumask_check(cpu), cpumask_bits(dstp));
}
</code></pre>
<p>The <code>set_bit</code> function takes two parameters too, and sets a given bit (first parameter) in the memory (second parameter or <code>cpu_online_bits</code> bitmap). We can see here that before <code>set_bit</code> is called, its two parameters will be passed to the</p>
<ul>
<li>cpumask_check;</li>
<li>cpumask_bits.</li>
</ul>
<p>Let's consider these two macros. First if <code>cpumask_check</code> does nothing in our case and just returns given parameter. The second <code>cpumask_bits</code> just returns the <code>bits</code> field from the given <code>struct cpumask *</code> structure:</p>
<pre><code class="language-C">#define cpumask_bits(maskp) ((maskp)-&gt;bits)
</code></pre>
<p>Now let's look on the <code>set_bit</code> implementation:</p>
<pre><code class="language-C"> static __always_inline void
 set_bit(long nr, volatile unsigned long *addr)
 {
         if (IS_IMMEDIATE(nr)) {
                asm volatile(LOCK_PREFIX &quot;orb %1,%0&quot;
                        : CONST_MASK_ADDR(nr, addr)
                        : &quot;iq&quot; ((u8)CONST_MASK(nr))
                        : &quot;memory&quot;);
        } else {
                asm volatile(LOCK_PREFIX &quot;bts %1,%0&quot;
                        : BITOP_ADDR(addr) : &quot;Ir&quot; (nr) : &quot;memory&quot;);
        }
 }
</code></pre>
<p>This function looks scary, but it is not so hard as it seems. First of all it passes <code>nr</code> or number of the bit to the <code>IS_IMMEDIATE</code> macro which just calls the GCC internal <code>__builtin_constant_p</code> function:</p>
<pre><code class="language-C">#define IS_IMMEDIATE(nr)    (__builtin_constant_p(nr))
</code></pre>
<p><code>__builtin_constant_p</code> checks that given parameter is known constant at compile-time. As our <code>cpu</code> is not compile-time constant, the <code>else</code> clause will be executed:</p>
<pre><code class="language-C">asm volatile(LOCK_PREFIX &quot;bts %1,%0&quot; : BITOP_ADDR(addr) : &quot;Ir&quot; (nr) : &quot;memory&quot;);
</code></pre>
<p>Let's try to understand how it works step by step:</p>
<p><code>LOCK_PREFIX</code> is a x86 <code>lock</code> instruction. This instruction tells the cpu to occupy the system bus while the instruction(s) will be executed. This allows the CPU to synchronize memory access, preventing simultaneous access of multiple processors (or devices - the DMA controller for example) to one memory cell.</p>
<p><code>BITOP_ADDR</code> casts the given parameter to the <code>(*(volatile long *)</code> and adds <code>+m</code> constraints. <code>+</code> means that this operand is both read and written by the instruction. <code>m</code> shows that this is a memory operand. <code>BITOP_ADDR</code> is defined as:</p>
<pre><code class="language-C">#define BITOP_ADDR(x) &quot;+m&quot; (*(volatile long *) (x))
</code></pre>
<p>Next is the <code>memory</code> clobber. It tells the compiler that the assembly code performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters).</p>
<p><code>Ir</code> - immediate register operand.</p>
<p>The <code>bts</code> instruction sets a given bit in a bit string and stores the value of a given bit in the <code>CF</code> flag. So we passed the cpu number which is zero in our case and after <code>set_bit</code> is executed, it sets the zero bit in the <code>cpu_online_bits</code> cpumask. It means that the first cpu is online at this moment.</p>
<p>Besides the <code>set_cpu_*</code> API, cpumask of course provides another API for cpumasks manipulation. Let's consider it in short.</p>
<h2 id="additional-cpumask-api"><a class="header" href="#additional-cpumask-api">Additional cpumask API</a></h2>
<p>cpumask provides a set of macros for getting the numbers of CPUs in various states. For example:</p>
<pre><code class="language-C">#define num_online_cpus()	cpumask_weight(cpu_online_mask)
</code></pre>
<p>This macro returns the amount of <code>online</code> CPUs. It calls the <code>cpumask_weight</code> function with the <code>cpu_online_mask</code> bitmap (read about it). The<code>cpumask_weight</code> function makes one call of the <code>bitmap_weight</code> function with two parameters:</p>
<ul>
<li>cpumask bitmap;</li>
<li><code>nr_cpumask_bits</code> - which is <code>NR_CPUS</code> in our case.</li>
</ul>
<pre><code class="language-C">static inline unsigned int cpumask_weight(const struct cpumask *srcp)
{
	return bitmap_weight(cpumask_bits(srcp), nr_cpumask_bits);
}
</code></pre>
<p>and calculates the number of bits in the given bitmap. Besides the <code>num_online_cpus</code>, cpumask provides macros for the all CPU states:</p>
<ul>
<li>num_possible_cpus;</li>
<li>num_active_cpus;</li>
<li>cpu_online;</li>
<li>cpu_possible.</li>
</ul>
<p>and many more.</p>
<p>Besides that the Linux kernel provides the following API for the manipulation of <code>cpumask</code>:</p>
<ul>
<li><code>for_each_cpu</code> - iterates over every cpu in a mask;</li>
<li><code>for_each_cpu_not</code> - iterates over every cpu in a complemented mask;</li>
<li><code>cpumask_clear_cpu</code> - clears a cpu in a cpumask;</li>
<li><code>cpumask_test_cpu</code> - tests a cpu in a mask;</li>
<li><code>cpumask_setall</code> - set all cpus in a mask;</li>
<li><code>cpumask_size</code> - returns size to allocate for a 'struct cpumask' in bytes;</li>
</ul>
<p>and many many more...</p>
<h2 id="links-49"><a class="header" href="#links-49">Links</a></h2>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">cpumask documentation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-initcall-mechanism"><a class="header" href="#the-initcall-mechanism">The initcall mechanism</a></h1>
<h2 id="introduction-12"><a class="header" href="#introduction-12">Introduction</a></h2>
<p>As you may understand from the title, this part will cover an interesting and important concept in the Linux kernel which is called <code>initcall</code>. We already saw definitions like these:</p>
<pre><code class="language-C">early_param(&quot;debug&quot;, debug_kernel);
</code></pre>
<p>or</p>
<pre><code class="language-C">arch_initcall(init_pit_clocksource);
</code></pre>
<p>in some parts of the Linux kernel. Before we will see how this mechanism is implemented in the Linux kernel, we must know actually what is it and how the Linux kernel uses it. Definitions like these represent a <a href="https://en.wikipedia.org/wiki/Callback_%28computer_programming%29">callback</a> function which is called during Linux kernel initialization. Actually the main point of the <code>initcall</code> mechanism is to determine correct order of the built-in modules and subsystems initialization. For example let's look at the following function:</p>
<pre><code class="language-C">static int __init nmi_warning_debugfs(void)
{
    debugfs_create_u64(&quot;nmi_longest_ns&quot;, 0644,
                       arch_debugfs_dir, &amp;nmi_longest_ns);
    return 0;
}
fs_initcall(nmi_warning_debugfs);
</code></pre>
<p>from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/nmi.c">arch/x86/kernel/nmi.c</a> source code file. As we may see it just creates the <code>nmi_longest_ns</code> <a href="https://en.wikipedia.org/wiki/Debugfs">debugfs</a> file in the <code>arch_debugfs_dir</code> directory. Actually, this <code>debugfs</code> file may be created only after the <code>arch_debugfs_dir</code> will be created. Creation of this directory occurs during the architecture-specific initialization of the Linux kernel. Actually this directory will be created in the <code>arch_kdebugfs_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/kdebugfs.c">arch/x86/kernel/kdebugfs.c</a> source code file. Note that the <code>arch_kdebugfs_init</code> function is marked as <code>initcall</code> too:</p>
<pre><code class="language-C">arch_initcall(arch_kdebugfs_init);
</code></pre>
<p>The Linux kernel calls all architecture-specific <code>initcalls</code> before the <code>fs</code> related <code>initcalls</code>. So, our <code>nmi_longest_ns</code> file will be created only after the <code>arch_kdebugfs_dir</code> directory will be created. Actually, the Linux kernel provides eight levels of main <code>initcalls</code>:</p>
<ul>
<li><code>early</code>;</li>
<li><code>core</code>;</li>
<li><code>postcore</code>;</li>
<li><code>arch</code>;</li>
<li><code>subsys</code>;</li>
<li><code>fs</code>;</li>
<li><code>device</code>;</li>
<li><code>late</code>.</li>
</ul>
<p>All of their names are represented by the <code>initcall_level_names</code> array which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> source code file:</p>
<pre><code class="language-C">static char *initcall_level_names[] __initdata = {
	&quot;early&quot;,
	&quot;core&quot;,
	&quot;postcore&quot;,
	&quot;arch&quot;,
	&quot;subsys&quot;,
	&quot;fs&quot;,
	&quot;device&quot;,
	&quot;late&quot;,
};
</code></pre>
<p>All functions which are marked as <code>initcall</code> by these identifiers, will be called in the same order presented in the <code>initcall_level_names</code> array, in other words, at first <code>early initcalls</code> will be called, then <code>core initcalls</code> and so forth. From this moment we know a little about <code>initcall</code> mechanism, so we can start to dive into the source code of the Linux kernel to see how this mechanism is implemented.</p>
<h2 id="implementation-initcall-mechanism-in-the-linux-kernel"><a class="header" href="#implementation-initcall-mechanism-in-the-linux-kernel">Implementation initcall mechanism in the Linux kernel</a></h2>
<p>The Linux kernel provides a set of macros from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init.h">include/linux/init.h</a> header file to mark a given function as <code>initcall</code>. All of these macros are pretty simple:</p>
<pre><code class="language-C">#define early_initcall(fn)		__define_initcall(fn, early)
#define core_initcall(fn)		__define_initcall(fn, 1)
#define postcore_initcall(fn)		__define_initcall(fn, 2)
#define arch_initcall(fn)		__define_initcall(fn, 3)
#define subsys_initcall(fn)		__define_initcall(fn, 4)
#define fs_initcall(fn)			__define_initcall(fn, 5)
#define device_initcall(fn)		__define_initcall(fn, 6)
#define late_initcall(fn)		__define_initcall(fn, 7)
</code></pre>
<p>and as we may see these macros just expand to the call of the <code>__define_initcall</code> macro from the same header file. Moreover, the <code>__define_initcall</code> macro takes two arguments:</p>
<ul>
<li><code>fn</code> - callback function which will be called during call of <code>initcalls</code> of the certain level;</li>
<li><code>id</code> - identifier to identify <code>initcall</code> to prevent error when two the same <code>initcalls</code> point to the same handler.</li>
</ul>
<p>The implementation of the <code>__define_initcall</code> macro looks like:</p>
<pre><code class="language-C">#define __define_initcall(fn, id) \
	static initcall_t __initcall_##fn##id __used \
	__attribute__((__section__(&quot;.initcall&quot; #id &quot;.init&quot;))) = fn; \
	LTO_REFERENCE_INITCALL(__initcall_##fn##id)
</code></pre>
<p>To understand the <code>__define_initcall</code> macro, first of all let's look at the <code>initcall_t</code> type. This type is defined in the same <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init.h">header</a> file and it represents pointer to a function which returns <a href="https://en.wikipedia.org/wiki/Integer">integer</a> which will be result of the <code>initcall</code>:</p>
<pre><code class="language-C">typedef int (*initcall_t)(void);
</code></pre>
<p>Now let's return to the <code>__define_initcall</code> macro. The <a href="https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html">##</a> provides ability to concatenate two symbols. In our case, the first line of the <code>__define_initcall</code> macro produces the definition of a given function, <code>__initcall_&lt;function-name&gt;_&lt;id&gt;</code>, which is located in the <code>.initcall &lt;id&gt; .init</code> <a href="http://www.skyfree.org/linux/references/ELF_Format.pdf">ELF section</a> and marked with the <code>__user</code> <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a> attribute. If we look at <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/asm-generic/vmlinux.lds.h">include/asm-generic/vmlinux.lds.h</a> header file, which represents data for the kernel <a href="https://en.wikipedia.org/wiki/Linker_%28computing%29">linker</a> script, we will see that all of <code>initcalls</code> sections will be placed in the <code>.data</code> section:</p>
<pre><code class="language-C">#define INIT_CALLS					\
		VMLINUX_SYMBOL(__initcall_start) = .;	\
		*(.initcallearly.init)					\
		INIT_CALLS_LEVEL(0)					    \
		INIT_CALLS_LEVEL(1)					    \
		INIT_CALLS_LEVEL(2)					    \
		INIT_CALLS_LEVEL(3)					    \
		INIT_CALLS_LEVEL(4)					    \
		INIT_CALLS_LEVEL(5)					    \
		INIT_CALLS_LEVEL(rootfs)				\
		INIT_CALLS_LEVEL(6)					    \
		INIT_CALLS_LEVEL(7)					    \
		VMLINUX_SYMBOL(__initcall_end) = .;

#define INIT_DATA_SECTION(initsetup_align)	\
	.init.data : AT(ADDR(.init.data) - LOAD_OFFSET) {	   \
        ...                                                \
        INIT_CALLS						                   \
        ...                                                \
	}

</code></pre>
<p>and their names are going to be as follows (got from System.map):</p>
<pre><code>...
ffffffff8320ce60 t __initcall_arch_kdebugfs_init3
...
ffffffff8320d0e0 t __initcall_nmi_warning_debugfs5
...
</code></pre>
<p>The attribute <code>__used</code> is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/compiler-gcc.h">include/linux/compiler-gcc.h</a> header file and it expands to the definition of the following <code>gcc</code> attribute:</p>
<pre><code class="language-C">#define __used   __attribute__((__used__))
</code></pre>
<p>which prevents <code>variable defined but not used</code> warning. The last line of the <code>__define_initcall</code> macro is:</p>
<pre><code class="language-C">LTO_REFERENCE_INITCALL(__initcall_##fn##id)
</code></pre>
<p>depends on the <code>CONFIG_LTO</code> kernel configuration option and just provides stub for the compiler <a href="https://gcc.gnu.org/wiki/LinkTimeOptimization">Link time optimization</a>:</p>
<pre><code>#ifdef CONFIG_LTO
#define LTO_REFERENCE_INITCALL(x) \
        static __used __exit void *reference_##x(void)  \
        {                                               \
                return &amp;x;                              \
        }
#else
#define LTO_REFERENCE_INITCALL(x)
#endif
</code></pre>
<p>In order to prevent any problem when there is no reference to a variable in a module, it will be moved to the end of the program. That's all about the <code>__define_initcall</code> macro. So, all of the <code>*_initcall</code> macros will be expanded during compilation of the Linux kernel, and all <code>initcalls</code> will be placed in their sections and all of them will be available from the <code>.data</code> section and the Linux kernel will know where to find a certain <code>initcall</code> to call it during initialization process.</p>
<p>As <code>initcalls</code> can be called by the Linux kernel, let's look how the Linux kernel does this. This process starts in the <code>do_basic_setup</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> source code file:</p>
<pre><code class="language-C">static void __init do_basic_setup(void)
{
    ...
    ...
    ...
   	do_initcalls();
    ...
    ...
    ...
}
</code></pre>
<p>which is called during the initialization of the Linux kernel, right after main steps of initialization like memory manager related initialization, <code>CPU</code> subsystem and others are already finished. The <code>do_initcalls</code> function just goes through the array of <code>initcall</code> levels and call the <code>do_initcall_level</code> function for each level:</p>
<pre><code class="language-C">static void __init do_initcalls(void)
{
	int level;

	for (level = 0; level &lt; ARRAY_SIZE(initcall_levels) - 1; level++)
		do_initcall_level(level);
}
</code></pre>
<p>The <code>initcall_levels</code> array is defined in the same source code <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">file</a> and contains pointers to the sections which were defined in the <code>__define_initcall</code> macro:</p>
<pre><code class="language-C">static initcall_t *initcall_levels[] __initdata = {
	__initcall0_start,
	__initcall1_start,
	__initcall2_start,
	__initcall3_start,
	__initcall4_start,
	__initcall5_start,
	__initcall6_start,
	__initcall7_start,
	__initcall_end,
};
</code></pre>
<p>If you are interested, you can find these sections in the <code>arch/x86/kernel/vmlinux.lds</code> linker script which is generated after the Linux kernel compilation:</p>
<pre><code>.init.data : AT(ADDR(.init.data) - 0xffffffff80000000) {
    ...
    ...
    ...
    ...
    __initcall_start = .;
    *(.initcallearly.init)
    __initcall0_start = .;
    *(.initcall0.init)
    *(.initcall0s.init)
    __initcall1_start = .;
    ...
    ...
}
</code></pre>
<p>If you are not familiar with this then you can know more about <a href="https://en.wikipedia.org/wiki/Linker_%28computing%29">linkers</a> in the special <a href="https://0xax.gitbook.io/linux-insides/summary/misc/linux-misc-3">part</a> of this book.</p>
<p>As we just saw, the <code>do_initcall_level</code> function takes one parameter - level of <code>initcall</code> - and does the following two things:</p>
<ul>
<li>
<p>parses the <code>initcall_command_line</code> which is copy of usual kernel <a href="https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.rst">command line</a> which may contain parameters for modules with the <code>parse_args</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/params.c">kernel/params.c</a> source code file;</p>
</li>
<li>
<p>call the <code>do_on_initcall</code> function for each level:</p>
</li>
</ul>
<pre><code class="language-C">for (fn = initcall_levels[level]; fn &lt; initcall_levels[level+1]; fn++)
		do_one_initcall(*fn);
</code></pre>
<p>The <code>do_one_initcall</code> does the main job for us. As we may see, this function takes one parameter which represent <code>initcall</code> callback function and does the call of the given callback:</p>
<pre><code class="language-C">int __init_or_module do_one_initcall(initcall_t fn)
{
	int count = preempt_count();
	int ret;
	char msgbuf[64];

	if (initcall_blacklisted(fn))
		return -EPERM;

	if (initcall_debug)
		ret = do_one_initcall_debug(fn);
	else
		ret = fn();

	msgbuf[0] = 0;

	if (preempt_count() != count) {
		sprintf(msgbuf, &quot;preemption imbalance &quot;);
		preempt_count_set(count);
	}
	if (irqs_disabled()) {
		strlcat(msgbuf, &quot;disabled interrupts &quot;, sizeof(msgbuf));
		local_irq_enable();
	}
	WARN(msgbuf[0], &quot;initcall %pF returned with %s\n&quot;, fn, msgbuf);

	return ret;
}
</code></pre>
<p>Let's try to understand what does the <code>do_one_initcall</code> function does. First of all we increase <a href="https://en.wikipedia.org/wiki/Preemption_%28computing%29">preemption</a> counter so that we can check it later to be sure that it is not imbalanced. After this step we can see the call of the <code>initcall_backlist</code> function which goes over the <code>blacklisted_initcalls</code> list which stores blacklisted <code>initcalls</code> and releases the given <code>initcall</code> if it is located in this list:</p>
<pre><code class="language-C">list_for_each_entry(entry, &amp;blacklisted_initcalls, next) {
	if (!strcmp(fn_name, entry-&gt;buf)) {
		pr_debug(&quot;initcall %s blacklisted\n&quot;, fn_name);
		kfree(fn_name);
		return true;
	}
}
</code></pre>
<p>This blacklist is filled during early Linux kernel initialization from the Linux kernel command line.</p>
<p>After the blacklisted <code>initcalls</code> are handled, the next part of code directly calls the <code>initcall</code> callback:</p>
<pre><code class="language-C">if (initcall_debug)
	ret = do_one_initcall_debug(fn);
else
	ret = fn();
</code></pre>
<p><code>initcall_debug</code> variable defines if the call should be handled through the debug codepath (with more information being printed to the <a href="https://en.wikipedia.org/wiki/Dmesg">kernel log buffer</a>) or not, where the callback will finally be executed. The <code>initcall_debug</code> variable is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">same</a> source code file:</p>
<pre><code class="language-C">bool initcall_debug;
</code></pre>
<p>The value of the variable can be set from the kernel commands via the <code>initcall_debug</code> parameter, as we can read from the <a href="https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.rst">documentation</a> of the Linux kernel command line:</p>
<pre><code>initcall_debug	[KNL] Trace initcalls as they are executed.  Useful
                      for working out where the kernel is dying during
                      startup.
</code></pre>
<p>And that's true. If we will look at the implementation of the <code>do_one_initcall_debug</code> function, we will see that it does the same as the <code>do_one_initcall</code> function, i.e. the <code>do_one_initcall_debug</code> function calls the given <code>initcall</code> and prints some information (like the <a href="https://en.wikipedia.org/wiki/Process_identifier">pid</a> of the currently running task, duration of execution of the <code>initcall</code> and etc.) related to the execution of the given <code>initcall</code>:</p>
<pre><code class="language-C">static int __init_or_module do_one_initcall_debug(initcall_t fn)
{
	ktime_t calltime, delta, rettime;
	unsigned long long duration;
	int ret;

	printk(KERN_DEBUG &quot;calling  %pF @ %i\n&quot;, fn, task_pid_nr(current));
	calltime = ktime_get();
	ret = fn();
	rettime = ktime_get();
	delta = ktime_sub(rettime, calltime);
	duration = (unsigned long long) ktime_to_ns(delta) &gt;&gt; 10;
	printk(KERN_DEBUG &quot;initcall %pF returned %d after %lld usecs\n&quot;,
		 fn, ret, duration);

	return ret;
}
</code></pre>
<p>As an <code>initcall</code> was called by the one of the <code> do_one_initcall</code> or <code>do_one_initcall_debug</code> functions, we may see two checks in the end of the <code>do_one_initcall</code> function. The first one checks the amount of possible <code>__preempt_count_add</code> and <code>__preempt_count_sub</code> calls inside of the executed initcall, and if this value is not equal to the previous value of the preemptible counter, we add the <code>preemption imbalance</code> string to the message buffer and set correct value of the preemptible counter:</p>
<pre><code class="language-C">if (preempt_count() != count) {
	sprintf(msgbuf, &quot;preemption imbalance &quot;);
	preempt_count_set(count);
}
</code></pre>
<p>The last check the state of local <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQs</a> and if they are disabled, we add the <code>disabled interrupts</code> strings to log buffer and enable <code>IRQs</code> for the current processor to make sure that <code>IRQs</code> are enabled after each <code>initcall</code> is completed (in case the callback disabled it and didn't enable before exiting):</p>
<pre><code class="language-C">if (irqs_disabled()) {
	strlcat(msgbuf, &quot;disabled interrupts &quot;, sizeof(msgbuf));
	local_irq_enable();
}
</code></pre>
<p>That's all. In this way the Linux kernel does initialization of many subsystems in a correct order. From now on, we know what is the <code>initcall</code> mechanism in the Linux kernel. In this part, we covered main general portion of the <code>initcall</code> mechanism but we left some important concepts. Let's make a short look at these concepts.</p>
<p>First of all, we have missed one level of <code>initcalls</code>, this is <code>rootfs initcalls</code>. You can find definition of the <code>rootfs_initcall</code> in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init.h">include/linux/init.h</a> header file along with all similar macros which we saw in this part:</p>
<pre><code class="language-C">#define rootfs_initcall(fn)		__define_initcall(fn, rootfs)
</code></pre>
<p>As we may understand from the macro's name, its main purpose is to store callbacks which are related to the <a href="https://en.wikipedia.org/wiki/Initramfs">rootfs</a>. Besides this goal, it may be useful to initialize other components after initialization related to filesystems level was already done, but before devices related initcalls. For example, the decompression of the <a href="https://en.wikipedia.org/wiki/Initramfs">initramfs</a> which occurred in the <code>populate_rootfs</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/initramfs.c">init/initramfs.c</a> source code file:</p>
<pre><code class="language-C">rootfs_initcall(populate_rootfs);
</code></pre>
<p>From this place, we may see familiar output:</p>
<pre><code>[    0.199960] Unpacking initramfs...
</code></pre>
<p>Besides the <code>rootfs_initcall</code> level, there are additional <code>console_initcall</code>, <code>security_initcall</code> and other secondary <code>initcall</code> levels. The last thing that we have missed is the set of the <code>*_initcall_sync</code> levels. Almost each <code>*_initcall</code> macro that we have seen in this part, has macro companion with the <code>_sync</code> prefix:</p>
<pre><code class="language-C">#define core_initcall_sync(fn)		__define_initcall(fn, 1s)
#define postcore_initcall_sync(fn)	__define_initcall(fn, 2s)
#define arch_initcall_sync(fn)		__define_initcall(fn, 3s)
#define subsys_initcall_sync(fn)	__define_initcall(fn, 4s)
#define fs_initcall_sync(fn)		__define_initcall(fn, 5s)
#define device_initcall_sync(fn)	__define_initcall(fn, 6s)
#define late_initcall_sync(fn)		__define_initcall(fn, 7s)
</code></pre>
<p>The main goal of these additional levels is to wait for completion of all modules related initialization routines for a certain level.</p>
<p>Another point worthy of mention is the <code>module_init(x)</code> macro, defined at <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/module.h">include/linux/module.h</a> as:</p>
<pre><code class="language-C">#define module_init(x)   __initcall(x);
</code></pre>
<p>If we follow and check what's the definition of <code>__initcall(x)</code> at <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init.h">include/linux/init.h</a> we can see that it's being set as an <code>device_initcall</code>:</p>
<pre><code class="language-C">#define __initcall(fn) device_initcall(fn)
</code></pre>
<p>With that we can conclude that when a function set as <code>__init</code> of certain module isn't explicitly added to a specific initcall category, but using <code>module_init()</code> macro, it is added to device initcall list by default.</p>
<p>That's all.</p>
<h2 id="conclusion-49"><a class="header" href="#conclusion-49">Conclusion</a></h2>
<p>In this part we saw the important mechanism of the Linux kernel which allows to call a function which depends on the current state of the Linux kernel during its initialization.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-50"><a class="header" href="#links-50">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Callback_%28computer_programming%29">callback</a></li>
<li><a href="https://en.wikipedia.org/wiki/Debugfs">debugfs</a></li>
<li><a href="https://en.wikipedia.org/wiki/Integer">integer type</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html">symbols concatenation</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a></li>
<li><a href="https://gcc.gnu.org/wiki/LinkTimeOptimization">Link time optimization</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/misc/linux-misc-3">Introduction to linkers</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.rst">Linux kernel command line</a></li>
<li><a href="https://en.wikipedia.org/wiki/Process_identifier">Process identifier</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQs</a></li>
<li><a href="https://en.wikipedia.org/wiki/Initramfs">rootfs</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notification-chains-in-linux-kernel"><a class="header" href="#notification-chains-in-linux-kernel">Notification Chains in Linux Kernel</a></h1>
<h2 id="introduction-13"><a class="header" href="#introduction-13">Introduction</a></h2>
<p>The Linux kernel is huge piece of <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> code which consists from many different subsystems. Each subsystem has its own purpose which is independent of other subsystems. But often one subsystem wants to know something from other subsystem(s). There is special mechanism in the Linux kernel which allows to solve this problem partly. The name of this mechanism is - <code>notification chains</code> and its main purpose to provide a way for different subsystems to subscribe on asynchronous events from other subsystems. Note that this mechanism is only for communication inside kernel, but there are other mechanisms for communication between kernel and userspace.</p>
<p>Before we consider <code>notification chains</code> <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> and implementation of this API, let's look at <code>Notification chains</code> mechanism from theoretical side as we did it in other parts of this book. Everything which is related to <code>notification chains</code> mechanism is located in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/notifier.h">include/linux/notifier.h</a> header file and <a href="https://github.com/torvalds/linux/blob/master/kernel/notifier.c">kernel/notifier.c</a> source code file. So let's open them and start to dive.</p>
<h2 id="notification-chains-related-data-structures"><a class="header" href="#notification-chains-related-data-structures">Notification Chains related data structures</a></h2>
<p>Let's start to consider <code>notification chains</code> mechanism from related data structures. As I wrote above, main data structures should be located in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/notifier.h">include/linux/notifier.h</a> header file, so the Linux kernel provides generic API which does not depend on certain architecture. In general, the <code>notification chains</code> mechanism represents a list (that's why it's named <code>chains</code>) of <a href="https://en.wikipedia.org/wiki/Callback_%28computer_programming%29">callback</a> functions which are will be executed when an event will be occurred.</p>
<p>All of these callback functions are represented as <code>notifier_fn_t</code> type in the Linux kernel:</p>
<pre><code class="language-C">typedef	int (*notifier_fn_t)(struct notifier_block *nb, unsigned long action, void *data);
</code></pre>
<p>So we may see that it takes three following arguments:</p>
<ul>
<li><code>nb</code> - is linked list of function pointers (will see it now);</li>
<li><code>action</code> - is type of an event. A notification chain may support multiple events, so we need this parameter to distinguish an event from other events;</li>
<li><code>data</code> - is storage for private information. Actually it allows to provide additional data information about an event.</li>
</ul>
<p>Additionally we may see that <code>notifier_fn_t</code> returns an integer value. This integer value maybe one of:</p>
<ul>
<li><code>NOTIFY_DONE</code> - subscriber does not interested in notification;</li>
<li><code>NOTIFY_OK</code> - notification was processed correctly;</li>
<li><code>NOTIFY_BAD</code> - something went wrong;</li>
<li><code>NOTIFY_STOP</code> - notification is done, but no further callbacks should be called for this event.</li>
</ul>
<p>All of these results defined as macros in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/notifier.h">include/linux/notifier.h</a> header file:</p>
<pre><code class="language-C">#define NOTIFY_DONE		0x0000
#define NOTIFY_OK		0x0001
#define NOTIFY_BAD		(NOTIFY_STOP_MASK|0x0002)
#define NOTIFY_STOP		(NOTIFY_OK|NOTIFY_STOP_MASK)
</code></pre>
<p>Where <code>NOTIFY_STOP_MASK</code> represented by the:</p>
<pre><code class="language-C">#define NOTIFY_STOP_MASK	0x8000
</code></pre>
<p>macro and means that callbacks will not be called during next notifications.</p>
<p>Each part of the Linux kernel which wants to be notified on a certain event will should provide own <code>notifier_fn_t</code> callback function. Main role of the <code>notification chains</code> mechanism is to call certain callbacks when an asynchronous event occurred.</p>
<p>The main building block of the <code>notification chains</code> mechanism is the <code>notifier_block</code> structure:</p>
<pre><code class="language-C">struct notifier_block {
	notifier_fn_t notifier_call;
	struct notifier_block __rcu *next;
	int priority;
};
</code></pre>
<p>which is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/notifier.h">include/linux/notifier.h</a> file. This struct contains pointer to callback function - <code>notifier_call</code>, link to the next notification callback and <code>priority</code> of a callback function as functions with higher priority are executed first.</p>
<p>The Linux kernel provides notification chains of four following types:</p>
<ul>
<li>Blocking notifier chains;</li>
<li>SRCU notifier chains;</li>
<li>Atomic notifier chains;</li>
<li>Raw notifier chains.</li>
</ul>
<p>Let's consider all of these types of notification chains by order:</p>
<p>In the first case for the <code>blocking notifier chains</code>, callbacks will be called/executed in process context. This means that the calls in a notification chain may be blocked.</p>
<p>The second <code>SRCU notifier chains</code> represent alternative form of <code>blocking notifier chains</code>. In the first case, blocking notifier chains uses <code>rw_semaphore</code> synchronization primitive to protect chain links. <code>SRCU</code> notifier chains run in process context too, but uses special form of <a href="https://en.wikipedia.org/wiki/Read-copy-update">RCU</a> mechanism which is permissible to block in an read-side critical section.</p>
<p>In the third case for the <code>atomic notifier chains</code> runs in interrupt or atomic context and protected by <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">spinlock</a> synchronization primitive. The last <code>raw notifier chains</code> provides special type of notifier chains without any locking restrictions on callbacks. This means that protection rests on the shoulders of caller side. It is very useful when we want to protect our chain with very specific locking mechanism.</p>
<p>If we will look at the implementation of the <code>notifier_block</code> structure, we will see that it contains pointer to the <code>next</code> element from a notification chain list, but we have no head. Actually a head of such list is in separate structure depends on type of a notification chain. For example for the <code>blocking notifier chains</code>:</p>
<pre><code class="language-C">struct blocking_notifier_head {
	struct rw_semaphore rwsem;
	struct notifier_block __rcu *head;
};
</code></pre>
<p>or for <code>atomic notification chains</code>:</p>
<pre><code class="language-C">struct atomic_notifier_head {
	spinlock_t lock;
	struct notifier_block __rcu *head;
};
</code></pre>
<p>Now as we know a little about <code>notification chains</code> mechanism let's consider implementation of its API.</p>
<h2 id="notification-chains"><a class="header" href="#notification-chains">Notification Chains</a></h2>
<p>Usually there are two sides in a publish/subscriber mechanisms. One side who wants to get notifications and other side(s) who generates these notifications. We will consider notification chains mechanism from both sides. We will consider <code>blocking notification chains</code> in this part, because of other types of notification chains are similar to it and differ mostly in protection mechanisms.</p>
<p>Before a notification producer is able to produce notification, first of all it should initialize head of a notification chain. For example let's consider notification chains related to kernel <a href="https://en.wikipedia.org/wiki/Loadable_kernel_module">loadable modules</a>. If we will look in the <a href="https://github.com/torvalds/linux/blob/master/kernel/module.c">kernel/module.c</a> source code file, we will see following definition:</p>
<pre><code class="language-C">static BLOCKING_NOTIFIER_HEAD(module_notify_list);
</code></pre>
<p>which defines head for loadable modules blocking notifier chain. The <code>BLOCKING_NOTIFIER_HEAD</code> macro is defined in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/notifier.h">include/linux/notifier.h</a> header file and expands to the following code:</p>
<pre><code class="language-C">#define BLOCKING_INIT_NOTIFIER_HEAD(name) do {	\
		init_rwsem(&amp;(name)-&gt;rwsem);	                            \
		(name)-&gt;head = NULL;		                            \
	} while (0)
</code></pre>
<p>So we may see that it takes name of a name of a head of a blocking notifier chain and initializes read/write <a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-3">semaphore</a> and set head to <code>NULL</code>. Besides the <code>BLOCKING_INIT_NOTIFIER_HEAD</code> macro, the Linux kernel additionally provides <code>ATOMIC_INIT_NOTIFIER_HEAD</code>, <code>RAW_INIT_NOTIFIER_HEAD</code> macros and <code>srcu_init_notifier</code> function for initialization atomic and other types of notification chains.</p>
<p>After initialization of a head of a notification chain, a subsystem which wants to receive notification from the given notification chain should register with certain function which depends on the type of notification. If you will look in the <a href="https://github.com/torvalds/linux/blob/master/include/linux/notifier.h">include/linux/notifier.h</a> header file, you will see following four function for this:</p>
<pre><code class="language-C">extern int atomic_notifier_chain_register(struct atomic_notifier_head *nh,
		struct notifier_block *nb);

extern int blocking_notifier_chain_register(struct blocking_notifier_head *nh,
		struct notifier_block *nb);

extern int raw_notifier_chain_register(struct raw_notifier_head *nh,
		struct notifier_block *nb);

extern int srcu_notifier_chain_register(struct srcu_notifier_head *nh,
		struct notifier_block *nb);
</code></pre>
<p>As I already wrote above, we will cover only blocking notification chains in the part, so let's consider implementation of the <code>blocking_notifier_chain_register</code> function. Implementation of this function is located in the <a href="https://github.com/torvalds/linux/blob/master/kernel/notifier.c">kernel/notifier.c</a> source code file and as we may see the <code>blocking_notifier_chain_register</code> takes two parameters:</p>
<ul>
<li><code>nh</code> - head of a notification chain;</li>
<li><code>nb</code> - notification descriptor.</li>
</ul>
<p>Now let's look at the implementation of the <code>blocking_notifier_chain_register</code> function:</p>
<pre><code class="language-C">int raw_notifier_chain_register(struct raw_notifier_head *nh,
		struct notifier_block *n)
{
	return notifier_chain_register(&amp;nh-&gt;head, n);
}
</code></pre>
<p>As we may see it just returns result of the <code>notifier_chain_register</code> function from the same source code file and as we may understand this function does all job for us. Definition of the <code>notifier_chain_register</code> function looks:</p>
<pre><code class="language-C">int blocking_notifier_chain_register(struct blocking_notifier_head *nh,
		struct notifier_block *n)
{
	int ret;

	if (unlikely(system_state == SYSTEM_BOOTING))
		return notifier_chain_register(&amp;nh-&gt;head, n);

	down_write(&amp;nh-&gt;rwsem);
	ret = notifier_chain_register(&amp;nh-&gt;head, n);
	up_write(&amp;nh-&gt;rwsem);
	return ret;
}
</code></pre>
<p>As we may see implementation of the <code>blocking_notifier_chain_register</code> is pretty simple. First of all there is check which check current system state and if a system in rebooting state we just call the <code>notifier_chain_register</code>. In other way we do the same call of the <code>notifier_chain_register</code> but as you may see this call is protected with read/write semaphores. Now let's look at the implementation of the <code>notifier_chain_register</code> function:</p>
<pre><code class="language-C">static int notifier_chain_register(struct notifier_block **nl,
		struct notifier_block *n)
{
	while ((*nl) != NULL) {
		if (n-&gt;priority &gt; (*nl)-&gt;priority)
			break;
		nl = &amp;((*nl)-&gt;next);
	}
	n-&gt;next = *nl;
	rcu_assign_pointer(*nl, n);
	return 0;
}
</code></pre>
<p>This function just inserts new <code>notifier_block</code> (given by a subsystem which wants to get notifications) to the notification chain list. Besides subscribing on an event, subscriber may unsubscribe from a certain events with the set of <code>unsubscribe</code> functions:</p>
<pre><code class="language-C">extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,
		struct notifier_block *nb);

extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,
		struct notifier_block *nb);

extern int raw_notifier_chain_unregister(struct raw_notifier_head *nh,
		struct notifier_block *nb);

extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,
		struct notifier_block *nb);
</code></pre>
<p>When a producer of notifications wants to notify subscribers about an event, the <code>*.notifier_call_chain</code> function will be called. As you already may guess each type of notification chains provides own function to produce notification:</p>
<pre><code class="language-C">extern int atomic_notifier_call_chain(struct atomic_notifier_head *nh,
		unsigned long val, void *v);

extern int blocking_notifier_call_chain(struct blocking_notifier_head *nh,
		unsigned long val, void *v);

extern int raw_notifier_call_chain(struct raw_notifier_head *nh,
		unsigned long val, void *v);

extern int srcu_notifier_call_chain(struct srcu_notifier_head *nh,
		unsigned long val, void *v);
</code></pre>
<p>Let's consider implementation of the <code>blocking_notifier_call_chain</code> function. This function is defined in the <a href="https://github.com/torvalds/linux/blob/master/kernel/notifier.c">kernel/notifier.c</a> source code file:</p>
<pre><code class="language-C">int blocking_notifier_call_chain(struct blocking_notifier_head *nh,
		unsigned long val, void *v)
{
	return __blocking_notifier_call_chain(nh, val, v, -1, NULL);
}
</code></pre>
<p>and as we may see it just returns result of the <code>__blocking_notifier_call_chain</code> function. As we may see, the <code>blocking_notifer_call_chain</code> takes three parameters:</p>
<ul>
<li><code>nh</code> - head of notification chain list;</li>
<li><code>val</code> - type of a notification;</li>
<li><code>v</code> -  input parameter which may be used by handlers.</li>
</ul>
<p>But the <code>__blocking_notifier_call_chain</code> function takes five parameters:</p>
<pre><code class="language-C">int __blocking_notifier_call_chain(struct blocking_notifier_head *nh,
				   unsigned long val, void *v,
				   int nr_to_call, int *nr_calls)
{
    ...
    ...
    ...
}
</code></pre>
<p>Where <code>nr_to_call</code> and <code>nr_calls</code> are number of notifier functions to be called and number of sent notifications. As you may guess the main goal of the <code>__blocking_notifer_call_chain</code> function and other functions for other notification types is to call callback function when an event occurs. Implementation of the <code>__blocking_notifier_call_chain</code> is pretty simple, it just calls the <code>notifier_call_chain</code> function from the same source code file protected with read/write semaphore:</p>
<pre><code class="language-C">int __blocking_notifier_call_chain(struct blocking_notifier_head *nh,
				   unsigned long val, void *v,
				   int nr_to_call, int *nr_calls)
{
	int ret = NOTIFY_DONE;

	if (rcu_access_pointer(nh-&gt;head)) {
		down_read(&amp;nh-&gt;rwsem);
		ret = notifier_call_chain(&amp;nh-&gt;head, val, v, nr_to_call,
					nr_calls);
		up_read(&amp;nh-&gt;rwsem);
	}
	return ret;
}
</code></pre>
<p>and returns its result. In this case all job is done by the <code>notifier_call_chain</code> function. Main purpose of this function is to inform registered notifiers about an asynchronous event:</p>
<pre><code class="language-C">static int notifier_call_chain(struct notifier_block **nl,
			       unsigned long val, void *v,
			       int nr_to_call, int *nr_calls)
{
    ...
    ...
    ...
    ret = nb-&gt;notifier_call(nb, val, v);
    ...
    ...
    ...
    return ret;
}
</code></pre>
<p>That's all. In general all looks pretty simple.</p>
<p>Now let's consider on a simple example related to <a href="https://en.wikipedia.org/wiki/Loadable_kernel_module">loadable modules</a>. If we will look in the <a href="https://github.com/torvalds/linux/blob/master/kernel/module.c">kernel/module.c</a>. As we already saw in this part, there is:</p>
<pre><code class="language-C">static BLOCKING_NOTIFIER_HEAD(module_notify_list);
</code></pre>
<p>definition of the <code>module_notify_list</code> in the <a href="https://github.com/torvalds/linux/blob/master/kernel/module.c">kernel/module.c</a> source code file. This definition determines head of list of blocking notifier chains related to kernel modules. There are at least three following events:</p>
<ul>
<li>MODULE_STATE_LIVE</li>
<li>MODULE_STATE_COMING</li>
<li>MODULE_STATE_GOING</li>
</ul>
<p>in which maybe interested some subsystems of the Linux kernel. For example tracing of kernel modules states. Instead of direct call of the <code>atomic_notifier_chain_register</code>, <code>blocking_notifier_chain_register</code> and etc., most notification chains come with a set of wrappers used to register to them. Registration on these modules events is going with the help of such wrapper:</p>
<pre><code class="language-C">int register_module_notifier(struct notifier_block *nb)
{
	return blocking_notifier_chain_register(&amp;module_notify_list, nb);
}
</code></pre>
<p>If we will look in the <a href="https://github.com/torvalds/linux/blob/master/kernel/tracepoint.c">kernel/tracepoint.c</a> source code file, we will see such registration during initialization of <a href="https://www.kernel.org/doc/Documentation/trace/tracepoints.txt">tracepoints</a>:</p>
<pre><code class="language-C">static __init int init_tracepoints(void)
{
	int ret;

	ret = register_module_notifier(&amp;tracepoint_module_nb);
	if (ret)
		pr_warn(&quot;Failed to register tracepoint module enter notifier\n&quot;);

	return ret;
}
</code></pre>
<p>Where <code>tracepoint_module_nb</code> provides callback function:</p>
<pre><code class="language-C">static struct notifier_block tracepoint_module_nb = {
	.notifier_call = tracepoint_module_notify,
	.priority = 0,
};
</code></pre>
<p>When one of the <code>MODULE_STATE_LIVE</code>, <code>MODULE_STATE_COMING</code> or <code>MODULE_STATE_GOING</code> events occurred. For example the <code>MODULE_STATE_LIVE</code> the <code>MODULE_STATE_COMING</code> notifications will be sent during execution of the <a href="http://man7.org/linux/man-pages/man2/init_module.2.html">init_module</a> <a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-1">system call</a>. Or for example <code>MODULE_STATE_GOING</code> will be sent during execution of the <a href="http://man7.org/linux/man-pages/man2/delete_module.2.html">delete_module</a> <code>system call</code>:</p>
<pre><code class="language-C">SYSCALL_DEFINE2(delete_module, const char __user *, name_user,
		unsigned int, flags)
{
    ...
    ...
    ...
    blocking_notifier_call_chain(&amp;module_notify_list,
				     MODULE_STATE_GOING, mod);
    ...
    ...
    ...
}
</code></pre>
<p>Thus when one of these system call will be called from userspace, the Linux kernel will send certain notification depending on a system call and the <code>tracepoint_module_notify</code> callback function will be called.</p>
<p>That's all.</p>
<h2 id="links-51"><a class="header" href="#links-51">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C programming language</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a></li>
<li><a href="https://en.wikipedia.org/wiki/Callback_%28computer_programming%29">callback</a></li>
<li><a href="https://en.wikipedia.org/wiki/Read-copy-update">RCU</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-1">spinlock</a></li>
<li><a href="https://en.wikipedia.org/wiki/Loadable_kernel_module">loadable modules</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syncprim/linux-sync-3">semaphore</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/trace/tracepoints.txt">tracepoints</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-1">system call</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/init_module.2.html">init_module system call</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/delete_module.2.html">delete_module</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-3">previous part</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures-in-the-linux-kernel"><a class="header" href="#data-structures-in-the-linux-kernel">Data Structures in the Linux Kernel</a></h1>
<p>Linux kernel provides different implementations of data structures like doubly linked list, B+ tree, priority heap and many many more.</p>
<p>This part considers the following data structures and algorithms:</p>
<ul>
<li><a href="DataStructures/linux-datastructures-1.html">Doubly linked list</a></li>
<li><a href="DataStructures/linux-datastructures-2.html">Radix tree</a></li>
<li><a href="DataStructures/linux-datastructures-3.html">Bit arrays</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures-in-the-linux-kernel-1"><a class="header" href="#data-structures-in-the-linux-kernel-1">Data Structures in the Linux Kernel</a></h1>
<h2 id="doubly-linked-list"><a class="header" href="#doubly-linked-list">Doubly linked list</a></h2>
<p>Linux kernel provides its own implementation of doubly linked list, which you can find in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/list.h">include/linux/list.h</a>. We will start <code>Data Structures in the Linux kernel</code> from the doubly linked list data structure. Why? Because it is very popular in the kernel, just try to <a href="http://lxr.free-electrons.com/ident?i=list_head">search</a></p>
<p>First of all, let's look on the main structure in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/types.h">include/linux/types.h</a>:</p>
<pre><code class="language-C">struct list_head {
	struct list_head *next, *prev;
};
</code></pre>
<p>You can note that it is different from many implementations of doubly linked list which you have seen. For example, this doubly linked list structure from the <a href="http://www.gnu.org/software/libc/">glib</a> library looks like :</p>
<pre><code class="language-C">struct GList {
  gpointer data;
  GList *next;
  GList *prev;
};
</code></pre>
<p>Usually a linked list structure contains a pointer to the item. The implementation of linked list in Linux kernel does not. So the main question is - <code>where does the list store the data?</code>. The actual implementation of linked list in the kernel is - <code>Intrusive list</code>. An intrusive linked list does not contain data in its nodes - A node just contains pointers to the next and previous node and list nodes part of the data that are added to the list. This makes the data structure generic, so it does not care about entry data type anymore.</p>
<p>For example:</p>
<pre><code class="language-C">struct nmi_desc {
    spinlock_t lock;
    struct list_head head;
};
</code></pre>
<p>Let's look at some examples to understand how <code>list_head</code> is used in the kernel. As I already wrote about, there are many, really many different places where lists are used in the kernel. Let's look for an example in miscellaneous character drivers. Misc character drivers API from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/drivers/char/misc.c">drivers/char/misc.c</a> is used for writing small drivers for handling simple hardware or virtual devices. Those drivers share same major number:</p>
<pre><code class="language-C">#define MISC_MAJOR              10
</code></pre>
<p>but have their own minor number. For example you can see it with:</p>
<pre><code>ls -l /dev |  grep 10
crw-------   1 root root     10, 235 Mar 21 12:01 autofs
drwxr-xr-x  10 root root         200 Mar 21 12:01 cpu
crw-------   1 root root     10,  62 Mar 21 12:01 cpu_dma_latency
crw-------   1 root root     10, 203 Mar 21 12:01 cuse
drwxr-xr-x   2 root root         100 Mar 21 12:01 dri
crw-rw-rw-   1 root root     10, 229 Mar 21 12:01 fuse
crw-------   1 root root     10, 228 Mar 21 12:01 hpet
crw-------   1 root root     10, 183 Mar 21 12:01 hwrng
crw-rw----+  1 root kvm      10, 232 Mar 21 12:01 kvm
crw-rw----   1 root disk     10, 237 Mar 21 12:01 loop-control
crw-------   1 root root     10, 227 Mar 21 12:01 mcelog
crw-------   1 root root     10,  59 Mar 21 12:01 memory_bandwidth
crw-------   1 root root     10,  61 Mar 21 12:01 network_latency
crw-------   1 root root     10,  60 Mar 21 12:01 network_throughput
crw-r-----   1 root kmem     10, 144 Mar 21 12:01 nvram
brw-rw----   1 root disk      1,  10 Mar 21 12:01 ram10
crw--w----   1 root tty       4,  10 Mar 21 12:01 tty10
crw-rw----   1 root dialout   4,  74 Mar 21 12:01 ttyS10
crw-------   1 root root     10,  63 Mar 21 12:01 vga_arbiter
crw-------   1 root root     10, 137 Mar 21 12:01 vhci
</code></pre>
<p>Now let's have a close look at how lists are used in the misc device drivers. First of all, let's look on <code>miscdevice</code> structure:</p>
<pre><code class="language-C">struct miscdevice
{
      int minor;
      const char *name;
      const struct file_operations *fops;
      struct list_head list;
      struct device *parent;
      struct device *this_device;
      const char *nodename;
      mode_t mode;
};
</code></pre>
<p>We can see the fourth field in the <code>miscdevice</code> structure - <code>list</code> which is a list of registered devices. In the beginning of the source code file we can see the definition of misc_list:</p>
<pre><code class="language-C">static LIST_HEAD(misc_list);
</code></pre>
<p>which expands to the definition of variables with <code>list_head</code> type:</p>
<pre><code class="language-C">#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)
</code></pre>
<p>and initializes it with the <code>LIST_HEAD_INIT</code> macro, which sets previous and next entries with the address of variable - name:</p>
<pre><code class="language-C">#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }
</code></pre>
<p>Now let's look on the <code>misc_register</code> function which registers a miscellaneous device. At the start it initializes <code>miscdevice-&gt;list</code> with the <code>INIT_LIST_HEAD</code> function:</p>
<pre><code class="language-C">INIT_LIST_HEAD(&amp;misc-&gt;list);
</code></pre>
<p>which does the same as the <code>LIST_HEAD_INIT</code> macro:</p>
<pre><code class="language-C">static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list-&gt;next = list;
	list-&gt;prev = list;
}
</code></pre>
<p>In the next step after a device is created by the <code>device_create</code> function, we add it to the miscellaneous devices list with:</p>
<pre><code>list_add(&amp;misc-&gt;list, &amp;misc_list);
</code></pre>
<p>Kernel <code>list.h</code> provides this API for the addition of a new entry to the list. Let's look at its implementation:</p>
<pre><code class="language-C">static inline void list_add(struct list_head *new, struct list_head *head)
{
	__list_add(new, head, head-&gt;next);
}
</code></pre>
<p>It just calls internal function <code>__list_add</code> with the 3 given parameters:</p>
<ul>
<li>new  - new entry.</li>
<li>head - list head after which the new item will be inserted.</li>
<li>head-&gt;next - next item after list head.</li>
</ul>
<p>Implementation of the <code>__list_add</code> is pretty simple:</p>
<pre><code class="language-C">static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next-&gt;prev = new;
	new-&gt;next = next;
	new-&gt;prev = prev;
	prev-&gt;next = new;
}
</code></pre>
<p>Here we add a new item between <code>prev</code> and <code>next</code>. So <code>misc</code> list which we defined at the start with the <code>LIST_HEAD_INIT</code> macro will contain previous and next pointers to the <code>miscdevice-&gt;list</code>.</p>
<p>There is still one question: how to get list's entry. There is a special macro:</p>
<pre><code class="language-C">#define list_entry(ptr, type, member) \
	container_of(ptr, type, member)
</code></pre>
<p>which gets three parameters:</p>
<ul>
<li>ptr - the structure list_head pointer;</li>
<li>type - structure type;</li>
<li>member - the name of the list_head within the structure;</li>
</ul>
<p>For example:</p>
<pre><code class="language-C">const struct miscdevice *p = list_entry(v, struct miscdevice, list)
</code></pre>
<p>After this we can access to any <code>miscdevice</code> field with <code>p-&gt;minor</code> or <code>p-&gt;name</code> and etc... Let's look on the <code>list_entry</code> implementation:</p>
<pre><code class="language-C">#define list_entry(ptr, type, member) \
	container_of(ptr, type, member)
</code></pre>
<p>As we can see it just calls <code>container_of</code> macro with the same arguments. At first sight, the <code>container_of</code> looks strange:</p>
<pre><code class="language-C">#define container_of(ptr, type, member) ({                      \
    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \
    (type *)( (char *)__mptr - offsetof(type,member) );})
</code></pre>
<p>First of all you can note that it consists of two expressions in curly brackets. The compiler will evaluate the whole block in the curly braces and use the value of the last expression.</p>
<p>For example:</p>
<pre><code>#include &lt;stdio.h&gt;

int main() {
	int i = 0;
	printf(&quot;i = %d\n&quot;, ({++i; ++i;}));
	return 0;
}
</code></pre>
<p>will print <code>2</code>.</p>
<p>The next point is <code>typeof</code>, it's simple. As you can understand from its name, it just returns the type of the given variable. When I first saw the implementation of the <code>container_of</code> macro, the strangest thing I found was the zero in the <code>((type *)0)</code> expression. Actually this pointer magic calculates the offset of the given field from the address of the structure, but as we have <code>0</code> here, it will be just a zero offset along with the field width. Let's look at a simple example:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

struct s {
        int field1;
        char field2;
		char field3;
};

int main() {
	printf(&quot;%p\n&quot;, &amp;((struct s*)0)-&gt;field3);
	return 0;
}
</code></pre>
<p>will print <code>0x5</code>.</p>
<p>The next <code>offsetof</code> macro calculates offset from the beginning of the structure to the given structure's field. Its implementation is very similar to the previous code:</p>
<pre><code class="language-C">#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
</code></pre>
<p>Let's summarize all about <code>container_of</code> macro. The <code>container_of</code> macro returns the address of the structure by the given address of the structure's field with <code>list_head</code> type, the name of the structure field with <code>list_head</code> type and type of the container structure. At the first line this macro declares the <code>__mptr</code> pointer which points to the field of the structure that <code>ptr</code> points to and assigns <code>ptr</code> to it. Now <code>ptr</code> and <code>__mptr</code> point to the same address. Technically we don't need this line but it's useful for type checking. The first line ensures that the given structure (<code>type</code> parameter) has a member called <code>member</code>. In the second line it calculates offset of the field from the structure with the <code>offsetof</code> macro and subtracts it from the structure address. That's all.</p>
<p>Of course <code>list_add</code> and <code>list_entry</code> is not the only functions which <code>&lt;linux/list.h&gt;</code> provides. Implementation of the doubly linked list provides the following API:</p>
<ul>
<li>list_add</li>
<li>list_add_tail</li>
<li>list_del</li>
<li>list_replace</li>
<li>list_move</li>
<li>list_is_last</li>
<li>list_empty</li>
<li>list_cut_position</li>
<li>list_splice</li>
<li>list_for_each</li>
<li>list_for_each_entry</li>
</ul>
<p>and many more.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures-in-the-linux-kernel-2"><a class="header" href="#data-structures-in-the-linux-kernel-2">Data Structures in the Linux Kernel</a></h1>
<h2 id="radix-tree"><a class="header" href="#radix-tree">Radix tree</a></h2>
<p>As you already know Linux kernel provides many different libraries and functions which implement different data structures and algorithms. In this part we will consider one of these data structures - <a href="http://en.wikipedia.org/wiki/Radix_tree">Radix tree</a>. There are two files which are related to <code>radix tree</code> implementation and API in the linux kernel:</p>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/radix-tree.h">include/linux/radix-tree.h</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/lib/radix-tree.c">lib/radix-tree.c</a></li>
</ul>
<p>Lets talk about what a <code>radix tree</code> is. Radix tree is a <code>compressed trie</code> where a <a href="http://en.wikipedia.org/wiki/Trie">trie</a> is a data structure which implements an interface of an associative array and allows to store values as <code>key-value</code>. The keys are usually strings, but any data type can be used. A trie is different from an <code>n-tree</code> because of its nodes. Nodes of a trie do not store keys; instead, a node of a trie stores single character labels. The key which is related to a given node is derived by traversing from the root of the tree to this node. For example:</p>
<pre><code>               +-----------+
               |           |
               |    &quot; &quot;    |
               |           |
        +------+-----------+------+
        |                         |
        |                         |
   +----v------+            +-----v-----+
   |           |            |           |
   |    g      |            |     c     |
   |           |            |           |
   +-----------+            +-----------+
        |                         |
        |                         |
   +----v------+            +-----v-----+
   |           |            |           |
   |    o      |            |     a     |
   |           |            |           |
   +-----------+            +-----------+
                                  |
                                  |
                            +-----v-----+
                            |           |
                            |     t     |
                            |           |
                            +-----------+
</code></pre>
<p>So in this example, we can see the <code>trie</code> with keys, <code>go</code> and <code>cat</code>. The compressed trie or <code>radix tree</code> differs from <code>trie</code> in that all intermediates nodes which have only one child are removed.</p>
<p>Radix tree in Linux kernel is the data structure which maps values to integer keys. It is represented by the following structures from the file <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/radix-tree.h">include/linux/radix-tree.h</a>:</p>
<pre><code class="language-C">struct radix_tree_root {
         unsigned int            height;
         gfp_t                   gfp_mask;
         struct radix_tree_node  __rcu *rnode;
};
</code></pre>
<p>This structure presents the root of a radix tree and contains three fields:</p>
<ul>
<li><code>height</code>   - height of the tree;</li>
<li><code>gfp_mask</code> - tells how memory allocations will be performed;</li>
<li><code>rnode</code>    - pointer to the child node.</li>
</ul>
<p>The first field we will discuss is <code>gfp_mask</code>:</p>
<p>Low-level kernel memory allocation functions take a set of flags as - <code>gfp_mask</code>, which describes how that allocation is to be performed. These <code>GFP_</code> flags which control the allocation process can have following values: (<code>GFP_NOIO</code> flag) means allocation can block but must not initiate disk I/O; (<code>__GFP_HIGHMEM</code> flag) means either ZONE_HIGHMEM or ZONE_NORMAL memory can be used; (<code>GFP_ATOMIC</code> flag) means the allocation is high-priority and must not sleep, etc.</p>
<ul>
<li><code>GFP_NOIO</code> - allocation can block but must not initiate disk I/O;</li>
<li><code>__GFP_HIGHMEM</code> - either ZONE_HIGHMEM or ZONE_NORMAL can be used;</li>
<li><code>GFP_ATOMIC</code> - allocation process is high-priority and must not sleep;</li>
</ul>
<p>etc.</p>
<p>The next field is <code>rnode</code>:</p>
<pre><code class="language-C">struct radix_tree_node {
        unsigned int    path;
        unsigned int    count;
        union {
                struct {
                        struct radix_tree_node *parent;
                        void *private_data;
                };
                struct rcu_head rcu_head;
        };
        /* For tree user */
        struct list_head private_list;
        void __rcu      *slots[RADIX_TREE_MAP_SIZE];
        unsigned long   tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS];
};
</code></pre>
<p>This structure contains information about the offset in a parent and height from the bottom, count of the child nodes and fields for accessing and freeing a node. This fields are described below:</p>
<ul>
<li><code>path</code> - offset in parent &amp; height from the bottom;</li>
<li><code>count</code> - count of the child nodes;</li>
<li><code>parent</code> - pointer to the parent node;</li>
<li><code>private_data</code> - used by the user of a tree;</li>
<li><code>rcu_head</code> - used for freeing a node;</li>
<li><code>private_list</code> - used by the user of a tree;</li>
</ul>
<p>The two last fields of the <code>radix_tree_node</code> - <code>tags</code> and <code>slots</code> are important and interesting. Every node can contains a set of slots which are store pointers to the data. Empty slots in the Linux kernel radix tree implementation store <code>NULL</code>. Radix trees in the linux kernel also supports tags which are associated with the <code>tags</code> fields in the <code>radix_tree_node</code> structure. Tags allow individual bits to be set on records which are stored in the radix tree.</p>
<p>Now that we know about radix tree structure, it is time to look on its API.</p>
<h2 id="linux-kernel-radix-tree-api"><a class="header" href="#linux-kernel-radix-tree-api">Linux kernel radix tree API</a></h2>
<p>We start from the data structure initialization. There are two ways to initialize a new radix tree. The first is to use <code>RADIX_TREE</code> macro:</p>
<pre><code class="language-C">RADIX_TREE(name, gfp_mask);
</code></pre>
<p>As you can see we pass the <code>name</code> parameter, so with the <code>RADIX_TREE</code> macro we can define and initialize radix tree with the given name. Implementation of the <code>RADIX_TREE</code> is easy:</p>
<pre><code class="language-C">#define RADIX_TREE(name, mask) \
         struct radix_tree_root name = RADIX_TREE_INIT(mask)

#define RADIX_TREE_INIT(mask)   { \
        .height = 0,              \
        .gfp_mask = (mask),       \
        .rnode = NULL,            \
}
</code></pre>
<p>At the beginning of the <code>RADIX_TREE</code> macro we define instance of the <code>radix_tree_root</code> structure with the given name and call <code>RADIX_TREE_INIT</code> macro with the given mask. The <code>RADIX_TREE_INIT</code> macro just initializes <code>radix_tree_root</code> structure with the default values and the given mask.</p>
<p>The second way is to define <code>radix_tree_root</code> structure by hand and pass it with mask to the <code>INIT_RADIX_TREE</code> macro:</p>
<pre><code class="language-C">struct radix_tree_root my_radix_tree;
INIT_RADIX_TREE(my_tree, gfp_mask_for_my_radix_tree);
</code></pre>
<p>where:</p>
<pre><code class="language-C">#define INIT_RADIX_TREE(root, mask)  \
do {                                 \
        (root)-&gt;height = 0;          \
        (root)-&gt;gfp_mask = (mask);   \
        (root)-&gt;rnode = NULL;        \
} while (0)
</code></pre>
<p>makes the same initialization with default values as it does <code>RADIX_TREE_INIT</code> macro.</p>
<p>The next are two functions for inserting and deleting records to/from a radix tree:</p>
<ul>
<li><code>radix_tree_insert</code>;</li>
<li><code>radix_tree_delete</code>;</li>
</ul>
<p>The first <code>radix_tree_insert</code> function takes three parameters:</p>
<ul>
<li>root of a radix tree;</li>
<li>index key;</li>
<li>data to insert;</li>
</ul>
<p>The <code>radix_tree_delete</code> function takes the same set of parameters as the <code>radix_tree_insert</code>, but without data.</p>
<p>Searching through a radix tree is implemented in three ways:</p>
<ul>
<li><code>radix_tree_lookup</code>;</li>
<li><code>radix_tree_gang_lookup</code>;</li>
<li><code>radix_tree_lookup_slot</code>.</li>
</ul>
<p>The first <code>radix_tree_lookup</code> function takes two parameters:</p>
<ul>
<li>root of a radix tree;</li>
<li>index key;</li>
</ul>
<p>This function tries to find the given key in the tree and return the record associated with this key. The second <code>radix_tree_gang_lookup</code> function have the following signature</p>
<pre><code class="language-C">unsigned int radix_tree_gang_lookup(struct radix_tree_root *root,
                                    void **results,
                                    unsigned long first_index,
                                    unsigned int max_items);
</code></pre>
<p>and returns number of records, sorted by the keys, starting from the first index. Number of the returned records will not be greater than <code>max_items</code> value.</p>
<p>And the last <code>radix_tree_lookup_slot</code> function will return the slot which will contain the data.</p>
<h2 id="links-52"><a class="header" href="#links-52">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Radix_tree">Radix tree</a></li>
<li><a href="http://en.wikipedia.org/wiki/Trie">Trie</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures-in-the-linux-kernel-3"><a class="header" href="#data-structures-in-the-linux-kernel-3">Data Structures in the Linux Kernel</a></h1>
<h2 id="bit-arrays-and-bit-operations-in-the-linux-kernel"><a class="header" href="#bit-arrays-and-bit-operations-in-the-linux-kernel">Bit arrays and bit operations in the Linux kernel</a></h2>
<p>Besides different <a href="https://en.wikipedia.org/wiki/Linked_data_structure">linked</a> and <a href="https://en.wikipedia.org/wiki/Tree_%28data_structure%29">tree</a> based data structures, the Linux kernel provides <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> for <a href="https://en.wikipedia.org/wiki/Bit_array">bit arrays</a> or <code>bitmap</code>. Bit arrays are heavily used in the Linux kernel and following source code files contain common <code>API</code> for work with such structures:</p>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/lib/bitmap.c">lib/bitmap.c</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitmap.h">include/linux/bitmap.h</a></li>
</ul>
<p>Besides these two files, there is also architecture-specific header file which provides optimized bit operations for certain architecture. We consider <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture, so in our case it will be:</p>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a></li>
</ul>
<p>header file. As I just wrote above, the <code>bitmap</code> is heavily used in the Linux kernel. For example a <code>bit array</code> is used to store set of online/offline processors for systems which support <a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">hot-plug</a> CPU (more about this you can read in the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumasks</a> part), a <code>bit array</code> stores set of allocated <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQs</a> during initialization of the Linux kernel and etc.</p>
<p>So, the main goal of this part is to see how <code>bit arrays</code> are implemented in the Linux kernel. Let's start.</p>
<h1 id="declaration-of-bit-array"><a class="header" href="#declaration-of-bit-array">Declaration of bit array</a></h1>
<p>Before we will look on <code>API</code> for bitmaps manipulation, we must know how to declare it in the Linux kernel. There are two common method to declare own bit array. The first simple way to declare a bit array is to array of <code>unsigned long</code>. For example:</p>
<pre><code class="language-C">unsigned long my_bitmap[8]
</code></pre>
<p>The second way is to use the <code>DECLARE_BITMAP</code> macro which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/types.h">include/linux/types.h</a> header file:</p>
<pre><code class="language-C">#define DECLARE_BITMAP(name,bits) \
    unsigned long name[BITS_TO_LONGS(bits)]
</code></pre>
<p>We can see that <code>DECLARE_BITMAP</code> macro takes two parameters:</p>
<ul>
<li><code>name</code> - name of bitmap;</li>
<li><code>bits</code> - amount of bits in bitmap;</li>
</ul>
<p>and just expands to the definition of <code>unsigned long</code> array with <code>BITS_TO_LONGS(bits)</code> elements, where the <code>BITS_TO_LONGS</code> macro converts a given number of bits to number of <code>longs</code> or in other words it calculates how many <code>8</code> byte elements in <code>bits</code>:</p>
<pre><code class="language-C">#define BITS_PER_BYTE           8
#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
#define BITS_TO_LONGS(nr)       DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
</code></pre>
<p>So, for example <code>DECLARE_BITMAP(my_bitmap, 64)</code> will produce:</p>
<pre><code class="language-python">&gt;&gt;&gt; (((64) + (64) - 1) / (64))
1
</code></pre>
<p>and:</p>
<pre><code class="language-C">unsigned long my_bitmap[1];
</code></pre>
<p>After we are able to declare a bit array, we can start to use it.</p>
<h1 id="architecture-specific-bit-operations"><a class="header" href="#architecture-specific-bit-operations">Architecture-specific bit operations</a></h1>
<p>We already saw above a couple of source code and header files which provide <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> for manipulation of bit arrays. The most important and widely used API of bit arrays is architecture-specific and located as we already know in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> header file.</p>
<p>First of all let's look at the two most important functions:</p>
<ul>
<li><code>set_bit</code>;</li>
<li><code>clear_bit</code>.</li>
</ul>
<p>I think that there is no need to explain what these function do. This is already must be clear from their name. Let's look on their implementation. If you will look into the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> header file, you will note that each of these functions represented by two variants: <a href="https://en.wikipedia.org/wiki/Linearizability">atomic</a> and not. Before we will start to dive into implementations of these functions, first of all we must to know a little about <code>atomic</code> operations.</p>
<p>In simple words atomic operations guarantees that two or more operations will not be performed on the same data concurrently. The <code>x86</code> architecture provides a set of atomic instructions, for example <a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">xchg</a> instruction, <a href="http://x86.renejeschke.de/html/file_module_x86_id_41.html">cmpxchg</a> instruction and etc. Besides atomic instructions, some of non-atomic instructions can be made atomic with the help of the <a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">lock</a> instruction. It is enough to know about atomic operations for now, so we can begin to consider implementation of <code>set_bit</code> and <code>clear_bit</code> functions.</p>
<p>First of all, let's start to consider <code>non-atomic</code> variants of this function. Names of non-atomic <code>set_bit</code> and <code>clear_bit</code> starts with double underscore. As we already know, all of these functions are defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> header file and the first function is <code>__set_bit</code>:</p>
<pre><code class="language-C">static inline void __set_bit(long nr, volatile unsigned long *addr)
{
	asm volatile(&quot;bts %1,%0&quot; : ADDR : &quot;Ir&quot; (nr) : &quot;memory&quot;);
}
</code></pre>
<p>As we can see it takes two arguments:</p>
<ul>
<li><code>nr</code> - number of bit in a bit array.</li>
<li><code>addr</code> - address of a bit array where we need to set bit.</li>
</ul>
<p>Note that the <code>addr</code> parameter is defined with <code>volatile</code> keyword which tells to compiler that value maybe changed by the given address. The implementation of the <code>__set_bit</code> is pretty easy. As we can see, it just contains one line of <a href="https://en.wikipedia.org/wiki/Inline_assembler">inline assembler</a> code. In our case we are using the <a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">bts</a> instruction which selects a bit which is specified with the first operand (<code>nr</code> in our case) from the bit array, stores the value of the selected bit in the <a href="https://en.wikipedia.org/wiki/FLAGS_register">CF</a> flags register and set this bit.</p>
<p>Note that we can see usage of the <code>nr</code>, but there is <code>addr</code> here. You already might guess that the secret is in <code>ADDR</code>. The <code>ADDR</code> is the macro which is defined in the same header code file and expands to the string which contains value of the given address and <code>+m</code> constraint:</p>
<pre><code class="language-C">#define ADDR				BITOP_ADDR(addr)
#define BITOP_ADDR(x) &quot;+m&quot; (*(volatile long *) (x))
</code></pre>
<p>Besides the <code>+m</code>, we can see other constraints in the <code>__set_bit</code> function. Let's look on they and try to understand what do they mean:</p>
<ul>
<li><code>+m</code> - represents memory operand where <code>+</code> tells that the given operand will be input and output operand;</li>
<li><code>I</code> - represents integer constant;</li>
<li><code>r</code> - represents register operand</li>
</ul>
<p>Besides these constraint, we also can see - the <code>memory</code> keyword which tells compiler that this code will change value in memory. That's all. Now let's look at the same function but at <code>atomic</code> variant. It looks more complex that its <code>non-atomic</code> variant:</p>
<pre><code class="language-C">static __always_inline void
set_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX &quot;orb %1,%0&quot;
			: CONST_MASK_ADDR(nr, addr)
			: &quot;iq&quot; ((u8)CONST_MASK(nr))
			: &quot;memory&quot;);
	} else {
		asm volatile(LOCK_PREFIX &quot;bts %1,%0&quot;
			: BITOP_ADDR(addr) : &quot;Ir&quot; (nr) : &quot;memory&quot;);
	}
}
</code></pre>
<p>First of all note that this function takes the same set of parameters that <code>__set_bit</code>, but additionally marked with the <code>__always_inline</code> attribute. The <code>__always_inline</code> is macro which defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/compiler-gcc.h">include/linux/compiler-gcc.h</a> and just expands to the <code>always_inline</code> attribute:</p>
<pre><code class="language-C">#define __always_inline inline __attribute__((always_inline))
</code></pre>
<p>which means that this function will be always inlined to reduce size of the Linux kernel image. Now let's try to understand implementation of the <code>set_bit</code> function. First of all we check a given number of bit at the beginning of the <code>set_bit</code> function. The <code>IS_IMMEDIATE</code> macro defined in the same <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">header</a> file and expands to the call of the builtin <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a> function:</p>
<pre><code class="language-C">#define IS_IMMEDIATE(nr)		(__builtin_constant_p(nr))
</code></pre>
<p>The <code>__builtin_constant_p</code> builtin function returns <code>1</code> if the given parameter is known to be constant at compile-time and returns <code>0</code> in other case. We do not need to use slow <code>bts</code> instruction to set bit if the given number of bit is known in compile time constant. We can just apply <a href="https://en.wikipedia.org/wiki/Bitwise_operation#OR">bitwise or</a> for byte from the give address which contains given bit and masked number of bits where high bit is <code>1</code> and other is zero. In other case if the given number of bit is not known constant at compile-time, we do the same as we did in the <code>__set_bit</code> function. The <code>CONST_MASK_ADDR</code> macro:</p>
<pre><code class="language-C">#define CONST_MASK_ADDR(nr, addr)	BITOP_ADDR((void *)(addr) + ((nr)&gt;&gt;3))
</code></pre>
<p>expands to the given address with offset to the byte which contains a given bit. For example we have address <code>0x1000</code> and the number of bit is <code>0x9</code>. So, as <code>0x9</code> is <code>one byte + one bit</code> our address with be <code>addr + 1</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; hex(0x1000 + (0x9 &gt;&gt; 3))
'0x1001'
</code></pre>
<p>The <code>CONST_MASK</code> macro represents our given number of bit as byte where high bit is <code>1</code> and other bits are <code>0</code>:</p>
<pre><code class="language-C">#define CONST_MASK(nr)			(1 &lt;&lt; ((nr) &amp; 7))
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; bin(1 &lt;&lt; (0x9 &amp; 7))
'0b10'
</code></pre>
<p>In the end we just apply bitwise <code>or</code> for these values. So, for example if our address will be <code>0x4097</code> and we need to set <code>0x9</code> bit:</p>
<pre><code class="language-python">&gt;&gt;&gt; bin(0x4097)
'0b100000010010111'
&gt;&gt;&gt; bin((0x4097 &gt;&gt; 0x9) | (1 &lt;&lt; (0x9 &amp; 7)))
'0b100010'
</code></pre>
<p>the <code>ninth</code> bit will be set.</p>
<p>Note that all of these operations are marked with <code>LOCK_PREFIX</code> which is expands to the <a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">lock</a> instruction which guarantees atomicity of this operation.</p>
<p>As we already know, besides the <code>set_bit</code> and <code>__set_bit</code> operations, the Linux kernel provides two inverse functions to clear bit in atomic and non-atomic context. They are <code>clear_bit</code> and <code>__clear_bit</code>. Both of these functions are defined in the same <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">header file</a> and takes the same set of arguments. But not only arguments are similar. Generally these functions are very similar on the <code>set_bit</code> and <code>__set_bit</code>. Let's look on the implementation of the non-atomic <code>__clear_bit</code> function:</p>
<pre><code class="language-C">static inline void __clear_bit(long nr, volatile unsigned long *addr)
{
	asm volatile(&quot;btr %1,%0&quot; : ADDR : &quot;Ir&quot; (nr));
}
</code></pre>
<p>Yes. As we see, it takes the same set of arguments and contains very similar block of inline assembler. It just uses the <a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">btr</a> instruction instead of <code>bts</code>. As we can understand form the function's name, it clears a given bit by the given address. The <code>btr</code> instruction acts like <code>bts</code>. This instruction also selects a given bit which is specified in the first operand, stores its value in the <code>CF</code> flag register and clears this bit in the given bit array which is specified with second operand.</p>
<p>The atomic variant of the <code>__clear_bit</code> is <code>clear_bit</code>:</p>
<pre><code class="language-C">static __always_inline void
clear_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX &quot;andb %1,%0&quot;
			: CONST_MASK_ADDR(nr, addr)
			: &quot;iq&quot; ((u8)~CONST_MASK(nr)));
	} else {
		asm volatile(LOCK_PREFIX &quot;btr %1,%0&quot;
			: BITOP_ADDR(addr)
			: &quot;Ir&quot; (nr));
	}
}
</code></pre>
<p>and as we can see it is very similar on <code>set_bit</code> and just contains two differences. The first difference it uses <code>btr</code> instruction to clear bit when the <code>set_bit</code> uses <code>bts</code> instruction to set bit. The second difference it uses negated mask and <code>and</code> instruction to clear bit in the given byte when the <code>set_bit</code> uses <code>or</code> instruction.</p>
<p>That's all. Now we can set and clear bit in any bit array and and we can go to other operations on bitmasks.</p>
<p>Most widely used operations on a bit arrays are set and clear bit in a bit array in the Linux kernel. But besides this operations it is useful to do additional operations on a bit array. Yet another widely used operation in the Linux kernel - is to know if a given bit is set or not in a bit array. We can achieve this with the help of the <code>test_bit</code> macro. This macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> header file and expands to the call of the <code>constant_test_bit</code> or <code>variable_test_bit</code> depending on bit number:</p>
<pre><code class="language-C">#define test_bit(nr, addr)			\
	(__builtin_constant_p((nr))                 \
	 ? constant_test_bit((nr), (addr))	        \
	 : variable_test_bit((nr), (addr)))
</code></pre>
<p>So, if the <code>nr</code> is known in compile time constant, the <code>test_bit</code> will be expanded to the call of the <code>constant_test_bit</code> function or <code>variable_test_bit</code> in other case. Now let's look at implementations of these functions. Let's start from the <code>variable_test_bit</code>:</p>
<pre><code class="language-C">static inline int variable_test_bit(long nr, volatile const unsigned long *addr)
{
	int oldbit;

	asm volatile(&quot;bt %2,%1\n\t&quot;
		     &quot;sbb %0,%0&quot;
		     : &quot;=r&quot; (oldbit)
		     : &quot;m&quot; (*(unsigned long *)addr), &quot;Ir&quot; (nr));

	return oldbit;
}
</code></pre>
<p>The <code>variable_test_bit</code> function takes similar set of arguments as <code>set_bit</code> and other function take. We also may see inline assembly code here which executes <a href="http://x86.renejeschke.de/html/file_module_x86_id_22.html">bt</a> and <a href="http://x86.renejeschke.de/html/file_module_x86_id_286.html">sbb</a> instruction. The <code>bt</code> or <code>bit test</code> instruction selects a given bit which is specified with first operand from the bit array which is specified with the second operand and stores its value in the <a href="https://en.wikipedia.org/wiki/FLAGS_register">CF</a> bit of flags register. The second <code>sbb</code> instruction subtracts first operand from second and subtracts value of the <code>CF</code>. So, here write a value of a given bit number from a given bit array to the <code>CF</code> bit of flags register and execute <code>sbb</code> instruction which calculates: <code>00000000 - CF</code> and writes the result to the <code>oldbit</code>.</p>
<p>The <code>constant_test_bit</code> function does the same as we saw in the <code>set_bit</code>:</p>
<pre><code class="language-C">static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL &lt;&lt; (nr &amp; (BITS_PER_LONG-1))) &amp;
		(addr[nr &gt;&gt; _BITOPS_LONG_SHIFT])) != 0;
}
</code></pre>
<p>It generates a byte where high bit is <code>1</code> and other bits are <code>0</code> (as we saw in <code>CONST_MASK</code>) and applies bitwise <a href="https://en.wikipedia.org/wiki/Bitwise_operation#AND">and</a> to the byte which contains a given bit number.</p>
<p>The next widely used bit array related operation is to change bit in a bit array. The Linux kernel provides two helper for this:</p>
<ul>
<li><code>__change_bit</code>;</li>
<li><code>change_bit</code>.</li>
</ul>
<p>As you already can guess, these two variants are atomic and non-atomic as for example <code>set_bit</code> and <code>__set_bit</code>. For the start, let's look at the implementation of the <code>__change_bit</code> function:</p>
<pre><code class="language-C">static inline void __change_bit(long nr, volatile unsigned long *addr)
{
    asm volatile(&quot;btc %1,%0&quot; : ADDR : &quot;Ir&quot; (nr));
}
</code></pre>
<p>Pretty easy, is it not? The implementation of the <code>__change_bit</code> is the same as <code>__set_bit</code>, but instead of <code>bts</code> instruction, we are using <a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">btc</a>. This instruction selects a given bit from a given bit array, stores its value in the <code>CF</code> and changes its value by the applying of complement operation. So, a bit with value <code>1</code> will be <code>0</code> and vice versa:</p>
<pre><code class="language-python">&gt;&gt;&gt; int(not 1)
0
&gt;&gt;&gt; int(not 0)
1
</code></pre>
<p>The atomic version of the <code>__change_bit</code> is the <code>change_bit</code> function:</p>
<pre><code class="language-C">static inline void change_bit(long nr, volatile unsigned long *addr)
{
	if (IS_IMMEDIATE(nr)) {
		asm volatile(LOCK_PREFIX &quot;xorb %1,%0&quot;
			: CONST_MASK_ADDR(nr, addr)
			: &quot;iq&quot; ((u8)CONST_MASK(nr)));
	} else {
		asm volatile(LOCK_PREFIX &quot;btc %1,%0&quot;
			: BITOP_ADDR(addr)
			: &quot;Ir&quot; (nr));
	}
}
</code></pre>
<p>It is similar on <code>set_bit</code> function, but also has two differences. The first difference is <code>xor</code> operation instead of <code>or</code> and the second is <code>btc</code> instead of <code>bts</code>.</p>
<p>For this moment we know the most important architecture-specific operations with bit arrays. Time to look at generic bitmap API.</p>
<h1 id="common-bit-operations"><a class="header" href="#common-bit-operations">Common bit operations</a></h1>
<p>Besides the architecture-specific API from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> header file, the Linux kernel provides common API for manipulation of bit arrays. As we know from the beginning of this part, we can find it in the  <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitmap.h">include/linux/bitmap.h</a> header file and additionally in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/lib/bitmap.c">lib/bitmap.c</a>  source code file. But before these source code files let's look into the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitops.h">include/linux/bitops.h</a> header file which provides a set of useful macro. Let's look on some of them.</p>
<p>First of all let's look at following four macros:</p>
<ul>
<li><code>for_each_set_bit</code></li>
<li><code>for_each_set_bit_from</code></li>
<li><code>for_each_clear_bit</code></li>
<li><code>for_each_clear_bit_from</code></li>
</ul>
<p>All of these macros provide iterator over certain set of bits in a bit array. The first macro iterates over bits which are set, the second does the same, but starts from a certain bits. The last two macros do the same, but iterates over clear bits. Let's look on implementation of the <code>for_each_set_bit</code> macro:</p>
<pre><code class="language-C">#define for_each_set_bit(bit, addr, size) \
	for ((bit) = find_first_bit((addr), (size));		\
	     (bit) &lt; (size);					\
	     (bit) = find_next_bit((addr), (size), (bit) + 1))
</code></pre>
<p>As we may see it takes three arguments and expands to the loop from first set bit which is returned as result of the <code>find_first_bit</code> function and to the last bit number while it is less than given size.</p>
<p>Besides these four macros, the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/bitops.h">arch/x86/include/asm/bitops.h</a> provides API for rotation of <code>64-bit</code> or <code>32-bit</code> values and etc.</p>
<p>The next <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitmap.h">header</a> file which provides API for manipulation with a bit arrays. For example it provides two functions:</p>
<ul>
<li><code>bitmap_zero</code>;</li>
<li><code>bitmap_fill</code>.</li>
</ul>
<p>To clear a bit array or fill it with <code>1</code>. Let's look at the implementation of the <code>bitmap_zero</code> function:</p>
<pre><code class="language-C">static inline void bitmap_zero(unsigned long *dst, unsigned int nbits)
{
	if (small_const_nbits(nbits))
		*dst = 0UL;
	else {
		unsigned int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
		memset(dst, 0, len);
	}
}
</code></pre>
<p>First of all we can see the check for <code>nbits</code>. The <code>small_const_nbits</code> is macro which defined in the same header <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitmap.h">file</a> and looks:</p>
<pre><code class="language-C">#define small_const_nbits(nbits) \
	(__builtin_constant_p(nbits) &amp;&amp; (nbits) &lt;= BITS_PER_LONG)
</code></pre>
<p>As we may see it checks that <code>nbits</code> is known constant in compile time and <code>nbits</code> value does not overflow <code>BITS_PER_LONG</code> or <code>64</code>. If bits number does not overflow amount of bits in a <code>long</code> value we can just set to zero. In other case we need to calculate how many <code>long</code> values do we need to fill our bit array and fill it with <a href="http://man7.org/linux/man-pages/man3/memset.3.html">memset</a>.</p>
<p>The implementation of the <code>bitmap_fill</code> function is similar on implementation of the <code>bitmap_zero</code> function, except we fill a given bit array with <code>0xff</code> values or <code>0b11111111</code>:</p>
<pre><code class="language-C">static inline void bitmap_fill(unsigned long *dst, unsigned int nbits)
{
	unsigned int nlongs = BITS_TO_LONGS(nbits);
	if (!small_const_nbits(nbits)) {
		unsigned int len = (nlongs - 1) * sizeof(unsigned long);
		memset(dst, 0xff,  len);
	}
	dst[nlongs - 1] = BITMAP_LAST_WORD_MASK(nbits);
}
</code></pre>
<p>Besides the <code>bitmap_fill</code> and <code>bitmap_zero</code> functions, the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitmap.h">include/linux/bitmap.h</a> header file provides <code>bitmap_copy</code> which is similar on the <code>bitmap_zero</code>, but just uses <a href="http://man7.org/linux/man-pages/man3/memcpy.3.html">memcpy</a> instead of <a href="http://man7.org/linux/man-pages/man3/memset.3.html">memset</a>. Also it provides bitwise operations for bit array like <code>bitmap_and</code>, <code>bitmap_or</code>, <code>bitamp_xor</code> and etc. We will not consider implementation of these functions because it is easy to understand implementations of these functions if you understood all from this part. Anyway if you are interested in how these function are implemented, you may open <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/bitmap.h">include/linux/bitmap.h</a> header file and start to research.</p>
<p>That's all.</p>
<h1 id="links-53"><a class="header" href="#links-53">Links</a></h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Bit_array">bitmap</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linked_data_structure">linked data structures</a></li>
<li><a href="https://en.wikipedia.org/wiki/Tree_%28data_structure%29">tree data structures</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">hot-plug</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">cpumasks</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQs</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linearizability">atomic operations</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_328.html">xchg instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_41.html">cmpxchg instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_159.html">lock instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_25.html">bts instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_24.html">btr instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_22.html">bt instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_286.html">sbb instruction</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_23.html">btc instruction</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/memcpy.3.html">man memcpy</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/memset.3.html">man memset</a></li>
<li><a href="https://en.wikipedia.org/wiki/FLAGS_register">CF</a></li>
<li><a href="https://en.wikipedia.org/wiki/Inline_assembler">inline assembler</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theory"><a class="header" href="#theory">Theory</a></h1>
<p>This chapter describes various theoretical concepts and concepts which are not directly related to practice but useful to know.</p>
<ul>
<li><a href="Theory/linux-theory-1.html">Paging</a></li>
<li><a href="Theory/linux-theory-2.html">Elf64 format</a></li>
<li><a href="Theory/linux-theory-3.html">Inline assembly</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paging"><a class="header" href="#paging">Paging</a></h1>
<h2 id="introduction-14"><a class="header" href="#introduction-14">Introduction</a></h2>
<p>In the fifth <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-5">part</a> of the series <code>Linux kernel booting process</code> we learned about what the kernel does in its earliest stage. In the next step the kernel will initialize different things like <code>initrd</code> mounting, lockdep initialization, and many many other things, before we can see how the kernel runs the first init process.</p>
<p>Yeah, there will be many different things, but many many and once again many work with <strong>memory</strong>.</p>
<p>In my view, memory management is one of the most complex parts of the Linux kernel and system programming in general. This is why we need to get acquainted with paging, before we proceed with the kernel initialization stuff.</p>
<p><code>Paging</code> is a mechanism that translates a linear memory address to a physical address. If you have read the previous parts of this book, you may remember that we saw segmentation in real mode when physical addresses are calculated by shifting a segment register by four and adding an offset. We also saw segmentation in protected mode, where we used the descriptor tables and base addresses from descriptors with offsets to calculate the physical addresses. Now we will see paging in 64-bit mode.</p>
<p>As the Intel manual says:</p>
<blockquote>
<p>Paging provides a mechanism for implementing a conventional demand-paged, virtual-memory system where sections of a program’s execution environment are mapped into physical memory as needed.</p>
</blockquote>
<p>So... In this post I will try to explain the theory behind paging. Of course it will be closely related to the <code>x86_64</code> version of the Linux kernel, but we will not go into too much details (at least in this post).</p>
<h2 id="enabling-paging"><a class="header" href="#enabling-paging">Enabling paging</a></h2>
<p>There are three paging modes:</p>
<ul>
<li>32-bit paging;</li>
<li>PAE paging;</li>
<li>IA-32e paging.</li>
</ul>
<p>We will only explain the last mode here. To enable the <code>IA-32e paging</code> paging mode we need to do the following things:</p>
<ul>
<li>set the <code>CR0.PG</code> bit;</li>
<li>set the <code>CR4.PAE</code> bit;</li>
<li>set the <code>IA32_EFER.LME</code> bit.</li>
</ul>
<p>We already saw where those bits were set in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a>:</p>
<pre><code class="language-assembly">movl	$(X86_CR0_PG | X86_CR0_PE), %eax
movl	%eax, %cr0
</code></pre>
<p>and</p>
<pre><code class="language-assembly">movl	$MSR_EFER, %ecx
rdmsr
btsl	$_EFER_LME, %eax
wrmsr
</code></pre>
<h2 id="paging-structures"><a class="header" href="#paging-structures">Paging structures</a></h2>
<p>Paging divides the linear address space into fixed-size pages. Pages can be mapped into the physical address space or external storage. This fixed size is <code>4096</code> bytes for the <code>x86_64</code> Linux kernel. To perform the translation from linear address to physical address, special structures are used. Every structure is <code>4096</code> bytes and contains <code>512</code> entries (this only for <code>PAE</code> and <code>IA32_EFER.LME</code> modes). Paging structures are hierarchical and the Linux kernel uses 4 level of paging in the <code>x86_64</code> architecture. The CPU uses a part of linear addresses to identify the entry in another paging structure which is at the lower level, physical memory region (<code>page frame</code>) or physical address in this region (<code>page offset</code>). The address of the top level paging structure located in the <code>cr3</code> register. We have already seen this in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/head_64.S">arch/x86/boot/compressed/head_64.S</a>:</p>
<pre><code class="language-assembly">leal	pgtable(%ebx), %eax
movl	%eax, %cr3
</code></pre>
<p>We build the page table structures and put the address of the top-level structure in the <code>cr3</code> register. Here <code>cr3</code> is used to store the address of the top-level structure, the <code>PML4</code> or <code>Page Global Directory</code> as it is called in the Linux kernel. <code>cr3</code> is 64-bit register and has the following structure:</p>
<pre><code>63                  52 51                                                        32
 --------------------------------------------------------------------------------
|                     |                                                          |
|    Reserved MBZ     |            Address of the top level structure            |
|                     |                                                          |
 --------------------------------------------------------------------------------
31                                  12 11            5     4     3 2             0
 --------------------------------------------------------------------------------
|                                     |               |  P  |  P  |              |
|  Address of the top level structure |   Reserved    |  C  |  W  |    Reserved  |
|                                     |               |  D  |  T  |              |
 --------------------------------------------------------------------------------
</code></pre>
<p>These fields have the following meanings:</p>
<ul>
<li>Bits 63:52 - reserved must be 0.</li>
<li>Bits 51:12 - stores the address of the top level paging structure;</li>
<li>Bits 11: 5 - reserved must be 0;</li>
<li>Bits 4 : 3 - PWT or Page-Level Writethrough and PCD or Page-level cache disable indicate. These bits control the way the page or Page Table is handled by the hardware cache;</li>
<li>Bits 2 : 0 - ignored;</li>
</ul>
<p>The linear address translation is following:</p>
<ul>
<li>A given linear address arrives to the <a href="http://en.wikipedia.org/wiki/Memory_management_unit">MMU</a> instead of memory bus.</li>
<li>64-bit linear address is split into some parts. Only low 48 bits are significant, it means that <code>2^48</code> or 256 TBytes of linear-address space may be accessed at any given time.</li>
<li><code>cr3</code> register stores the address of the 4 top-level paging structure.</li>
<li><code>47:39</code> bits of the given linear address store an index into the paging structure level-4, <code>38:30</code> bits store index into the paging structure level-3, <code>29:21</code> bits store an index into the paging structure level-2, <code>20:12</code> bits store an index into the paging structure level-1 and <code>11:0</code> bits provide the offset into the physical page in byte.</li>
</ul>
<p>schematically, we can imagine it like this:</p>
<p><img src="Theory/images/4_level_paging.png" alt="4-level paging" /></p>
<p>Every access to a linear address is either a supervisor-mode access or a user-mode access. This access is determined by the <code>CPL</code> (current privilege level). If <code>CPL &lt; 3</code> it is a supervisor mode access level, otherwise it is a user mode access level. For example, the top level page table entry contains access bits and has the following structure (See <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/pgtable_types.h">arch/x86/include/asm/pgtable_types.h</a> for the bit offset definitions):</p>
<pre><code>63  62                  52 51                                                    32
 --------------------------------------------------------------------------------
| N |                     |                                                     |
|   |     Available       |     Address of the paging structure on lower level  |
| X |                     |                                                     |
 --------------------------------------------------------------------------------
31                                              12 11  9 8 7 6 5   4   3 2 1     0
 --------------------------------------------------------------------------------
|                                                |     | M |I| | P | P |U|W|    |
| Address of the paging structure on lower level | AVL | B |G|A| C | W | | |  P |
|                                                |     | Z |N| | D | T |S|R|    |
 --------------------------------------------------------------------------------
</code></pre>
<p>Where:</p>
<ul>
<li>63 bit - N/X bit (No Execute Bit) which presents ability to execute the code from physical pages mapped by the table entry;</li>
<li>62:52 bits - ignored by CPU, used by system software;</li>
<li>51:12 bits - stores physical address of the lower level paging structure;</li>
<li>11: 9 bits - ignored by CPU;</li>
<li>MBZ - must be zero bits;</li>
<li>Ignored bits;</li>
<li>A - accessed bit indicates was physical page or page structure accessed;</li>
<li>PWT and PCD used for cache;</li>
<li>U/S - user/supervisor bit controls user access to all the physical pages mapped by this table entry;</li>
<li>R/W - read/write bit controls read/write access to all the physical pages mapped by this table entry;</li>
<li>P - present bit. Current bit indicates was page table or physical page loaded into primary memory or not.</li>
</ul>
<p>Ok, we know about the paging structures and their entries. Now let's see some details about 4-level paging in the Linux kernel.</p>
<h2 id="paging-structures-in-the-linux-kernel"><a class="header" href="#paging-structures-in-the-linux-kernel">Paging structures in the Linux kernel</a></h2>
<p>As we've seen, the Linux kernel in <code>x86_64</code> uses 4-level page tables. Their names are:</p>
<ul>
<li>Page Global Directory</li>
<li>Page Upper  Directory</li>
<li>Page Middle Directory</li>
<li>Page Table Entry</li>
</ul>
<p>After you've compiled and installed the Linux kernel, you can see the <code>System.map</code> file which stores the virtual addresses of the functions that are used by the kernel. For example:</p>
<pre><code>$ grep &quot;start_kernel&quot; System.map
ffffffff81efe497 T x86_64_start_kernel
ffffffff81efeaa2 T start_kernel
</code></pre>
<p>We can see <code>0xffffffff81efe497</code> here. I doubt you really have that much RAM installed. But anyway, <code>start_kernel</code> and <code>x86_64_start_kernel</code> will be executed. The address space in <code>x86_64</code> is <code>2^64</code> wide, but it's too large, that's why a smaller address space is used, only 48-bits wide. So we have a situation where the physical address space is limited to 48 bits, but addressing still performs with 64 bit pointers. How is this problem solved? Look at this diagram:</p>
<pre><code>0xffffffffffffffff  +-----------+
                    |           |
                    |           | Kernelspace
                    |           |
0xffff800000000000  +-----------+
                    |           |
                    |           |
                    |   hole    |
                    |           |
                    |           |
0x00007fffffffffff  +-----------+
                    |           |
                    |           |  Userspace
                    |           |
0x0000000000000000  +-----------+
</code></pre>
<p>This solution is <code>sign extension</code>. Here we can see that the lower 48 bits of a virtual address can be used for addressing. Bits <code>63:48</code> can be either only zeroes or only ones. Note that the virtual address space is split into 2 parts:</p>
<ul>
<li>Kernel space</li>
<li>Userspace</li>
</ul>
<p>Userspace occupies the lower part of the virtual address space, from <code>0x000000000000000</code> to <code>0x00007fffffffffff</code> and kernel space occupies the highest part from <code>0xffff8000000000</code> to <code>0xffffffffffffffff</code>. Note that bits <code>63:47</code> is 0 for userspace and 1 for kernel space. All addresses which are in kernel space and in userspace or in other words which higher <code>63:48</code> bits are zeroes or ones are called <code>canonical</code> addresses. There is a <code>non-canonical</code> area between these memory regions. Together these two memory regions (kernel space and user space) are exactly <code>2^48</code> bits wide. We can find the virtual memory map with 4 level page tables in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/x86_64/mm.txt">Documentation/x86/x86_64/mm.txt</a>:</p>
<pre><code>0000000000000000 - 00007fffffffffff (=47 bits) user space, different per mm
hole caused by [48:63] sign extension
ffff800000000000 - ffff87ffffffffff (=43 bits) guard hole, reserved for hypervisor
ffff880000000000 - ffffc7ffffffffff (=64 TB) direct mapping of all phys. memory
ffffc80000000000 - ffffc8ffffffffff (=40 bits) hole
ffffc90000000000 - ffffe8ffffffffff (=45 bits) vmalloc/ioremap space
ffffe90000000000 - ffffe9ffffffffff (=40 bits) hole
ffffea0000000000 - ffffeaffffffffff (=40 bits) virtual memory map (1TB)
... unused hole ...
ffffec0000000000 - fffffc0000000000 (=44 bits) kasan shadow memory (16TB)
... unused hole ...
ffffff0000000000 - ffffff7fffffffff (=39 bits) %esp fixup stacks
... unused hole ...
ffffffff80000000 - ffffffffa0000000 (=512 MB)  kernel text mapping, from phys 0
ffffffffa0000000 - ffffffffff5fffff (=1525 MB) module mapping space
ffffffffff600000 - ffffffffffdfffff (=8 MB) vsyscalls
ffffffffffe00000 - ffffffffffffffff (=2 MB) unused hole
</code></pre>
<p>We can see here the memory map for user space, kernel space and the non-canonical area in-between them. The user space memory map is simple. Let's take a closer look at the kernel space. We can see that it starts from the guard hole which is reserved for the hypervisor. We can find the definition of this guard hole in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/page_64_types.h">arch/x86/include/asm/page_64_types.h</a>:</p>
<pre><code class="language-C">#define __PAGE_OFFSET _AC(0xffff880000000000, UL)
</code></pre>
<p>Previously this guard hole and <code>__PAGE_OFFSET</code> was from <code>0xffff800000000000</code> to <code>0xffff87ffffffffff</code> to prevent access to non-canonical area, but was later extended by 3 bits for the hypervisor.</p>
<p>Next is the lowest usable address in kernel space - <code>ffff880000000000</code>. This virtual memory region is for direct mapping of all the physical memory. After the memory space which maps all the physical addresses, the guard hole. It needs to be between the direct mapping of all the physical memory and the vmalloc area. After the virtual memory map for the first terabyte and the unused hole after it, we can see the <code>kasan</code> shadow memory. It was added by <a href="https://github.com/torvalds/linux/commit/ef7f0d6a6ca8c9e4b27d78895af86c2fbfaeedb2">commit</a> and provides the kernel address sanitizer. After the next unused hole we can see the <code>esp</code> fixup stacks (we will talk about it in other parts of this book) and the start of the kernel text mapping from the physical address - <code>0</code>. We can find the definition of this address in the same file as the <code>__PAGE_OFFSET</code>:</p>
<pre><code class="language-C">#define __START_KERNEL_map      _AC(0xffffffff80000000, UL)
</code></pre>
<p>Usually kernel's <code>.text</code> starts here with the <code>CONFIG_PHYSICAL_START</code> offset. We have seen it in the post about <a href="https://github.com/0xAX/linux-insides/blob/master/Theory/ELF.md">ELF64</a>:</p>
<pre><code>readelf -s vmlinux | grep ffffffff81000000
     1: ffffffff81000000     0 SECTION LOCAL  DEFAULT    1
 65099: ffffffff81000000     0 NOTYPE  GLOBAL DEFAULT    1 _text
 90766: ffffffff81000000     0 NOTYPE  GLOBAL DEFAULT    1 startup_64
</code></pre>
<p>Here I check <code>vmlinux</code> with <code>CONFIG_PHYSICAL_START</code> is <code>0x1000000</code>. So we have the start point of the kernel <code>.text</code> - <code>0xffffffff80000000</code> and offset - <code>0x1000000</code>, the resulted virtual address will be <code>0xffffffff80000000 + 1000000 = 0xffffffff81000000</code>.</p>
<p>After the kernel <code>.text</code> region there is the virtual memory region for kernel module, <code>vsyscalls</code> and an unused hole of 2 megabytes.</p>
<p>We've seen how virtual memory map in the kernel is laid out and how a virtual address is translated into a physical one. Let's take the following address as example:</p>
<pre><code>0xffffffff81000000
</code></pre>
<p>In binary it will be:</p>
<pre><code>1111111111111111 111111111 111111110 000001000 000000000 000000000000
      63:48        47:39     38:30     29:21     20:12      11:0
</code></pre>
<p>This virtual address is split in parts as described above:</p>
<ul>
<li><code>63:48</code> - bits not used;</li>
<li><code>47:39</code> - bits store an index into the paging structure level-4;</li>
<li><code>38:30</code> - bits store index into the paging structure level-3;</li>
<li><code>29:21</code> - bits store an index into the paging structure level-2;</li>
<li><code>20:12</code> - bits store an index into the paging structure level-1;</li>
<li><code>11:0</code>  - bits provide the offset into the physical page in byte.</li>
</ul>
<p>That is all. Now you know a little about theory of <code>paging</code> and we can go ahead in the kernel source code and see the first initialization steps.</p>
<h2 id="conclusion-50"><a class="header" href="#conclusion-50">Conclusion</a></h2>
<p>It's the end of this short part about paging theory. Of course this post doesn't cover every detail of paging, but soon we'll see in practice how the Linux kernel builds paging structures and works with them.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you've found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links-54"><a class="header" href="#links-54">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Paging">Paging on Wikipedia</a></li>
<li><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel 64 and IA-32 architectures software developer's manual volume 3A</a></li>
<li><a href="http://en.wikipedia.org/wiki/Memory_management_unit">MMU</a></li>
<li><a href="https://github.com/0xAX/linux-insides/blob/master/Theory/ELF.md">ELF64</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/x86_64/mm.txt">Documentation/x86/x86_64/mm.txt</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-5">Last part - Kernel booting process</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executable-and-linkable-format"><a class="header" href="#executable-and-linkable-format">Executable and Linkable Format</a></h1>
<p>ELF (Executable and Linkable Format) is a standard file format for executable files, object code, shared libraries and core dumps. Linux and many UNIX-like operating systems use this format. Let's look at the structure of the ELF-64 Object File Format and some definitions in the Linux kernel source code which related with it.</p>
<p>An ELF object file consists of the following parts:</p>
<ul>
<li>ELF header - describes the main characteristics of the object file: type, CPU architecture, the virtual address of the entry point, the size and offset of the remaining parts, etc...;</li>
<li>Program header table - lists the available segments and their attributes. Program header table need loaders for placing sections of the file as virtual memory segments;</li>
<li>Section header table - contains the description of the sections.</li>
</ul>
<p>Now let's have a closer look on these components.</p>
<p><strong>ELF header</strong></p>
<p>The ELF header is located at the beginning of the object file. Its main purpose is to locate all other parts of the object file. The file header contains the following fields:</p>
<ul>
<li>ELF identification - array of bytes which helps identify the file as an ELF object file and also provides information about general object file characteristic;</li>
<li>Object file type - identifies the object file type. This field can describe that ELF file is a relocatable object file, an executable file, etc...;</li>
<li>Target architecture;</li>
<li>Version of the object file format;</li>
<li>Virtual address of the program entry point;</li>
<li>File offset of the program header table;</li>
<li>File offset of the section header table;</li>
<li>Size of an ELF header;</li>
<li>Size of a program header table entry;</li>
<li>and other fields...</li>
</ul>
<p>You can find the <code>elf64_hdr</code> structure which presents ELF64 header in the Linux kernel source code:</p>
<pre><code class="language-C">typedef struct elf64_hdr {
	unsigned char	e_ident[EI_NIDENT];
	Elf64_Half e_type;
	Elf64_Half e_machine;
	Elf64_Word e_version;
	Elf64_Addr e_entry;
	Elf64_Off e_phoff;
	Elf64_Off e_shoff;
	Elf64_Word e_flags;
	Elf64_Half e_ehsize;
	Elf64_Half e_phentsize;
	Elf64_Half e_phnum;
	Elf64_Half e_shentsize;
	Elf64_Half e_shnum;
	Elf64_Half e_shstrndx;
} Elf64_Ehdr;
</code></pre>
<p>This structure defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/uapi/linux/elf.h#L220">elf.h</a></p>
<p><strong>Sections</strong></p>
<p>All data stores in a sections in an Elf object file. Sections identified by index in the section header table. Section header contains following fields:</p>
<ul>
<li>Section name;</li>
<li>Section type;</li>
<li>Section attributes;</li>
<li>Virtual address in memory;</li>
<li>Offset in file;</li>
<li>Size of section;</li>
<li>Link to other section;</li>
<li>Miscellaneous information;</li>
<li>Address alignment boundary;</li>
<li>Size of entries, if section has table;</li>
</ul>
<p>And presented with the following <code>elf64_shdr</code> structure in the Linux kernel:</p>
<pre><code class="language-C">typedef struct elf64_shdr {
	Elf64_Word sh_name;
	Elf64_Word sh_type;
	Elf64_Xword sh_flags;
	Elf64_Addr sh_addr;
	Elf64_Off sh_offset;
	Elf64_Xword sh_size;
	Elf64_Word sh_link;
	Elf64_Word sh_info;
	Elf64_Xword sh_addralign;
	Elf64_Xword sh_entsize;
} Elf64_Shdr;
</code></pre>
<p><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/uapi/linux/elf.h#L312">elf.h</a></p>
<p><strong>Program header table</strong></p>
<p>All sections are grouped into segments in an executable or shared object file. Program header is an array of structures which describe every segment. It looks like:</p>
<pre><code class="language-C">typedef struct elf64_phdr {
	Elf64_Word p_type;
	Elf64_Word p_flags;
	Elf64_Off p_offset;
	Elf64_Addr p_vaddr;
	Elf64_Addr p_paddr;
	Elf64_Xword p_filesz;
	Elf64_Xword p_memsz;
	Elf64_Xword p_align;
} Elf64_Phdr;
</code></pre>
<p>in the Linux kernel source code.</p>
<p><code>elf64_phdr</code> defined in the same <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/uapi/linux/elf.h#L254">elf.h</a>.</p>
<p>The ELF object file also contains other fields/structures which you can find in the <a href="http://www.uclibc.org/docs/elf-64-gen.pdf">Documentation</a>. Now let's a look at the <code>vmlinux</code> ELF object.</p>
<h2 id="vmlinux"><a class="header" href="#vmlinux">vmlinux</a></h2>
<p><code>vmlinux</code> is also a relocatable ELF object file . We can take a look at it with the <code>readelf</code> utility. First of all let's look at the header:</p>
<pre><code>$ readelf -h  vmlinux
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x1000000
  Start of program headers:          64 (bytes into file)
  Start of section headers:          381608416 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         5
  Size of section headers:           64 (bytes)
  Number of section headers:         73
  Section header string table index: 70
</code></pre>
<p>Here we can see that <code>vmlinux</code> is a 64-bit executable file.</p>
<p>We can read from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/x86/x86_64/mm.txt#L21">Documentation/x86/x86_64/mm.txt</a>:</p>
<pre><code>ffffffff80000000 - ffffffffa0000000 (=512 MB)  kernel text mapping, from phys 0
</code></pre>
<p>We can then look this address up in the <code>vmlinux</code> ELF object with:</p>
<pre><code>$ readelf -s vmlinux | grep ffffffff81000000
     1: ffffffff81000000     0 SECTION LOCAL  DEFAULT    1
 65099: ffffffff81000000     0 NOTYPE  GLOBAL DEFAULT    1 _text
 90766: ffffffff81000000     0 NOTYPE  GLOBAL DEFAULT    1 startup_64
</code></pre>
<p>Note that the address of the <code>startup_64</code> routine is not <code>ffffffff80000000</code>, but <code>ffffffff81000000</code> and now I'll explain why.</p>
<p>We can see following definition in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/vmlinux.lds.S">arch/x86/kernel/vmlinux.lds.S</a>:</p>
<pre><code>    . = __START_KERNEL;
	...
	...
	..
	/* Text and read-only data */
	.text :  AT(ADDR(.text) - LOAD_OFFSET) {
		_text = .;
		...
		...
		...
	}
</code></pre>
<p>Where <code>__START_KERNEL</code> is:</p>
<pre><code>#define __START_KERNEL		(__START_KERNEL_map + __PHYSICAL_START)
</code></pre>
<p><code>__START_KERNEL_map</code> is the value from the documentation - <code>ffffffff80000000</code> and <code>__PHYSICAL_START</code> is <code>0x1000000</code>. That's why address of the <code>startup_64</code> is <code>ffffffff81000000</code>.</p>
<p>And at last we can get program headers from <code>vmlinux</code> with the following command:</p>
<pre><code>readelf -l vmlinux

Elf file type is EXEC (Executable file)
Entry point 0x1000000
There are 5 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000200000 0xffffffff81000000 0x0000000001000000
                 0x0000000000cfd000 0x0000000000cfd000  R E    200000
  LOAD           0x0000000001000000 0xffffffff81e00000 0x0000000001e00000
                 0x0000000000100000 0x0000000000100000  RW     200000
  LOAD           0x0000000001200000 0x0000000000000000 0x0000000001f00000
                 0x0000000000014d98 0x0000000000014d98  RW     200000
  LOAD           0x0000000001315000 0xffffffff81f15000 0x0000000001f15000
                 0x000000000011d000 0x0000000000279000  RWE    200000
  NOTE           0x0000000000b17284 0xffffffff81917284 0x0000000001917284
                 0x0000000000000024 0x0000000000000024         4

 Section to Segment mapping:
  Segment Sections...
   00     .text .notes __ex_table .rodata __bug_table .pci_fixup .builtin_fw
          .tracedata __ksymtab __ksymtab_gpl __kcrctab __kcrctab_gpl
		  __ksymtab_strings __param __modver
   01     .data .vvar
   02     .data..percpu
   03     .init.text .init.data .x86_cpu_dev.init .altinstructions
          .altinstr_replacement .iommu_table .apicdrivers .exit.text
		  .smp_locks .data_nosave .bss .brk
</code></pre>
<p>Here we can see five segments with sections list. You can find all of these sections in the generated linker script at - <code>arch/x86/kernel/vmlinux.lds</code>.</p>
<p>That's all. Of course it's not a full description of ELF (Executable and Linkable Format), but if you want to know more, you can find the documentation - <a href="http://www.uclibc.org/docs/elf-64-gen.pdf">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-assembly"><a class="header" href="#inline-assembly">Inline assembly</a></h1>
<h2 id="introduction-15"><a class="header" href="#introduction-15">Introduction</a></h2>
<p>While reading source code in the <a href="https://github.com/torvalds/linux">Linux kernel</a>, I often see statements like this:</p>
<pre><code class="language-C">__asm__(&quot;andq %%rsp,%0; &quot;:&quot;=r&quot; (ti) : &quot;0&quot; (CURRENT_MASK));
</code></pre>
<p>Yes, this is <a href="https://en.wikipedia.org/wiki/Inline_assembler">inline assembly</a> or in other words assembler code which is integrated in a high level programming language. In this case the high level programming language is <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a>. Yes, the <code>C</code> programming language is not very high-level, but still.</p>
<p>If you are familiar with the <a href="https://en.wikipedia.org/wiki/Assembly_language">assembly</a> programming language, you may notice that <code>inline assembly</code> is not very different from normal assembler. Moreover, the special form of inline assembly which is called <code>basic form</code> is exactly the same. For example:</p>
<pre><code class="language-C">__asm__(&quot;movq %rax, %rsp&quot;);
</code></pre>
<p>or:</p>
<pre><code class="language-C">__asm__(&quot;hlt&quot;);
</code></pre>
<p>The same code (of course without <code>__asm__</code> prefix) you might see in plain assembly code. Yes, this is very similar, but not so simple as it might seem at first glance. Actually, the <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a> supports two forms of inline assembly statements:</p>
<ul>
<li><code>basic</code>;</li>
<li><code>extended</code>.</li>
</ul>
<p>The basic form consists of only two things: the <code>__asm__</code> keyword and the string with valid assembler instructions. For example it may look something like this:</p>
<pre><code class="language-C">__asm__(&quot;movq    $3, %rax\t\n&quot;
        &quot;movq    %rsi, %rdi&quot;);
</code></pre>
<p>The <code>asm</code> keyword may be used in place of <code>__asm__</code>, however <code>__asm__</code> is portable whereas the <code>asm</code> keyword is a <code>GNU</code> <a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html">extension</a>. In further examples I will only use the <code>__asm__</code> variant.</p>
<p>If you know assembly programming language this looks pretty familiar. The main problem is in the second form of inline assembly statements - <code>extended</code>. This form allows us to pass parameters to an assembly statement, perform <a href="https://en.wikipedia.org/wiki/Branch_%28computer_science%29">jumps</a> etc. Does not sound difficult, but requires knowledge of special rules in addition to knowledge of the assembly language. Every time I see yet another piece of inline assembly code in the Linux kernel, I need to refer to the official <a href="https://gcc.gnu.org/onlinedocs/">documentation</a> of <code>GCC</code> to remember how a particular <code>qualifier</code> behaves or what the meaning of <code>=&amp;r</code> is for example.</p>
<p>I've decided to write this part to consolidate my knowledge related to the inline assembly, as inline assembly statements are quite common in the Linux kernel and we may see them in <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">linux-insides</a> parts sometimes. I thought that it would be useful if we have a special part which contains information on more important aspects of the inline assembly. Of course you may find comprehensive information about inline assembly in the official <a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html#Using-Assembly-Language-with-C">documentation</a>, but I like to put everything in one place.</p>
<p>** Note: This part will not provide guide for assembly programming. It is not intended to teach you to write programs with assembler or to know what one or another assembler instruction means. Just a little memo for extended asm. **</p>
<h2 id="introduction-to-extended-inline-assembly"><a class="header" href="#introduction-to-extended-inline-assembly">Introduction to extended inline assembly</a></h2>
<p>So, let's start. As I already mentioned above, the <code>basic</code> assembly statement consists of the <code>asm</code> or <code>__asm__</code> keyword and set of assembly instructions. This form is in no way different from &quot;normal&quot; assembly. The most interesting part is inline assembler with operands, or <code>extended</code> assembler. An extended assembly statement looks more complicated and consists of more than two parts:</p>
<pre><code class="language-assembly">__asm__ [volatile] [goto] (AssemblerTemplate
                           [ : OutputOperands ]
                           [ : InputOperands  ]
                           [ : Clobbers       ]
                           [ : GotoLabels     ]);
</code></pre>
<p>All parameters which are marked with squared brackets are optional. You may notice that if we skip the optional parameters and the modifiers <code>volatile</code> and <code>goto</code> we obtain the <code>basic</code> form.</p>
<p>Let's start to consider this in order. The first optional <code>qualifier</code> is <code>volatile</code>. This specifier tells the compiler that an assembly statement may produce <code>side effects</code>. In this case we need to prevent compiler optimizations related to the given assembly statement. In simple terms the <code>volatile</code> specifier instructs the compiler not to modify the statement and place it exactly where it was in the original code. As an example let's look at the following function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/desc.h">Linux kernel</a>:</p>
<pre><code class="language-C">static inline void native_load_gdt(const struct desc_ptr *dtr)
{
	asm volatile(&quot;lgdt %0&quot;::&quot;m&quot; (*dtr));
}
</code></pre>
<p>Here we see the <code>native_load_gdt</code> function which loads a base address from the <a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a> to the <code>GDTR</code> register with the <code>lgdt</code> instruction. This assembly statement is marked with <code>volatile</code> qualifier. It is very important that the compiler does not change the original place of this assembly statement in the resulting code. Otherwise the <code>GDTR</code> register may contain wrong address for the <code>Global Descriptor Table</code> or the address may be correct, but the structure has not been filled yet. This can lead to an exception being generated, preventing the kernel from booting correctly.</p>
<p>The second optional <code>qualifier</code> is the <code>goto</code>. This qualifier tells the compiler that the given assembly statement may perform a jump to one of the labels which are listed in the <code>GotoLabels</code>. For example:</p>
<pre><code class="language-C">__asm__ goto(&quot;jmp %l[label]&quot; : : : : label);
</code></pre>
<p>Since we finished with these two qualifiers, let's look at the main part of an assembly statement body. As we have seen above, the main part of an assembly statement consists of the following four parts:</p>
<ul>
<li>set of assembly instructions;</li>
<li>output parameters;</li>
<li>input parameters;</li>
<li>clobbers.</li>
</ul>
<p>The first represents a string which contains a set of valid assembly instructions which may be separated by the <code>\t\n</code> sequence. Names of processor <a href="https://en.wikipedia.org/wiki/Processor_register">registers</a> must be prefixed with the <code>%%</code> sequence in <code>extended</code> form and other symbols like immediates must start with the <code>$</code> symbol. The <code>OutputOperands</code> and <code>InputOperands</code> are comma-separated lists of <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> variables which may be provided with &quot;constraints&quot; and the <code>Clobbers</code> is a list of registers or other values which are modified by the assembler instructions from the <code>AssemblerTemplate</code> beyond those listed in the <code>OutputOperands</code>. Before we dive into the examples we have to know a little bit about <code>constraints</code>. A constraint is a string which specifies placement of an operand. For example the value of an operand may be written to a processor register or read from memory etc.</p>
<p>Consider the following simple example:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

int main(void)
{
        unsigned long a = 5;
        unsigned long b = 10;
        unsigned long sum = 0;

        __asm__(&quot;addq %1,%2&quot; : &quot;=r&quot; (sum) : &quot;r&quot; (a), &quot;0&quot; (b));
        printf(&quot;a + b = %lu\n&quot;, sum);
        return 0;
}
</code></pre>
<p>Let's compile and run it to be sure that it works as expected:</p>
<pre><code>$ gcc test.c -o test
./test
a + b = 15
</code></pre>
<p>Ok, great. It works. Now let's look at this example in detail. Here we see a simple <code>C</code> program which calculates the sum of two variables placing the result into the <code>sum</code> variable and in the end we print the result. This example consists of three parts. The first is the assembly statement with the <a href="http://x86.renejeschke.de/html/file_module_x86_id_5.html">add</a> instruction. It adds the value of the source operand together with the value of the destination operand and stores the result in the destination operand. In our case:</p>
<pre><code class="language-assembly">addq %1, %2
</code></pre>
<p>will be expanded to the:</p>
<pre><code class="language-assembly">addq a, b
</code></pre>
<p>Variables and expressions which are listed in the <code>OutputOperands</code> and <code>InputOperands</code> may be matched in the <code>AssemblerTemplate</code>. An input/output operand is designated as <code>%N</code> where the <code>N</code> is the number of operand from left to right beginning from <code>zero</code>. The second part of the our assembly statement is located after the first <code>:</code> symbol and contains the definition of the output value:</p>
<pre><code class="language-assembly">&quot;=r&quot; (sum)
</code></pre>
<p>Notice that the <code>sum</code> is marked with two special symbols: <code>=r</code>. This is the first constraint that we have encountered. The actual constraint here is only <code>r</code> itself. The <code>=</code> symbol is <code>modifier</code> which denotes output value. This tells to compiler that the previous value will be discarded and replaced by the new data. Besides the <code>=</code> modifier, <code>GCC</code> provides support for following three modifiers:</p>
<ul>
<li><code>+</code> - an operand is read and written by an instruction;</li>
<li><code>&amp;</code> - output register shouldn't overlap an input register and should be used only for output;</li>
<li><code>%</code> - tells the compiler that operands may be <a href="https://en.wikipedia.org/wiki/Commutative_property">commutative</a>.</li>
</ul>
<p>Now let's go back to the <code>r</code> qualifier. As I mentioned above, a qualifier denotes the placement of an operand. The <code>r</code> symbol means a value will be stored in one of the <a href="https://en.wikipedia.org/wiki/Processor_register">general purpose register</a>. The last part of our assembly statement:</p>
<pre><code class="language-assembly">&quot;r&quot; (a), &quot;0&quot; (b)
</code></pre>
<p>These are input operands - variables <code>a</code> and <code>b</code>. We already know what the <code>r</code> qualifier does. Now we can have a look at the constraint for the variable <code>b</code>. The <code>0</code> or any other digit from <code>1</code> to <code>9</code> is called &quot;matching constraint&quot;. With this a single operand can be used for multiple roles. The value of the constraint is the source operand index. In our case <code>0</code> will match <code>sum</code>. If we look at assembly output of our program:</p>
<pre><code class="language-C">0000000000400400 &lt;main&gt;:
  ...
  ...
  ...
  4004fe:       48 c7 45 f8 05 00 00    movq   $0x5,-0x8(%rbp)
  400506:       48 c7 45 f0 0a 00 00    movq   $0xa,-0x10(%rbp)

  400516:       48 8b 55 f8             mov    -0x8(%rbp),%rdx
  40051a:       48 8b 45 f0             mov    -0x10(%rbp),%rax
  40051e:       48 01 d0                add    %rdx,%rax
</code></pre>
<p>First of all our values <code>5</code> and <code>10</code> will be put at the stack and then these values will be moved to the two general purpose registers: <code>%rdx</code> and <code>%rax</code>.</p>
<p>This way the <code>%rax</code> register is used for storing the value of the <code>b</code> as well as storing the result of the calculation. <strong>NOTE</strong> that I've used <code>gcc 6.3.1</code> version, so the resulted code of your compiler may differ.</p>
<p>We have looked at input and output parameters of an inline assembly statement. Before we move on to other constraints supported by <code>gcc</code>, there is one remaining part of the inline assembly statement we have not discussed yet - <code>clobbers</code>.</p>
<h2 id="clobbers"><a class="header" href="#clobbers">Clobbers</a></h2>
<p>As mentioned above, the &quot;clobbered&quot; part should contain a comma-separated list of registers whose content will be modified by the assembler code. This is useful if our assembly expression needs additional registers for calculation. If we add clobbered registers to the inline assembly statement, the compiler take this into account and the register in question will not simultaneously be used by the compiler.</p>
<p>Consider the example from before, but we will add an additional, simple assembler instruction:</p>
<pre><code class="language-C">__asm__(&quot;movq $100, %%rdx\t\n&quot;
        &quot;addq %1,%2&quot; : &quot;=r&quot; (sum) : &quot;r&quot; (a), &quot;0&quot; (b));
</code></pre>
<p>If we look at the assembly output:</p>
<pre><code class="language-C">0000000000400400 &lt;main&gt;:
  ...
  ...
  ...
  4004fe:       48 c7 45 f8 05 00 00    movq   $0x5,-0x8(%rbp)
  400506:       48 c7 45 f0 0a 00 00    movq   $0xa,-0x10(%rbp)

  400516:       48 8b 55 f8             mov    -0x8(%rbp),%rdx
  40051a:       48 8b 45 f0             mov    -0x10(%rbp),%rax

  40051e:       48 c7 c2 64 00 00 00    mov    $0x64,%rdx
  400525:       48 01 d0                add    %rdx,%rax
</code></pre>
<p>we will see that the <code>%rdx</code> register is overwritten with <code>0x64</code> or <code>100</code> and the result will be <code>110</code> instead of <code>10</code>. Now if we add the <code>%rdx</code> register to the list of <code>clobbered</code> registers:</p>
<pre><code class="language-C">__asm__(&quot;movq $100, %%rdx\t\n&quot;
        &quot;addq %1,%2&quot; : &quot;=r&quot; (sum) : &quot;r&quot; (a), &quot;0&quot; (b) : &quot;%rdx&quot;);
</code></pre>
<p>and look at the assembler output again:</p>
<pre><code class="language-C">0000000000400400 &lt;main&gt;:
  4004fe:       48 c7 45 f8 05 00 00    movq   $0x5,-0x8(%rbp)
  400506:       48 c7 45 f0 0a 00 00    movq   $0xa,-0x10(%rbp)

  400516:       48 8b 4d f8             mov    -0x8(%rbp),%rcx
  40051a:       48 8b 45 f0             mov    -0x10(%rbp),%rax

  40051e:       48 c7 c2 64 00 00 00    mov    $0x64,%rdx
  400525:       48 01 c8                add    %rcx,%rax
</code></pre>
<p>the <code>%rcx</code> register will be used for <code>sum</code> calculation, preserving the intended semantics of the program. Besides general purpose registers, we may pass two special specifiers. They are:</p>
<ul>
<li><code>cc</code>;</li>
<li><code>memory</code>.</li>
</ul>
<p>The first - <code>cc</code> indicates that an assembler code modifies <a href="https://en.wikipedia.org/wiki/FLAGS_register">flags</a> register. This is typically used if the assembly within contains arithmetic or logic instructions:</p>
<pre><code class="language-C">__asm__(&quot;incq %0&quot; ::&quot;&quot;(variable): &quot;cc&quot;);
</code></pre>
<p>The second <code>memory</code> specifier tells the compiler that the given inline assembly statement executes read/write operations on memory not specified by operands in the output list. This prevents the compiler from keeping memory values loaded and cached in registers. Let's take a look at the following example:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

int main(void)
{
        unsigned long a[3] = {10000000000, 0, 1};
        unsigned long b = 5;

        __asm__ volatile(&quot;incq %0&quot; :: &quot;m&quot; (a[0]));

        printf(&quot;a[0] - b = %lu\n&quot;, a[0] - b);
        return 0;
}
</code></pre>
<p>This example may be artificial, but it illustrates the main idea. Here we have an array of integers and one integer variable. The example is pretty simple, we take the first element of <code>a</code> and increment its value. After this we subtract the value of <code>b</code> from the  first element of <code>a</code>. In the end we print the result. If we compile and run this simple example the result may surprise you:</p>
<pre><code>~$ gcc -O3  test.c -o test
~$ ./test
a[0] - b = 9999999995
</code></pre>
<p>The result is <code>a[0] - b = 9999999995</code> here, but why? We incremented <code>a[0]</code> and subtracted <code>b</code>, so the result should be <code>a[0] - b = 9999999996</code> here.</p>
<p>If we have a look at the assembler output for this example:</p>
<pre><code class="language-assembly">00000000004004f6 &lt;main&gt;:
  4004b4:       48 b8 00 e4 0b 54 02    movabs $0x2540be400,%rax
  4004be:       48 89 04 24             mov    %rax,(%rsp)
  ...
  ...
  ...
  40050e:       ff 44 24 f0             incq   (%rsp)

  4004d8:       48 be fb e3 0b 54 02    movabs $0x2540be3fb,%rsi
</code></pre>
<p>we will see that the first element of the <code>a</code> contains the value <code>0x2540be400</code> (<code>10000000000</code>). The last two lines of code are the actual calculations.</p>
<p>We see our increment instruction with <code>incq</code> but then just a move of <code>0x2540be3fb</code> (<code>9999999995</code>) to the <code>%rsi</code> register. This looks strange.</p>
<p>The problem is we have passed the <code>-O3</code> flag to <code>gcc</code>, so the compiler did some constant folding and propagation to determine the result of <code>a[0] - 5</code> at compile time and reduced it to a <code>movabs</code> with a constant <code>0x2540be3fb</code> or <code>9999999995</code> in runtime.</p>
<p>Let's now add <code>memory</code> to the clobbers list:</p>
<pre><code class="language-C">__asm__ volatile(&quot;incq %0&quot; :: &quot;m&quot; (a[0]) : &quot;memory&quot;);
</code></pre>
<p>and the new result of running this is:</p>
<pre><code>~$ gcc -O3  test.c -o test
~$ ./test
a[0] - b = 9999999996
</code></pre>
<p>Now the result is correct. If we look at the assembly output again:</p>
<pre><code class="language-assembly">00000000004004f6 &lt;main&gt;:
  400404:       48 b8 00 e4 0b 54 02    movabs $0x2540be400,%rax
  40040b:       00 00 00
  40040e:       48 89 04 24             mov    %rax,(%rsp)
  400412:       48 c7 44 24 08 00 00    movq   $0x0,0x8(%rsp)
  400419:       00 00
  40041b:       48 c7 44 24 10 01 00    movq   $0x1,0x10(%rsp)
  400422:       00 00
  400424:       48 ff 04 24             incq   (%rsp)
  400428:       48 8b 04 24             mov    (%rsp),%rax
  400431:       48 8d 70 fb             lea    -0x5(%rax),%rsi
</code></pre>
<p>we will see one difference here which is in the last two lines:</p>
<pre><code class="language-assembly">  400428:       48 8b 04 24             mov    (%rsp),%rax
  400431:       48 8d 70 fb             lea    -0x5(%rax),%rsi
</code></pre>
<p>Instead of constant folding, <code>GCC</code> now preserves calculations in the assembly and places the value of <code>a[0]</code> in the <code>%rax</code> register afterwards. In the end it just subtracts the constant value of <code>b</code> from the <code>%rax</code> register and puts the result to the <code>%rsi</code>.</p>
<p>Besides the <code>memory</code> specifier, we also see a new constraint here - <code>m</code>. This constraint tells the compiler to use the address of <code>a[0]</code>, instead of its value. So, now we are finished with <code>clobbers</code> and we may continue by looking at other constraints supported by <code>GCC</code> besides <code>r</code> and <code>m</code> which we have already seen.</p>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p>Now that we are finished with all three parts of an inline assembly statement, let's return to constraints. We already saw some constraints in the previous parts, like <code>r</code> which represents a <code>register</code> operand, <code>m</code> which represents a memory operand and <code>0-9</code> which represent a reused, indexed operand. Besides these <code>GCC</code> provides support for other constraints. For example the <code>i</code> constraint represents an <code>immediate</code> integer operand with known value:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

int main(void)
{
        int a = 0;

        __asm__(&quot;movl %1, %0&quot; : &quot;=r&quot;(a) : &quot;i&quot;(100));
        printf(&quot;a = %d\n&quot;, a);
        return 0;
}
</code></pre>
<p>The result is:</p>
<pre><code>~$ gcc test.c -o test
~$ ./test
a = 100
</code></pre>
<p>Or for example <code>I</code> which represents an immediate 32-bit integer. The difference between <code>i</code> and <code>I</code> is that <code>i</code> is general, whereas <code>I</code> is strictly specified to 32-bit integer data. For example if you try to compile the following code:</p>
<pre><code class="language-C">unsigned long test_asm(int nr)
{
        unsigned long a = 0;

        __asm__(&quot;movq %1, %0&quot; : &quot;=r&quot;(a) : &quot;I&quot;(0xffffffffffff));
        return a;
}
</code></pre>
<p>you will get an error:</p>
<pre><code>$ gcc -O3 test.c -o test
test.c: In function ‘test_asm’:
test.c:7:9: warning: asm operand 1 probably doesn’t match constraints
         __asm__(&quot;movq %1, %0&quot; : &quot;=r&quot;(a) : &quot;I&quot;(0xffffffffffff));
         ^
test.c:7:9: error: impossible constraint in ‘asm’
</code></pre>
<p>when at the same time:</p>
<pre><code class="language-C">unsigned long test_asm(int nr)
{
        unsigned long a = 0;

        __asm__(&quot;movq %1, %0&quot; : &quot;=r&quot;(a) : &quot;i&quot;(0xffffffffffff));
        return a;
}
</code></pre>
<p>works perfectly:</p>
<pre><code>~$ gcc -O3 test.c -o test
~$ echo $?
0
</code></pre>
<p><code>GCC</code> also supports <code>J</code>, <code>K</code>, <code>N</code> constraints for integer constants in the range of 0-63 bits, signed 8-bit integer constants and unsigned 8-bit integer constants respectively. The <code>o</code> constraint represents a memory operand with an <code>offsetable</code> memory address. For example:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

int main(void)
{
        static unsigned long arr[3] = {0, 1, 2};
        static unsigned long element;

        __asm__ volatile(&quot;movq 16+%1, %0&quot; : &quot;=r&quot;(element) : &quot;o&quot;(arr));
        printf(&quot;%lu\n&quot;, element);
        return 0;
}
</code></pre>
<p>The result, as expected:</p>
<pre><code>~$ gcc -O3 test.c -o test
~$ ./test
2
</code></pre>
<p>All of these constraints may be combined (so long as they do not conflict). In this case the compiler will choose the best one for a certain situation. For example:</p>
<pre><code class="language-C">unsigned long a = 10;
unsigned long b = 20;

void main(void)
{
    __asm__ (&quot;movq %1,%0&quot; : &quot;=mr&quot;(b) : &quot;rm&quot;(a));
}
</code></pre>
<p>will use a memory operand:</p>
<pre><code class="language-assembly">main:
        movq a(%rip),b(%rip)
        ret
b:
        .quad   20
a:
        .quad   10
</code></pre>
<p>instead of direct usage of general purpose registers.</p>
<p>That's about all of the commonly used constraints in inline assembly statements. You can find more in the official <a href="https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints">documentation</a>.</p>
<h2 id="architecture-specific-constraints"><a class="header" href="#architecture-specific-constraints">Architecture specific constraints</a></h2>
<p>Before we finish, let's look at the set of special constraints. These constrains are architecture specific and as this book is specific to the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture, we will look at constraints related to it. First of all the set of <code>a</code> ... <code>d</code> and also <code>S</code> and <code>D</code> constraints represent <a href="https://en.wikipedia.org/wiki/Processor_register">generic purpose</a> registers. In this case the <code>a</code> constraint corresponds to <code>%al</code>, <code>%ax</code>, <code>%eax</code> or <code>%rax</code> register depending on instruction size. The <code>S</code> and <code>D</code> constraints are <code>%si</code> and <code>%di</code> registers respectively. For example let's take our previous example. We can see in its assembly output that value of the <code>a</code> variable is stored in the <code>%eax</code> register. Now let's look at the assembly output of the same assembly, but with other constraint:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

int a = 1;

int main(void)
{
        int b;
        __asm__ (&quot;movq %1,%0&quot; : &quot;=r&quot;(b) : &quot;d&quot;(a));
        return b;
}
</code></pre>
<p>Now we see that value of the <code>a</code> variable will be stored in the <code>%rax</code> register:</p>
<pre><code class="language-assembly">0000000000400400 &lt;main&gt;:
  4004aa:       48 8b 05 6f 0b 20 00    mov    0x200b6f(%rip),%rax        # 601020 &lt;a&gt;
</code></pre>
<p>The <code>f</code> and <code>t</code> constraints represent any floating point stack register - <code>%st</code> and the top of the floating point stack respectively. The <code>u</code> constraint represents the second value from the top of the floating point stack.</p>
<p>That's all. You may find more details about <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> and general constraints in the official <a href="https://gcc.gnu.org/onlinedocs/gcc/Machine-Constraints.html#Machine-Constraints">documentation</a>.</p>
<h2 id="links-55"><a class="header" href="#links-55">Links</a></h2>
<ul>
<li><a href="https://github.com/torvalds/linux">Linux kernel source code</a></li>
<li><a href="https://en.wikipedia.org/wiki/Assembly_language">assembly programming language</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html">GNU extension</a></li>
<li><a href="https://en.wikipedia.org/wiki/Global_Descriptor_Table">Global Descriptor Table</a></li>
<li><a href="https://en.wikipedia.org/wiki/Processor_register">Processor registers</a></li>
<li><a href="http://x86.renejeschke.de/html/file_module_x86_id_5.html">add instruction</a></li>
<li><a href="https://en.wikipedia.org/wiki/FLAGS_register">flags register</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Machine-Constraints.html#Machine-Constraints">constraints</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="misc"><a class="header" href="#misc">Misc</a></h1>
<p>This chapter contains parts which are not directly related to the Linux kernel source code and implementation of different subsystems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-kernel-development"><a class="header" href="#linux-kernel-development">Linux kernel development</a></h1>
<h2 id="introduction-16"><a class="header" href="#introduction-16">Introduction</a></h2>
<p>As you already may know, I've started a series of <a href="https://0xax.github.io/categories/assembler/">blog posts</a> about assembler programming for <code>x86_64</code> architecture in the last year. I have never written a line of low-level code before this moment, except for a couple of toy <code>Hello World</code> examples in university. It was a long time ago and, as I already said, I didn't write low-level code at all. Some time ago I became interested in such things. I understood that I can write programs, but didn't actually understand how my program is arranged.</p>
<p>After writing some assembler code I began to understand how my program looks after compilation, <strong>approximately</strong>. But anyway, I didn't understand many other things. For example: what occurs when the <code>syscall</code> instruction is executed in my assembler, what occurs when the <code>printf</code> function starts to work or how can my program talk with other computers via network. <a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">Assembler</a> programming language didn't give me answers to my questions and I decided to go deeper in my research. I started to learn from the source code of the Linux kernel and tried to understand the things that I'm interested in. The source code of the Linux kernel didn't give me the answers to <strong>all</strong> of my questions, but now my knowledge about the Linux kernel and the processes around it is much better.</p>
<p>I'm writing this part nine and a half months after I've started to learn from the source code of the Linux kernel and published the first <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-1">part</a> of this book. Now it contains forty parts and it is not the end. I decided to write this series about the Linux kernel mostly for myself. As you know the Linux kernel is very huge piece of code and it is easy to forget what does this or that part of the Linux kernel mean and how does it implement something. But soon the <a href="https://github.com/0xAX/linux-insides">linux-insides</a> repo became popular and after nine months it has <code>9096</code> stars:</p>
<p><img src="Misc/images/github.png" alt="github" /></p>
<p>It seems that people are interested in the insides of the Linux kernel. Besides this, in all the time that I have been writing <code>linux-insides</code>, I have received many questions from different people about how to begin contributing to the Linux kernel. Generally people are interested in contributing to open source projects and the Linux kernel is not an exception:</p>
<p><img src="Misc/images/google_linux.png" alt="google-linux" /></p>
<p>So, it seems that people are interested in the Linux kernel development process. I thought it would be strange if a book about the Linux kernel would not contain a part describing how to take a part in the Linux kernel development and that's why I decided to write it. You will not find information about why you should be interested in contributing to the Linux kernel in this part. But if you are interested how to start with Linux kernel development, this part is for you.</p>
<p>Let's start.</p>
<h2 id="how-to-start-with-linux-kernel"><a class="header" href="#how-to-start-with-linux-kernel">How to start with Linux kernel</a></h2>
<p>First of all, let's see how to get, build, and run the Linux kernel. You can run your custom build of the Linux kernel in two ways:</p>
<ul>
<li>Run the Linux kernel on a virtual machine;</li>
<li>Run the Linux kernel on real hardware.</li>
</ul>
<p>I'll provide descriptions for both methods. Before we start doing anything with the Linux kernel, we need to get it. There are a couple of ways to do this depending on your purpose. If you just want to update the current version of the Linux kernel on your computer, you can use the instructions specific to your Linux <a href="https://en.wikipedia.org/wiki/Linux_distribution">distro</a>.</p>
<p>In the first case you just need to download new version of the Linux kernel with the <a href="https://en.wikipedia.org/wiki/Package_manager">package manager</a>. For example, to upgrade the version of the Linux kernel to <code>4.1</code> for <a href="http://releases.ubuntu.com/15.04/">Ubuntu (Vivid Vervet)</a>, you will just need to execute the following commands:</p>
<pre><code>$ sudo add-apt-repository ppa:kernel-ppa/ppa
$ sudo apt-get update
</code></pre>
<p>After this execute this command:</p>
<pre><code>$ apt-cache showpkg linux-headers
</code></pre>
<p>and choose the version of the Linux kernel in which you are interested. In the end execute the next command and replace <code>${version}</code> with the version that you chose in the output of the previous command:</p>
<pre><code>$ sudo apt-get install linux-headers-${version} linux-headers-${version}-generic linux-image-${version}-generic --fix-missing
</code></pre>
<p>and reboot your system. After the reboot you will see the new kernel in the <a href="https://en.wikipedia.org/wiki/GNU_GRUB">grub</a> menu.</p>
<p>In the other way if you are interested in the Linux kernel development, you will need to get the source code of the Linux kernel. You can find it on the <a href="https://kernel.org/">kernel.org</a> website and download an archive with the Linux kernel source code. Actually the Linux kernel development process is fully built around <code>git</code> <a href="https://en.wikipedia.org/wiki/Version_control">version control system</a>. So you can get it with <code>git</code> from the <code>kernel.org</code>:</p>
<pre><code>$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
</code></pre>
<p>I don't know how about you, but I prefer <code>github</code>. There is a <a href="https://github.com/torvalds/linux">mirror</a> of the Linux kernel mainline repository, so you can clone it with:</p>
<pre><code>$ git clone git@github.com:torvalds/linux.git
</code></pre>
<p>I  use my own <a href="https://github.com/0xAX/linux">fork</a> for development and when I want to pull updates from the main repository I just execute the following command:</p>
<pre><code>$ git checkout master
$ git pull upstream master
</code></pre>
<p>Note that the remote name of the main repository is <code>upstream</code>. To add a new remote with the main Linux repository you can execute:</p>
<pre><code>git remote add upstream git@github.com:torvalds/linux.git
</code></pre>
<p>After this you will have two remotes:</p>
<pre><code>~/dev/linux (master) $ git remote -v
origin	git@github.com:0xAX/linux.git (fetch)
origin	git@github.com:0xAX/linux.git (push)
upstream	https://github.com/torvalds/linux.git (fetch)
upstream	https://github.com/torvalds/linux.git (push)
</code></pre>
<p>One is of your fork (<code>origin</code>) and the second is for the main repository (<code>upstream</code>).</p>
<p>Now that we have a local copy of the Linux kernel source code, we need to configure and build it. The Linux kernel can be configured in different ways. The simplest way is to just copy the configuration file of the already installed kernel that is located in the <code>/boot</code> directory:</p>
<pre><code>$ sudo cp /boot/config-$(uname -r) ~/dev/linux/.config
</code></pre>
<p>If your current Linux kernel was built with the support for access to the <code>/proc/config.gz</code> file, you can copy your actual kernel configuration file with this command:</p>
<pre><code>$ cat /proc/config.gz | gunzip &gt; ~/dev/linux/.config
</code></pre>
<p>If you are not satisfied with the standard kernel configuration that is provided by the maintainers of your distro, you can configure the Linux kernel manually. There are a couple of ways to do it. The Linux kernel root <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Makefile">Makefile</a> provides a set of targets that allows you to configure it. For example <code>menuconfig</code> provides a menu-driven interface for the kernel configuration:</p>
<p><img src="Misc/images/menuconfig.png" alt="menuconfig" /></p>
<p>The <code>defconfig</code> argument generates the default kernel configuration file for the current architecture, for example <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/configs/x86_64_defconfig">x86_64 defconfig</a>. You can pass the <code>ARCH</code> command line argument to <code>make</code> to build <code>defconfig</code> for the given architecture:</p>
<pre><code>$ make ARCH=arm64 defconfig
</code></pre>
<p>The <code>allnoconfig</code>, <code>allyesconfig</code> and <code>allmodconfig</code> arguments allow you to generate a new configuration file where all options will be disabled, enabled, and enabled as modules respectively. The <code>nconfig</code> command line arguments that provides <code>ncurses</code> based program with menu to configure Linux kernel:</p>
<p><img src="Misc/images/nconfig.png" alt="nconfig" /></p>
<p>And even <code>randconfig</code> to generate random Linux kernel configuration file. I will not write about how to configure the Linux kernel or which options to enable because it makes no sense to do so for two reasons: First of all I do not know your hardware and second, if you know your hardware, the only remaining task is to find out how to use programs for kernel configuration, and all of them are pretty simple to use.</p>
<p>OK, we now have the source code of the Linux kernel and configured it. The next step is the compilation of the Linux kernel. The simplest way to compile Linux kernel is to just execute:</p>
<pre><code>$ make
scripts/kconfig/conf  --silentoldconfig Kconfig
#
# configuration written to .config
#
  CHK     include/config/kernel.release
  UPD     include/config/kernel.release
  CHK     include/generated/uapi/linux/version.h
  CHK     include/generated/utsrelease.h
  ...
  ...
  ...
  OBJCOPY arch/x86/boot/vmlinux.bin
  AS      arch/x86/boot/header.o
  LD      arch/x86/boot/setup.elf
  OBJCOPY arch/x86/boot/setup.bin
  BUILD   arch/x86/boot/bzImage
  Setup is 15740 bytes (padded to 15872 bytes).
System is 4342 kB
CRC 82703414
Kernel: arch/x86/boot/bzImage is ready  (#73)
</code></pre>
<p>To increase the speed of kernel compilation you can pass <code>-jN</code> command line argument to <code>make</code>, where <code>N</code> specifies the number of commands to run simultaneously:</p>
<pre><code>$ make -j8
</code></pre>
<p>If you want to build Linux kernel for an architecture that differs from your current, the simplest way to do it pass two arguments:</p>
<ul>
<li><code>ARCH</code> command line argument and the name of the target architecture;</li>
<li><code>CROSS_COMPILER</code> command line argument and the cross-compiler tool prefix;</li>
</ul>
<p>For example if we want to compile the Linux kernel for the <a href="https://en.wikipedia.org/wiki/ARM_architecture#AArch64_features">arm64</a> with default kernel configuration file, we need to execute following command:</p>
<pre><code>$ make -j4 ARCH=arm64 CROSS_COMPILER=aarch64-linux-gnu- defconfig
$ make -j4 ARCH=arm64 CROSS_COMPILER=aarch64-linux-gnu-
</code></pre>
<p>As result of compilation we can see the compressed kernel - <code>arch/x86/boot/bzImage</code>. Now that we have compiled the kernel, we can either install it on our computer or just run it in an emulator.</p>
<h2 id="installing-linux-kernel"><a class="header" href="#installing-linux-kernel">Installing Linux kernel</a></h2>
<p>As I already wrote we will consider two ways to launch new kernel: in the first case we can install and run the new version of the Linux kernel on the real hardware and the second is launch the Linux kernel on a virtual machine. In the previous paragraph we saw how to build the Linux kernel from source code and as a result we have got compressed image:</p>
<pre><code>...
...
...
Kernel: arch/x86/boot/bzImage is ready  (#73)
</code></pre>
<p>After we have got the <a href="https://en.wikipedia.org/wiki/Vmlinux#bzImage">bzImage</a> we need to install <code>headers</code>, <code>modules</code> of the new Linux kernel with the:</p>
<pre><code>$ sudo make headers_install
$ sudo make modules_install
</code></pre>
<p>and directly the kernel itself:</p>
<pre><code>$ sudo make install
</code></pre>
<p>From this moment we have installed new version of the Linux kernel and now we must tell the <code>bootloader</code> about it. Of course we can add it manually by the editing of the <code>/boot/grub2/grub.cfg</code> configuration file, but I prefer to use a script for this purpose. I'm using two different Linux distros: Fedora and Ubuntu. There are two different ways to update the <a href="https://en.wikipedia.org/wiki/GNU_GRUB">grub</a> configuration file. I'm using following script for this purpose:</p>
<pre><code class="language-shell">#!/bin/bash

source &quot;term-colors&quot;

DISTRIBUTIVE=$(cat /etc/*-release | grep NAME | head -1 | sed -n -e 's/NAME\=//p')
echo -e &quot;Distributive: ${Green}${DISTRIBUTIVE}${Color_Off}&quot;

if [[ &quot;$DISTRIBUTIVE&quot; == &quot;Fedora&quot; ]] ;
then
    su -c 'grub2-mkconfig -o /boot/grub2/grub.cfg'
else
    sudo update-grub
fi

echo &quot;${Green}Done.${Color_Off}&quot;
</code></pre>
<p>This is the last step of the new Linux kernel installation and after this you can reboot your computer and select new version of the kernel during boot.</p>
<p>The second case is to launch new Linux kernel in the virtual machine. I prefer <a href="https://en.wikipedia.org/wiki/QEMU">qemu</a>. First of all we need to build initial ramdisk - <a href="https://en.wikipedia.org/wiki/Initrd">initrd</a> for this. The <code>initrd</code> is a temporary root file system that is used by the Linux kernel during initialization process while other filesystems are not mounted. We can build <code>initrd</code> with the following commands:</p>
<p>First of all we need to download <a href="https://en.wikipedia.org/wiki/BusyBox">busybox</a> and run <code>menuconfig</code> for its configuration:</p>
<pre><code class="language-shell">$ mkdir initrd
$ cd initrd
$ curl http://busybox.net/downloads/busybox-1.23.2.tar.bz2 | tar xjf -
$ cd busybox-1.23.2/
$ make menuconfig
$ make -j4
</code></pre>
<p><code>busybox</code> is an executable file - <code>/bin/busybox</code> that contains a set of standard tools like <a href="https://en.wikipedia.org/wiki/GNU_Core_Utilities">coreutils</a>. In the <code>busybox</code> menu we need to enable: <code>Build BusyBox as a static binary (no shared libs)</code> option:</p>
<p><img src="https://i.imgur.com/TxPRCzQ.png" alt="busysbox menu" /></p>
<p>We can find this menu in the:</p>
<pre><code>Busybox Settings
--&gt; Build Options
</code></pre>
<p>After this we exit from the <code>busybox</code> configuration menu and execute following commands for building and installation of it:</p>
<pre><code>$ make -j4
$ sudo make install
</code></pre>
<p>Now that <code>busybox</code> is installed, we can begin building our <code>initrd</code>. To do this, we go to the previous <code>initrd</code> directory and:</p>
<pre><code>$ cd ..
$ mkdir -p initramfs
$ cd initramfs
$ mkdir -pv {bin,sbin,etc,proc,sys,usr/{bin,sbin}}
$ cp -av ../busybox-1.23.2/_install/* .
</code></pre>
<p>copy <code>busybox</code> fields to the <code>bin</code>, <code>sbin</code> and other directories. Now we need to create executable <code>init</code> file that will be executed as a first process in the system. My <code>init</code> file just mounts <a href="https://en.wikipedia.org/wiki/Procfs">procfs</a> and <a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a> filesystems and executed shell:</p>
<pre><code class="language-shell">#!/bin/sh

mount -t proc none /proc
mount -t sysfs none /sys

exec /bin/sh
</code></pre>
<p>Now we can create an archive that will be our <code>initrd</code>:</p>
<pre><code>$ find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ~/dev/initrd_x86_64.gz
</code></pre>
<p>We can now run our kernel in the virtual machine. As I already wrote I prefer <a href="https://en.wikipedia.org/wiki/QEMU">qemu</a> for this. We can run our kernel with the following command:</p>
<pre><code>$ qemu-system-x86_64 -snapshot -m 8GB -serial stdio -kernel ~/dev/linux/arch/x86_64/boot/bzImage -initrd ~/dev/initrd_x86_64.gz -append &quot;root=/dev/sda1 ignore_loglevel&quot;
</code></pre>
<p><img src="Misc/images/qemu.png" alt="qemu" /></p>
<p>From now we can run the Linux kernel in the virtual machine and this means that we can begin to change and test the kernel.</p>
<p>Consider using <a href="https://github.com/ivandavidov/minimal">ivandaviov/minimal</a> or <a href="https://buildroot.org/">Buildroot</a> to automate the process of generating initrd.</p>
<h2 id="getting-started-with-the-linux-kernel-development"><a class="header" href="#getting-started-with-the-linux-kernel-development">Getting started with the Linux Kernel Development</a></h2>
<p>The main point of this paragraph is to answer two questions: what to do and what not to do before sending your first patch to the Linux kernel. Please, do not confuse this <code>to do</code> with <code>todo</code>. I have no answer what you can fix in the Linux kernel. I just want to tell you my workflow during experimenting with the Linux kernel source code.</p>
<p>First of all I pull the latest updates from Linus's repo with the following commands:</p>
<pre><code>$ git checkout master
$ git pull upstream master
</code></pre>
<p>As soon as your local copy of the Linux kernel source code is in sync with the <a href="https://github.com/torvalds/linux">mainline</a> repository, we can start to apply changes to it. I already wrote, I have no advice for where you should start and what <code>TODO</code> to choose within the Linux kernel. But the best place for newbies is the <code>staging</code> tree. In other words the set of drivers from the <a href="https://github.com/torvalds/linux/tree/master/drivers/staging">drivers/staging</a> directory. The maintainer of this tree is <a href="https://en.wikipedia.org/wiki/Greg_Kroah-Hartman">Greg Kroah-Hartman</a> and the <code>staging</code> drivers are a good target for trivial patch fixes. Let's look at this simple example, that describes how to generate a patch, check it and send it to the <a href="https://lkml.org/">Linux kernel mail listing</a>.</p>
<p>If we look in the driver for the <a href="https://github.com/torvalds/linux/tree/master/drivers/staging/dgap">Digi International EPCA PCI</a> based devices, we will see the <code>dgap_sindex</code> function on line 295:</p>
<pre><code class="language-C">static char *dgap_sindex(char *string, char *group)
{
	char *ptr;

	if (!string || !group)
		return NULL;

	for (; *string; string++) {
		for (ptr = group; *ptr; ptr++) {
			if (*ptr == *string)
				return string;
		}
	}

	return NULL;
}
</code></pre>
<p>This function looks for a match of any character in the group and returns that position. During research of source code of the Linux kernel, I have noted that the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/lib/string.c#L473">lib/string.c</a> source code file contains the implementation of the <code>strpbrk</code> function that does the same thing as <code>dgap_sinidex</code>. It is not a good idea to use a custom implementation of a function that already exists, so we can remove the <code>dgap_sindex</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/drivers/staging/dgap/dgap.c">drivers/staging/dgap/dgap.c</a> source code file and use the <code>strpbrk</code> instead.</p>
<p>First of all let's create new <code>git</code> branch based on the current master that synced with the Linux kernel mainline repo:</p>
<pre><code>$ git checkout -b &quot;dgap-remove-dgap_sindex&quot;
</code></pre>
<p>And now we can replace the <code>dgap_sindex</code> with the <code>strpbrk</code>. After we did all changes we need to recompile the Linux kernel or just <a href="https://github.com/torvalds/linux/tree/master/drivers/staging/dgap">dgap</a> directory. Do not forget to enable this driver in the kernel configuration. You can find it in the:</p>
<pre><code>Device Drivers
--&gt; Staging drivers
----&gt; Digi EPCA PCI products
</code></pre>
<p><img src="Misc/images/dgap_menu.png" alt="dgap menu" /></p>
<p>Now is time to make commit. I'm using following combination for this:</p>
<pre><code>$ git add .
$ git commit -s -v
</code></pre>
<p>After the last command an editor will be opened that will be chosen from <code>$GIT_EDITOR</code> or <code>$EDITOR</code> environment variable. The <code>-s</code> command line argument will add <code>Signed-off-by</code> line by the committer at the end of the commit log message. You can find this line in the end of each commit message, for example - <a href="https://github.com/torvalds/linux/commit/00cc1633816de8c95f337608a1ea64e228faf771">00cc1633</a>. The main point of this line is the tracking of who did a change. The <code>-v</code> option show unified diff between the HEAD commit and what would be committed at the bottom of the commit message. It is not necessary, but very useful sometimes. A couple of words about commit message. Actually a commit message consists from two parts:</p>
<p>The first part is on the first line and contains short description of changes. It starts from the <code>[PATCH]</code> prefix followed by a subsystem, driver or architecture name and after <code>:</code> symbol short description. In our case it will be something like this:</p>
<pre><code>[PATCH] staging/dgap: Use strpbrk() instead of dgap_sindex()
</code></pre>
<p>After short description usually we have an empty line and full description of the commit. In our case it will be:</p>
<pre><code>The &lt;linux/string.h&gt; provides strpbrk() function that does the same that the
dgap_sindex(). Let's use already defined function instead of writing custom.
</code></pre>
<p>And the <code>Sign-off-by</code> line in the end of the commit message. Note that each line of a commit message must no be longer than <code>80</code> symbols and commit message must describe your changes in details. Do not just write a commit message like: <code>Custom function removed</code>, you need to describe what you did and why. The patch reviewers must know what they review. Besides this commit messages in this view are very helpful. Each time when we can't understand something, we can use <a href="http://git-scm.com/docs/git-blame">git blame</a> to read description of changes.</p>
<p>After we have committed changes time to generate patch. We can do it with the <code>format-patch</code> command:</p>
<pre><code>$ git format-patch master
0001-staging-dgap-Use-strpbrk-instead-of-dgap_sindex.patch
</code></pre>
<p>We've passed name of the branch (<code>master</code> in this case) to the <code>format-patch</code> command that will generate a patch with the last changes that are in the <code>dgap-remove-dgap_sindex</code> branch and not are in the <code>master</code> branch. As you can note, the <code>format-patch</code> command generates file that contains last changes and has name that is based on the commit short description. If you want to generate a patch with the custom name, you can use <code>--stdout</code> option:</p>
<pre><code>$ git format-patch master --stdout &gt; dgap-patch-1.patch
</code></pre>
<p>The last step after we have generated our patch is to send it to the Linux kernel mailing list. Of course, you can use any email client, <code>git</code> provides a special command for this: <code>git send-email</code>. Before you send your patch, you need to know where to send it. Yes, you can just send it to the Linux kernel mailing list address which is <code>linux-kernel@vger.kernel.org</code>, but it is very likely that the patch will be ignored, because of the large flow of messages. The better choice would be to send the patch to the maintainers of the subsystem where you have made changes. To find the names of these maintainers use the <code>get_maintainer.pl</code> script. All you need to do is pass the file or directory where you wrote code.</p>
<pre><code>$ ./scripts/get_maintainer.pl -f drivers/staging/dgap/dgap.c
Lidza Louina &lt;lidza.louina@gmail.com&gt; (maintainer:DIGI EPCA PCI PRODUCTS)
Mark Hounschell &lt;markh@compro.net&gt; (maintainer:DIGI EPCA PCI PRODUCTS)
Daeseok Youn &lt;daeseok.youn@gmail.com&gt; (maintainer:DIGI EPCA PCI PRODUCTS)
Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt; (supporter:STAGING SUBSYSTEM)
driverdev-devel@linuxdriverproject.org (open list:DIGI EPCA PCI PRODUCTS)
devel@driverdev.osuosl.org (open list:STAGING SUBSYSTEM)
linux-kernel@vger.kernel.org (open list)
</code></pre>
<p>You will see the set of the names and related emails. Now we can send our patch with:</p>
<pre><code>$ git send-email --to &quot;Lidza Louina &lt;lidza.louina@gmail.com&gt;&quot; \
  --cc &quot;Mark Hounschell &lt;markh@compro.net&gt;&quot;                   \
  --cc &quot;Daeseok Youn &lt;daeseok.youn@gmail.com&gt;&quot;                \
  --cc &quot;Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;&quot;      \
  --cc &quot;driverdev-devel@linuxdriverproject.org&quot;               \
  --cc &quot;devel@driverdev.osuosl.org&quot;                           \
  --cc &quot;linux-kernel@vger.kernel.org&quot;
</code></pre>
<p>That's all. The patch is sent and now you only have to wait for feedback from the Linux kernel developers. After you send a patch and a maintainer accepts it, you will find it in the maintainer's repository (for example <a href="https://git.kernel.org/cgit/linux/kernel/git/gregkh/staging.git/commit/?h=staging-testing&amp;id=b9f7f1d0846f15585b8af64435b6b706b25a5c0b">patch</a> that you saw in this part) and after some time the maintainer will send a pull request to Linus and you will see your patch in the mainline repository.</p>
<p>That's all.</p>
<h2 id="some-advice"><a class="header" href="#some-advice">Some advice</a></h2>
<p>In the end of this part I want to give you some advice that will describe what to do and what not to do during development of the Linux kernel:</p>
<ul>
<li>
<p>Think, Think, Think. And think again before you decide to send a patch.</p>
</li>
<li>
<p>Each time when you have changed something in the Linux kernel source code - compile it. After any changes. Again and again. Nobody likes changes that don't even compile.</p>
</li>
<li>
<p>The Linux kernel has a coding style <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/CodingStyle">guide</a> and you need to comply with it. There is great script which can help to check your changes. This script is - <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/scripts/checkpatch.pl">scripts/checkpatch.pl</a>. Just pass source code file with changes to it and you will see:</p>
</li>
</ul>
<pre><code>$ ./scripts/checkpatch.pl -f drivers/staging/dgap/dgap.c
WARNING: Block comments use * on subsequent lines
#94: FILE: drivers/staging/dgap/dgap.c:94:
+/*
+     SUPPORTED PRODUCTS

CHECK: spaces preferred around that '|' (ctx:VxV)
#143: FILE: drivers/staging/dgap/dgap.c:143:
+	{ PPCM,        PCI_DEV_XEM_NAME,     64, (T_PCXM|T_PCLITE|T_PCIBUS) },

</code></pre>
<p>Also you can see problematic places with the help of the <code>git diff</code>:</p>
<p><img src="Misc/images/git_diff.png" alt="git diff" /></p>
<ul>
<li>
<p><a href="https://github.com/torvalds/linux/pull/17#issuecomment-5654674">Linus doesn't accept github pull requests</a></p>
</li>
<li>
<p>If your change consists from some different and unrelated changes, you need to split the changes via separate commits. The <code>git format-patch</code> command will generate patches for each commit and the subject of each patch will contain a <code>vN</code> prefix where the <code>N</code> is the number of the patch. If you are planning to send a series of patches it will be helpful to pass the <code>--cover-letter</code> option to the <code>git format-patch</code> command. This will generate an additional file that will contain the cover letter that you can use to describe what your patchset changes. It is also a good idea to use the <code>--in-reply-to</code> option in the <code>git send-email</code> command. This option allows you to send your patch series in reply to your cover message. The structure of the your patch will look like this for a maintainer:</p>
</li>
</ul>
<pre><code>|--&gt; cover letter
  |----&gt; patch_1
  |----&gt; patch_2
</code></pre>
<p>You need to pass <code>message-id</code> as an argument of the <code>--in-reply-to</code> option that you can find in the output of the <code>git send-email</code>:</p>
<p>It's important that your email be in the <a href="https://en.wikipedia.org/wiki/Plain_text">plain text</a> format. Generally, <code>send-email</code> and <code>format-patch</code> are very useful during development, so look at the documentation for the commands and you'll find some useful options such as: <a href="http://git-scm.com/docs/git-send-email">git send-email</a> and <a href="http://git-scm.com/docs/git-format-patch">git format-patch</a>.</p>
<ul>
<li>
<p>Do not be surprised if you do not get an immediate answer after you send your patch. Maintainers can be very busy.</p>
</li>
<li>
<p>The <a href="https://github.com/torvalds/linux/tree/master/scripts">scripts</a> directory contains many different useful scripts that are related to Linux kernel development. We already saw two scripts from this directory: the <code>checkpatch.pl</code> and the <code>get_maintainer.pl</code> scripts. Outside of those scripts, you can find the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/scripts/stackusage">stackusage</a> script that will print usage of the stack, <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/scripts/extract-vmlinux">extract-vmlinux</a> for extracting an uncompressed kernel image, and many others. Outside of the <code>scripts</code> directory you can find some very useful <a href="https://github.com/lorenzo-stoakes/kernel-scripts">scripts</a> by <a href="https://twitter.com/ljsloz">Lorenzo Stoakes</a> for kernel development.</p>
</li>
<li>
<p>Subscribe to the Linux kernel mailing list. There are a large number of letters every day on <code>lkml</code>, but it is very useful to read them and understand things such as the current state of the Linux kernel. Other than <code>lkml</code> there are <a href="http://vger.kernel.org/vger-lists.html">set</a> mailing listings which are related to the different Linux kernel subsystems.</p>
</li>
<li>
<p>If your patch is not accepted the first time and you receive feedback from Linux kernel developers, make your changes and resend the patch with the <code>[PATCH vN]</code> prefix (where <code>N</code> is the number of patch version). For example:</p>
</li>
</ul>
<pre><code>[PATCH v2] staging/dgap: Use strpbrk() instead of dgap_sindex()
</code></pre>
<p>Also it must contain a changelog that describes all changes from previous patch versions. Of course, this is not an exhaustive list of requirements for Linux kernel development, but some of the most important items were addressed.</p>
<p>Happy Hacking!</p>
<h2 id="conclusion-51"><a class="header" href="#conclusion-51">Conclusion</a></h2>
<p>I hope this will help others join the Linux kernel community!
If you have any questions or suggestions, write me at <a href="mailto:kuleshovmail@gmail.com">email</a> or ping <a href="https://twitter.com/0xAX">me</a> on twitter.</p>
<p>Please note that English is not my first language, and I am really sorry for any inconvenience. If you find any mistakes please let me know via email or send a PR.</p>
<h2 id="links-56"><a class="header" href="#links-56">Links</a></h2>
<ul>
<li><a href="https://0xax.github.io/categories/assembler/">blog posts about assembly programming for x86_64</a></li>
<li><a href="https://en.wikipedia.org/wiki/Assembly_language#Assembler">Assembler</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linux_distribution">distro</a></li>
<li><a href="https://en.wikipedia.org/wiki/Package_manager">package manager</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_GRUB">grub</a></li>
<li><a href="https://kernel.org/">kernel.org</a></li>
<li><a href="https://en.wikipedia.org/wiki/Version_control">version control system</a></li>
<li><a href="https://en.wikipedia.org/wiki/ARM_architecture#AArch64_features">arm64</a></li>
<li><a href="https://en.wikipedia.org/wiki/Vmlinux#bzImage">bzImage</a></li>
<li><a href="https://en.wikipedia.org/wiki/QEMU">qemu</a></li>
<li><a href="https://en.wikipedia.org/wiki/Initrd">initrd</a></li>
<li><a href="https://en.wikipedia.org/wiki/BusyBox">busybox</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_Core_Utilities">coreutils</a></li>
<li><a href="https://en.wikipedia.org/wiki/Procfs">procfs</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a></li>
<li><a href="https://lkml.org/">Linux kernel mail listing archive</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/CodingStyle">Linux kernel coding style guide</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/SubmittingPatches">How to Get Your Change Into the Linux Kernel</a></li>
<li><a href="http://kernelnewbies.org/">Linux Kernel Newbies</a></li>
<li><a href="https://en.wikipedia.org/wiki/Plain_text">plain text</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="process-of-the-linux-kernel-building"><a class="header" href="#process-of-the-linux-kernel-building">Process of the Linux kernel building</a></h1>
<h2 id="introduction-17"><a class="header" href="#introduction-17">Introduction</a></h2>
<p>I won't tell you how to build and install a custom Linux kernel on your machine. If you need help with this, you can find many <a href="https://encrypted.google.com/search?q=building+linux+kernel#q=building+linux+kernel+from+source+code">resources</a> that will help you do it. Instead, we will learn what occurs when you execute <code>make</code> in the root directory of the Linux kernel source code.</p>
<p>When I started to study the source code of the Linux kernel, the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Makefile">makefile</a> was the first file that I opened. And it was scary :). The <a href="https://en.wikipedia.org/wiki/Make_%28software%29">makefile</a> contained <code>1591</code> lines of code when I wrote this part and the kernel was the <a href="https://github.com/torvalds/linux/commit/52721d9d3334c1cb1f76219a161084094ec634dc">4.2.0-rc3</a> release.</p>
<p>This makefile is the top makefile in the Linux kernel source code and the kernel building starts here. Yes, it is big, but moreover, if you've read the source code of the Linux kernel you may have noted that all directories containing source code has its own makefile. Of course it is not possible to describe how each source file is compiled and linked, so we will only study the standard compilation case. You will not find here building of the kernel's documentation, cleaning of the kernel source code, <a href="https://en.wikipedia.org/wiki/Ctags">tags</a> generation, <a href="https://en.wikipedia.org/wiki/Cross_compiler">cross-compilation</a> related stuff, etc... We will start from the <code>make</code> execution with the standard kernel configuration file and will finish with the building of the <a href="https://en.wikipedia.org/wiki/Vmlinux#bzImage">bzImage</a>.</p>
<p>It would be better if you're already familiar with the <a href="https://en.wikipedia.org/wiki/Make_%28software%29">make</a> util, but I will try to describe every piece of code in this part anyway.</p>
<p>So let's start.</p>
<h2 id="preparation-before-the-kernel-compilation"><a class="header" href="#preparation-before-the-kernel-compilation">Preparation before the kernel compilation</a></h2>
<p>There are many things to prepare before the kernel compilation can be started. The main point here is to find and configure
the type of compilation, to parse command line arguments that are passed to <code>make</code>, etc... So let's dive into the top <code>Makefile</code> of Linux kernel.</p>
<p>The top <code>Makefile</code> of Linux kernel is responsible for building two major products: <a href="https://en.wikipedia.org/wiki/Vmlinux">vmlinux</a> (the resident kernel image) and the modules (any module files). The <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Makefile">Makefile</a> of the Linux kernel starts with the definition of following variables:</p>
<pre><code class="language-Makefile">VERSION = 4
PATCHLEVEL = 2
SUBLEVEL = 0
EXTRAVERSION = -rc3
NAME = Hurr durr I'm a sheep
</code></pre>
<p>These variables determine the current version of Linux kernel and are used in different places, for example in the forming of the <code>KERNELVERSION</code> variable in the same <code>Makefile</code>:</p>
<pre><code class="language-Makefile">KERNELVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)
</code></pre>
<p>After this we can see a couple of <code>ifeq</code> conditions that check some of the parameters passed to <code>make</code>. The Linux kernel <code>makefiles</code> provides a special <code>make help</code> target that prints all available targets and some of the command line arguments that can be passed to <code>make</code>. For example : <code>make V=1</code> =&gt; verbose build. The first <code>ifeq</code> checks whether the <code>V=n</code> option is passed to <code>make</code>:</p>
<pre><code class="language-Makefile">ifeq (&quot;$(origin V)&quot;, &quot;command line&quot;)
  KBUILD_VERBOSE = $(V)
endif
ifndef KBUILD_VERBOSE
  KBUILD_VERBOSE = 0
endif

ifeq ($(KBUILD_VERBOSE),1)
  quiet =
  Q =
else
  quiet=quiet_
  Q = @
endif

export quiet Q KBUILD_VERBOSE
</code></pre>
<p>If this option is passed to <code>make</code>, we set the <code>KBUILD_VERBOSE</code> variable to the value of <code>V</code> option. Otherwise we set the <code>KBUILD_VERBOSE</code> variable to zero. After this we check the value of <code>KBUILD_VERBOSE</code> variable and set values of the <code>quiet</code> and <code>Q</code> variables depending on the value of <code>KBUILD_VERBOSE</code> variable. The <code>@</code> symbols suppress the output of command. And if it is present before a command the output will be something like this: <code>CC scripts/mod/empty.o</code> instead of <code>Compiling .... scripts/mod/empty.o</code>. In the end we just export all of these variables. The next <code>ifeq</code> statement checks that <code>O=/dir</code> option was passed to the <code>make</code>. This option allows to locate all output files in the given <code>dir</code>:</p>
<pre><code class="language-Makefile">ifeq ($(KBUILD_SRC),)

ifeq (&quot;$(origin O)&quot;, &quot;command line&quot;)
  KBUILD_OUTPUT := $(O)
endif

ifneq ($(KBUILD_OUTPUT),)
saved-output := $(KBUILD_OUTPUT)
KBUILD_OUTPUT := $(shell mkdir -p $(KBUILD_OUTPUT) &amp;&amp; cd $(KBUILD_OUTPUT) \
								&amp;&amp; /bin/pwd)
$(if $(KBUILD_OUTPUT),, \
     $(error failed to create output directory &quot;$(saved-output)&quot;))

sub-make: FORCE
	$(Q)$(MAKE) -C $(KBUILD_OUTPUT) KBUILD_SRC=$(CURDIR) \
	-f $(CURDIR)/Makefile $(filter-out _all sub-make,$(MAKECMDGOALS))

skip-makefile := 1
endif # ifneq ($(KBUILD_OUTPUT),)
endif # ifeq ($(KBUILD_SRC),)
</code></pre>
<p>We check the <code>KBUILD_SRC</code> that represents the top directory of the kernel source code and whether it is empty (it is empty when the makefile is executed for the first time). We then set the <code>KBUILD_OUTPUT</code> variable to the value passed with the <code>O</code> option (if this option was passed). In the next step we check this <code>KBUILD_OUTPUT</code> variable and if it is set, we do following things:</p>
<ul>
<li>Store the value of <code>KBUILD_OUTPUT</code> in the temporary <code>saved-output</code> variable;</li>
<li>Try to create the given output directory;</li>
<li>Check that directory created, in other way print error message;</li>
<li>If the custom output directory was created successfully, execute <code>make</code> again with the new directory (see the <code>-C</code> option).</li>
</ul>
<p>The next <code>ifeq</code> statements check that the <code>C</code> or <code>M</code> options passed to <code>make</code>:</p>
<pre><code class="language-Makefile">ifeq (&quot;$(origin C)&quot;, &quot;command line&quot;)
  KBUILD_CHECKSRC = $(C)
endif
ifndef KBUILD_CHECKSRC
  KBUILD_CHECKSRC = 0
endif

ifeq (&quot;$(origin M)&quot;, &quot;command line&quot;)
  KBUILD_EXTMOD := $(M)
endif
</code></pre>
<p>The <code>C</code> option tells the <code>makefile</code> that we need to check all <code>c</code> source code with a tool provided by the <code>$CHECK</code> environment variable, by default it is <a href="https://en.wikipedia.org/wiki/Sparse">sparse</a>. The second <code>M</code> option provides build for the external modules (will not see this case in this part). We also check whether the <code>KBUILD_SRC</code> variable is set, and if it isn't, we set the <code>srctree</code> variable to <code>.</code>:</p>
<pre><code class="language-Makefile">ifeq ($(KBUILD_SRC),)
        srctree := .
endif

objtree	:= .
src		:= $(srctree)
obj		:= $(objtree)

export srctree objtree VPATH
</code></pre>
<p>That tells <code>Makefile</code> that the kernel source tree will be in the current directory where <code>make</code> was executed. We then set <code>objtree</code> and other variables to this directory and export them. The next step is to get value for the <code>SUBARCH</code> variable that represents what the underlying architecture is:</p>
<pre><code class="language-Makefile">SUBARCH := $(shell uname -m | sed -e s/i.86/x86/ -e s/x86_64/x86/ \
				  -e s/sun4u/sparc64/ \
				  -e s/arm.*/arm/ -e s/sa110/arm/ \
				  -e s/s390x/s390/ -e s/parisc64/parisc/ \
				  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ \
				  -e s/sh[234].*/sh/ -e s/aarch64.*/arm64/ )
</code></pre>
<p>As you can see, it executes the <a href="https://en.wikipedia.org/wiki/Uname">uname</a> util that prints information about machine, operating system and architecture. As it gets the output of <code>uname</code>, it parses the output and assigns the result to the <code>SUBARCH</code> variable. Now that we have <code>SUBARCH</code>, we set the <code>SRCARCH</code> variable that provides the directory of the certain architecture and <code>hdr-arch</code> that provides the directory for the header files:</p>
<pre><code class="language-Makefile">ifeq ($(ARCH),i386)
        SRCARCH := x86
endif
ifeq ($(ARCH),x86_64)
        SRCARCH := x86
endif

hdr-arch  := $(SRCARCH)
</code></pre>
<p>Note <code>ARCH</code> is an alias for <code>SUBARCH</code>. In the next step we set the <code>KCONFIG_CONFIG</code> variable that represents path to the kernel configuration file and if it was not set before, it is set to <code>.config</code> by default:</p>
<pre><code class="language-Makefile">KCONFIG_CONFIG	?= .config
export KCONFIG_CONFIG
</code></pre>
<p>and the <a href="https://en.wikipedia.org/wiki/Shell_%28computing%29">shell</a> that will be used during kernel compilation:</p>
<pre><code class="language-Makefile">CONFIG_SHELL := $(shell if [ -x &quot;$$BASH&quot; ]; then echo $$BASH; \
	  else if [ -x /bin/bash ]; then echo /bin/bash; \
	  else echo sh; fi ; fi)
</code></pre>
<p>The next set of variables are related to the compilers used during Linux kernel compilation. We set the host compilers for the <code>c</code> and <code>c++</code> and the flags to be used with them:</p>
<pre><code class="language-Makefile">HOSTCC       = gcc
HOSTCXX      = g++
HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89
HOSTCXXFLAGS = -O2
</code></pre>
<p>Next we get to the <code>CC</code> variable that represents compiler too, so why do we need the <code>HOST*</code> variables? <code>CC</code> is the target compiler that will be used during kernel compilation, but <code>HOSTCC</code> will be used during compilation of the set of the <code>host</code> programs (we will see it soon). After this we can see the definition of <code>KBUILD_MODULES</code> and <code>KBUILD_BUILTIN</code> variables that are used to determine what to compile (modules, kernel, or both):</p>
<pre><code class="language-Makefile">KBUILD_MODULES :=
KBUILD_BUILTIN := 1

ifeq ($(MAKECMDGOALS),modules)
  KBUILD_BUILTIN := $(if $(CONFIG_MODVERSIONS),1)
endif
</code></pre>
<p>Here we can see definition of these variables and the value of <code>KBUILD_BUILTIN</code> variable will depend on the <code>CONFIG_MODVERSIONS</code> kernel configuration parameter if we pass only <code>modules</code> to <code>make</code>. The next step is to include the <code>kbuild</code> file.</p>
<pre><code class="language-Makefile">include scripts/Kbuild.include
</code></pre>
<p>The <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/kbuild/kbuild.txt">Kbuild</a> or <code>Kernel Build System</code> is a special infrastructure to manage building the kernel and its modules. <code>kbuild</code> files have the same syntax as makefiles. The <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/scripts/Kbuild.include">scripts/Kbuild.include</a> file provides some generic definitions for the <code>kbuild</code> system. After including this <code>kbuild</code> file (back in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Makefile">makefile</a>) we can see the definitions of the variables that are related to the different tools used during kernel and module compilation (like linker, compilers, utils from the <a href="http://www.gnu.org/software/binutils/">binutils</a>, etc...):</p>
<pre><code class="language-Makefile">AS		= $(CROSS_COMPILE)as
LD		= $(CROSS_COMPILE)ld
CC		= $(CROSS_COMPILE)gcc
CPP		= $(CC) -E
AR		= $(CROSS_COMPILE)ar
NM		= $(CROSS_COMPILE)nm
STRIP		= $(CROSS_COMPILE)strip
OBJCOPY		= $(CROSS_COMPILE)objcopy
OBJDUMP		= $(CROSS_COMPILE)objdump
AWK		= awk
...
...
...
</code></pre>
<p>We then define two other variables: <code>USERINCLUDE</code> and <code>LINUXINCLUDE</code>, which specify paths to header file directories (public for users in the first case and for kernel in the second case):</p>
<pre><code class="language-Makefile">USERINCLUDE    := \
		-I$(srctree)/arch/$(hdr-arch)/include/uapi \
		-Iarch/$(hdr-arch)/include/generated/uapi \
		-I$(srctree)/include/uapi \
		-Iinclude/generated/uapi \
        -include $(srctree)/include/linux/kconfig.h

LINUXINCLUDE    := \
		-I$(srctree)/arch/$(hdr-arch)/include \
		...
</code></pre>
<p>And the standard flags for the C compiler:</p>
<pre><code class="language-Makefile">KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
		   -fno-strict-aliasing -fno-common \
		   -Werror-implicit-function-declaration \
		   -Wno-format-security \
		   -std=gnu89
</code></pre>
<p>These are not the final compilation flags, as they can be updated in other makefiles (for example kbuilds from <code>arch/</code>). After all of these, all variables will be exported to be available in the other makefiles. The <code>RCS_FIND_IGNORE</code> and the <code>RCS_TAR_IGNORE</code> variables contain files that will be ignored in the version control system:</p>
<pre><code class="language-Makefile">export RCS_FIND_IGNORE := \( -name SCCS -o -name BitKeeper -o -name .svn -o    \
			  -name CVS -o -name .pc -o -name .hg -o -name .git \) \
			  -prune -o
export RCS_TAR_IGNORE := --exclude SCCS --exclude BitKeeper --exclude .svn \
			 --exclude CVS --exclude .pc --exclude .hg --exclude .git
</code></pre>
<p>With that, we have finished all preparations. The next step is building the <code>vmlinux</code> target.</p>
<h2 id="directly-to-the-kernel-build"><a class="header" href="#directly-to-the-kernel-build">Directly to the kernel build</a></h2>
<p>We have now finished all the preparations, and next step in the main makefile is related to the kernel build. Before this moment, nothing has been printed to the terminal by <code>make</code>. But now the first steps of the compilation are started. We need to go to line <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Makefile#L598">598</a> of the Linux kernel top makefile and we will find the <code>vmlinux</code> target there:</p>
<pre><code class="language-Makefile">all: vmlinux
	include arch/$(SRCARCH)/Makefile
</code></pre>
<p>Don't worry that we have missed many lines in Makefile that are between <code>export RCS_FIND_IGNORE.....</code> and <code>all: vmlinux.....</code>. This part of the makefile is responsible for the <code>make *.config</code> targets and as I wrote in the beginning of this part we will see only building of the kernel in a general way.</p>
<p>The <code>all:</code> target is the default when no target is given on the command line. You can see here that we include architecture specific makefile there (in our case it will be <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/Makefile">arch/x86/Makefile</a>). From this moment we will continue from this makefile. As we can see <code>all</code> target depends on the <code>vmlinux</code> target that is defined a little lower in the top makefile:</p>
<pre><code class="language-Makefile">vmlinux: scripts/link-vmlinux.sh $(vmlinux-deps) FORCE
</code></pre>
<p>The <code>vmlinux</code> is the Linux kernel in a statically linked executable file format. The <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/scripts/link-vmlinux.sh">scripts/link-vmlinux.sh</a> script links and combines different compiled subsystems into vmlinux. The second target is the <code>vmlinux-deps</code> that defined as:</p>
<pre><code class="language-Makefile">vmlinux-deps := $(KBUILD_LDS) $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN)
</code></pre>
<p>and consists from the set of the <code>built-in.o</code> from each top directory of the Linux kernel. Later, when we will go through all directories in the Linux kernel, the <code>Kbuild</code> will compile all the <code>$(obj-y)</code> files.  It then calls <code>$(LD) -r</code> to merge these files into one <code>built-in.o</code> file. For this moment we have no <code>vmlinux-deps</code>, so the <code>vmlinux</code> target will not be executed now. For me <code>vmlinux-deps</code> contains following files:</p>
<pre><code>arch/x86/kernel/vmlinux.lds arch/x86/kernel/head_64.o
arch/x86/kernel/head64.o    arch/x86/kernel/head.o
init/built-in.o             usr/built-in.o
arch/x86/built-in.o         kernel/built-in.o
mm/built-in.o               fs/built-in.o
ipc/built-in.o              security/built-in.o
crypto/built-in.o           block/built-in.o
lib/lib.a                   arch/x86/lib/lib.a
lib/built-in.o              arch/x86/lib/built-in.o
drivers/built-in.o          sound/built-in.o
firmware/built-in.o         arch/x86/pci/built-in.o
arch/x86/power/built-in.o   arch/x86/video/built-in.o
net/built-in.o
</code></pre>
<p>The next target that can be executed is following:</p>
<pre><code class="language-Makefile">$(sort $(vmlinux-deps)): $(vmlinux-dirs) ;
$(vmlinux-dirs): prepare scripts
	$(Q)$(MAKE) $(build)=$@
</code></pre>
<p>As we can see <code>vmlinux-dirs</code> depends on two targets: <code>prepare</code> and <code>scripts</code>. <code>prepare</code> is defined in the top <code>Makefile</code> of the Linux kernel and executes three stages of preparations:</p>
<pre><code class="language-Makefile">prepare: prepare0
prepare0: archprepare FORCE
	$(Q)$(MAKE) $(build)=.
archprepare: archheaders archscripts prepare1 scripts_basic

prepare1: prepare2 $(version_h) include/generated/utsrelease.h \
                   include/config/auto.conf
	$(cmd_crmodverdir)
prepare2: prepare3 outputmakefile asm-generic
</code></pre>
<p>The first <code>prepare0</code> expands to the <code>archprepare</code> that expands to the <code>archheaders</code> and <code>archscripts</code> that defined in the <code>x86_64</code> specific <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/Makefile">Makefile</a>. Let's look on it. The <code>x86_64</code> specific makefile starts from the definition of the variables that are related to the architecture-specific configs (<a href="https://github.com/torvalds/linux/tree/master/arch/x86/configs">defconfig</a>, etc...). After this it defines flags for the compiling of the <a href="https://en.wikipedia.org/wiki/Real_mode">16-bit</a> code, calculating of the <code>BITS</code> variable that can be <code>32</code> for <code>i386</code> or <code>64</code> for the <code>x86_64</code> flags for the assembly source code, flags for the linker and many many more (all definitions you can find in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/Makefile">arch/x86/Makefile</a>). The first target is <code>archheaders</code> in the makefile and it generates syscall table:</p>
<pre><code class="language-Makefile">archheaders:
	$(Q)$(MAKE) $(build)=arch/x86/entry/syscalls all
</code></pre>
<p>And the second target is <code>archscripts</code> in this makefile is:</p>
<pre><code class="language-Makefile">archscripts: scripts_basic
	$(Q)$(MAKE) $(build)=arch/x86/tools relocs
</code></pre>
<p>We can see that it depends on the <code>scripts_basic</code> target from the top <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Makefile">Makefile</a>. At the first we can see the <code>scripts_basic</code> target that executes make for the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/scripts/basic/Makefile">scripts/basic</a> makefile:</p>
<pre><code class="language-Makefile">scripts_basic:
	$(Q)$(MAKE) $(build)=scripts/basic
</code></pre>
<p>The <code>scripts/basic/Makefile</code> contains targets for compilation of the two host programs: <code>fixdep</code> and <code>bin2</code>:</p>
<pre><code class="language-Makefile">hostprogs-y	:= fixdep
hostprogs-$(CONFIG_BUILD_BIN2C)     += bin2c
always		:= $(hostprogs-y)

$(addprefix $(obj)/,$(filter-out fixdep,$(always))): $(obj)/fixdep
</code></pre>
<p>First program is <code>fixdep</code> - optimizes list of dependencies generated by <a href="https://gcc.gnu.org/">gcc</a> that tells make when to remake a source code file. The second program is <code>bin2c</code>, which depends on the value of the <code>CONFIG_BUILD_BIN2C</code> kernel configuration option and is a very little C program that allows to convert a binary on stdin to a C include on stdout. You can note here a strange notation: <code>hostprogs-y</code>, etc... This notation is used in the all <code>kbuild</code> files and you can read more about it in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/kbuild/makefiles.txt">documentation</a>. In our case <code>hostprogs-y</code> tells <code>kbuild</code> that there is one host program named <code>fixdep</code> that will be built from <code>fixdep.c</code> that is located in the same directory where the <code>Makefile</code> is. The first output after we execute <code>make</code> in our terminal will be result of this <code>kbuild</code> file:</p>
<pre><code>$ make
  HOSTCC  scripts/basic/fixdep
</code></pre>
<p>As <code>script_basic</code> target was executed, the <code>archscripts</code> target will execute <code>make</code> for the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/tools/Makefile">arch/x86/tools</a> makefile with the <code>relocs</code> target:</p>
<pre><code class="language-Makefile">$(Q)$(MAKE) $(build)=arch/x86/tools relocs
</code></pre>
<p>The <code>relocs_32.c</code> and the <code>relocs_64.c</code> will be compiled that will contain <a href="https://en.wikipedia.org/wiki/Relocation_%28computing%29">relocation</a> information and we will see it in the <code>make</code> output:</p>
<pre><code class="language-Makefile">  HOSTCC  arch/x86/tools/relocs_32.o
  HOSTCC  arch/x86/tools/relocs_64.o
  HOSTCC  arch/x86/tools/relocs_common.o
  HOSTLD  arch/x86/tools/relocs
</code></pre>
<p>There is checking of the <code>version.h</code> after compiling of the <code>relocs.c</code>:</p>
<pre><code class="language-Makefile">$(version_h): $(srctree)/Makefile FORCE
	$(call filechk,version.h)
	$(Q)rm -f $(old_version_h)
</code></pre>
<p>We can see it in the output:</p>
<pre><code>CHK     include/config/kernel.release
</code></pre>
<p>and the building of the <code>generic</code> assembly headers with the <code>asm-generic</code> target from the <code>arch/x86/include/generated/asm</code> that generated in the top Makefile of the Linux kernel. After the <code>asm-generic</code> target the <code>archprepare</code> will be done, so the <code>prepare0</code> target will be executed. As I wrote above:</p>
<pre><code class="language-Makefile">prepare0: archprepare FORCE
	$(Q)$(MAKE) $(build)=.
</code></pre>
<p>Note on the <code>build</code>. It defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/scripts/Kbuild.include">scripts/Kbuild.include</a> and looks like this:</p>
<pre><code class="language-Makefile">build := -f $(srctree)/scripts/Makefile.build obj
</code></pre>
<p>Or in our case it is current source directory - <code>.</code>:</p>
<pre><code class="language-Makefile">$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.build obj=.
</code></pre>
<p>The <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/scripts/Makefile.build">scripts/Makefile.build</a> tries to find the <code>Kbuild</code> file by the given directory via the <code>obj</code> parameter, include this <code>Kbuild</code> files:</p>
<pre><code class="language-Makefile">include $(kbuild-file)
</code></pre>
<p>and build targets from it. In our case <code>.</code> contains the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Kbuild">Kbuild</a> file that generates the <code>kernel/bounds.s</code> and the <code>arch/x86/kernel/asm-offsets.s</code>. After this the <code>prepare</code> target finished to work. The <code>vmlinux-dirs</code> also depends on the second target - <code>scripts</code> that compiles following programs: <code>file2alias</code>, <code>mk_elfconfig</code>, <code>modpost</code>, etc..... After scripts/host-programs compilation our <code>vmlinux-dirs</code> target can be executed. First of all let's try to understand what does <code>vmlinux-dirs</code> contain. For my case it contains paths of the following kernel directories:</p>
<pre><code>init usr arch/x86 kernel mm fs ipc security crypto block
drivers sound firmware arch/x86/pci arch/x86/power
arch/x86/video net lib arch/x86/lib
</code></pre>
<p>We can find definition of the <code>vmlinux-dirs</code> in the top <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Makefile">Makefile</a> of the Linux kernel:</p>
<pre><code class="language-Makefile">vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
		     $(net-y) $(net-m) $(libs-y) $(libs-m)))

init-y		:= init/
drivers-y	:= drivers/ sound/ firmware/
net-y		:= net/
libs-y		:= lib/
...
...
...
</code></pre>
<p>Here we remove the <code>/</code> symbol from the each directory with the help of the <code>patsubst</code> and <code>filter</code> functions and put it to the <code>vmlinux-dirs</code>. So we have list of directories in the <code>vmlinux-dirs</code> and the following code:</p>
<pre><code class="language-Makefile">$(vmlinux-dirs): prepare scripts
	$(Q)$(MAKE) $(build)=$@
</code></pre>
<p>The <code>$@</code> represents <code>vmlinux-dirs</code> here that means that it will go recursively over all directories from the <code>vmlinux-dirs</code> and its internal directories (depends on configuration) and will execute <code>make</code> in there. We can see it in the output:</p>
<pre><code>  CC      init/main.o
  CHK     include/generated/compile.h
  CC      init/version.o
  CC      init/do_mounts.o
  ...
  CC      arch/x86/crypto/glue_helper.o
  AS      arch/x86/crypto/aes-x86_64-asm_64.o
  CC      arch/x86/crypto/aes_glue.o
  ...
  AS      arch/x86/entry/entry_64.o
  AS      arch/x86/entry/thunk_64.o
  CC      arch/x86/entry/syscall_64.o
</code></pre>
<p>Source code in each directory will be compiled and linked to the <code>built-in.o</code>:</p>
<pre><code>$ find . -name built-in.o
./arch/x86/crypto/built-in.o
./arch/x86/crypto/sha-mb/built-in.o
./arch/x86/net/built-in.o
./init/built-in.o
./usr/built-in.o
...
...
</code></pre>
<p>Ok, all buint-in.o(s) built, now we can back to the <code>vmlinux</code> target. As you remember, the <code>vmlinux</code> target is in the top Makefile of the Linux kernel. Before the linking of the <code>vmlinux</code> it builds <a href="https://github.com/torvalds/linux/tree/master/samples">samples</a>, <a href="https://github.com/torvalds/linux/tree/master/Documentation">Documentation</a>, etc... but I will not describe it here as I wrote in the beginning of this part.</p>
<pre><code class="language-Makefile">vmlinux: scripts/link-vmlinux.sh $(vmlinux-deps) FORCE
    ...
    ...
    +$(call if_changed,link-vmlinux)
</code></pre>
<p>As you can see main purpose of it is a call of the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/scripts/link-vmlinux.sh">scripts/link-vmlinux.sh</a> script is linking of the all <code>built-in.o</code>(s) to the one statically linked executable and creation of the <a href="https://en.wikipedia.org/wiki/System.map">System.map</a>. In the end we will see following output:</p>
<pre><code>  LINK    vmlinux
  LD      vmlinux.o
  MODPOST vmlinux.o
  GEN     .version
  CHK     include/generated/compile.h
  UPD     include/generated/compile.h
  CC      init/version.o
  LD      init/built-in.o
  KSYM    .tmp_kallsyms1.o
  KSYM    .tmp_kallsyms2.o
  LD      vmlinux
  SORTEX  vmlinux
  SYSMAP  System.map
</code></pre>
<p>and <code>vmlinux</code> and <code>System.map</code> in the root of the Linux kernel source tree:</p>
<pre><code>$ ls vmlinux System.map
System.map  vmlinux
</code></pre>
<p>That's all, <code>vmlinux</code> is ready. The next step is creation of the <a href="https://en.wikipedia.org/wiki/Vmlinux#bzImage">bzImage</a>.</p>
<h2 id="building-bzimage"><a class="header" href="#building-bzimage">Building bzImage</a></h2>
<p>The <code>bzImage</code> file is the compressed Linux kernel image. We can get it by executing <code>make bzImage</code> after <code>vmlinux</code> is built. That, or we can just execute <code>make</code> without any argument and we will get <code>bzImage</code> anyway because it is default image:</p>
<pre><code class="language-Makefile">all: bzImage
</code></pre>
<p>in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/Makefile">arch/x86/kernel/Makefile</a>. Let's look on this target, it will help us to understand how this image builds. As I already said the <code>bzImage</code> target defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/Makefile">arch/x86/kernel/Makefile</a> and looks like this:</p>
<pre><code class="language-Makefile">bzImage: vmlinux
	$(Q)$(MAKE) $(build)=$(boot) $(KBUILD_IMAGE)
	$(Q)mkdir -p $(objtree)/arch/$(UTS_MACHINE)/boot
	$(Q)ln -fsn ../../x86/boot/bzImage $(objtree)/arch/$(UTS_MACHINE)/boot/$@
</code></pre>
<p>We can see here, that first of all called <code>make</code> for the boot directory, in our case it is:</p>
<pre><code class="language-Makefile">boot := arch/x86/boot
</code></pre>
<p>The main goal now is to build the source code in the <code>arch/x86/boot</code> and <code>arch/x86/boot/compressed</code> directories, build <code>setup.bin</code> and <code>vmlinux.bin</code>, and build the <code>bzImage</code> from them in the end. First target in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/Makefile">arch/x86/boot/Makefile</a> is the <code>$(obj)/setup.elf</code>:</p>
<pre><code class="language-Makefile">$(obj)/setup.elf: $(src)/setup.ld $(SETUP_OBJS) FORCE
	$(call if_changed,ld)
</code></pre>
<p>We already have the <code>setup.ld</code> linker script in the <code>arch/x86/boot</code> directory and the <code>SETUP_OBJS</code> variable that expands to the all source files from the <code>boot</code> directory. We can see first output:</p>
<pre><code class="language-Makefile">  AS      arch/x86/boot/bioscall.o
  CC      arch/x86/boot/cmdline.o
  AS      arch/x86/boot/copy.o
  HOSTCC  arch/x86/boot/mkcpustr
  CPUSTR  arch/x86/boot/cpustr.h
  CC      arch/x86/boot/cpu.o
  CC      arch/x86/boot/cpuflags.o
  CC      arch/x86/boot/cpucheck.o
  CC      arch/x86/boot/early_serial_console.o
  CC      arch/x86/boot/edd.o
</code></pre>
<p>The next source file is <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/header.S">arch/x86/boot/header.S</a>, but we can't build it now because this target depends on the following two header files:</p>
<pre><code class="language-Makefile">$(obj)/header.o: $(obj)/voffset.h $(obj)/zoffset.h
</code></pre>
<p>The first is <code>voffset.h</code> generated by the <code>sed</code> script that gets two addresses from the <code>vmlinux</code> with the <code>nm</code> util:</p>
<pre><code class="language-C">#define VO__end 0xffffffff82ab0000
#define VO__text 0xffffffff81000000
</code></pre>
<p>They are the start and the end of the kernel. The second is <code>zoffset.h</code> depens on the <code>vmlinux</code> target from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/compressed/Makefile">arch/x86/boot/compressed/Makefile</a>:</p>
<pre><code class="language-Makefile">$(obj)/zoffset.h: $(obj)/compressed/vmlinux FORCE
	$(call if_changed,zoffset)
</code></pre>
<p>The <code>$(obj)/compressed/vmlinux</code> target depends on the <code>vmlinux-objs-y</code> that compiles source code files from the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/boot/compressed">arch/x86/boot/compressed</a> directory and generates <code>vmlinux.bin</code>, <code>vmlinux.bin.bz2</code>, and compiles program - <code>mkpiggy</code>. We can see this in the output:</p>
<pre><code class="language-Makefile">  LDS     arch/x86/boot/compressed/vmlinux.lds
  AS      arch/x86/boot/compressed/head_64.o
  CC      arch/x86/boot/compressed/misc.o
  CC      arch/x86/boot/compressed/string.o
  CC      arch/x86/boot/compressed/cmdline.o
  OBJCOPY arch/x86/boot/compressed/vmlinux.bin
  BZIP2   arch/x86/boot/compressed/vmlinux.bin.bz2
  HOSTCC  arch/x86/boot/compressed/mkpiggy
</code></pre>
<p>Where <code>vmlinux.bin</code> is the <code>vmlinux</code> file with debugging information and comments stripped and the <code>vmlinux.bin.bz2</code> compressed <code>vmlinux.bin.all</code> + <code>u32</code> size of <code>vmlinux.bin.all</code>. The <code>vmlinux.bin.all</code> is <code>vmlinux.bin + vmlinux.relocs</code>, where <code>vmlinux.relocs</code> is the <code>vmlinux</code> that was handled by the <code>relocs</code> program (see above). As we got these files, the <code>piggy.S</code> assembly files will be generated with the <code>mkpiggy</code> program and compiled:</p>
<pre><code class="language-Makefile">  MKPIGGY arch/x86/boot/compressed/piggy.S
  AS      arch/x86/boot/compressed/piggy.o
</code></pre>
<p>This assembly files will contain the computed offset from the compressed kernel. After this we can see that <code>zoffset</code> generated:</p>
<pre><code class="language-Makefile">  ZOFFSET arch/x86/boot/zoffset.h
</code></pre>
<p>As the <code>zoffset.h</code> and the <code>voffset.h</code> are generated, compilation of the source code files from the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/boot/">arch/x86/boot</a> can be continued:</p>
<pre><code class="language-Makefile">  AS      arch/x86/boot/header.o
  CC      arch/x86/boot/main.o
  CC      arch/x86/boot/mca.o
  CC      arch/x86/boot/memory.o
  CC      arch/x86/boot/pm.o
  AS      arch/x86/boot/pmjump.o
  CC      arch/x86/boot/printf.o
  CC      arch/x86/boot/regs.o
  CC      arch/x86/boot/string.o
  CC      arch/x86/boot/tty.o
  CC      arch/x86/boot/video.o
  CC      arch/x86/boot/video-mode.o
  CC      arch/x86/boot/video-vga.o
  CC      arch/x86/boot/video-vesa.o
  CC      arch/x86/boot/video-bios.o
</code></pre>
<p>As all source code files will be compiled, they will be linked to the <code>setup.elf</code>:</p>
<pre><code class="language-Makefile">  LD      arch/x86/boot/setup.elf
</code></pre>
<p>or:</p>
<pre><code>ld -m elf_x86_64   -T arch/x86/boot/setup.ld arch/x86/boot/a20.o arch/x86/boot/bioscall.o arch/x86/boot/cmdline.o arch/x86/boot/copy.o arch/x86/boot/cpu.o arch/x86/boot/cpuflags.o arch/x86/boot/cpucheck.o arch/x86/boot/early_serial_console.o arch/x86/boot/edd.o arch/x86/boot/header.o arch/x86/boot/main.o arch/x86/boot/mca.o arch/x86/boot/memory.o arch/x86/boot/pm.o arch/x86/boot/pmjump.o arch/x86/boot/printf.o arch/x86/boot/regs.o arch/x86/boot/string.o arch/x86/boot/tty.o arch/x86/boot/video.o arch/x86/boot/video-mode.o arch/x86/boot/version.o arch/x86/boot/video-vga.o arch/x86/boot/video-vesa.o arch/x86/boot/video-bios.o -o arch/x86/boot/setup.elf
</code></pre>
<p>The last two things is the creation of the <code>setup.bin</code> that will contain compiled code from the <code>arch/x86/boot/*</code> directory:</p>
<pre><code>objcopy  -O binary arch/x86/boot/setup.elf arch/x86/boot/setup.bin
</code></pre>
<p>and the creation of the <code>vmlinux.bin</code> from the <code>vmlinux</code>:</p>
<pre><code>objcopy  -O binary -R .note -R .comment -S arch/x86/boot/compressed/vmlinux arch/x86/boot/vmlinux.bin
</code></pre>
<p>In the end we compile host program: <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/tools/build.c">arch/x86/boot/tools/build.c</a> that will create our <code>bzImage</code> from the <code>setup.bin</code> and the <code>vmlinux.bin</code>:</p>
<pre><code>arch/x86/boot/tools/build arch/x86/boot/setup.bin arch/x86/boot/vmlinux.bin arch/x86/boot/zoffset.h arch/x86/boot/bzImage
</code></pre>
<p>Actually the <code>bzImage</code> is the concatenated <code>setup.bin</code> and the <code>vmlinux.bin</code>. In the end we will see the output which is familiar to all who once built the Linux kernel from source:</p>
<pre><code>Setup is 16268 bytes (padded to 16384 bytes).
System is 4704 kB
CRC 94a88f9a
Kernel: arch/x86/boot/bzImage is ready  (#5)
</code></pre>
<p>That's all.</p>
<h1 id="conclusion-52"><a class="header" href="#conclusion-52">Conclusion</a></h1>
<p>It is the end of this part and here we saw all steps from the execution of the <code>make</code> command to the generation of the <code>bzImage</code>. I know, the Linux kernel makefiles and process of the Linux kernel building may seem confusing at first glance, but it is not so hard. Hope this part will help you understand the process of building the Linux kernel.</p>
<h1 id="links-57"><a class="header" href="#links-57">Links</a></h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Make_%28software%29">GNU make util</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Makefile">Linux kernel top Makefile</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cross_compiler">cross-compilation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Ctags">Ctags</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sparse">sparse</a></li>
<li><a href="https://en.wikipedia.org/wiki/Vmlinux#bzImage">bzImage</a></li>
<li><a href="https://en.wikipedia.org/wiki/Uname">uname</a></li>
<li><a href="https://en.wikipedia.org/wiki/Shell_%28computing%29">shell</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/kbuild/kbuild.txt">Kbuild</a></li>
<li><a href="http://www.gnu.org/software/binutils/">binutils</a></li>
<li><a href="https://gcc.gnu.org/">gcc</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/Documentation/kbuild/makefiles.txt">Documentation</a></li>
<li><a href="https://en.wikipedia.org/wiki/System.map">System.map</a></li>
<li><a href="https://en.wikipedia.org/wiki/Relocation_%28computing%29">Relocation</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/driver-api/device_link.html">The Linux Kernel</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="introduction-18"><a class="header" href="#introduction-18">Introduction</a></h2>
<p>During the writing of the <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">linux-insides</a> book I have received many emails with questions related to the <a href="https://en.wikipedia.org/wiki/Linker_%28computing%29">linker</a> script and linker-related subjects. So I've decided to write this to cover some aspects of the linker and the linking of object files.</p>
<p>If we open the <code>Linker</code> page on Wikipedia, we will see following definition:</p>
<blockquote>
<p>In computer science, a linker or link editor is a computer program that takes one or more object files generated by a compiler and combines them into a single executable file, library file, or another object file.</p>
</blockquote>
<p>If you've written at least one program on C in your life, you will have seen files with the <code>*.o</code> extension. These files are <a href="https://en.wikipedia.org/wiki/Object_file">object files</a>. Object files are blocks of machine code and data with placeholder addresses that reference data and functions in other object files or libraries, as well as a list of its own functions and data. The main purpose of the linker is collect/handle the code and data of each object file, turning it into the final executable file or library. In this post we will try to go through all aspects of this process. Let's start.</p>
<h2 id="linking-process"><a class="header" href="#linking-process">Linking process</a></h2>
<p>Let's create a simple project with the following structure:</p>
<pre><code>*-linkers
*--main.c
*--lib.c
*--lib.h
</code></pre>
<p>Our <code>main.c</code> source code file contains:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;

#include &quot;lib.h&quot;

int main(int argc, char **argv) {
	printf(&quot;factorial of 5 is: %d\n&quot;, factorial(5));
	return 0;
}
</code></pre>
<p>The <code>lib.c</code> file contains:</p>
<pre><code class="language-C">int factorial(int base) {
	int res,i = 1;

	if (base == 0) {
		return 1;
	}

	while (i &lt;= base) {
		res *= i;
		i++;
	}

	return res;
}
</code></pre>
<p>And the <code>lib.h</code> file contains:</p>
<pre><code class="language-C">#ifndef LIB_H
#define LIB_H

int factorial(int base);

#endif
</code></pre>
<p>Now let's compile only the <code>main.c</code> source code file with:</p>
<pre><code>$ gcc -c main.c
</code></pre>
<p>If we look inside the outputted object file with the <code>nm</code> util, we will see the
following output:</p>
<pre><code>$ nm -A main.o
main.o:                 U factorial
main.o:0000000000000000 T main
main.o:                 U printf
</code></pre>
<p>The <code>nm</code> util allows us to see the list of symbols from the given object file. It consists of three columns: the first is the name of the given object file and the address of any resolved symbols. The second column contains a character that represents the status of the given symbol. In this case the <code>U</code> means <code>undefined</code> and the <code>T</code> denotes that the symbols are placed in the <code>.text</code> section of the object. The <code>nm</code> utility shows us here that we have three symbols in the <code>main.c</code> source code file:</p>
<ul>
<li><code>factorial</code> - the factorial function defined in the <code>lib.c</code> source code file. It is marked as <code>undefined</code> here because we compiled only the <code>main.c</code> source code file, and it does not know anything about code from the <code>lib.c</code> file for now;</li>
<li><code>main</code> - the main function;</li>
<li><code>printf</code> - the function from the <a href="https://en.wikipedia.org/wiki/GNU_C_Library">glibc</a> library. <code>main.c</code> does not know anything about it for now either.</li>
</ul>
<p>What can we understand from the output of <code>nm</code> so far? The <code>main.o</code> object file contains the local symbol <code>main</code> at address <code>0000000000000000</code> (it will be filled with the correct address after it is linked), and two unresolved symbols. We can see all of this information in the disassembly output of the <code>main.o</code> object file:</p>
<pre><code>$ objdump -S main.o

main.o:     file format elf64-x86-64
Disassembly of section .text:

0000000000000000 &lt;main&gt;:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	89 7d fc             	mov    %edi,-0x4(%rbp)
   b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   f:	bf 05 00 00 00       	mov    $0x5,%edi
  14:	e8 00 00 00 00       	callq  19 &lt;main+0x19&gt;
  19:	89 c6                	mov    %eax,%esi
  1b:	bf 00 00 00 00       	mov    $0x0,%edi
  20:	b8 00 00 00 00       	mov    $0x0,%eax
  25:	e8 00 00 00 00       	callq  2a &lt;main+0x2a&gt;
  2a:	b8 00 00 00 00       	mov    $0x0,%eax
  2f:	c9                   	leaveq
  30:	c3                   	retq
</code></pre>
<p>Here we are interested only in the two <code>callq</code> operations. The two <code>callq</code> operations contain <code>linker stubs</code>, or the function name and offset from it to the next instruction. These stubs will be updated to the real addresses of the functions. We can see these functions' names within the following <code>objdump</code> output:</p>
<pre><code>$ objdump -S -r main.o

...
  14:	e8 00 00 00 00       	callq  19 &lt;main+0x19&gt;
  15: R_X86_64_PC32	               factorial-0x4
  19:	89 c6                	mov    %eax,%esi
...
  25:	e8 00 00 00 00       	callq  2a &lt;main+0x2a&gt;
  26:   R_X86_64_PC32	               printf-0x4
  2a:	b8 00 00 00 00       	mov    $0x0,%eax
...
</code></pre>
<p>The <code>-r</code> or <code>--reloc </code> flags of the <code>objdump</code> util print the <code>relocation</code> entries of the file. Now let's look in more detail at the relocation process.</p>
<h2 id="relocation"><a class="header" href="#relocation">Relocation</a></h2>
<p>Relocation is the process of connecting symbolic references with symbolic definitions. Let's look at the previous snippet from the <code>objdump</code> output:</p>
<pre><code>  14:	e8 00 00 00 00       	callq  19 &lt;main+0x19&gt;
  15:   R_X86_64_PC32	               factorial-0x4
  19:	89 c6                	mov    %eax,%esi
</code></pre>
<p>Note the <code>e8 00 00 00 00</code> on the first line. The <code>e8</code> is the <a href="https://en.wikipedia.org/wiki/Opcode">opcode</a> of the <code>call</code>, and the remainder of the line is a relative offset. So the <code>e8 00 00 00 00</code> contains a one-byte operation code followed by a four-byte address. Note that the <code>00 00 00 00</code> is 4-bytes. Why only 4-bytes if an address can be 8-bytes in a <code>x86_64</code> (64-bit) machine? Actually, we compiled the <code>main.c</code> source code file with the <code>-mcmodel=small</code>! From the <code>gcc</code> man page:</p>
<pre><code>-mcmodel=small

Generate code for the small code model: the program and its symbols must be linked in the lower 2 GB of the address space. Pointers are 64 bits. Programs can be statically or dynamically linked. This is the default code model.
</code></pre>
<p>Of course we didn't pass this option to the <code>gcc</code> when we compiled the <code>main.c</code>, but it is the default. We know that our program will be linked in the lower 2 GB of the address space from the <code>gcc</code> manual extract above. Four bytes is therefore enough for this. So we have the opcode of the <code>call</code> instruction and an unknown address. When we compile <code>main.c</code> with all its dependencies to an executable file, and then look at the factorial call, we see:</p>
<pre><code>$ gcc main.c lib.c -o factorial | objdump -S factorial | grep factorial

factorial:     file format elf64-x86-64
...
...
0000000000400506 &lt;main&gt;:
	40051a:	e8 18 00 00 00       	callq  400537 &lt;factorial&gt;
...
...
0000000000400537 &lt;factorial&gt;:
	400550:	75 07                	jne    400559 &lt;factorial+0x22&gt;
	400557:	eb 1b                	jmp    400574 &lt;factorial+0x3d&gt;
	400559:	eb 0e                	jmp    400569 &lt;factorial+0x32&gt;
	40056f:	7e ea                	jle    40055b &lt;factorial+0x24&gt;
...
...
</code></pre>
<p>As we can see in the previous output, the address of the <code>main</code> function is <code>0x0000000000400506</code>. Why doesn't it start from <code>0x0</code>? You may already know that standard C programs are linked with the <code>glibc</code> C standard library (assuming the <code>-nostdlib</code> was not passed to the <code>gcc</code>). The compiled code for a program includes constructor functions to initialize data in the program when the program is started. These functions need to be called before the program is started, or in another words before the <code>main</code> function is called. To make the initialization and termination functions work, the compiler must output something in the assembler code to cause those functions to be called at the appropriate time. Execution of this program will start from the code placed in the special <code>.init</code> section. We can see this in the beginning of the objdump output:</p>
<pre><code>objdump -S factorial | less

factorial:     file format elf64-x86-64

Disassembly of section .init:

00000000004003a8 &lt;_init&gt;:
  4003a8:       48 83 ec 08             sub    $0x8,%rsp
  4003ac:       48 8b 05 a5 05 20 00    mov    0x2005a5(%rip),%rax        # 600958 &lt;_DYNAMIC+0x1d0&gt;
</code></pre>
<p>Not that it starts at the <code>0x00000000004003a8</code> address relative to the <code>glibc</code> code. We can check it also in the <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> output by running <code>readelf</code>:</p>
<pre><code>$ readelf -d factorial | grep \(INIT\)
 0x000000000000000c (INIT)               0x4003a8
</code></pre>
<p>So, the address of the <code>main</code> function is <code>0000000000400506</code> and is offset from the <code>.init</code> section. As we can see from the output, the address of the <code>factorial</code> function is <code>0x0000000000400537</code> and binary code for the call of the <code>factorial</code> function now is <code>e8 18 00 00 00</code>. We already know that <code>e8</code> is opcode for the <code>call</code> instruction, the next <code>18 00 00 00</code> (note that address represented as little endian for <code>x86_64</code>, so it is <code>00 00 00 18</code>) is the offset from the <code>callq</code> to the <code>factorial</code> function:</p>
<pre><code class="language-python">&gt;&gt;&gt; hex(0x40051a + 0x18 + 0x5) == hex(0x400537)
True
</code></pre>
<p>So we add <code>0x18</code> and <code>0x5</code> to the address of the <code>call</code> instruction. The offset is measured from the address of the following instruction. Our call instruction is 5-bytes long (<code>e8 18 00 00 00</code>) and the <code>0x18</code> is the offset after the call instruction to the <code>factorial</code> function. A compiler generally creates each object file with the program addresses starting at zero. But if a program is created from multiple object files, these will overlap.</p>
<p>What we have seen in this section is the <code>relocation</code> process. This process assigns load addresses to the various parts of the program, adjusting the code and data in the program to reflect the assigned addresses.</p>
<p>Ok, now that we know a little about linkers and relocation, it is time to learn more about linkers by linking our object files.</p>
<h2 id="gnu-linker"><a class="header" href="#gnu-linker">GNU linker</a></h2>
<p>As you can understand from the title, I will use <a href="https://en.wikipedia.org/wiki/GNU_linker">GNU linker</a> or just <code>ld</code> in this post. Of course we can use <code>gcc</code> to link our <code>factorial</code> project:</p>
<pre><code>$ gcc main.c lib.o -o factorial
</code></pre>
<p>and after it we will get executable file - <code>factorial</code> as a result:</p>
<pre><code>./factorial
factorial of 5 is: 120
</code></pre>
<p>But <code>gcc</code> does not link object files. Instead it uses <code>collect2</code> which is just wrapper for the <code>GNU ld</code> linker:</p>
<pre><code>~$ /usr/lib/gcc/x86_64-linux-gnu/4.9/collect2 --version
collect2 version 4.9.3
/usr/bin/ld --version
GNU ld (GNU Binutils for Debian) 2.25
...
...
...
</code></pre>
<p>Ok, we can use gcc and it will produce executable file of our program for us. But let's look how to use <code>GNU ld</code> linker for the same purpose. First of all let's try to link these object files with the following example:</p>
<pre><code>ld main.o lib.o -o factorial
</code></pre>
<p>Try to do it and you will get following error:</p>
<pre><code>$ ld main.o lib.o -o factorial
ld: warning: cannot find entry symbol _start; defaulting to 00000000004000b0
main.o: In function `main':
main.c:(.text+0x26): undefined reference to `printf'
</code></pre>
<p>Here we can see two problems:</p>
<ul>
<li>Linker can't find <code>_start</code> symbol;</li>
<li>Linker does not know anything about <code>printf</code> function.</li>
</ul>
<p>First of all let's try to understand what is this <code>_start</code> entry symbol that appears to be required for our program to run? When I started to learn programming I learned that the <code>main</code> function is the entry point of the program. I think you learned this too :) But it actually isn't the entry point, it's <code>_start</code> instead. The <code>_start</code> symbol is defined in the <code>crt1.o</code> object file. We can find it with the following command:</p>
<pre><code>$ objdump -S /usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o

/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	31 ed                	xor    %ebp,%ebp
   2:	49 89 d1             	mov    %rdx,%r9
   ...
   ...
   ...
</code></pre>
<p>We pass this object file to the <code>ld</code> command as its first argument (see above). Now let's try to link it and will look on result:</p>
<pre><code>ld /usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o \
main.o lib.o -o factorial

/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o: In function `_start':
/tmp/buildd/glibc-2.19/csu/../sysdeps/x86_64/start.S:115: undefined reference to `__libc_csu_fini'
/tmp/buildd/glibc-2.19/csu/../sysdeps/x86_64/start.S:116: undefined reference to `__libc_csu_init'
/tmp/buildd/glibc-2.19/csu/../sysdeps/x86_64/start.S:122: undefined reference to `__libc_start_main'
main.o: In function `main':
main.c:(.text+0x26): undefined reference to `printf'
</code></pre>
<p>Unfortunately we will see even more errors. We can see here old error about undefined <code>printf</code> and yet another three undefined references:</p>
<ul>
<li><code>__libc_csu_fini</code></li>
<li><code>__libc_csu_init</code></li>
<li><code>__libc_start_main</code></li>
</ul>
<p>The <code>_start</code> symbol is defined in the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/x86_64/start.S;h=0d27a38e9c02835ce17d1c9287aa01be222e72eb;hb=HEAD">sysdeps/x86_64/start.S</a> assembly file in the <code>glibc</code> source code. We can find following assembly code lines there:</p>
<pre><code class="language-assembly">mov $__libc_csu_fini, %R8_LP
mov $__libc_csu_init, %RCX_LP
...
call __libc_start_main
</code></pre>
<p>Here we pass address of the entry point to the <code>.init</code> and <code>.fini</code> section that contain code that starts to execute when the program is ran and the code that executes when program terminates. And in the end we see the call of the <code>main</code> function from our program. These three symbols are defined in the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=csu/elf-init.c;hb=1d4bbc54bd4f7d85d774871341b49f4357af1fb7">csu/elf-init.c</a> source code file. The following two object files:</p>
<ul>
<li><code>crtn.o</code>;</li>
<li><code>crti.o</code>.</li>
</ul>
<p>define the function prologs/epilogs for the .init and .fini sections (with the <code>_init</code> and <code>_fini</code> symbols respectively).</p>
<p>The <code>crtn.o</code> object file contains these <code>.init</code> and <code>.fini</code> sections:</p>
<pre><code>$ objdump -S /usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crtn.o

0000000000000000 &lt;.init&gt;:
   0:	48 83 c4 08          	add    $0x8,%rsp
   4:	c3                   	retq

Disassembly of section .fini:

0000000000000000 &lt;.fini&gt;:
   0:	48 83 c4 08          	add    $0x8,%rsp
   4:	c3                   	retq
</code></pre>
<p>And the <code>crti.o</code> object file contains the <code>_init</code> and <code>_fini</code> symbols. Let's try to link again with these two object files:</p>
<pre><code>$ ld \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crti.o \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crtn.o main.o lib.o \
-o factorial
</code></pre>
<p>And anyway we will get the same errors. Now we need to pass <code>-lc</code> option to the <code>ld</code>. This option will search for the standard library in the paths present in the <code>$LD_LIBRARY_PATH</code> environment variable. Let's try to link again with the <code>-lc</code> option:</p>
<pre><code>$ ld \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crti.o \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crtn.o main.o lib.o -lc \
-o factorial
</code></pre>
<p>Finally we get an executable file, but if we try to run it, we will get strange results:</p>
<pre><code>$ ./factorial
bash: ./factorial: No such file or directory
</code></pre>
<p>What's the problem here? Let's look on the executable file with the <a href="https://sourceware.org/binutils/docs/binutils/readelf.html">readelf</a> util:</p>
<pre><code>$ readelf -l factorial

Elf file type is EXEC (Executable file)
Entry point 0x4003c0
There are 7 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                 0x0000000000000188 0x0000000000000188  R E    8
  INTERP         0x00000000000001c8 0x00000000004001c8 0x00000000004001c8
                 0x000000000000001c 0x000000000000001c  R      1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000610 0x0000000000000610  R E    200000
  LOAD           0x0000000000000610 0x0000000000600610 0x0000000000600610
                 0x00000000000001cc 0x00000000000001cc  RW     200000
  DYNAMIC        0x0000000000000610 0x0000000000600610 0x0000000000600610
                 0x0000000000000190 0x0000000000000190  RW     8
  NOTE           0x00000000000001e4 0x00000000004001e4 0x00000000004001e4
                 0x0000000000000020 0x0000000000000020  R      4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     10

 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame
   03     .dynamic .got .got.plt .data
   04     .dynamic
   05     .note.ABI-tag
   06
</code></pre>
<p>Note on the strange line:</p>
<pre><code>  INTERP         0x00000000000001c8 0x00000000004001c8 0x00000000004001c8
                 0x000000000000001c 0x000000000000001c  R      1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
</code></pre>
<p>The <code>.interp</code> section in the <code>elf</code> file holds the path name of a program interpreter or in another words the <code>.interp</code> section simply contains an <code>ascii</code> string that is the name of the dynamic linker. The dynamic linker is the part of Linux that loads and links shared libraries needed by an executable when it is executed, by copying the content of libraries from disk to RAM. As we can see in the output of the <code>readelf</code> command it is placed in the <code>/lib64/ld-linux-x86-64.so.2</code> file for the <code>x86_64</code> architecture. Now let's add the <code>-dynamic-linker</code> option with the path of <code>ld-linux-x86-64.so.2</code> to the <code>ld</code> call and will see the following results:</p>
<pre><code>$ gcc -c main.c lib.c

$ ld \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crti.o \
/usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crtn.o main.o lib.o \
-dynamic-linker /lib64/ld-linux-x86-64.so.2 \
-lc -o factorial
</code></pre>
<p>Now we can run it as normal executable file:</p>
<pre><code>$ ./factorial

factorial of 5 is: 120
</code></pre>
<p>It works! With the first line we compile the <code>main.c</code> and the <code>lib.c</code> source code files to object files. We will get the <code>main.o</code> and the <code>lib.o</code> after execution of the <code>gcc</code>:</p>
<pre><code>$ file lib.o main.o
lib.o:  ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
</code></pre>
<p>and after this we link object files of our program with the needed system object files and libraries. We just saw a simple example of how to compile and link a C program with the <code>gcc</code> compiler and <code>GNU ld</code> linker. In this example we have used a couple command line options of the <code>GNU linker</code>, but it supports much more command line options than <code>-o</code>, <code>-dynamic-linker</code>, etc... Moreover <code>GNU ld</code> has its own language that allows to control the linking process. In the next two paragraphs we will look into it.</p>
<h2 id="useful-command-line-options-of-the-gnu-linker"><a class="header" href="#useful-command-line-options-of-the-gnu-linker">Useful command line options of the GNU linker</a></h2>
<p>As I already wrote and as you can see in the manual of the <code>GNU linker</code>, it has a big set of command line options. We've seen a couple of options in this post: <code>-o &lt;output&gt;</code> - that tells <code>ld</code> to produce an output file called <code>output</code> as the result of linking, <code>-l&lt;name&gt;</code> that adds the archive or object file specified by the name, <code>-dynamic-linker</code> that specifies the name of the dynamic linker. Of course <code>ld</code> supports much more command line options, let's look at some of them.</p>
<p>The first useful command line option is <code>@file</code>. In this case the <code>file</code> specifies filename where command line options will be read. For example we can create file with the name <code>linker.ld</code>, put there our command line arguments from the previous example and execute it with:</p>
<pre><code>$ ld @linker.ld
</code></pre>
<p>The next command line option is <code>-b</code> or <code>--format</code>. This command line option specifies format of the input object files <code>ELF</code>, <code>DJGPP/COFF</code> and etc. There is a command line option for the same purpose but for the output file: <code>--oformat=output-format</code>.</p>
<p>The next command line option is <code>--defsym</code>. Full format of this command line option is the <code>--defsym=symbol=expression</code>. It allows to create global symbol in the output file containing the absolute address given by expression. We can find following case where this command line option can be useful: in the Linux kernel source code and more precisely in the Makefile that is related to the kernel decompression for the ARM architecture - <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/arm/boot/compressed/Makefile">arch/arm/boot/compressed/Makefile</a>, we can find following definition:</p>
<pre><code>LDFLAGS_vmlinux = --defsym _kernel_bss_size=$(KBSS_SZ)
</code></pre>
<p>As we already know, it defines the <code>_kernel_bss_size</code> symbol with the size of the <code>.bss</code> section in the output file. This symbol will be used in the first <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/arm/boot/compressed/head.S">assembly file</a> that will be executed during kernel decompression:</p>
<pre><code class="language-assembly">ldr r5, =_kernel_bss_size
</code></pre>
<p>The next command line options is the <code>-shared</code> that allows us to create shared library. The <code>-M</code> or <code>-map &lt;filename&gt;</code> command line option prints the linking map with the information about symbols. In our case:</p>
<pre><code>$ ld -M @linker.ld
...
...
...
.text           0x00000000004003c0      0x112
 *(.text.unlikely .text.*_unlikely .text.unlikely.*)
 *(.text.exit .text.exit.*)
 *(.text.startup .text.startup.*)
 *(.text.hot .text.hot.*)
 *(.text .stub .text.* .gnu.linkonce.t.*)
 .text          0x00000000004003c0       0x2a /usr/lib/gcc/x86_64-linux-gnu/4.9/../../../x86_64-linux-gnu/crt1.o
...
...
...
 .text          0x00000000004003ea       0x31 main.o
                0x00000000004003ea                main
 .text          0x000000000040041b       0x3f lib.o
                0x000000000040041b                factorial
</code></pre>
<p>Of course the <code>GNU linker</code> supports standard command line options: <code>--help</code> and <code>--version</code> that prints common help of the usage of the <code>ld</code> and its version. That's all about command line options of the <code>GNU linker</code>. Of course it is not the full set of command line options supported by the <code>ld</code> util. You can find the complete documentation of the <code>ld</code> util in the manual.</p>
<h2 id="control-language-linker"><a class="header" href="#control-language-linker">Control Language linker</a></h2>
<p>As I wrote previously, <code>ld</code> has support for its own language. It accepts Linker Command Language files written in a superset of AT&amp;T's Link Editor Command Language syntax, to provide explicit and total control over the linking process. Let's look on its details.</p>
<p>With the linker language we can control:</p>
<ul>
<li>input files;</li>
<li>output files;</li>
<li>file formats</li>
<li>addresses of sections;</li>
<li>etc...</li>
</ul>
<p>Commands written in the linker control language are usually placed in a file called linker script. We can pass it to <code>ld</code> with the <code>-T</code> command line option. The main command in a linker script is the <code>SECTIONS</code> command. Each linker script must contain this command and it determines the <code>map</code> of the output file. The special variable <code>.</code> contains current position of the output. Let's write a simple assembly program and we will look at how we can use a linker script to control linking of this program. We will take a hello world program for this example:</p>
<pre><code class="language-assembly">.data
        msg:    .ascii  &quot;hello, world!\n&quot;

.text

.global _start

_start:
        mov    $1,%rax
        mov    $1,%rdi
        mov    $msg,%rsi
        mov    $14,%rdx
        syscall

        mov    $60,%rax
        mov    $0,%rdi
        syscall
</code></pre>
<p>We can compile and link it with the following commands:</p>
<pre><code>$ as -o hello.o hello.asm
$ ld -o hello hello.o
</code></pre>
<p>Our program consists from two sections: <code>.text</code> contains code of the program and <code>.data</code> contains initialized variables. Let's write simple linker script and try to link our <code>hello.asm</code> assembly file with it. Our script is:</p>
<pre><code>/*
 * Linker script for the factorial
 */
OUTPUT(hello)
OUTPUT_FORMAT(&quot;elf64-x86-64&quot;)
INPUT(hello.o)

SECTIONS
{
	. = 0x200000;
	.text : {
	      *(.text)
	}

	. = 0x400000;
	.data : {
	      *(.data)
	}
}
</code></pre>
<p>On the first three lines you can see a comment written in <code>C</code> style. After it the <code>OUTPUT</code> and the <code>OUTPUT_FORMAT</code> commands specify the name of our executable file and its format. The next command, <code>INPUT</code>, specifies the input file to the <code>ld</code> linker. Then, we can see the main <code>SECTIONS</code> command, which, as I already wrote, must be present in every linker script. The <code>SECTIONS</code> command represents the set and order of the sections which will be in the output file. At the beginning of the <code>SECTIONS</code> command we can see following line <code>. = 0x200000</code>. I already wrote above that <code>.</code> command points to the current position of the output. This line says that the code should be loaded at address <code>0x200000</code> and the line <code>. = 0x400000</code> says that data section should be loaded at address <code>0x400000</code>. The second line after the <code>. = 0x200000</code> defines <code>.text</code> as an output section. We can see <code>*(.text)</code> expression inside it. The <code>*</code> symbol is wildcard that matches any file name. In other words, the <code>*(.text)</code> expression says all <code>.text</code> input sections in all input files. We can rewrite it as <code>hello.o(.text)</code> for our example. After the following location counter <code>. = 0x400000</code>, we can see definition of the data section.</p>
<p>We can compile and link it with the following command:</p>
<pre><code>$ as -o hello.o hello.S &amp;&amp; ld -T linker.script &amp;&amp; ./hello
hello, world!
</code></pre>
<p>If we look inside it with the <code>objdump</code> util, we can see that <code>.text</code> section starts from the address <code>0x200000</code> and the <code>.data</code> sections starts from the address <code>0x400000</code>:</p>
<pre><code>$ objdump -D hello

Disassembly of section .text:

0000000000200000 &lt;_start&gt;:
  200000:	48 c7 c0 01 00 00 00 	mov    $0x1,%rax
  ...

Disassembly of section .data:

0000000000400000 &lt;msg&gt;:
  400000:	68 65 6c 6c 6f       	pushq  $0x6f6c6c65
  ...
</code></pre>
<p>Apart from the commands we have already seen, there are a few others. The first is the <code>ASSERT(exp, message)</code> that ensures that given expression is not zero. If it is zero, then exit the linker with an error code and print the given error message. If you've read about Linux kernel booting process in the <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">linux-insides</a> book, you may know that the setup header of the Linux kernel has offset <code>0x1f1</code>. In the linker script of the Linux kernel we can find a check for this:</p>
<pre><code>. = ASSERT(hdr == 0x1f1, &quot;The setup header has the wrong offset!&quot;);
</code></pre>
<p>The <code>INCLUDE filename</code> command allows to include external linker script symbols in the current one. In a linker script we can assign a value to a symbol. <code>ld</code> supports a couple of assignment operators:</p>
<ul>
<li>symbol = expression   ;</li>
<li>symbol += expression  ;</li>
<li>symbol -= expression  ;</li>
<li>symbol *= expression  ;</li>
<li>symbol /= expression  ;</li>
<li>symbol &lt;&lt;= expression ;</li>
<li>symbol &gt;&gt;= expression ;</li>
<li>symbol &amp;= expression  ;</li>
<li>symbol |= expression  ;</li>
</ul>
<p>As you can note all operators are C assignment operators. For example we can use it in our linker script as:</p>
<pre><code>START_ADDRESS = 0x200000;
DATA_OFFSET   = 0x200000;

SECTIONS
{
	. = START_ADDRESS;
	.text : {
	      *(.text)
	}

	. = START_ADDRESS + DATA_OFFSET;
	.data : {
	      *(.data)
	}
}
</code></pre>
<p>As you already may have noted, the syntax for expressions in the linker script language is identical to that of C expressions. Besides this the control language of the linking supports following builtin functions:</p>
<ul>
<li><code>ABSOLUTE</code> - returns absolute value of the given expression;</li>
<li><code>ADDR</code> - takes the section and returns its address;</li>
<li><code>ALIGN</code> - returns the value of the location counter (<code>.</code> operator) that aligned by the boundary of the next expression after the given expression;</li>
<li><code>DEFINED</code> - returns <code>1</code> if the given symbol placed in the global symbol table and <code>0</code> otherwise;</li>
<li><code>MAX</code> and <code>MIN</code> - return maximum and minimum of the two given expressions;</li>
<li><code>NEXT</code> - returns the next unallocated address that is a multiple of the given expression;</li>
<li><code>SIZEOF</code> - returns the size in bytes of the given named section.</li>
</ul>
<p>That's all.</p>
<h2 id="conclusion-53"><a class="header" href="#conclusion-53">Conclusion</a></h2>
<p>This is the end of the post about linkers. We learned many things about linkers in this post, such as what is a linker and why it is needed, how to use it, etc..</p>
<p>If you have any questions or suggestions, write me an <a href="mailto:kuleshovmail@gmail.com">email</a> or ping <a href="https://twitter.com/0xAX">me</a> on twitter.</p>
<p>Please note that English is not my first language, and I am really sorry for any inconvenience. If you find any mistakes please let me know via email or send a PR.</p>
<h2 id="links-58"><a class="header" href="#links-58">Links</a></h2>
<ul>
<li><a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">Book about Linux kernel insides</a></li>
<li><a href="https://en.wikipedia.org/wiki/Linker_%28computing%29">linker</a></li>
<li><a href="https://en.wikipedia.org/wiki/Object_file">object files</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_C_Library">glibc</a></li>
<li><a href="https://en.wikipedia.org/wiki/Opcode">opcode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a></li>
<li><a href="https://en.wikipedia.org/wiki/GNU_linker">GNU linker</a></li>
<li><a href="https://0xax.github.io/categories/assembler/">My posts about assembly programming for x86_64</a></li>
<li><a href="https://sourceware.org/binutils/docs/binutils/readelf.html">readelf</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-startup-process-in-userspace"><a class="header" href="#program-startup-process-in-userspace">Program startup process in userspace</a></h1>
<h2 id="introduction-19"><a class="header" href="#introduction-19">Introduction</a></h2>
<p>Despite the <a href="https://www.gitbook.com/book/0xax/linux-insides/details">linux-insides</a> described mostly Linux kernel related stuff, I have decided to write this one part which mostly relates to userspace.</p>
<p>There is already fourth <a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-4">part</a> of <a href="https://en.wikipedia.org/wiki/System_call">System calls</a> chapter which describes what the Linux kernel does when we want to start a program. In this part I want to explore what happens when we run a program on a Linux machine from userspace perspective.</p>
<p>I don't know how about you, but in my university I learn that a <code>C</code> program starts executing from the function which is called <code>main</code>. And that's partly true. Whenever we are starting to write new program, we start our program from the following lines of code:</p>
<pre><code class="language-C">int main(int argc, char *argv[]) {
	// Entry point is here
}
</code></pre>
<p>But if you are interested in low-level programming, you may already know that the <code>main</code> function isn't the actual entry point of a program. You will believe it's true after you look at this simple program in debugger:</p>
<pre><code class="language-C">int main(int argc, char *argv[]) {
	return 0;
}
</code></pre>
<p>Let's compile this and run in <a href="https://www.gnu.org/software/gdb/">gdb</a>:</p>
<pre><code>$ gcc -ggdb program.c -o program
$ gdb ./program
The target architecture is assumed to be i386:x86-64:intel
Reading symbols from ./program...done.
</code></pre>
<p>Let's execute gdb <code>info</code> subcommand with <code>files</code> argument. The <code>info files</code> prints information about debugging targets and memory spaces occupied by different sections.</p>
<pre><code>(gdb) info files
Symbols from &quot;/home/alex/program&quot;.
Local exec file:
	`/home/alex/program', file type elf64-x86-64.
	Entry point: 0x400430
	0x0000000000400238 - 0x0000000000400254 is .interp
	0x0000000000400254 - 0x0000000000400274 is .note.ABI-tag
	0x0000000000400274 - 0x0000000000400298 is .note.gnu.build-id
	0x0000000000400298 - 0x00000000004002b4 is .gnu.hash
	0x00000000004002b8 - 0x0000000000400318 is .dynsym
	0x0000000000400318 - 0x0000000000400357 is .dynstr
	0x0000000000400358 - 0x0000000000400360 is .gnu.version
	0x0000000000400360 - 0x0000000000400380 is .gnu.version_r
	0x0000000000400380 - 0x0000000000400398 is .rela.dyn
	0x0000000000400398 - 0x00000000004003c8 is .rela.plt
	0x00000000004003c8 - 0x00000000004003e2 is .init
	0x00000000004003f0 - 0x0000000000400420 is .plt
	0x0000000000400420 - 0x0000000000400428 is .plt.got
	0x0000000000400430 - 0x00000000004005e2 is .text
	0x00000000004005e4 - 0x00000000004005ed is .fini
	0x00000000004005f0 - 0x0000000000400610 is .rodata
	0x0000000000400610 - 0x0000000000400644 is .eh_frame_hdr
	0x0000000000400648 - 0x000000000040073c is .eh_frame
	0x0000000000600e10 - 0x0000000000600e18 is .init_array
	0x0000000000600e18 - 0x0000000000600e20 is .fini_array
	0x0000000000600e20 - 0x0000000000600e28 is .jcr
	0x0000000000600e28 - 0x0000000000600ff8 is .dynamic
	0x0000000000600ff8 - 0x0000000000601000 is .got
	0x0000000000601000 - 0x0000000000601028 is .got.plt
	0x0000000000601028 - 0x0000000000601034 is .data
	0x0000000000601034 - 0x0000000000601038 is .bss
</code></pre>
<p>Note on <code>Entry point: 0x400430</code> line. Now we know the actual address of entry point of our program. Let's put a breakpoint by this address, run our program and see what happens:</p>
<pre><code>(gdb) break *0x400430
Breakpoint 1 at 0x400430
(gdb) run
Starting program: /home/alex/program

Breakpoint 1, 0x0000000000400430 in _start ()
</code></pre>
<p>Interesting. We don't see execution of the <code>main</code> function here, but we have seen that another function is called. This function is <code>_start</code> and as our debugger shows us, it is the actual entry point of our program. Where is this function from? Who does call <code>main</code> and when is it called? I will try to answer all these questions in the following post.</p>
<h2 id="how-the-kernel-starts-a-new-program"><a class="header" href="#how-the-kernel-starts-a-new-program">How the kernel starts a new program</a></h2>
<p>First of all, let's take a look at the following simple <code>C</code> program:</p>
<pre><code class="language-C">// program.c

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

static int x = 1;

int y = 2;

int main(int argc, char *argv[]) {
	int z = 3;

	printf(&quot;x + y + z = %d\n&quot;, x + y + z);

	return EXIT_SUCCESS;
}
</code></pre>
<p>We can be sure that this program works as we expect. Let's compile it:</p>
<pre><code>$ gcc -Wall program.c -o sum
</code></pre>
<p>and run:</p>
<pre><code>$ ./sum
x + y + z = 6
</code></pre>
<p>Ok, everything looks pretty good up to now. You may already know that there is a special family of functions - <a href="http://man7.org/linux/man-pages/man3/execl.3.html">exec*</a>. As we read in the man page:</p>
<blockquote>
<p>The exec() family of functions replaces the current process image with a new process image.</p>
</blockquote>
<p>All the <code>exec*</code> functions are simple frontends to the <a href="http://man7.org/linux/man-pages/man2/execve.2.html">execve</a> system call. If you have read the fourth <a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-4">part</a> of the chapter which describes <a href="https://en.wikipedia.org/wiki/System_call">system calls</a>, you may know that the <a href="http://linux.die.net/man/2/execve">execve</a> system call is defined in the <a href="https://github.com/torvalds/linux/blob/08e4e0d0456d0ca8427b2d1ddffa30f1c3e774d7/fs/exec.c#L1888">files/exec.c</a> source code file and looks like:</p>
<pre><code class="language-C">SYSCALL_DEFINE3(execve,
		const char __user *, filename,
		const char __user *const __user *, argv,
		const char __user *const __user *, envp)
{
	return do_execve(getname(filename), argv, envp);
}
</code></pre>
<p>It takes an executable file name, set of command line arguments, and set of environment variables. As you may guess, everything is done by the <code>do_execve</code> function. I will not describe the implementation of the <code>do_execve</code> function in detail because you can read about this in <a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-4">here</a>. But in short words, the <code>do_execve</code> function does many checks like <code>filename</code> is valid, limit of launched processes is not exceeded in our system and etc. After all of these checks, this function parses our executable file which is represented in <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a> format, creates memory descriptor for newly executed executable file and fills it with the appropriate values like area for the stack, heap and etc. When the setup of new binary image is done, the <code>start_thread</code> function will set up one new process. This function is architecture-specific and for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture, its definition will be located in the <a href="https://github.com/torvalds/linux/blob/08e4e0d0456d0ca8427b2d1ddffa30f1c3e774d7/arch/x86/kernel/process_64.c#L239">arch/x86/kernel/process_64.c</a> source code file.</p>
<p>The <code>start_thread</code> function sets new value to <a href="https://en.wikipedia.org/wiki/X86_memory_segmentation">segment registers</a> and program execution address. From this point, our new process is ready to start. Once the <a href="https://en.wikipedia.org/wiki/Context_switch">context switch</a> will be done, control will be returned to userspace with new values of registers and the new executable will be started to execute.</p>
<p>That's all from the kernel side. The Linux kernel prepares the binary image for execution and its execution starts right after the context switch and returns control to userspace when it is finished. But it does not answer our questions like where does <code>_start</code> come from and others. Let's try to answer these questions in the next paragraph.</p>
<h2 id="how-does-a-program-start-in-userspace"><a class="header" href="#how-does-a-program-start-in-userspace">How does a program start in userspace</a></h2>
<p>In the previous paragraph we saw how an executable file is prepared to run by the Linux kernel. Let's look at the same, but from userspace side. We already know that the entry point of each program is its <code>_start</code> function. But where is this function from? It may come from a library. But if you remember correctly we didn't link our program with any libraries during compilation of our program:</p>
<pre><code>$ gcc -Wall program.c -o sum
</code></pre>
<p>You may guess that <code>_start</code> comes from the <a href="https://en.wikipedia.org/wiki/Standard_library">standard library</a> and that's true. If you try to compile our program again and pass the <code>-v</code> option to gcc which will enable <code>verbose mode</code>, you will see a long output. The full output is not interesting for us, let's look at the following steps:</p>
<p>First of all, our program should be compiled with <code>gcc</code>:</p>
<pre><code>$ gcc -v -ggdb program.c -o sum
...
...
...
/usr/libexec/gcc/x86_64-redhat-linux/6.1.1/cc1 -quiet -v program.c -quiet -dumpbase program.c -mtune=generic -march=x86-64 -auxbase test -ggdb -version -o /tmp/ccvUWZkF.s
...
...
...
</code></pre>
<p>The <code>cc1</code> compiler will compile our <code>C</code> source code and an produce assembly named <code>/tmp/ccvUWZkF.s</code> file. After this we can see that our assembly file will be compiled into object file with the <code>GNU as</code> assembler:</p>
<pre><code>$ gcc -v -ggdb program.c -o sum
...
...
...
as -v --64 -o /tmp/cc79wZSU.o /tmp/ccvUWZkF.s
...
...
...
</code></pre>
<p>In the end our object file will be linked by <code>collect2</code>:</p>
<pre><code>$ gcc -v -ggdb program.c -o sum
...
...
...
/usr/libexec/gcc/x86_64-redhat-linux/6.1.1/collect2 -plugin /usr/libexec/gcc/x86_64-redhat-linux/6.1.1/liblto_plugin.so -plugin-opt=/usr/libexec/gcc/x86_64-redhat-linux/6.1.1/lto-wrapper -plugin-opt=-fresolution=/tmp/ccLEGYra.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --no-add-needed --eh-frame-hdr --hash-style=gnu -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o test /usr/lib/gcc/x86_64-redhat-linux/6.1.1/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/6.1.1/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/6.1.1/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/6.1.1 -L/usr/lib/gcc/x86_64-redhat-linux/6.1.1/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L. -L/usr/lib/gcc/x86_64-redhat-linux/6.1.1/../../.. /tmp/cc79wZSU.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/6.1.1/crtend.o /usr/lib/gcc/x86_64-redhat-linux/6.1.1/../../../../lib64/crtn.o
...
...
...
</code></pre>
<p>Yes, we can see a long set of command line options which are passed to the linker. Let's go from another way. We know that our program depends on <code>stdlib</code>:</p>
<pre><code>$ ldd program
	linux-vdso.so.1 (0x00007ffc9afd2000)
	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f56b389b000)
	/lib64/ld-linux-x86-64.so.2 (0x0000556198231000)
</code></pre>
<p>as we use some stuff from there like <code>printf</code> and etc. But not only. That's why we will get an error when we pass <code>-nostdlib</code> option to the compiler:</p>
<pre><code>$ gcc -nostdlib program.c -o program
/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 000000000040017c
/tmp/cc02msGW.o: In function `main':
/home/alex/program.c:11: undefined reference to `printf'
collect2: error: ld returned 1 exit status
</code></pre>
<p>Besides other errors, we also see that <code>_start</code> symbol is undefined. So now we are sure that the <code>_start</code> function comes from standard library. But even if we link it with the standard library, it will not be compiled successfully anyway:</p>
<pre><code>$ gcc -nostdlib -lc -ggdb program.c -o program
/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000400350
</code></pre>
<p>Ok, the compiler does not complain about undefined reference of standard library functions anymore as we linked our program with <code>/usr/lib64/libc.so.6</code>, but the <code>_start</code> symbol isn't resolved yet. Let's return to the verbose output of <code>gcc</code> and look at the parameters of <code>collect2</code>. The most important thing that we may see is that our program is linked not only with the standard library, but also with some object files. The first object file is: <code>/lib64/crt1.o</code>. And if we look inside this object file with <code>objdump</code>, we will see the <code>_start</code> symbol:</p>
<pre><code>$ objdump -d /lib64/crt1.o

/lib64/crt1.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	31 ed                	xor    %ebp,%ebp
   2:	49 89 d1             	mov    %rdx,%r9
   5:	5e                   	pop    %rsi
   6:	48 89 e2             	mov    %rsp,%rdx
   9:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
   d:	50                   	push   %rax
   e:	54                   	push   %rsp
   f:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8
  16:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
  1d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
  24:	e8 00 00 00 00       	callq  29 &lt;_start+0x29&gt;
  29:	f4                   	hlt
</code></pre>
<p>As <code>crt1.o</code> is a shared object file, we see only stubs here instead of real calls. Let's look at the source code of the <code>_start</code> function. As this function is architecture specific, implementation for <code>_start</code> will be located in the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/x86_64/start.S;h=f1b961f5ba2d6a1ebffee0005f43123c4352fbf4;hb=HEAD">sysdeps/x86_64/start.S</a> assembly file.</p>
<p>The <code>_start</code> starts from the clearing of <code>ebp</code> register as <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">ABI</a> suggests.</p>
<pre><code class="language-assembly">xorl %ebp, %ebp
</code></pre>
<p>And after this we put the address of termination function to the <code>r9</code> register:</p>
<pre><code class="language-assembly">mov %RDX_LP, %R9_LP
</code></pre>
<p>As described in the <a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf">ELF</a> specification:</p>
<blockquote>
<p>After the dynamic linker has built the process image and performed the relocations, each shared object
gets the opportunity to execute some initialization code.
...
Similarly, shared objects may have termination functions, which are executed with the atexit (BA_OS)
mechanism after the base process begins its termination sequence.</p>
</blockquote>
<p>So we need to put the address of the termination function to the <code>r9</code> register as it will be passed to <code>__libc_start_main</code> in future as sixth argument. Note that the address of the termination function initially is located in the <code>rdx</code> register. Other registers besides <code>rdx</code> and <code>rsp</code> contain unspecified values. Actually the main point of the <code>_start</code> function is to call <code>__libc_start_main</code>. So the next action is to prepare for this function.</p>
<p>The signature of the <code>__libc_start_main</code> function is located in the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=csu/libc-start.c;h=9a56dcbbaeb7ef85c495b4df9ab1d0b13454c043;hb=HEAD#l107">csu/libc-start.c</a> source code file. Let's look on it:</p>
<pre><code class="language-C">STATIC int LIBC_START_MAIN (int (*main) (int, char **, char **),
 			                int argc,
			                char **argv,
 			                __typeof (main) init,
			                void (*fini) (void),
			                void (*rtld_fini) (void),
			                void *stack_end)
</code></pre>
<p>It takes the address of the <code>main</code> function of a program, <code>argc</code> and <code>argv</code>. <code>init</code> and <code>fini</code> functions are constructor and destructor of the program. The <code>rtld_fini</code> is the termination function which will be called after the program will be exited to terminate and free its dynamic section. The last parameter of the <code>__libc_start_main</code> is a pointer to the stack of the program. Before we can call the <code>__libc_start_main</code> function, all of these parameters must be prepared and passed to it. Let's return to the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/x86_64/start.S;h=f1b961f5ba2d6a1ebffee0005f43123c4352fbf4;hb=HEAD">sysdeps/x86_64/start.S</a> assembly file and continue to see what happens before the <code>__libc_start_main</code> function will be called from there.</p>
<p>We can get all the arguments we need for <code>__libc_start_main</code> function from the stack. At the very beginning, when <code>_start</code> is called, our stack looks like:</p>
<pre><code>+-----------------+
|       NULL      |
+-----------------+
|       ...       |
|       envp      |
|       ...       |
+-----------------+
|       NULL      |
+------------------
|       ...       |
|       argv      |
|       ...       |
+------------------
|       argc      | &lt;- rsp
+-----------------+
</code></pre>
<p>After we cleared <code>ebp</code> register and saved the address of the termination function in the <code>r9</code> register, we pop an element from the stack to the <code>rsi</code> register, so after this <code>rsp</code> will point to the <code>argv</code> array and <code>rsi</code> will contain count of command line arguments passed to the program:</p>
<pre><code>+-----------------+
|       NULL      |
+-----------------+
|       ...       |
|       envp      |
|       ...       |
+-----------------+
|       NULL      |
+------------------
|       ...       |
|       argv      |
|       ...       | &lt;- rsp
+-----------------+
</code></pre>
<p>After this we move the address of the <code>argv</code> array to the <code>rdx</code> register</p>
<pre><code class="language-assembly">popq %rsi
mov %RSP_LP, %RDX_LP
</code></pre>
<p>From this moment we have <code>argc</code> and <code>argv</code>. We still need to put pointers to the constructor, destructor in appropriate registers and pass pointer to the stack. At the first following three lines we align stack to <code>16</code> bytes boundary as suggested in <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">ABI</a> and push <code>rax</code> which contains garbage:</p>
<pre><code class="language-assembly">and  $~15, %RSP_LP
pushq %rax

pushq %rsp
mov $__libc_csu_fini, %R8_LP
mov $__libc_csu_init, %RCX_LP
mov $main, %RDI_LP
</code></pre>
<p>After stack aligning we push the address of the stack, move the addresses of constructor and destructor to the <code>r8</code> and <code>rcx</code> registers and address of the <code>main</code> symbol to the <code>rdi</code>. From this moment we can call the <code>__libc_start_main</code> function from the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=csu/libc-start.c;h=0fb98f1606bab475ab5ba2d0fe08c64f83cce9df;hb=HEAD">csu/libc-start.c</a>.</p>
<p>Before we look at the <code>__libc_start_main</code> function, let's add the <code>/lib64/crt1.o</code> and try to compile our program again:</p>
<pre><code>$ gcc -nostdlib /lib64/crt1.o -lc -ggdb program.c -o program
/lib64/crt1.o: In function `_start':
(.text+0x12): undefined reference to `__libc_csu_fini'
/lib64/crt1.o: In function `_start':
(.text+0x19): undefined reference to `__libc_csu_init'
collect2: error: ld returned 1 exit status
</code></pre>
<p>Now we see another error that both <code>__libc_csu_fini</code> and <code>__libc_csu_init</code> functions are not found. We know that the addresses of these two functions are passed to the <code>__libc_start_main</code> as parameters and also these functions are constructor and destructor of our programs. But what do <code>constructor</code> and <code>destructor</code> in terms of <code>C</code> program means? We already saw the quote from the <a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf">ELF</a> specification:</p>
<blockquote>
<p>After the dynamic linker has built the process image and performed the relocations, each shared object
gets the opportunity to execute some initialization code.
...
Similarly, shared objects may have termination functions, which are executed with the atexit (BA_OS)
mechanism after the base process begins its termination sequence.</p>
</blockquote>
<p>So the linker creates two special sections besides usual sections like <code>.text</code>, <code>.data</code> and others:</p>
<ul>
<li><code>.init</code></li>
<li><code>.fini</code></li>
</ul>
<p>We can find them with the <code>readelf</code> util:</p>
<pre><code>$ readelf -e test | grep init
  [11] .init             PROGBITS         00000000004003c8  000003c8

$ readelf -e test | grep fini
  [15] .fini             PROGBITS         0000000000400504  00000504
</code></pre>
<p>Both of these sections will be placed at the start and end of the binary image and contain routines which are called constructor and destructor respectively. The main point of these routines is to do some initialization/finalization like initialization of global variables, such as <a href="http://man7.org/linux/man-pages/man3/errno.3.html">errno</a>, allocation and deallocation of memory for system routines and etc., before the actual code of a program is executed.</p>
<p>You may infer from the names of these functions, they will be called before the <code>main</code> function and after the <code>main</code> function. Definitions of <code>.init</code> and <code>.fini</code> sections are located in the <code>/lib64/crti.o</code> and if we add this object file:</p>
<pre><code>$ gcc -nostdlib /lib64/crt1.o /lib64/crti.o  -lc -ggdb program.c -o program
</code></pre>
<p>we will not get any errors. But let's try to run our program and see what happens:</p>
<pre><code>$ ./program
Segmentation fault (core dumped)
</code></pre>
<p>Yeah, we got segmentation fault. Let's look inside of the <code>lib64/crti.o</code> with <code>objdump</code>:</p>
<pre><code>$ objdump -D /lib64/crti.o

/lib64/crti.o:     file format elf64-x86-64


Disassembly of section .init:

0000000000000000 &lt;_init&gt;:
   0:	48 83 ec 08          	sub    $0x8,%rsp
   4:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # b &lt;_init+0xb&gt;
   b:	48 85 c0             	test   %rax,%rax
   e:	74 05                	je     15 &lt;_init+0x15&gt;
  10:	e8 00 00 00 00       	callq  15 &lt;_init+0x15&gt;

Disassembly of section .fini:

0000000000000000 &lt;_fini&gt;:
   0:	48 83 ec 08          	sub    $0x8,%rsp
</code></pre>
<p>As I wrote above, the <code>/lib64/crti.o</code> object file contains definition of the <code>.init</code> and <code>.fini</code> section, but also we can see here the stub for function. Let's look at the source code which is placed in the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/x86_64/crti.S;h=e9d86ed08ab134a540e3dae5f97a9afb82cdb993;hb=HEAD">sysdeps/x86_64/crti.S</a> source code file:</p>
<pre><code class="language-assembly">	.section .init,&quot;ax&quot;,@progbits
	.p2align 2
	.globl _init
	.type _init, @function
_init:
	subq $8, %rsp
	movq PREINIT_FUNCTION@GOTPCREL(%rip), %rax
	testq %rax, %rax
	je .Lno_weak_fn
	call *%rax
.Lno_weak_fn:
	call PREINIT_FUNCTION
</code></pre>
<p>It contains the definition of the <code>.init</code> section and assembly code does 16-byte stack alignment and next we move address of the <code>PREINIT_FUNCTION</code> and if it is zero we don't call it:</p>
<pre><code>00000000004003c8 &lt;_init&gt;:
  4003c8:       48 83 ec 08             sub    $0x8,%rsp
  4003cc:       48 8b 05 25 0c 20 00    mov    0x200c25(%rip),%rax        # 600ff8 &lt;_DYNAMIC+0x1d0&gt;
  4003d3:       48 85 c0                test   %rax,%rax
  4003d6:       74 05                   je     4003dd &lt;_init+0x15&gt;
  4003d8:       e8 43 00 00 00          callq  400420 &lt;__libc_start_main@plt+0x10&gt;
  4003dd:       48 83 c4 08             add    $0x8,%rsp
  4003e1:       c3                      retq
</code></pre>
<p>where the <code>PREINIT_FUNCTION</code> is the <code>__gmon_start__</code> which does setup for profiling. You may note that we have no return instruction in the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/x86_64/crti.S;h=e9d86ed08ab134a540e3dae5f97a9afb82cdb993;hb=HEAD">sysdeps/x86_64/crti.S</a>. Actually that's why we got a segmentation fault. Prolog of <code>_init</code> and <code>_fini</code> is placed in the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/x86_64/crtn.S;h=e9d86ed08ab134a540e3dae5f97a9afb82cdb993;hb=HEAD">sysdeps/x86_64/crtn.S</a> assembly file:</p>
<pre><code class="language-assembly">.section .init,&quot;ax&quot;,@progbits
addq $8, %rsp
ret

.section .fini,&quot;ax&quot;,@progbits
addq $8, %rsp
ret
</code></pre>
<p>and if we will add it to the compilation, our program will be successfully compiled and run!</p>
<pre><code>$ gcc -nostdlib /lib64/crt1.o /lib64/crti.o /lib64/crtn.o  -lc -ggdb program.c -o program

$ ./program
x + y + z = 6
</code></pre>
<h2 id="conclusion-54"><a class="header" href="#conclusion-54">Conclusion</a></h2>
<p>Now let's return to the <code>_start</code> function and try to go through a full chain of calls before the <code>main</code> of our program will be called.</p>
<p>The <code>_start</code> is always placed at the beginning of the <code>.text</code> section in our programs by the linked which is used default <code>ld</code> script:</p>
<pre><code>$ ld --verbose | grep ENTRY
ENTRY(_start)
</code></pre>
<p>The <code>_start</code> function is defined in the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/x86_64/start.S;h=f1b961f5ba2d6a1ebffee0005f43123c4352fbf4;hb=HEAD">sysdeps/x86_64/start.S</a> assembly file and does preparation like getting <code>argc/argv</code> from the stack, stack preparation and etc., before the <code>__libc_start_main</code> function will be called. The <code>__libc_start_main</code> function from the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=csu/libc-start.c;h=0fb98f1606bab475ab5ba2d0fe08c64f83cce9df;hb=HEAD">csu/libc-start.c</a> source code file does a registration of the constructor and destructor of application which are will be called before <code>main</code> and after it, starts up threading, does some security related actions like setting stack canary if need, calls initialization related routines and in the end it calls <code>main</code> function of our application and exits with its result:</p>
<pre><code class="language-C">result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);
exit (result);
</code></pre>
<p>That's all.</p>
<h2 id="links-59"><a class="header" href="#links-59">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/System_call">system call</a></li>
<li><a href="https://www.gnu.org/software/gdb/">gdb</a></li>
<li><a href="http://linux.die.net/man/2/execve">execve</a></li>
<li><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86_memory_segmentation">segment registers</a></li>
<li><a href="https://en.wikipedia.org/wiki/Context_switch">context switch</a></li>
<li><a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">System V ABI</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal-system-structures-of-the-linux-kernel"><a class="header" href="#internal-system-structures-of-the-linux-kernel">Internal <code>system</code> structures of the Linux kernel</a></h1>
<p>This is not usual chapter of <code>linux-insides</code>. As you may understand from the title, it mostly describes
internal <code>system</code> structures of the Linux kernel. Like <code>Interrupt Descriptor Table</code>, <code>Global Descriptor Table</code> and many many more.</p>
<p>Most of information is taken from official <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel</a> and <a href="http://developer.amd.com/resources/developer-guides-manuals/">AMD</a> manuals.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupt-descriptor-table-idt"><a class="header" href="#interrupt-descriptor-table-idt">interrupt-descriptor table (IDT)</a></h1>
<p>Three general interrupt &amp; exceptions sources:</p>
<ul>
<li>Exceptions - sync;</li>
<li>Software interrupts - sync;</li>
<li>External interrupts - async.</li>
</ul>
<p>Types of Exceptions:</p>
<ul>
<li>Faults - are precise exceptions reported on the boundary <code>before</code> the instruction causing the exception. The saved <code>%rip</code> points to the faulting instruction;</li>
<li>Traps - are precise exceptions reported on the boundary <code>following</code> the instruction causing the exception. The same with <code>%rip</code>;</li>
<li>Aborts - are imprecise exceptions. Because they are imprecise, aborts typically do not allow reliable program restart.</li>
</ul>
<p><code>Maskable</code> interrupts trigger the interrupt-handling mechanism only when <code>RFLAGS.IF=1</code>. Otherwise they are held pending for as long as the <code>RFLAGS.IF</code> bit is cleared to 0.</p>
<p><code>Nonmaskable</code> interrupts (NMI) are unaffected by the value of the 'RFLAGS.IF' bit. However, the occurrence of an NMI masks further NMIs until an IRET instruction is executed.</p>
<p>Specific exception and interrupt sources are assigned a fixed vector-identification number (also called an “interrupt vector” or simply “vector”). The interrupt vector is used by the interrupt-handling mechanism to locate the system-software service routine assigned to the exception or interrupt. Up to
256 unique interrupt vectors are available. The first 32 vectors are reserved for predefined exception and interrupt conditions. They are defined in the <a href="http://lxr.free-electrons.com/source/arch/x86/include/asm/traps.h#L121">arch/x86/include/asm/traps.h</a> header file:</p>
<pre><code>/* Interrupts/Exceptions */
enum {
	X86_TRAP_DE = 0,	/*  0, Divide-by-zero */
	X86_TRAP_DB,		/*  1, Debug */
	X86_TRAP_NMI,		/*  2, Non-maskable Interrupt */
	X86_TRAP_BP,		/*  3, Breakpoint */
	X86_TRAP_OF,		/*  4, Overflow */
	X86_TRAP_BR,		/*  5, Bound Range Exceeded */
	X86_TRAP_UD,		/*  6, Invalid Opcode */
	X86_TRAP_NM,		/*  7, Device Not Available */
	X86_TRAP_DF,		/*  8, Double Fault */
	X86_TRAP_OLD_MF,	/*  9, Coprocessor Segment Overrun */
	X86_TRAP_TS,		/* 10, Invalid TSS */
	X86_TRAP_NP,		/* 11, Segment Not Present */
	X86_TRAP_SS,		/* 12, Stack Segment Fault */
	X86_TRAP_GP,		/* 13, General Protection Fault */
	X86_TRAP_PF,		/* 14, Page Fault */
	X86_TRAP_SPURIOUS,	/* 15, Spurious Interrupt */
	X86_TRAP_MF,		/* 16, x87 Floating-Point Exception */
	X86_TRAP_AC,		/* 17, Alignment Check */
	X86_TRAP_MC,		/* 18, Machine Check */
	X86_TRAP_XF,		/* 19, SIMD Floating-Point Exception */
	X86_TRAP_IRET = 32,	/* 32, IRET Exception */
};
</code></pre>
<h2 id="error-codes"><a class="header" href="#error-codes">Error Codes</a></h2>
<p>The processor exception-handling mechanism reports error and status information for some exceptions using an error code. The error code is pushed onto the stack by the exception-mechanism during the control transfer into the exception handler. The error code has two formats:</p>
<ul>
<li>most error-reporting exceptions format;</li>
<li>page fault format.</li>
</ul>
<p>Here is format of selector error code:</p>
<pre><code>31                           16 15                                  3   2   1   0
+-------------------------------------------------------------------------------+
|                              |                                    | T | I | E |
|           Reserved           |             Selector Index         | - | D | X |
|                              |                                    | I | T | T |
+-------------------------------------------------------------------------------+
</code></pre>
<p>Where:</p>
<ul>
<li><code>EXT</code> - If this bit is set to 1, the exception source is external to the processor. If cleared to 0, the exception source is internal to the processor;</li>
<li><code>IDT</code> - If this bit is set to 1, the error-code selector-index field references a gate descriptor located in the <code>interrupt-descriptor table</code>. If cleared to 0, the selector-index field references a descriptor in either the <code>global-descriptor table</code> or local-descriptor table <code>LDT</code>, as indicated by the <code>TI</code> bit;</li>
<li><code>TI</code> - If this bit is set to 1, the error-code selector-index field references a descriptor in the <code>LDT</code>. If cleared to 0, the selector-index field references a descriptor in the <code>GDT</code>.</li>
<li><code>Selector Index</code> - The selector-index field specifies the index into either the <code>GDT</code>, <code>LDT</code>, or <code>IDT</code>, as specified by the <code>IDT</code> and <code>TI</code> bits.</li>
</ul>
<p>Page-Fault Error Code format is:</p>
<pre><code>31                                                              4   3   2   1   0
+-------------------------------------------------------------------------------+
|                                                         |     | R | U | R | - |
|                       Reserved                          | I/D | S | - | - | P |
|                                                         |     | V | S | W | - |
+-------------------------------------------------------------------------------+
</code></pre>
<p>Where:</p>
<ul>
<li><code>I/D</code> - If this bit is set to 1, it indicates that the access that caused the page fault was an instruction fetch;</li>
<li><code>RSV</code> - If this bit is set to 1, the page fault is a result of the processor reading a 1 from a reserved field within a page-translation-table entry;</li>
<li><code>U/S</code> - If this bit is cleared to 0, an access in supervisor mode (<code>CPL=0, 1, or 2</code>) caused the page fault. If this bit is set to 1, an access in user mode (CPL=3) caused the page fault;</li>
<li><code>R/W</code> - If this bit is cleared to 0, the access that caused the page fault is a memory read. If this bit is set to 1, the memory access that caused the page fault was a write;</li>
<li><code>P</code> - If this bit is cleared to 0, the page fault was caused by a not-present page. If this bit is set to 1, the page fault was caused by a page-protection violation.</li>
</ul>
<h2 id="interrupt-control-transfers"><a class="header" href="#interrupt-control-transfers">Interrupt Control Transfers</a></h2>
<p>The IDT may contain any of three kinds of gate descriptors:</p>
<ul>
<li><code>Task Gate</code> - contains the segment selector for a TSS for an exception and/or interrupt handler task;</li>
<li><code>Interrupt Gate</code> - contains segment selector and offset that the processor uses to transfer program execution to a handler procedure in an interrupt handler code segment;</li>
<li><code>Trap Gate</code> - contains segment selector and offset that the processor uses to transfer program execution to a handler procedure in an exception handler code segment.</li>
</ul>
<p>General format of gates is:</p>
<pre><code>127                                                                             96
+-------------------------------------------------------------------------------+
|                                                                               |
|                                Reserved                                       |
|                                                                               |
+--------------------------------------------------------------------------------
95                                                                              64
+-------------------------------------------------------------------------------+
|                                                                               |
|                               Offset 63..32                                   |
|                                                                               |
+-------------------------------------------------------------------------------+
63                               48 47      46  44   42    39             34    32
+-------------------------------------------------------------------------------+
|                                  |       |  D  |   |     |      |   |   |     |
|       Offset 31..16              |   P   |  P  | 0 |Type |0 0 0 | 0 | 0 | IST |
|                                  |       |  L  |   |     |      |   |   |     |
 -------------------------------------------------------------------------------+
31                                   16 15                                      0
+-------------------------------------------------------------------------------+
|                                      |                                        |
|          Segment Selector            |                 Offset 15..0           |
|                                      |                                        |
+-------------------------------------------------------------------------------+
</code></pre>
<p>Where</p>
<ul>
<li><code>Selector</code> - Segment Selector for destination code segment;</li>
<li><code>Offset</code> - Offset to handler procedure entry point;</li>
<li><code>DPL</code> - Descriptor Privilege Level;</li>
<li><code>P</code> - Segment Present flag;</li>
<li><code>IST</code> - Interrupt Stack Table;</li>
<li><code>TYPE</code> - one of: Local descriptor-table (LDT) segment descriptor, Task-state segment (TSS) descriptor, Call-gate descriptor, Interrupt-gate descriptor, Trap-gate descriptor or Task-gate descriptor.</li>
</ul>
<p>An <code>IDT</code> descriptor is represented by the following structure in the Linux kernel (only for <code>x86_64</code>):</p>
<pre><code class="language-C">struct gate_struct64 {
	u16 offset_low;
	u16 segment;
	unsigned ist : 3, zero0 : 5, type : 5, dpl : 2, p : 1;
	u16 offset_middle;
	u32 offset_high;
	u32 zero1;
} __attribute__((packed));
</code></pre>
<p>which is defined in the <a href="http://lxr.free-electrons.com/source/arch/x86/include/asm/desc_defs.h#L51">arch/x86/include/asm/desc_defs.h</a> header file.</p>
<p>A task gate descriptor does not contain <code>IST</code> field and its format differs from interrupt/trap gates:</p>
<pre><code class="language-C">struct ldttss_desc64 {
	u16 limit0;
	u16 base0;
	unsigned base1 : 8, type : 5, dpl : 2, p : 1;
	unsigned limit1 : 4, zero0 : 3, g : 1, base2 : 8;
	u32 base3;
	u32 zero1;
} __attribute__((packed));
</code></pre>
<h2 id="exceptions-during-a-task-switch"><a class="header" href="#exceptions-during-a-task-switch">Exceptions During a Task Switch</a></h2>
<p>An exception can occur during a task switch while loading a segment selector. Page faults can also occur when accessing a TSS. In these cases, the hardware task-switch mechanism completes loading the new task state from the TSS, and then triggers the appropriate exception mechanism.</p>
<p><strong>In long mode, an exception cannot occur during a task switch, because the hardware task-switch mechanism is disabled.</strong></p>
<h2 id="nonmaskable-interrupt"><a class="header" href="#nonmaskable-interrupt">Nonmaskable interrupt</a></h2>
<p><strong>TODO</strong></p>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p><strong>TODO</strong></p>
<h2 id="interrupt-stack-table"><a class="header" href="#interrupt-stack-table">Interrupt Stack Table</a></h2>
<p><strong>TODO</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-links"><a class="header" href="#useful-links">Useful links</a></h1>
<h2 id="linux-boot"><a class="header" href="#linux-boot">Linux boot</a></h2>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">Linux/x86 boot protocol</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.rst">Linux kernel parameters</a></li>
</ul>
<h2 id="protected-mode-1"><a class="header" href="#protected-mode-1">Protected mode</a></h2>
<ul>
<li><a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf</a></li>
</ul>
<h2 id="memory-management-in-the-linux-kernel"><a class="header" href="#memory-management-in-the-linux-kernel">Memory management in the Linux kernel</a></h2>
<ul>
<li><a href="https://github.com/lorenzo-stoakes/linux-vm-notes">Notes on the linux kernel VM subsystem by @lorenzo-stoakes</a></li>
</ul>
<h2 id="serial-programming"><a class="header" href="#serial-programming">Serial programming</a></h2>
<ul>
<li><a href="http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming#UART_Registers">8250 UART Programming</a></li>
<li><a href="http://wiki.osdev.org/Serial_Ports">Serial ports on OSDEV</a></li>
</ul>
<h2 id="vga"><a class="header" href="#vga">VGA</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Video_Graphics_Array">Video Graphics Array (VGA)</a></li>
</ul>
<h2 id="io"><a class="header" href="#io">IO</a></h2>
<ul>
<li><a href="http://www.tldp.org/HOWTO/text/IO-Port-Programming">IO port programming</a></li>
</ul>
<h2 id="gcc-and-gas"><a class="header" href="#gcc-and-gas">GCC and GAS</a></h2>
<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html">GCC type attributes</a></li>
<li><a href="http://www.chemie.fu-berlin.de/chemnet/use/info/gas/gas_toc.html#TOC65">Assembler Directives</a></li>
</ul>
<h2 id="important-data-structures"><a class="header" href="#important-data-structures">Important data structures</a></h2>
<ul>
<li><a href="http://lxr.free-electrons.com/source/include/linux/sched.h#L1274">task_struct definition</a></li>
</ul>
<h2 id="useful-links-1"><a class="header" href="#useful-links-1">Useful links</a></h2>
<ul>
<li><a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html">Linux x86 Program Start Up</a></li>
<li><a href="http://fgiasson.com/articles/memorylayout.txt">Memory Layout in Program Execution (32 bits)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="thank-you-to-all-contributors"><a class="header" href="#thank-you-to-all-contributors">Thank you to all contributors:</a></h2>
<ul>
<li><a href="https://github.com/akash0x53">Akash Shende</a></li>
<li><a href="https://github.com/jkramarz">Jakub Kramarz</a></li>
<li><a href="https://github.com/ckrooss">ckrooss</a></li>
<li><a href="https://github.com/ecksun">ecksun</a></li>
<li><a href="https://github.com/mmakowski">Maciek Makowski</a></li>
<li><a href="https://github.com/ThomasMarcelis">Thomas Marcelis</a></li>
<li><a href="https://github.com/ccostes">Chris Costes</a></li>
<li><a href="https://github.com/nathansoz">nathansoz</a></li>
<li><a href="https://github.com/RubanDeventhiran">RubanDeventhiran</a></li>
<li><a href="https://github.com/fuzhli">fuzhli</a></li>
<li><a href="https://github.com/andars">andars</a></li>
<li><a href="https://github.com/alexpana">Alexandru Pana</a></li>
<li><a href="https://github.com/bogdanr">Bogdan Rădulescu</a></li>
<li><a href="https://github.com/zil">zil</a></li>
<li><a href="https://github.com/codelitt">codelitt</a></li>
<li><a href="https://github.com/gulyasm">gulyasm</a></li>
<li><a href="https://github.com/alx741">alx741</a></li>
<li><a href="https://github.com/Haddayn">Haddayn</a></li>
<li><a href="https://github.com/alx741">Daniel Campoverde Carrión</a></li>
<li><a href="https://github.com/GuillaumeGomez">Guillaume Gomez</a></li>
<li><a href="https://github.com/leandromoreira">Leandro Moreira</a></li>
<li><a href="https://github.com/jonte">Jonatan Pålsson</a></li>
<li><a href="https://github.com/georgehorrell">George Horrell</a></li>
<li><a href="https://github.com/cirosantilli">Ciro Santilli</a></li>
<li><a href="https://github.com/eax64">Kevin Soules</a></li>
<li><a href="https://github.com/fabiopozzi">Fabio Pozzi</a></li>
<li><a href="https://github.com/kevinjswinton">Kevin Swinton</a></li>
<li><a href="https://github.com/leandromoreira">Leandro Moreira</a></li>
<li><a href="https://github.com/LYF610400210">LYF610400210</a></li>
<li><a href="https://github.com/ccope">Cam Cope</a></li>
<li><a href="https://github.com/mssola">Miquel Sabaté Solà</a></li>
<li><a href="https://github.com/MichaelAquilina">Michael Aquilina</a></li>
<li><a href="https://github.com/gabesullice">Gabriel Sullice</a></li>
<li><a href="https://github.com/darkstar">Michael Drüing</a></li>
<li><a href="https://github.com/polachok">Alexander Polakov</a></li>
<li><a href="https://github.com/davydovanton">Anton Davydov</a></li>
<li><a href="https://github.com/arpankapoor">Arpan Kapoor</a></li>
<li><a href="https://github.com/bfoz">Brandon Fosdick</a></li>
<li><a href="https://github.com/anewmanjones">Ashleigh Newman-Jones</a></li>
<li><a href="https://github.com/trel">Terrell Russell</a></li>
<li><a href="https://github.com/bedna-KU">Mario</a></li>
<li><a href="https://github.com/ekohl">Ewoud Kohl van Wijngaarden</a></li>
<li><a href="https://github.com/sejo">Jochen Maes</a></li>
<li><a href="https://github.com/Brother-Lal">Brother-Lal</a></li>
<li><a href="https://github.com/puffnfresh">Brian McKenna</a></li>
<li><a href="https://github.com/joshtriplett">Josh Triplett</a></li>
<li><a href="https://github.com/comjf">James Flowers</a></li>
<li><a href="https://github.com/aeharding">Alexander Harding</a></li>
<li><a href="https://github.com/plashchynski">Dzmitry Plashchynski</a></li>
<li><a href="https://github.com/simar7">Simarpreet Singh</a></li>
<li><a href="https://github.com/umatomba">umatomba</a></li>
<li><a href="https://github.com/xennygrimmato">Vaibhav Tulsyan</a></li>
<li><a href="https://github.com/brandonwamboldt">Brandon Wamboldt</a></li>
<li><a href="https://github.com/leboeuf">Maxime Leboeuf</a></li>
<li><a href="https://github.com/halfa">Maximilien Richer</a></li>
<li><a href="https://github.com/marmeladema">marmeladema</a></li>
<li><a href="https://github.com/anisse">Anisse Astier</a></li>
<li><a href="https://github.com/TheCodeArtist">TheCodeArtist</a></li>
<li><a href="https://github.com/imehsunn">Ehsun N</a></li>
<li><a href="https://github.com/adamdecaf">Adam Shannon</a></li>
<li><a href="https://github.com/dnadolny">Donny Nadolny</a></li>
<li><a href="https://github.com/imehsunn">Ehsun N</a></li>
<li><a href="https://github.com/Waqar144">Waqar Ahmed</a></li>
<li><a href="https://github.com/ianmiell">Ian Miell</a></li>
<li><a href="https://github.com/mudongliang">DongLiang Mu</a></li>
<li><a href="https://github.com/29jm">Johan Manuel</a></li>
<li><a href="https://github.com/brakthehack">Brian Rak</a></li>
<li><a href="https://github.com/rpeiremans">Robin Peiremans</a></li>
<li><a href="https://github.com/hitmoon">xiaoqiang zhao</a></li>
<li><a href="https://github.com/aouelete">aouelete</a></li>
<li><a href="https://github.com/dennisbirkholz">Dennis Birkholz</a></li>
<li><a href="https://github.com/noxiouz">Anton Tyurin</a></li>
<li><a href="https://github.com/kulbida">Bogdan Kulbida</a></li>
<li><a href="https://github.com/mhudgins">Matt Hudgins</a></li>
<li><a href="https://github.com/ruthgrace">Ruth Grace Wong</a></li>
<li><a href="https://github.com/jlacomis">Jeremy Lacomis</a></li>
<li><a href="https://github.com/Dubyah">Dubyah</a></li>
<li><a href="https://github.com/c0riolis">Matthieu Tardy</a></li>
<li><a href="https://github.com/mennis">michaelian ennis</a></li>
<li><a href="https://github.com/amist">Amitay Stern</a></li>
<li><a href="https://github.com/mtodd">Matt Todd</a></li>
<li><a href="https://github.com/pangteypiyush">Piyush Pangtey</a></li>
<li><a href="https://github.com/Alcaro">Alfred Agrell</a></li>
<li><a href="https://github.com/jwilk">Jakub Wilk</a></li>
<li><a href="https://github.com/JustusAdam">Justus Adam</a></li>
<li><a href="https://github.com/thanatos">Roy Wellington Ⅳ</a></li>
<li><a href="https://github.com/JGRennison">Jonathan Rennison</a></li>
<li><a href="https://github.com/rmbreak">Mack Stump</a></li>
<li><a href="https://github.com/PrinceDhaliwal">Pushpinder Singh</a></li>
<li><a href="https://github.com/huxq">Xiaoqin Hu</a></li>
<li><a href="https://github.com/jeremycline">Jeremy Cline</a></li>
<li><a href="https://github.com/kavi-nikhurpa">Kavindra Nikhurpa</a></li>
<li><a href="https://github.com/mullen3">Connor Mullen</a></li>
<li><a href="https://github.com/alex-gonz">Alex Gonzalez</a></li>
<li><a href="https://github.com/tijko">Tim Konick</a></li>
<li><a href="https://github.com/anastasds">Anastas Stoyanovsky</a></li>
<li><a href="https://github.com/7coder7">Faiz Halde</a></li>
<li><a href="https://github.com/AndrewRussellHayes">Andrew Hayes</a></li>
<li><a href="https://github.com/Smattr">Matthew Fernandez</a></li>
<li><a href="https://github.com/yunomae">Yoshihiro YUNOMAE</a></li>
<li><a href="https://github.com/paulch">paulch</a></li>
<li><a href="https://github.com/ndauten">Nathan Dautenhahn</a></li>
<li><a href="https://github.com/psachin">Sachin Patil</a></li>
<li><a href="https://github.com/phantez">Stéphan Gorget</a></li>
<li><a href="https://github.com/int3rrupt">Adrian Reyes</a></li>
<li><a href="https://github.com/crowchirp">Chandan Rai</a></li>
<li><a href="https://github.com/jbcayrou">JB Cayrou</a></li>
<li><a href="https://github.com/diekmann">Cornelius Diekmann</a></li>
<li><a href="https://github.com/c0r3dump3d">Andrés Rojas</a></li>
<li><a href="https://github.com/0xF0D0">Beomsu Kim</a></li>
<li><a href="https://github.com/firogh">Firo Yang</a></li>
<li><a href="https://github.com/BDHU">Edward Hu</a></li>
<li><a href="https://github.com/WarpspeedSCP">WarpspeedSCP</a></li>
<li><a href="https://github.com/gabi-250">Gabriela Moldovan</a></li>
<li><a href="https://github.com/kuritonasu/">kuritonasu</a></li>
<li><a href="https://github.com/milesfrain">Miles Frain</a></li>
<li><a href="https://github.com/horaceheaven">Horace Heaven</a></li>
<li><a href="https://github.com/zidarsk8">Miha Zidar</a></li>
<li><a href="https://github.com/sevenfourk">Ivan Kovnatsky</a></li>
<li><a href="https://github.com/tkyymmt">Takuya Yamamoto</a></li>
<li><a href="https://github.com/dragonly">Dragonly</a></li>
<li><a href="https://github.com/Blameying">Blameying</a></li>
<li><a href="https://github.com/junsooo">Junsoo Lee</a></li>
<li><a href="https://github.com/sjp38">SeongJae Park</a></li>
<li><a href="https://github.com/stefan20162016">Stefan20162016</a></li>
<li><a href="https://github.com/md1512">Marco Torsello</a></li>
<li><a href="https://github.com/bmeneguele">Bruno Meneguele</a></li>
<li><a href="https://github.com/initBasti">Sebastian Fricke</a></li>
<li><a href="https://github.com/zhouzhouyi-hub">Zhouyi Zhou</a></li>
<li><a href="https://github.com/Mutated1994">Mingzhe Yang</a></li>
<li><a href="https://github.com/chaffz">Yuxin Wu</a></li>
<li><a href="https://github.com/SmallPond">Biao Ding</a></li>
<li><a href="https://github.com/slowy07">Arfy slowy</a></li>
<li><a href="https://github.com/junbo42">Junbo Jiang</a></li>
<li><a href="https://github.com/dexterp">Dexter Plameras</a></li>
<li><a href="https://github.com/waltforme">Jun Duan</a></li>
<li><a href="https://github.com/XieGuochao">Guochao Xie</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
