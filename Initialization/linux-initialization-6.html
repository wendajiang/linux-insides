<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Architecture-specific initializations, again... - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html" class="active">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="kernel-initialization-part-6"><a class="header" href="#kernel-initialization-part-6">Kernel initialization. Part 6.</a></h1>
<h1 id="architecture-specific-initialization-again"><a class="header" href="#architecture-specific-initialization-again">Architecture-specific initialization, again...</a></h1>
<p>In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">part</a> we saw architecture-specific (<code>x86_64</code> in our case) initialization stuff from the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> and finished on <code>x86_configure_nx</code> function which sets the <code>_PAGE_NX</code> flag depends on support of <a href="http://en.wikipedia.org/wiki/NX_bit">NX bit</a>. As I wrote before <code>setup_arch</code> function and <code>start_kernel</code> are very big, so in this and in the next part we will continue to learn about architecture-specific initialization process. The next function after <code>x86_configure_nx</code> is <code>parse_early_param</code>. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> and as you can understand from its name, this function parses kernel command line and setups different services depends on the given parameters (all kernel command line parameters you can find are in the <a href="https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.rst">Documentation/kernel-parameters.txt</a>). You may remember how we setup <code>earlyprintk</code> in the earliest <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-2">part</a>. On the early stage we looked for kernel parameters and their value with the <code>cmdline_find_option</code> function and <code>__cmdline_find_option</code>, <code>__cmdline_find_option_bool</code> helpers from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/boot/cmdline.c">arch/x86/boot/cmdline.c</a>. There we're in the generic kernel part which does not depend on architecture and here we use another approach. If you are reading Linux kernel source code, you already note calls like this:</p>
<pre><code class="language-C">early_param(&quot;gbpages&quot;, parse_direct_gbpages_on);
</code></pre>
<p><code>early_param</code> macro takes two parameters:</p>
<ul>
<li>command line parameter name;</li>
<li>function which will be called if given parameter is passed.</li>
</ul>
<p>and defined as:</p>
<pre><code class="language-C">#define early_param(str, fn) \
        __setup_param(str, fn, fn, 1)
</code></pre>
<p>in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/init.h">include/linux/init.h</a>. As you can see <code>early_param</code> macro just makes call of the <code>__setup_param</code> macro:</p>
<pre><code class="language-C">#define __setup_param(str, unique_id, fn, early)                \
        static const char __setup_str_##unique_id[] __initconst \
                __aligned(1) = str; \
        static struct obs_kernel_param __setup_##unique_id      \
                __used __section(.init.setup)                   \
                __attribute__((aligned((sizeof(long)))))        \
                = { __setup_str_##unique_id, fn, early }
</code></pre>
<p>This macro defines <code>__setup_str_*_id</code> variable (where <code>*</code> depends on given function name) and assigns it to the given command line parameter name. In the next line we can see definition of the <code>__setup_*</code> variable which type is <code>obs_kernel_param</code> and its initialization. <code>obs_kernel_param</code> structure defined as:</p>
<pre><code class="language-C">struct obs_kernel_param {
        const char *str;
        int (*setup_func)(char *);
        int early;
};
</code></pre>
<p>and contains three fields:</p>
<ul>
<li>name of the kernel parameter;</li>
<li>function which setups something depend on parameter;</li>
<li>field determines is parameter early (1) or not (0).</li>
</ul>
<p>Note that <code>__set_param</code> macro defines with <code>__section(.init.setup)</code> attribute. It means that all <code>__setup_str_*</code> will be placed in the <code>.init.setup</code> section, moreover, as we can see in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/asm-generic/vmlinux.lds.h">include/asm-generic/vmlinux.lds.h</a>, they will be placed between <code>__setup_start</code> and <code>__setup_end</code>:</p>
<pre><code>#define INIT_SETUP(initsetup_align)                \
                . = ALIGN(initsetup_align);        \
                VMLINUX_SYMBOL(__setup_start) = .; \
                *(.init.setup)                     \
                VMLINUX_SYMBOL(__setup_end) = .;
</code></pre>
<p>Now we know how parameters are defined, let's back to the <code>parse_early_param</code> implementation:</p>
<pre><code class="language-C">void __init parse_early_param(void)
{
        static int done __initdata;
        static char tmp_cmdline[COMMAND_LINE_SIZE] __initdata;

        if (done)
                return;

        /* All fall through to do_early_param. */
        strlcpy(tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);
        parse_early_options(tmp_cmdline);
        done = 1;
}
</code></pre>
<p>The <code>parse_early_param</code> function defines two static variables. First <code>done</code> check that <code>parse_early_param</code> already called and the second is temporary storage for kernel command line. After this we copy <code>boot_command_line</code> to the temporary command line which we just defined and call the <code>parse_early_options</code> function from the same source code <code>main.c</code> file. <code>parse_early_options</code> calls the <code>parse_args</code> function from the <a href="https://github.com/torvalds/linux">kernel/params.c</a> where <code>parse_args</code> parses given command line and calls <code>do_early_param</code> function. This <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c#L413">function</a> goes from the <code> __setup_start</code> to <code>__setup_end</code>, and calls the function from the <code>obs_kernel_param</code> if a parameter is early. After this all services which are depend on early command line parameters were setup and the next call after the <code>parse_early_param</code> is <code>x86_report_nx</code>. As I wrote in the beginning of this part, we already set <code>NX-bit</code> with the <code>x86_configure_nx</code>. The next <code>x86_report_nx</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/setup_nx.c">arch/x86/mm/setup_nx.c</a> just prints information about the <code>NX</code>. Note that we call <code>x86_report_nx</code> not right after the <code>x86_configure_nx</code>, but after the call of the <code>parse_early_param</code>. The answer is simple: we call it after the <code>parse_early_param</code> because the kernel support <code>noexec</code> parameter:</p>
<pre><code>noexec		[X86]
			On X86-32 available only on PAE configured kernels.
			noexec=on: enable non-executable mappings (default)
			noexec=off: disable non-executable mappings
</code></pre>
<p>We can see it in the booting time:</p>
<p><img src="images/NX.png" alt="NX" /></p>
<p>After this we can see call of the:</p>
<pre><code class="language-C">	memblock_x86_reserve_range_setup_data();
</code></pre>
<p>function. This function is defined in the same <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> source code file and remaps memory for the <code>setup_data</code> and reserved memory block for the <code>setup_data</code> (more about <code>setup_data</code> you can read in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">part</a> and about <code>ioremap</code> and <code>memblock</code> you can read in the <a href="https://0xax.gitbook.io/linux-insides/summary/mm">Linux kernel memory management</a>).</p>
<p>In the next step we can see following conditional statement:</p>
<pre><code class="language-C">	if (acpi_mps_check()) {
#ifdef CONFIG_X86_LOCAL_APIC
		disable_apic = 1;
#endif
		setup_clear_cpu_cap(X86_FEATURE_APIC);
	}
</code></pre>
<p>The first <code>acpi_mps_check</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/acpi/boot.c">arch/x86/kernel/acpi/boot.c</a> depends on <code>CONFIG_X86_LOCAL_APIC</code> and <code>CONFIG_x86_MPPARSE</code> configuration options:</p>
<pre><code class="language-C">int __init acpi_mps_check(void)
{
#if defined(CONFIG_X86_LOCAL_APIC) &amp;&amp; !defined(CONFIG_X86_MPPARSE)
        /* mptable code is not built-in*/
        if (acpi_disabled || acpi_noirq) {
                printk(KERN_WARNING &quot;MPS support code is not built-in.\n&quot;
                       &quot;Using acpi=off or acpi=noirq or pci=noacpi &quot;
                       &quot;may have problem\n&quot;);
                 return 1;
        }
#endif
        return 0;
}
</code></pre>
<p>It checks the built-in <code>MPS</code> or <a href="http://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Specification</a> table. If <code>CONFIG_X86_LOCAL_APIC</code> is set and <code>CONFIG_x86_MPPARSE</code> is not set, <code>acpi_mps_check</code> prints warning message if the one of the command line options: <code>acpi=off</code>, <code>acpi=noirq</code> or <code>pci=noacpi</code> passed to the kernel. If <code>acpi_mps_check</code> returns <code>1</code> it means that we disable local <a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a> and clear <code>X86_FEATURE_APIC</code> bit in the of the current CPU with the <code>setup_clear_cpu_cap</code> macro. (more about CPU mask you can read in the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">CPU masks</a>).</p>
<h2 id="early-pci-dump"><a class="header" href="#early-pci-dump">Early PCI dump</a></h2>
<p>In the next step we make a dump of the <a href="http://en.wikipedia.org/wiki/Conventional_PCI">PCI</a> devices with the following code:</p>
<pre><code class="language-C">#ifdef CONFIG_PCI
	if (pci_early_dump_regs)
		early_dump_pci_devices();
#endif
</code></pre>
<p><code>pci_early_dump_regs</code> variable defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/pci/common.c">arch/x86/pci/common.c</a> and its value depends on the kernel command line parameter: <code>pci=earlydump</code>. We can find definition of this parameter in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch">drivers/pci/pci.c</a>:</p>
<pre><code class="language-C">early_param(&quot;pci&quot;, pci_setup);
</code></pre>
<p><code>pci_setup</code> function gets the string after the <code>pci=</code> and analyzes it. This function calls <code>pcibios_setup</code> which defined as <code>__weak</code> in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch">drivers/pci/pci.c</a> and every architecture defines the same function which overrides <code>__weak</code> analog. For example <code>x86_64</code> architecture-dependent version is in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/pci/common.c">arch/x86/pci/common.c</a>:</p>
<pre><code class="language-C">char *__init pcibios_setup(char *str) {
        ...
		...
		...
		} else if (!strcmp(str, &quot;earlydump&quot;)) {
                pci_early_dump_regs = 1;
                return NULL;
        }
		...
		...
		...
}
</code></pre>
<p>So, if <code>CONFIG_PCI</code> option is set and we passed <code>pci=earlydump</code> option to the kernel command line, next function which will be called - <code>early_dump_pci_devices</code> from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/pci/early.c">arch/x86/pci/early.c</a>. This function checks <code>noearly</code> PCI parameter with:</p>
<pre><code class="language-C">if (!early_pci_allowed())
        return;
</code></pre>
<p>and returns if it was passed. Each PCI domain can host up to <code>256</code> buses and each bus hosts up to 32 devices. So, we goes in a loop:</p>
<pre><code class="language-C">for (bus = 0; bus &lt; 256; bus++) {
                for (slot = 0; slot &lt; 32; slot++) {
                        for (func = 0; func &lt; 8; func++) {
						...
						...
						...
                        }
                }
}
</code></pre>
<p>and read the <code>pci</code> config with the <code>read_pci_config</code> function.</p>
<p>That's all. We will not go deep in the <code>pci</code> details, but will see more details in the special <code>Drivers/PCI</code> part.</p>
<h2 id="finish-with-memory-parsing"><a class="header" href="#finish-with-memory-parsing">Finish with memory parsing</a></h2>
<p>After the <code>early_dump_pci_devices</code>, there are a couple of function related with available memory and <a href="http://en.wikipedia.org/wiki/E820">e820</a> which we collected in the <a href="https://0xax.gitbook.io/linux-insides/summary/booting/linux-bootstrap-2">First steps in the kernel setup</a> part:</p>
<pre><code class="language-C">	/* update the e820_saved too */
	e820_reserve_setup_data();
	finish_e820_parsing();
	...
	...
	...
	e820_add_kernel_range();
	trim_bios_range(void);
	max_pfn = e820_end_of_ram_pfn();
	early_reserve_e820_mpc_new();
</code></pre>
<p>Let's look at it. As you can see the first function is <code>e820_reserve_setup_data</code>. This function does almost the same as <code>memblock_x86_reserve_range_setup_data</code> which we saw above, but it also calls <code>e820_update_range</code> which adds new regions to the <code>e820map</code> with the given type which is <code>E820_RESERVED_KERN</code> in our case. The next function is <code>finish_e820_parsing</code> which sanitizes <code>e820map</code> with the <code>sanitize_e820_map</code> function. Besides this two functions we can see a couple of functions related to the <a href="http://en.wikipedia.org/wiki/E820">e820</a>. You can see it in the listing above. <code>e820_add_kernel_range</code> function takes the physical address of the kernel start and end:</p>
<pre><code class="language-C">u64 start = __pa_symbol(_text);
u64 size = __pa_symbol(_end) - start;
</code></pre>
<p>checks that <code>.text</code> <code>.data</code> and <code>.bss</code> marked as <code>E820RAM</code> in the <code>e820map</code> and prints the warning message if not. The next function <code>trm_bios_range</code> update first 4096 bytes in <code>e820Map</code> as <code>E820_RESERVED</code> and sanitizes it again with the call of the <code>sanitize_e820_map</code>. After this we get the last page frame number with the call of the <code>e820_end_of_ram_pfn</code> function. Every memory page has a unique number - <code>Page frame number</code>  and <code>e820_end_of_ram_pfn</code> function returns the maximum with the call of the <code>e820_end_pfn</code>:</p>
<pre><code class="language-C">unsigned long __init e820_end_of_ram_pfn(void)
{
	return e820_end_pfn(MAX_ARCH_PFN);
}
</code></pre>
<p>where <code>e820_end_pfn</code> takes maximum page frame number on the certain architecture (<code>MAX_ARCH_PFN</code> is <code>0x400000000</code> for <code>x86_64</code>). In the <code>e820_end_pfn</code> we go through the all <code>e820</code> slots and check that <code>e820</code> entry has <code>E820_RAM</code> or <code>E820_PRAM</code> type because we calculate page frame numbers only for these types, gets the base address and end address of the page frame number for the current <code>e820</code> entry and makes some checks for these addresses:</p>
<pre><code class="language-C">for (i = 0; i &lt; e820.nr_map; i++) {
		struct e820entry *ei = &amp;e820.map[i];
		unsigned long start_pfn;
		unsigned long end_pfn;

		if (ei-&gt;type != E820_RAM &amp;&amp; ei-&gt;type != E820_PRAM)
			continue;

		start_pfn = ei-&gt;addr &gt;&gt; PAGE_SHIFT;
		end_pfn = (ei-&gt;addr + ei-&gt;size) &gt;&gt; PAGE_SHIFT;

        if (start_pfn &gt;= limit_pfn)
			continue;
		if (end_pfn &gt; limit_pfn) {
			last_pfn = limit_pfn;
			break;
		}
		if (end_pfn &gt; last_pfn)
			last_pfn = end_pfn;
}
</code></pre>
<pre><code class="language-C">	if (last_pfn &gt; max_arch_pfn)
		last_pfn = max_arch_pfn;

	printk(KERN_INFO &quot;e820: last_pfn = %#lx max_arch_pfn = %#lx\n&quot;,
			 last_pfn, max_arch_pfn);
	return last_pfn;
</code></pre>
<p>After this we check that <code>last_pfn</code> which we got in the loop is not greater that maximum page frame number for the certain architecture (<code>x86_64</code> in our case), print information about last page frame number and return it. We can see the <code>last_pfn</code> in the <code>dmesg</code> output:</p>
<pre><code>...
[    0.000000] e820: last_pfn = 0x41f000 max_arch_pfn = 0x400000000
...
</code></pre>
<p>After this, as we have calculated the biggest page frame number, we calculate <code>max_low_pfn</code> which is the biggest page frame number in the <code>low memory</code> or below first <code>4</code> gigabytes. If installed more than 4 gigabytes of RAM, <code>max_low_pfn</code> will be result of the <code>e820_end_of_low_ram_pfn</code> function which does the same <code>e820_end_of_ram_pfn</code> but with 4 gigabytes limit, in other way <code>max_low_pfn</code> will be the same as <code>max_pfn</code>:</p>
<pre><code class="language-C">if (max_pfn &gt; (1UL&lt;&lt;(32 - PAGE_SHIFT)))
	max_low_pfn = e820_end_of_low_ram_pfn();
else
	max_low_pfn = max_pfn;

high_memory = (void *)__va(max_pfn * PAGE_SIZE - 1) + 1;
</code></pre>
<p>Next we calculate <code>high_memory</code> (defines the upper bound on direct map memory) with <code>__va</code> macro which returns a virtual address by the given physical memory.</p>
<h2 id="dmi-scanning"><a class="header" href="#dmi-scanning">DMI scanning</a></h2>
<p>The next step after manipulations with different memory regions and <code>e820</code> slots is collecting information about computer. We will get all information with the <a href="http://en.wikipedia.org/wiki/Desktop_Management_Interface">Desktop Management Interface</a> and following functions:</p>
<pre><code class="language-C">dmi_scan_machine();
dmi_memdev_walk();
</code></pre>
<p>First is <code>dmi_scan_machine</code> defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/drivers/firmware/dmi_scan.c">drivers/firmware/dmi_scan.c</a>. This function goes through the <a href="http://en.wikipedia.org/wiki/System_Management_BIOS">System Management BIOS</a> structures and extracts information. There are two ways specified to gain access to the <code>SMBIOS</code> table: get the pointer to the <code>SMBIOS</code> table from the <a href="http://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">EFI</a>'s configuration table and scanning the physical memory between <code>0xF0000</code> and <code>0xFFFFF</code> addresses, <code>0x10000</code> bytes totally. Let's look on the second approach. <code>dmi_scan_machine</code> function remaps memory addresses start from <code>0xF0000</code> to <code>0xFFFFF</code> with size of <code>0x10000</code> bytes with the <code>dmi_early_remap</code> which just expands to the <code>early_ioremap</code>:</p>
<pre><code class="language-C">void __init dmi_scan_machine(void)
{
	char __iomem *p, *q;
	char buf[32];
	...
	...
	...
	p = dmi_early_remap(0xF0000, 0x10000);
	if (p == NULL)
			goto error;
</code></pre>
<p>and iterates over all <code>DMI</code> header address and find search <code>_SM_</code> string:</p>
<pre><code class="language-C">memset(buf, 0, 16);
for (q = p; q &lt; p + 0x10000; q += 16) {
		memcpy_fromio(buf + 16, q, 16);
		if (!dmi_smbios3_present(buf) || !dmi_present(buf)) {
			dmi_available = 1;
			dmi_early_unmap(p, 0x10000);
			goto out;
		}
		memcpy(buf, buf + 16, 16);
}
</code></pre>
<p><code>_SM_</code> string must be between <code>000F0000h</code> and <code>0x000FFFFF</code>. Here we copy 16 bytes to the <code>buf</code> with <code>memcpy_fromio</code> which is the same <code>memcpy</code> and execute <code>dmi_smbios3_present</code> and <code>dmi_present</code> on the buffer. These functions check that first 4 bytes is <code>_SM_</code> string, get <code>SMBIOS</code> version and gets <code>_DMI_</code> attributes as <code>DMI</code> structure table length, table address and etc... After one of these functions finish, you will see the result of it in the <code>dmesg</code> output:</p>
<pre><code>[    0.000000] SMBIOS 2.7 present.
[    0.000000] DMI: Gigabyte Technology Co., Ltd. Z97X-UD5H-BK/Z97X-UD5H-BK, BIOS F6 06/17/2014
</code></pre>
<p>In the end of the <code>dmi_scan_machine</code>, we unmap the previously remapped memory:</p>
<pre><code class="language-C">dmi_early_unmap(p, 0x10000);
</code></pre>
<p>The second function is - <code>dmi_memdev_walk</code>. As you can understand it goes over memory devices. Let's look on it:</p>
<pre><code class="language-C">void __init dmi_memdev_walk(void)
{
	if (!dmi_available)
		return;

	if (dmi_walk_early(count_mem_devices) == 0 &amp;&amp; dmi_memdev_nr) {
		dmi_memdev = dmi_alloc(sizeof(*dmi_memdev) * dmi_memdev_nr);
		if (dmi_memdev)
			dmi_walk_early(save_mem_devices);
	}
}
</code></pre>
<p>It checks that <code>DMI</code> available (we got it in the previous function - <code>dmi_scan_machine</code>) and collects information about memory devices with <code>dmi_walk_early</code> and <code>dmi_alloc</code> which defined as:</p>
<pre><code>#ifdef CONFIG_DMI
RESERVE_BRK(dmi_alloc, 65536);
#endif
</code></pre>
<p><code>RESERVE_BRK</code> defined in the <a href="http://github.com/torvalds/linux/blob/master/arch/x86/include/asm/setup.h">arch/x86/include/asm/setup.h</a> and reserves space with given size in the <code>brk</code> section.</p>
<hr />
<pre><code>init_hypervisor_platform();
x86_init.resources.probe_roms();
insert_resource(&amp;iomem_resource, &amp;code_resource);
insert_resource(&amp;iomem_resource, &amp;data_resource);
insert_resource(&amp;iomem_resource, &amp;bss_resource);
early_gart_iommu_check();
</code></pre>
<h2 id="smp-config"><a class="header" href="#smp-config">SMP config</a></h2>
<p>The next step is parsing of the <a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a> configuration. We do it with the call of the <code>find_smp_config</code> function which just calls function:</p>
<pre><code class="language-C">static inline void find_smp_config(void)
{
        x86_init.mpparse.find_smp_config();
}
</code></pre>
<p>inside. <code>x86_init.mpparse.find_smp_config</code> is the <code>default_find_smp_config</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/mpparse.c">arch/x86/kernel/mpparse.c</a>. In the <code>default_find_smp_config</code> function we are scanning a couple of memory regions for <code>SMP</code> config and return if they are found:</p>
<pre><code class="language-C">if (smp_scan_config(0x0, 0x400) ||
            smp_scan_config(639 * 0x400, 0x400) ||
            smp_scan_config(0xF0000, 0x10000))
            return;
</code></pre>
<p>First of all <code>smp_scan_config</code> function defines a couple of variables:</p>
<pre><code class="language-C">unsigned int *bp = phys_to_virt(base);
struct mpf_intel *mpf;
</code></pre>
<p>First is virtual address of the memory region where we will scan <code>SMP</code> config, second is the pointer to the <code>mpf_intel</code> structure. Let's try to understand what is it <code>mpf_intel</code>. All information stores in the multiprocessor configuration data structure. <code>mpf_intel</code> presents this structure and looks:</p>
<pre><code class="language-C">struct mpf_intel {
        char signature[4];
        unsigned int physptr;
        unsigned char length;
        unsigned char specification;
        unsigned char checksum;
        unsigned char feature1;
        unsigned char feature2;
        unsigned char feature3;
        unsigned char feature4;
        unsigned char feature5;
};
</code></pre>
<p>As we can read in the documentation - one of the main functions of the system BIOS is to construct the MP floating pointer structure and the MP configuration table. And operating system must have access to this information about the multiprocessor configuration and <code>mpf_intel</code> stores the physical address (look at second parameter) of the multiprocessor configuration table. So, <code>smp_scan_config</code> going in a loop through the given memory range and tries to find <code>MP floating pointer structure</code> there. It checks that current byte points to the <code>SMP</code> signature, checks checksum, checks if <code>mpf-&gt;specification</code> is 1 or 4(it must be <code>1</code> or <code>4</code> by specification) in the loop:</p>
<pre><code class="language-C">while (length &gt; 0) {
if ((*bp == SMP_MAGIC_IDENT) &amp;&amp;
    (mpf-&gt;length == 1) &amp;&amp;
    !mpf_checksum((unsigned char *)bp, 16) &amp;&amp;
    ((mpf-&gt;specification == 1)
    || (mpf-&gt;specification == 4))) {

        mem = virt_to_phys(mpf);
        memblock_reserve(mem, sizeof(*mpf));
        if (mpf-&gt;physptr)
            smp_reserve_memory(mpf);
	}
}
</code></pre>
<p>reserves given memory block if search is successful with <code>memblock_reserve</code> and reserves physical address of the multiprocessor configuration table. You can find documentation about this in the - <a href="http://www.intel.com/design/pentium/datashts/24201606.pdf">MultiProcessor Specification</a>. You can read More details in the special part about <code>SMP</code>.</p>
<h2 id="additional-early-memory-initialization-routines"><a class="header" href="#additional-early-memory-initialization-routines">Additional early memory initialization routines</a></h2>
<p>In the next step of the <code>setup_arch</code> we can see the call of the <code>early_alloc_pgt_buf</code> function which allocates the page table buffer for early stage. The page table buffer will be placed in the <code>brk</code> area. Let's look on its implementation:</p>
<pre><code class="language-C">void  __init early_alloc_pgt_buf(void)
{
        unsigned long tables = INIT_PGT_BUF_SIZE;
        phys_addr_t base;

        base = __pa(extend_brk(tables, PAGE_SIZE));

        pgt_buf_start = base &gt;&gt; PAGE_SHIFT;
        pgt_buf_end = pgt_buf_start;
        pgt_buf_top = pgt_buf_start + (tables &gt;&gt; PAGE_SHIFT);
}
</code></pre>
<p>First of all it get the size of the page table buffer, it will be <code>INIT_PGT_BUF_SIZE</code> which is <code>(6 * PAGE_SIZE)</code> in the current Linux kernel 4.0. As we got the size of the page table buffer, we call <code>extend_brk</code> function with two parameters: size and align. As you can understand from its name, this function extends the <code>brk</code> area. As we can see in the linux kernel linker script <code>brk</code> is in memory right after the <a href="http://en.wikipedia.org/wiki/.bss">BSS</a>:</p>
<pre><code class="language-C">	. = ALIGN(PAGE_SIZE);
	.brk : AT(ADDR(.brk) - LOAD_OFFSET) {
		__brk_base = .;
		. += 64 * 1024;		/* 64k alignment slop space */
		*(.brk_reservation)	/* areas brk users have reserved */
		__brk_limit = .;
	}
</code></pre>
<p>Or we can find it with <code>readelf</code> util:</p>
<p><img src="images/brk_area.png" alt="brk area" /></p>
<p>After that we got physical address of the new <code>brk</code> with the <code>__pa</code> macro, we calculate the base address and the end of the page table buffer. In the next step as we got page table buffer, we reserve memory block for the brk area with the <code>reserve_brk</code> function:</p>
<pre><code class="language-C">static void __init reserve_brk(void)
{
	if (_brk_end &gt; _brk_start)
		memblock_reserve(__pa_symbol(_brk_start),
				 _brk_end - _brk_start);

	_brk_start = 0;
}
</code></pre>
<p>Note that in the end of the <code>reserve_brk</code>, we set <code>brk_start</code> to zero, because after this we will not allocate it anymore. The next step after reserving memory block for the <code>brk</code>, we need to unmap out-of-range memory areas in the kernel mapping with the <code>cleanup_highmap</code> function. Remember that kernel mapping is <code>__START_KERNEL_map</code> and <code>_end - _text</code> or <code>level2_kernel_pgt</code> maps the kernel <code>_text</code>, <code>data</code> and <code>bss</code>. In the start of the <code>clean_high_map</code> we define these parameters:</p>
<pre><code class="language-C">unsigned long vaddr = __START_KERNEL_map;
unsigned long end = roundup((unsigned long)_end, PMD_SIZE) - 1;
pmd_t *pmd = level2_kernel_pgt;
pmd_t *last_pmd = pmd + PTRS_PER_PMD;
</code></pre>
<p>Now, as we defined start and end of the kernel mapping, we go in the loop through the all kernel page middle directory entries and clean entries which are not between <code>_text</code> and <code>end</code>:</p>
<pre><code class="language-C">for (; pmd &lt; last_pmd; pmd++, vaddr += PMD_SIZE) {
        if (pmd_none(*pmd))
            continue;
        if (vaddr &lt; (unsigned long) _text || vaddr &gt; end)
            set_pmd(pmd, __pmd(0));
}
</code></pre>
<p>After this we set the limit for the <code>memblock</code> allocation with the <code>memblock_set_current_limit</code> function (read more about <code>memblock</code> you can in the <a href="https://github.com/0xAX/linux-insides/blob/master/MM/linux-mm-2.md">Linux kernel memory management Part 2</a>), it will be <code>ISA_END_ADDRESS</code> or <code>0x100000</code> and fill the <code>memblock</code> information according to <code>e820</code> with the call of the <code>memblock_x86_fill</code> function. You can see the result of this function in the kernel initialization time:</p>
<pre><code>MEMBLOCK configuration:
 memory size = 0x1fff7ec00 reserved size = 0x1e30000
 memory.cnt  = 0x3
 memory[0x0]	[0x00000000001000-0x0000000009efff], 0x9e000 bytes flags: 0x0
 memory[0x1]	[0x00000000100000-0x000000bffdffff], 0xbfee0000 bytes flags: 0x0
 memory[0x2]	[0x00000100000000-0x0000023fffffff], 0x140000000 bytes flags: 0x0
 reserved.cnt  = 0x3
 reserved[0x0]	[0x0000000009f000-0x000000000fffff], 0x61000 bytes flags: 0x0
 reserved[0x1]	[0x00000001000000-0x00000001a57fff], 0xa58000 bytes flags: 0x0
 reserved[0x2]	[0x0000007ec89000-0x0000007fffffff], 0x1377000 bytes flags: 0x0
</code></pre>
<p>The rest functions after the <code>memblock_x86_fill</code> are: <code>early_reserve_e820_mpc_new</code> allocates additional slots in the <code>e820map</code> for MultiProcessor Specification table, <code>reserve_real_mode</code> - reserves low memory from <code>0x0</code> to 1 megabyte for the trampoline to the real mode (for rebooting, etc.), <code>trim_platform_memory_ranges</code> - trims certain memory regions started from <code>0x20050000</code>, <code>0x20110000</code>, etc. these regions must be excluded because <a href="http://en.wikipedia.org/wiki/Sandy_Bridge">Sandy Bridge</a> has problems with these regions, <code>trim_low_memory_range</code> reserves the first 4 kilobyte page in <code>memblock</code>, <code>init_mem_mapping</code> function reconstructs direct memory mapping and setups the direct mapping of the physical memory at <code>PAGE_OFFSET</code>, <code>early_trap_pf_init</code> setups <code>#PF</code> handler (we will look on it in the chapter about interrupts) and <code>setup_real_mode</code> function setups trampoline to the <a href="http://en.wikipedia.org/wiki/Real_mode">real mode</a> code.</p>
<p>That's all. You can note that this part will not cover all functions which are in the <code>setup_arch</code> (like <code>early_gart_iommu_check</code>, <a href="http://en.wikipedia.org/wiki/Memory_type_range_register">mtrr</a> initialization, etc.). As I already wrote many times, <code>setup_arch</code> is big, and Linux kernel is big. That's why I can't cover every line in the linux kernel. I don't think that we missed something important, but you can say something like: each line of code is important. Yes, it's true, but I missed them anyway, because I think that it is not realistic to cover full linux kernel. Anyway we will often return to the idea that we have already seen, and if something is unfamiliar, we will cover this theme.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>It is the end of the sixth part about Linux kernel initialization process. In this part we continued to dive in the <code>setup_arch</code> function again and it was long part, but we are not finished with it. Yes, <code>setup_arch</code> is big, hope that next part will be the last part about this function.</p>
<p>If you have any questions or suggestions write me a comment or ping me at <a href="https://twitter.com/0xAX">twitter</a>.</p>
<p><strong>Please note that English is not my first language, And I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/MultiProcessor_Specification">MultiProcessor Specification</a></li>
<li><a href="http://en.wikipedia.org/wiki/NX_bit">NX bit</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/kernel-parameters.rst">Documentation/kernel-parameters.txt</a></li>
<li><a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">APIC</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">CPU masks</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm">Linux kernel memory management</a></li>
<li><a href="http://en.wikipedia.org/wiki/Conventional_PCI">PCI</a></li>
<li><a href="http://en.wikipedia.org/wiki/E820">e820</a></li>
<li><a href="http://en.wikipedia.org/wiki/System_Management_BIOS">System Management BIOS</a></li>
<li><a href="http://en.wikipedia.org/wiki/System_Management_BIOS">System Management BIOS</a></li>
<li><a href="http://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">EFI</a></li>
<li><a href="http://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a></li>
<li><a href="http://www.intel.com/design/pentium/datashts/24201606.pdf">MultiProcessor Specification</a></li>
<li><a href="http://en.wikipedia.org/wiki/.bss">BSS</a></li>
<li><a href="http://www.dmtf.org/sites/default/files/standards/documents/DSP0134v2.5Final.pdf">SMBIOS specification</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">Previous part</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Initialization/linux-initialization-5.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Initialization/linux-initialization-7.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Initialization/linux-initialization-5.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Initialization/linux-initialization-7.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
