<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cpumasks - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html" class="active">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cpu-masks"><a class="header" href="#cpu-masks">CPU masks</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p><code>Cpumasks</code> is a special way provided by the Linux kernel to store information about CPUs in the system. The relevant source code and header files which contains API for <code>Cpumasks</code> manipulation:</p>
<ul>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/cpumask.h">include/linux/cpumask.h</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/lib/cpumask.c">lib/cpumask.c</a></li>
<li><a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/cpu.c">kernel/cpu.c</a></li>
</ul>
<p>As comment says from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/cpumask.h">include/linux/cpumask.h</a>: Cpumasks provide a bitmap suitable for representing the set of CPU's in a system, one bit position per CPU number. We already saw a bit about cpumask in the <code>boot_cpu_init</code> function from the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">Kernel entry point</a> part. This function makes first boot cpu online, active and etc...:</p>
<pre><code class="language-C">set_cpu_online(cpu, true);
set_cpu_active(cpu, true);
set_cpu_present(cpu, true);
set_cpu_possible(cpu, true);
</code></pre>
<p>Before we consider implementation of these functions, let's consider all of these masks.</p>
<p>The <code>cpu_possible</code> is a set of cpu ID's which can be plugged in anytime during the life of that system boot or in other words mask of possible CPUs contains maximum number of CPUs which are possible in the system. It will be equal to value of the <code>NR_CPUS</code> which is set statically via the <code>CONFIG_NR_CPUS</code> kernel configuration option.</p>
<p>The <code>cpu_present</code> mask represents which CPUs are currently plugged in.</p>
<p>The <code>cpu_online</code> represents a subset of the <code>cpu_present</code> and indicates CPUs which are available for scheduling or in other words a bit from this mask tells the kernel if a processor may be utilized by the Linux kernel.</p>
<p>The last mask is <code>cpu_active</code>. Bits of this mask tells to Linux kernel is a task may be moved to a certain processor.</p>
<p>All of these masks depend on the <code>CONFIG_HOTPLUG_CPU</code> configuration option and if this option is disabled <code>possible == present</code> and <code>active == online</code>. The implementations of all of these functions are very similar. Every function checks the second parameter. If it is <code>true</code>, it calls <code>cpumask_set_cpu</code> otherwise it calls <code>cpumask_clear_cpu</code> .</p>
<p>There are two ways for a <code>cpumask</code> creation. First is to use <code>cpumask_t</code>. It is defined as:</p>
<pre><code class="language-C">typedef struct cpumask { DECLARE_BITMAP(bits, NR_CPUS); } cpumask_t;
</code></pre>
<p>It wraps the <code>cpumask</code> structure which contains one bitmask <code>bits</code> field. The <code>DECLARE_BITMAP</code> macro gets two parameters:</p>
<ul>
<li>bitmap name;</li>
<li>number of bits.</li>
</ul>
<p>and creates an array of <code>unsigned long</code> with the given name. Its implementation is pretty easy:</p>
<pre><code class="language-C">#define DECLARE_BITMAP(name,bits) \
        unsigned long name[BITS_TO_LONGS(bits)]
</code></pre>
<p>where <code>BITS_TO_LONGS</code>:</p>
<pre><code class="language-C">#define BITS_TO_LONGS(nr)       DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
</code></pre>
<p>As we are focusing on the <code>x86_64</code> architecture, <code>unsigned long</code> is 8-bytes size and our array will contain only one element:</p>
<pre><code>(((8) + (64) - 1) / (64)) = 1
</code></pre>
<p><code>NR_CPUS</code> macro represents the number of CPUs in the system and depends on the <code>CONFIG_NR_CPUS</code> macro which is defined in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/threads.h">include/linux/threads.h</a> and looks like this:</p>
<pre><code class="language-C">#ifndef CONFIG_NR_CPUS
        #define CONFIG_NR_CPUS  1
#endif

#define NR_CPUS         CONFIG_NR_CPUS
</code></pre>
<p>The second way to define cpumask is to use the <code>DECLARE_BITMAP</code> macro directly and the <code>to_cpumask</code> macro which converts the given bitmap to <code>struct cpumask *</code>:</p>
<pre><code class="language-C">#define to_cpumask(bitmap)                                              \
        ((struct cpumask *)(1 ? (bitmap)                                \
                            : (void *)sizeof(__check_is_bitmap(bitmap))))
</code></pre>
<p>We can see the ternary operator operator here which is <code>true</code> every time. <code>__check_is_bitmap</code> inline function is defined as:</p>
<pre><code class="language-C">static inline int __check_is_bitmap(const unsigned long *bitmap)
{
        return 1;
}
</code></pre>
<p>And returns <code>1</code> every time. We need it here for only one purpose: at compile time it checks that a given <code>bitmap</code> is a bitmap, or in other words it checks that a given <code>bitmap</code> has type - <code>unsigned long *</code>. So we just pass <code>cpu_possible_bits</code> to the <code>to_cpumask</code> macro for converting an array of <code>unsigned long</code> to the <code>struct cpumask *</code>.</p>
<h2 id="cpumask-api"><a class="header" href="#cpumask-api">cpumask API</a></h2>
<p>As we can define cpumask with one of the methods, Linux kernel provides API for manipulating a cpumask. Let's consider one of the function which presented above. For example <code>set_cpu_online</code>. This function takes two parameters:</p>
<ul>
<li>Index of CPU;</li>
<li>CPU status;</li>
</ul>
<p>Implementation of this function looks as:</p>
<pre><code class="language-C">void set_cpu_online(unsigned int cpu, bool online)
{
	if (online) {
		cpumask_set_cpu(cpu, to_cpumask(cpu_online_bits));
		cpumask_set_cpu(cpu, to_cpumask(cpu_active_bits));
	} else {
		cpumask_clear_cpu(cpu, to_cpumask(cpu_online_bits));
	}
}
</code></pre>
<p>First of all it checks the second <code>state</code> parameter and calls <code>cpumask_set_cpu</code> or <code>cpumask_clear_cpu</code> depending on it. Here we can see casting to the <code>struct cpumask *</code> of the second parameter in the <code>cpumask_set_cpu</code>. In our case it is <code>cpu_online_bits</code> which is a bitmap and defined as:</p>
<pre><code class="language-C">static DECLARE_BITMAP(cpu_online_bits, CONFIG_NR_CPUS) __read_mostly;
</code></pre>
<p>The <code>cpumask_set_cpu</code> function makes only one call to the <code>set_bit</code> function:</p>
<pre><code class="language-C">static inline void cpumask_set_cpu(unsigned int cpu, struct cpumask *dstp)
{
        set_bit(cpumask_check(cpu), cpumask_bits(dstp));
}
</code></pre>
<p>The <code>set_bit</code> function takes two parameters too, and sets a given bit (first parameter) in the memory (second parameter or <code>cpu_online_bits</code> bitmap). We can see here that before <code>set_bit</code> is called, its two parameters will be passed to the</p>
<ul>
<li>cpumask_check;</li>
<li>cpumask_bits.</li>
</ul>
<p>Let's consider these two macros. First if <code>cpumask_check</code> does nothing in our case and just returns given parameter. The second <code>cpumask_bits</code> just returns the <code>bits</code> field from the given <code>struct cpumask *</code> structure:</p>
<pre><code class="language-C">#define cpumask_bits(maskp) ((maskp)-&gt;bits)
</code></pre>
<p>Now let's look on the <code>set_bit</code> implementation:</p>
<pre><code class="language-C"> static __always_inline void
 set_bit(long nr, volatile unsigned long *addr)
 {
         if (IS_IMMEDIATE(nr)) {
                asm volatile(LOCK_PREFIX &quot;orb %1,%0&quot;
                        : CONST_MASK_ADDR(nr, addr)
                        : &quot;iq&quot; ((u8)CONST_MASK(nr))
                        : &quot;memory&quot;);
        } else {
                asm volatile(LOCK_PREFIX &quot;bts %1,%0&quot;
                        : BITOP_ADDR(addr) : &quot;Ir&quot; (nr) : &quot;memory&quot;);
        }
 }
</code></pre>
<p>This function looks scary, but it is not so hard as it seems. First of all it passes <code>nr</code> or number of the bit to the <code>IS_IMMEDIATE</code> macro which just calls the GCC internal <code>__builtin_constant_p</code> function:</p>
<pre><code class="language-C">#define IS_IMMEDIATE(nr)    (__builtin_constant_p(nr))
</code></pre>
<p><code>__builtin_constant_p</code> checks that given parameter is known constant at compile-time. As our <code>cpu</code> is not compile-time constant, the <code>else</code> clause will be executed:</p>
<pre><code class="language-C">asm volatile(LOCK_PREFIX &quot;bts %1,%0&quot; : BITOP_ADDR(addr) : &quot;Ir&quot; (nr) : &quot;memory&quot;);
</code></pre>
<p>Let's try to understand how it works step by step:</p>
<p><code>LOCK_PREFIX</code> is a x86 <code>lock</code> instruction. This instruction tells the cpu to occupy the system bus while the instruction(s) will be executed. This allows the CPU to synchronize memory access, preventing simultaneous access of multiple processors (or devices - the DMA controller for example) to one memory cell.</p>
<p><code>BITOP_ADDR</code> casts the given parameter to the <code>(*(volatile long *)</code> and adds <code>+m</code> constraints. <code>+</code> means that this operand is both read and written by the instruction. <code>m</code> shows that this is a memory operand. <code>BITOP_ADDR</code> is defined as:</p>
<pre><code class="language-C">#define BITOP_ADDR(x) &quot;+m&quot; (*(volatile long *) (x))
</code></pre>
<p>Next is the <code>memory</code> clobber. It tells the compiler that the assembly code performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters).</p>
<p><code>Ir</code> - immediate register operand.</p>
<p>The <code>bts</code> instruction sets a given bit in a bit string and stores the value of a given bit in the <code>CF</code> flag. So we passed the cpu number which is zero in our case and after <code>set_bit</code> is executed, it sets the zero bit in the <code>cpu_online_bits</code> cpumask. It means that the first cpu is online at this moment.</p>
<p>Besides the <code>set_cpu_*</code> API, cpumask of course provides another API for cpumasks manipulation. Let's consider it in short.</p>
<h2 id="additional-cpumask-api"><a class="header" href="#additional-cpumask-api">Additional cpumask API</a></h2>
<p>cpumask provides a set of macros for getting the numbers of CPUs in various states. For example:</p>
<pre><code class="language-C">#define num_online_cpus()	cpumask_weight(cpu_online_mask)
</code></pre>
<p>This macro returns the amount of <code>online</code> CPUs. It calls the <code>cpumask_weight</code> function with the <code>cpu_online_mask</code> bitmap (read about it). The<code>cpumask_weight</code> function makes one call of the <code>bitmap_weight</code> function with two parameters:</p>
<ul>
<li>cpumask bitmap;</li>
<li><code>nr_cpumask_bits</code> - which is <code>NR_CPUS</code> in our case.</li>
</ul>
<pre><code class="language-C">static inline unsigned int cpumask_weight(const struct cpumask *srcp)
{
	return bitmap_weight(cpumask_bits(srcp), nr_cpumask_bits);
}
</code></pre>
<p>and calculates the number of bits in the given bitmap. Besides the <code>num_online_cpus</code>, cpumask provides macros for the all CPU states:</p>
<ul>
<li>num_possible_cpus;</li>
<li>num_active_cpus;</li>
<li>cpu_online;</li>
<li>cpu_possible.</li>
</ul>
<p>and many more.</p>
<p>Besides that the Linux kernel provides the following API for the manipulation of <code>cpumask</code>:</p>
<ul>
<li><code>for_each_cpu</code> - iterates over every cpu in a mask;</li>
<li><code>for_each_cpu_not</code> - iterates over every cpu in a complemented mask;</li>
<li><code>cpumask_clear_cpu</code> - clears a cpu in a cpumask;</li>
<li><code>cpumask_test_cpu</code> - tests a cpu in a mask;</li>
<li><code>cpumask_setall</code> - set all cpus in a mask;</li>
<li><code>cpumask_size</code> - returns size to allocate for a 'struct cpumask' in bytes;</li>
</ul>
<p>and many many more...</p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">cpumask documentation</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Concepts/linux-cpu-1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Concepts/linux-cpu-3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Concepts/linux-cpu-1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Concepts/linux-cpu-3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
