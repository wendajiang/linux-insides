<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Implementation of the open system call - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html" class="active">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="how-does-the-open-system-call-work"><a class="header" href="#how-does-the-open-system-call-work">How does the <code>open</code> system call work</a></h2>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>This is the fifth part of the chapter that describes <a href="https://en.wikipedia.org/wiki/System_call">system calls</a> mechanism in the Linux kernel. Previous parts of this chapter described the mechanism of system calls in general. I will now try to describe the implementation of different system calls in the Linux kernel. Previous parts from this chapter and parts of other chapters of the book mostly described deep parts of the Linux kernel that are barely visible or  invisible from userspace. However, the greatness of the Linux kernel is not its singular existence, but its ability to enable our code to perform various useful functions such as reading/writing from/to files without the knowledge of details such as sectors, tracks and other nitty gritties of the disk layout. For eg., the kernel allows programs to send data over networks without our having to encapsulate network packets by hand etc.</p>
<p>I don't know how about you, but the inner workings of the operating system both fascinate and excite my curiosity greatly. As you may know, our programs interact with the kernel through a special mechanism called <a href="https://en.wikipedia.org/wiki/System_call">system call</a>. I will hence attempt to describe the implementation and behavior of system calls such as <code>read</code>, <code>write</code>, <code>open</code>, <code>close</code>, <code>dup</code> etc. in a series of articles.</p>
<p>Let me start with the description of the simplest (and commonly used) <a href="http://man7.org/linux/man-pages/man2/open.2.html">open</a> system call. if you have done any <code>C</code> programming at all, you should know that a file must be opened using the <code>open</code> system call before we are able to read/write to it.</p>
<pre><code class="language-C">#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;

int main(int argc, char *argv) {
        int fd = open(&quot;test&quot;, O_RDONLY);

        if fd &lt; 0 {
                perror(&quot;Opening of the file is failed\n&quot;);
        }
        else {
                printf(&quot;file successfully opened\n&quot;);
        }

        close(fd);
        return 0;
}
</code></pre>
<p>In this case, <code>open</code> is a function from standard library, but not the system call. The standard library will call the related system call for us. The <code>open</code> call will return a <a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a> which is just a unique number within our process which is associated with the opened file. Now as we opened a file and got file descriptor as result of <code>open</code> call, we may start to interact with this file. We can write into, read from it and etc. List of opened file by a process is available via <a href="https://en.wikipedia.org/wiki/Procfs">proc</a> filesystem: </p>
<pre><code>$ sudo ls /proc/1/fd/

0  10  12  14  16  2   21  23  25  27  29  30  32  34  36  38  4   41  43  45  47  49  50  53  55  58  6   61  63  67  8
1  11  13  15  19  20  22  24  26  28  3   31  33  35  37  39  40  42  44  46  48  5   51  54  57  59  60  62  65  7   9
</code></pre>
<p>I am not going to describe more details about the <code>open</code> routine from the userspace view in this post, but mostly from the kernel side. If you are not very familiar with, you can get more info in the <a href="http://man7.org/linux/man-pages/man2/open.2.html">man page</a>.</p>
<p>So let's start.</p>
<h2 id="definition-of-the-open-system-call"><a class="header" href="#definition-of-the-open-system-call">Definition of the open system call</a></h2>
<p>If you have read the <a href="https://github.com/0xAX/linux-insides/blob/master/SysCall/linux-syscall-4.md">fourth part</a> of the <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">linux-insides</a> book, you should know that system calls are defined with the help of <code>SYSCALL_DEFINE</code> macro. So, the <code>open</code> system call is no exception.</p>
<p>Definition of the <code>open</code> system call is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c">fs/open.c</a> source code file and looks pretty small for the first view:</p>
<pre><code class="language-C">SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
{
	if (force_o_largefile())
		flags |= O_LARGEFILE;

	return do_sys_open(AT_FDCWD, filename, flags, mode);
}
</code></pre>
<p>As you may guess, the <code>do_sys_open</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c">same</a> source code file does the main job. But before this function is called, let's consider the <code>if</code> clause from which the implementation of the <code>open</code> system call starts:</p>
<pre><code class="language-C">if (force_o_largefile())
	flags |= O_LARGEFILE;
</code></pre>
<p>Here we apply the <code>O_LARGEFILE</code> flag to the flags which were passed to <code>open</code> system call in a case when the <code>force_o_largefile()</code> will return true.
What is <code>O_LARGEFILE</code>? We may read this in the <a href="http://man7.org/linux/man-pages/man2/open.2.html">man page</a> for the <code>open(2)</code> system call:</p>
<blockquote>
<p>O_LARGEFILE</p>
<p>(LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened.</p>
</blockquote>
<p>As we may read in the <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Position-Primitive">GNU C Library Reference Manual</a>:</p>
<blockquote>
<p>off_t</p>
<p>This is a signed integer type used to represent file sizes.
In the GNU C Library, this type is no narrower than int.
If the source is compiled with _FILE_OFFSET_BITS == 64 this
type is transparently replaced by off64_t.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>off64_t</p>
<p>This type is used similar to off_t. The difference is that
even on 32 bit machines, where the off_t type would have 32 bits,
off64_t has 64 bits and so is able to address files up to 2^63 bytes
in length. When compiling with _FILE_OFFSET_BITS == 64 this type
is available under the name off_t.</p>
</blockquote>
<p>So it is not hard to guess that the <code>off_t</code>, <code>off64_t</code> and <code>O_LARGEFILE</code> are about a file size. In the case of the Linux kernel, the <code>O_LARGEFILE</code> is used  to disallow opening large files on 32bit systems if the caller didn't specify <code>O_LARGEFILE</code> flag during opening of a file. On 64bit systems we force on this flag in open system call. And the <code>force_o_largefile</code> macro from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/fcntl.h#L7">include/linux/fcntl.h</a> Linux kernel header file confirms this:</p>
<pre><code class="language-C">#ifndef force_o_largefile
#define force_o_largefile() (BITS_PER_LONG != 32)
#endif
</code></pre>
<p>This macro may be architecture-specific as for example for <a href="https://en.wikipedia.org/wiki/IA-64">IA-64</a> architecture, but in our case the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> does not provide definition of the <code>force_o_largefile</code> and it will be used from <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/fcntl.h#L7">include/linux/fcntl.h</a>.</p>
<p>So, as we may see the <code>force_o_largefile</code> is just a macro which expands to the <code>true</code> value in our case of <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture. As we are considering 64-bit architecture, the <code>force_o_largefile</code> will be expanded to <code>true</code> and the <code>O_LARGEFILE</code> flag will be added to the set of flags which were passed to the <code>open</code> system call.</p>
<p>Now as we considered meaning of the <code>O_LARGEFILE</code> flag and <code>force_o_largefile</code> macro, we can proceed to the consideration of the implementation of the <code>do_sys_open</code> function. As I wrote above, this function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c">same</a> source code file and looks:</p>
<pre><code class="language-C">long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
{
	struct open_flags op;
	int fd = build_open_flags(flags, mode, &amp;op);
	struct filename *tmp;

	if (fd)
		return fd;

	tmp = getname(filename);
	if (IS_ERR(tmp))
		return PTR_ERR(tmp);

	fd = get_unused_fd_flags(flags);
	if (fd &gt;= 0) {
		struct file *f = do_filp_open(dfd, tmp, &amp;op);
		if (IS_ERR(f)) {
			put_unused_fd(fd);
			fd = PTR_ERR(f);
		} else {
			fsnotify_open(f);
			fd_install(fd, f);
		}
	}
	putname(tmp);
	return fd;
}
</code></pre>
<p>Let's try to understand how the <code>do_sys_open</code> works step by step.</p>
<h2 id="open2-flags"><a class="header" href="#open2-flags">open(2) flags</a></h2>
<p>As you know the <code>open</code> system call takes set of <code>flags</code> as second argument that control opening a file and <code>mode</code> as third argument that specifies permission the permissions of a file if it is created. The <code>do_sys_open</code> function starts from the call of the <code>build_open_flags</code> function which does some checks that set of the given flags is valid and handles different conditions of flags and mode.</p>
<p>Let's look at the implementation of the <code>build_open_flags</code>. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c">same</a> kernel file and takes three arguments:</p>
<ul>
<li>flags - flags that control opening of a file;</li>
<li>mode - permissions for newly created file;</li>
</ul>
<p>The last argument - <code>op</code> is represented with the <code>open_flags</code> structure:</p>
<pre><code class="language-C">struct open_flags {
        int open_flag;
        umode_t mode;
        int acc_mode;
        int intent;
        int lookup_flags;
};
</code></pre>
<p>which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/internal.h#L99">fs/internal.h</a> header file and as we may see it holds information about flags and access mode for internal kernel purposes. As you already may guess the main goal of the <code>build_open_flags</code> function is to fill an instance of this structure.</p>
<p>Implementation of the <code>build_open_flags</code> function starts from the definition of local variables and one of them is:</p>
<pre><code class="language-C">int acc_mode = ACC_MODE(flags);
</code></pre>
<p>This local variable represents access mode and its initial value will be equal to the value of expanded <code>ACC_MODE</code> macro. This macro is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/fs.h">include/linux/fs.h</a> and looks pretty interesting:</p>
<pre><code class="language-C">#define ACC_MODE(x) (&quot;\004\002\006\006&quot;[(x)&amp;O_ACCMODE])
#define O_ACCMODE   00000003
</code></pre>
<p>The <code>&quot;\004\002\006\006&quot;</code> is an array of four chars:</p>
<pre><code>&quot;\004\002\006\006&quot; == {'\004', '\002', '\006', '\006'}
</code></pre>
<p>So, the <code>ACC_MODE</code> macro just expands to the accession to this array by <code>[(x) &amp; O_ACCMODE]</code> index. As we just saw, the <code>O_ACCMODE</code> is <code>00000003</code>. By applying <code>x &amp; O_ACCMODE</code> we will take the two least significant bits which are represents <code>read</code>, <code>write</code> or <code>read/write</code> access modes:</p>
<pre><code class="language-C">#define O_RDONLY        00000000
#define O_WRONLY        00000001
#define O_RDWR          00000002
</code></pre>
<p>After getting value from the array by the calculated index, the <code>ACC_MODE</code> will be expanded to access mode mask of a file which will hold <code>MAY_WRITE</code>, <code>MAY_READ</code> and other information.</p>
<p>We may see following condition after we have calculated initial access mode:</p>
<pre><code class="language-C">if (flags &amp; (O_CREAT | __O_TMPFILE))
	op-&gt;mode = (mode &amp; S_IALLUGO) | S_IFREG;
else
	op-&gt;mode = 0;
</code></pre>
<p>Here we reset permissions in <code>open_flags</code> instance if an open file wasn't temporary and wasn't open for creation. This is because:</p>
<blockquote>
<p>if  neither O_CREAT nor O_TMPFILE is specified, then mode is ignored.</p>
</blockquote>
<p>In other case if <code>O_CREAT</code> or <code>O_TMPFILE</code> were passed we canonicalize it to a regular file because a directory should be created with the <a href="http://man7.org/linux/man-pages/man3/opendir.3.html">opendir</a> system call.</p>
<p>At the next step we check that a file is not tried to be opened via <a href="http://man7.org/linux/man-pages/man7/fanotify.7.html">fanotify</a> and without the <code>O_CLOEXEC</code> flag:</p>
<pre><code class="language-C">flags &amp;= ~FMODE_NONOTIFY &amp; ~O_CLOEXEC;
</code></pre>
<p>We do this to not leak a <a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a>. By default, the new file descriptor is set to remain open across an <code>execve</code> system call, but the <code>open</code> system call supports <code>O_CLOEXEC</code> flag that can be used to change this default behaviour. So we do this to prevent leaking of a file descriptor when one thread opens a file to set <code>O_CLOEXEC</code> flag and in the same time the second process does a <a href="https://en.wikipedia.org/wiki/Fork_(system_call)">fork</a> + <a href="https://en.wikipedia.org/wiki/Exec_(system_call)">execve</a> and as you may remember that child will have copies of the parent's set of open file descriptors.</p>
<p>At the next step we check that if our flags contains <code>O_SYNC</code> flag, we apply <code>O_DSYNC</code> flag too:</p>
<pre><code>if (flags &amp; __O_SYNC)
	flags |= O_DSYNC;
</code></pre>
<p>The <code>O_SYNC</code> flag guarantees that the any write call will not return before all data has been transferred to the disk. The <code>O_DSYNC</code> is like <code>O_SYNC</code> except that there is no requirement to wait for any metadata (like <code>atime</code>, <code>mtime</code> and etc.) changes will be written. We apply <code>O_DSYNC</code> in a case of <code>__O_SYNC</code> because it is implemented as <code>__O_SYNC|O_DSYNC</code> in the Linux kernel.</p>
<p>After this we must be sure that if a user wants to create temporary file, the flags should contain <code>O_TMPFILE_MASK</code> or in other words it should contain or <code>O_CREAT</code> or <code>O_TMPFILE</code> or both and also it should be writeable:</p>
<pre><code class="language-C">if (flags &amp; __O_TMPFILE) {
	if ((flags &amp; O_TMPFILE_MASK) != O_TMPFILE)
		return -EINVAL;
	if (!(acc_mode &amp; MAY_WRITE))
		return -EINVAL;
} else if (flags &amp; O_PATH) {
       	flags &amp;= O_DIRECTORY | O_NOFOLLOW | O_PATH;
        acc_mode = 0;
}
</code></pre>
<p>as it is written in in the manual page:</p>
<blockquote>
<p>O_TMPFILE  must  be  specified  with one of O_RDWR or O_WRONLY</p>
</blockquote>
<p>If we didn't pass <code>O_TMPFILE</code> for creation of a temporary file, we check the <code>O_PATH</code> flag at the next condition. The <code>O_PATH</code> flag allows us to obtain a file descriptor that may be used for two following purposes:</p>
<ul>
<li>to indicate a location in the filesystem tree;</li>
<li>to perform operations that act purely at the file descriptor level.</li>
</ul>
<p>So, in this case the file itself is not opened, but operations like <code>dup</code>, <code>fcntl</code> and other can be used. So, if all file content related operations like <code>read</code>, <code>write</code> and other are not permitted, only <code>O_DIRECTORY | O_NOFOLLOW | O_PATH</code> flags can be used. We have finished with flags for this moment in the <code>build_open_flags</code> for this moment and we may fill our <code>open_flags-&gt;open_flag</code> with them:</p>
<pre><code class="language-C">op-&gt;open_flag = flags;
</code></pre>
<p>Now we have filled <code>open_flag</code> field which represents flags that will control opening of a file and <code>mode</code> that will represent <code>umask</code> of a new file if we open file for creation. There are still to fill last flags in our <code>open_flags</code> structure. The next is <code>op-&gt;acc_mode</code> which represents access mode to a opened file. We already filled the <code>acc_mode</code> local variable with the initial value at the beginning of the <code>build_open_flags</code> and now we check last two flags related to access mode:</p>
<pre><code class="language-C">if (flags &amp; O_TRUNC)
        acc_mode |= MAY_WRITE;
if (flags &amp; O_APPEND)
	acc_mode |= MAY_APPEND;
op-&gt;acc_mode = acc_mode;
</code></pre>
<p>These flags are - <code>O_TRUNC</code> that will truncate an opened file to length <code>0</code> if it existed before we open it and the <code>O_APPEND</code> flag allows to open a file in <code>append mode</code>. So the opened file will be appended during write but not overwritten.</p>
<p>The next field of the <code>open_flags</code> structure is - <code>intent</code>. It allows us to know about our intention or in other words what do we really want to do with file, open it, create, rename it or something else. So we set it to zero if our flags contains the <code>O_PATH</code> flag as we can't do anything related to a file content with this flag:</p>
<pre><code class="language-C">op-&gt;intent = flags &amp; O_PATH ? 0 : LOOKUP_OPEN;
</code></pre>
<p>or just to <code>LOOKUP_OPEN</code> intention. Additionally we set <code>LOOKUP_CREATE</code> intention if we want to create new file and to be sure that a file didn't exist before with <code>O_EXCL</code> flag:</p>
<pre><code class="language-C">if (flags &amp; O_CREAT) {
	op-&gt;intent |= LOOKUP_CREATE;
	if (flags &amp; O_EXCL)
		op-&gt;intent |= LOOKUP_EXCL;
}
</code></pre>
<p>The last flag of the <code>open_flags</code> structure is the <code>lookup_flags</code>:</p>
<pre><code class="language-C">if (flags &amp; O_DIRECTORY)
	lookup_flags |= LOOKUP_DIRECTORY;
if (!(flags &amp; O_NOFOLLOW))
	lookup_flags |= LOOKUP_FOLLOW;
op-&gt;lookup_flags = lookup_flags;

return 0;
</code></pre>
<p>We fill it with <code>LOOKUP_DIRECTORY</code> if we want to open a directory and <code>LOOKUP_FOLLOW</code> if we don't want to follow (open) <a href="https://en.wikipedia.org/wiki/Symbolic_link">symlink</a>. That's all. It is the end of the <code>build_open_flags</code> function. The <code>open_flags</code> structure is filled with modes and flags for a file opening and we can return back to the <code>do_sys_open</code>.</p>
<h2 id="actual-opening-of-a-file"><a class="header" href="#actual-opening-of-a-file">Actual opening of a file</a></h2>
<p>At the next step after <code>build_open_flags</code> function is finished and we have formed flags and modes for our file we should get the <code>filename</code> structure with the help of the <code>getname</code> function by name of a file which was passed to the <code>open</code> system call:</p>
<pre><code class="language-C">tmp = getname(filename);
if (IS_ERR(tmp))
	return PTR_ERR(tmp);
</code></pre>
<p>The <code>getname</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/namei.c">fs/namei.c</a> source code file and looks:</p>
<pre><code class="language-C">struct filename *
getname(const char __user * filename)
{
        return getname_flags(filename, 0, NULL);
}
</code></pre>
<p>So, it just calls the <code>getname_flags</code> function and returns its result. The main goal of the <code>getname_flags</code> function is to copy a file path given from userland to kernel space. The <code>filename</code> structure is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/fs.h">include/linux/fs.h</a> Linux kernel header file and contains following fields:</p>
<ul>
<li>name - pointer to a file path in kernel space;</li>
<li>uptr - original pointer from userland;</li>
<li>aname - filename from <a href="https://linux.die.net/man/8/auditd">audit</a> context;</li>
<li>refcnt - reference counter;</li>
<li>iname - a filename in a case when it will be less than <code>PATH_MAX</code>.</li>
</ul>
<p>As I already wrote above, the main goal of the <code>getname_flags</code> function is to copy name of a file which was passed to the <code>open</code> system call from user space to kernel space with the strncpy_from_user function. The next step after a filename will be copied to kernel space is getting of new non-busy file descriptor:</p>
<pre><code class="language-C">fd = get_unused_fd_flags(flags);
</code></pre>
<p>The <code>get_unused_fd_flags</code> function takes table of open files of the current process, minimum (<code>0</code>) and maximum (<code>RLIMIT_NOFILE</code>) possible number of a file descriptor in the system and flags that we have passed to the <code>open</code> system call and allocates file descriptor and mark it busy in the file descriptor table of the current process. The <code>get_unused_fd_flags</code> function sets or clears the <code>O_CLOEXEC</code> flag depends on its state in the passed flags.</p>
<p>The last and main step in the <code>do_sys_open</code> is the <code>do_filp_open</code> function:</p>
<pre><code class="language-C">struct file *f = do_filp_open(dfd, tmp, &amp;op);

if (IS_ERR(f)) {
	put_unused_fd(fd);
	fd = PTR_ERR(f);
} else {
	fsnotify_open(f);
	fd_install(fd, f);
}
</code></pre>
<p>The main goal of this function is to resolve given path name into <code>file</code> structure which represents an opened file of a process. If something going wrong and execution of the <code>do_filp_open</code> function will be failed, we should free new file descriptor with the <code>put_unused_fd</code> or in other way the <code>file</code> structure returned by the <code>do_filp_open</code> will be stored in the file descriptor table of the current process.</p>
<p>Now let's take a short look at the implementation of the <code>do_filp_open</code> function. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/namei.c">fs/namei.c</a> Linux kernel source code file and starts from initialization of the <code>nameidata</code> structure. This structure will provide a link to a file <a href="https://en.wikipedia.org/wiki/Inode">inode</a>. Actually this is one of the main point of the <code>do_filp_open</code> function to acquire an <code>inode</code> by the filename given to <code>open</code> system call. After the <code>nameidata</code> structure will be initialized, the <code>path_openat</code> function will be called:</p>
<pre><code class="language-C">filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU);

if (unlikely(filp == ERR_PTR(-ECHILD)))
	filp = path_openat(&amp;nd, op, flags);
if (unlikely(filp == ERR_PTR(-ESTALE)))
	filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL);
</code></pre>
<p>Note that it is called three times. Actually, the Linux kernel will open the file in <a href="https://www.kernel.org/doc/Documentation/RCU/whatisRCU.txt">RCU</a> mode. This is the most efficient way to open a file. If this try will be failed, the kernel enters the normal mode. The third call is relatively rare, only in the <a href="https://en.wikipedia.org/wiki/Network_File_System">nfs</a> file system is likely to be used. The <code>path_openat</code> function executes <code>path lookup</code> or in other words it tries to find a <code>dentry</code> (what the Linux kernel uses to keep track of the hierarchy of files in directories) corresponding to a path.</p>
<p>The <code>path_openat</code> function starts from the call of the <code>get_empty_flip()</code> function that allocates a new <code>file</code> structure with some additional checks like do we exceed amount of opened files in the system or not and etc. After we have got allocated new <code>file</code> structure we call the <code>do_tmpfile</code> or <code>do_o_path</code> functions in a case if we have passed <code>O_TMPFILE | O_CREATE</code> or <code>O_PATH</code> flags during call of the <code>open</code> system call. Both these cases are quite specific, so let's consider quite usual case when we want to open already existed file and want to read/write from/to it.</p>
<p>In this case the <code>path_init</code> function will be called. This function performs some preparatory work before actual path lookup. This includes search of start position of path traversal and its metadata like <code>inode</code> of the path, <code>dentry inode</code> and etc. This can be <code>root</code> directory - <code>/</code> or current directory as in our case, because we use <code>AT_CWD</code> as starting point (see call of the <code>do_sys_open</code> at the beginning of the post).</p>
<p>The next step after the <code>path_init</code> is the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/namei.c#L3457">loop</a> which executes the <code>link_path_walk</code> and <code>do_last</code>. The first function executes name resolution or in other words this function starts process of walking along a given path. It handles everything step by step except the last component of a file path. This handling includes checking of a permissions and getting a file component. As a file component is gotten, it is passed to <code>walk_component</code> that updates current directory entry from the <code>dcache</code> or asks underlying filesystem. This repeats before all path's components will not be handled in such way. After the <code>link_path_walk</code> will be executed, the <code>do_last</code> function will populate a <code>file</code> structure based on the result of the <code>link_path_walk</code>. As we reached last component of the given file path the <code>vfs_open</code> function from the <code>do_last</code> will be called.</p>
<p>This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/fs/open.c">fs/open.c</a> Linux kernel source code file and the main goal of this function is to call an <code>open</code> operation of underlying filesystem.</p>
<p>That's all for now. We didn't consider <strong>full</strong> implementation of the <code>open</code> system call. We skip some parts like handling case when we want to open a file from other filesystem with different mount point, resolving symlinks and etc., but it should be not so hard to follow this stuff. This stuff does not included in <strong>generic</strong> implementation of open system call and depends on underlying filesystem. If you are interested in, you may lookup the <code>file_operations.open</code> callback function for a certain <a href="https://github.com/torvalds/linux/tree/master/fs">filesystem</a>.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This is the end of the fifth part of the implementation of different system calls in the Linux kernel. If you have questions or suggestions, ping me on twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a>, or just create an <a href="https://github.com/0xAX/linux-internals/issues/new">issue</a>. In the next part, we will continue to dive into system calls in the Linux kernel and see the implementation of the <a href="http://man7.org/linux/man-pages/man2/read.2.html">read</a> system call.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you find any mistakes please send me PR to <a href="https://github.com/0xAX/linux-internals">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/System_call">system call</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/open.2.html">open</a></li>
<li><a href="https://en.wikipedia.org/wiki/File_descriptor">file descriptor</a></li>
<li><a href="https://en.wikipedia.org/wiki/Procfs">proc</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Position-Primitive">GNU C Library Reference Manual</a></li>
<li><a href="https://en.wikipedia.org/wiki/IA-64">IA-64</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/opendir.3.html">opendir</a></li>
<li><a href="http://man7.org/linux/man-pages/man7/fanotify.7.html">fanotify</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fork_(system_call)">fork</a></li>
<li><a href="https://en.wikipedia.org/wiki/Exec_(system_call)">execve</a></li>
<li><a href="https://en.wikipedia.org/wiki/Symbolic_link">symlink</a></li>
<li><a href="https://linux.die.net/man/8/auditd">audit</a></li>
<li><a href="https://en.wikipedia.org/wiki/Inode">inode</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/RCU/whatisRCU.txt">RCU</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/read.2.html">read</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/syscall/linux-syscall-4">previous part</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../SysCall/linux-syscall-4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../SysCall/linux-syscall-6.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../SysCall/linux-syscall-4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../SysCall/linux-syscall-6.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
