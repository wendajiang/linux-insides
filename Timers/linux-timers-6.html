<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>x86 related clock sources - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html" class="active">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="timers-and-time-management-in-the-linux-kernel-part-6"><a class="header" href="#timers-and-time-management-in-the-linux-kernel-part-6">Timers and time management in the Linux kernel. Part 6.</a></h1>
<h2 id="x86_64-related-clock-sources"><a class="header" href="#x86_64-related-clock-sources">x86_64 related clock sources</a></h2>
<p>This is sixth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> which describes timers and time management related stuff in the Linux kernel. In the previous <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-5">part</a> we saw <code>clockevents</code> framework and now we will continue to dive into time management related stuff in the Linux kernel. This part will describe implementation of <a href="https://en.wikipedia.org/wiki/X86">x86</a> architecture related clock sources (more about <code>clocksource</code> concept you can read in the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-2">second part</a> of this chapter).</p>
<p>First of all we must know what clock sources may be used at <code>x86</code> architecture. It is easy to know from the <a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a> or from content of the <code>/sys/devices/system/clocksource/clocksource0/available_clocksource</code>. The <code>/sys/devices/system/clocksource/clocksourceN</code> provides two special files to achieve this:</p>
<ul>
<li><code>available_clocksource</code> - provides information about available clock sources in the system;</li>
<li><code>current_clocksource</code>   - provides information about currently used clock source in the system.</li>
</ul>
<p>So, let's look:</p>
<pre><code>$ cat /sys/devices/system/clocksource/clocksource0/available_clocksource 
tsc hpet acpi_pm 
</code></pre>
<p>We can see that there are three registered clock sources in my system:</p>
<ul>
<li><code>tsc</code> - <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a>;</li>
<li><code>hpet</code> - <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a>;</li>
<li><code>acpi_pm</code> - <a href="http://uefi.org/sites/default/files/resources/ACPI_5.pdf">ACPI Power Management Timer</a>.</li>
</ul>
<p>Now let's look at the second file which provides best clock source (a clock source which has the best rating in the system):</p>
<pre><code>$ cat /sys/devices/system/clocksource/clocksource0/current_clocksource 
tsc
</code></pre>
<p>For me it is <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a>. As we may know from the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-2">second part</a> of this chapter, which describes internals of the <code>clocksource</code> framework in the Linux kernel, the best clock source in a system is a clock source with the best (highest) rating or in other words with the highest <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>.</p>
<p>Frequency of the <a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI</a> power management timer is <code>3.579545 MHz</code>. Frequency of the <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a> is at least <code>10 MHz</code>. And the frequency of the <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a> depends on processor. For example On older processors, the <code>Time Stamp Counter</code> was counting internal processor clock cycles. This means its frequency changed when the processor's frequency scaling changed. The situation has changed for newer processors. Newer processors have an <code>invariant Time Stamp counter</code> that increments at a constant rate in all operational states of processor. Actually we can get its frequency in the output of the <code>/proc/cpuinfo</code>. For example for the first processor in the system:</p>
<pre><code>$ cat /proc/cpuinfo
...
model name	: Intel(R) Core(TM) i7-4790K CPU @ 4.00GHz
...
</code></pre>
<p>And although Intel manual says that the frequency of the <code>Time Stamp Counter</code>, while constant, is not necessarily the maximum qualified frequency of the processor, or the frequency given in the brand string, anyway we may see that it will be much more than frequency of the <code>ACPI PM</code> timer or <code>High Precision Event Timer</code>. And we can see that the clock source with the best rating or highest frequency is current in the system.</p>
<p>You can note that besides these three clock source, we don't see yet another two familiar us clock sources in the output of the <code>/sys/devices/system/clocksource/clocksource0/available_clocksource</code>. These clock sources are <code>jiffy</code> and <code>refined_jiffies</code>. We don't see them because this filed maps only high resolution clock sources or in other words clock sources with the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clocksource.h#L113">CLOCK_SOURCE_VALID_FOR_HRES</a> flag.</p>
<p>As I already wrote above, we will consider all of these three clock sources in this part. We will consider it in order of their initialization or:</p>
<ul>
<li><code>hpet</code>;</li>
<li><code>acpi_pm</code>;</li>
<li><code>tsc</code>.</li>
</ul>
<p>We can make sure that the order is exactly like this in the output of the <a href="https://en.wikipedia.org/wiki/Dmesg">dmesg</a> util:</p>
<pre><code>$ dmesg | grep clocksource
[    0.000000] clocksource: refined-jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1910969940391419 ns
[    0.000000] clocksource: hpet: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 133484882848 ns
[    0.094369] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1911260446275000 ns
[    0.186498] clocksource: Switched to clocksource hpet
[    0.196827] clocksource: acpi_pm: mask: 0xffffff max_cycles: 0xffffff, max_idle_ns: 2085701024 ns
[    1.413685] tsc: Refined TSC clocksource calibration: 3999.981 MHz
[    1.413688] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x73509721780, max_idle_ns: 881591102108 ns
[    2.413748] clocksource: Switched to clocksource tsc
</code></pre>
<p>The first clock source is the <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a>, so let's start from it.</p>
<h2 id="high-precision-event-timer"><a class="header" href="#high-precision-event-timer">High Precision Event Timer</a></h2>
<p>The implementation of the <code>High Precision Event Timer</code> for the <a href="https://en.wikipedia.org/wiki/X86">x86</a> architecture is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/hpet.c">arch/x86/kernel/hpet.c</a> source code file. Its initialization starts from the call of the <code>hpet_enable</code> function. This function is called during Linux kernel initialization. If we will look into <code>start_kernel</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/init/main.c">init/main.c</a> source code file, we will see that after the all architecture-specific stuff initialized, early console is disabled and time management subsystem already ready, call of the following function:</p>
<pre><code class="language-C">if (late_time_init)
	late_time_init();
</code></pre>
<p>which does initialization of the late architecture specific timers after early jiffy counter already initialized. The definition of the <code>late_time_init</code> function for the <code>x86</code> architecture is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/time.c">arch/x86/kernel/time.c</a> source code file. It looks pretty easy:</p>
<pre><code class="language-C">static __init void x86_late_time_init(void)
{
	x86_init.timers.timer_init();
	tsc_init();
}
</code></pre>
<p>As we may see, it does initialization of the <code>x86</code> related timer and initialization of the <code>Time Stamp Counter</code>. The seconds we will see in the next paragraph, but now let's consider the call of the <code>x86_init.timers.timer_init</code> function. The <code>timer_init</code> points to the <code>hpet_time_init</code> function from the same source code file. We can verify this by looking on the definition of the <code>x86_init</code> structure from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/x86_init.c">arch/x86/kernel/x86_init.c</a>:</p>
<pre><code class="language-C">struct x86_init_ops x86_init __initdata = {
   ...
   ...
   ...
   .timers = {
		.setup_percpu_clockev	= setup_boot_APIC_clock,
		.timer_init		= hpet_time_init,
		.wallclock_init		= x86_init_noop,
   },
   ...
   ...
   ...
</code></pre>
<p>The <code>hpet_time_init</code> function does setup of the <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a> if we can not enable <code>High Precision Event Timer</code> and setups default timer <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> for the enabled timer:</p>
<pre><code class="language-C">void __init hpet_time_init(void)
{
	if (!hpet_enable())
		setup_pit_timer();
	setup_default_timer_irq();
}
</code></pre>
<p>First of all the <code>hpet_enable</code> function check we can enable <code>High Precision Event Timer</code> in the system by the call of the <code>is_hpet_capable</code> function and if we can, we map a virtual address space for it:</p>
<pre><code class="language-C">int __init hpet_enable(void)
{
	if (!is_hpet_capable())
		return 0;

    hpet_set_mapping();
}
</code></pre>
<p>The <code>is_hpet_capable</code> function checks that we didn't pass <code>hpet=disable</code> to the kernel command line and the <code>hpet_address</code> is received from the <a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI HPET</a> table. The <code>hpet_set_mapping</code> function just maps the virtual address spaces for the timer registers:</p>
<pre><code class="language-C">hpet_virt_address = ioremap_nocache(hpet_address, HPET_MMAP_SIZE);
</code></pre>
<p>As we can read in the  <a href="http://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/software-developers-hpet-spec-1-0a.pdf">IA-PC HPET (High Precision Event Timers) Specification</a>:</p>
<blockquote>
<p>The timer register space is 1024 bytes</p>
</blockquote>
<p>So, the <code>HPET_MMAP_SIZE</code> is <code>1024</code> bytes too:</p>
<pre><code class="language-C">#define HPET_MMAP_SIZE		1024
</code></pre>
<p>After we mapped virtual space for the <code>High Precision Event Timer</code>, we read <code>HPET_ID</code> register to get number of the timers:</p>
<pre><code class="language-C">id = hpet_readl(HPET_ID);

last = (id &amp; HPET_ID_NUMBER) &gt;&gt; HPET_ID_NUMBER_SHIFT;
</code></pre>
<p>We need to get this number to allocate correct amount of space for the <code>General Configuration Register</code> of the <code>High Precision Event Timer</code>:</p>
<pre><code class="language-C">cfg = hpet_readl(HPET_CFG);

hpet_boot_cfg = kmalloc((last + 2) * sizeof(*hpet_boot_cfg), GFP_KERNEL);
</code></pre>
<p>After the space is allocated for the configuration register of the <code>High Precision Event Timer</code>, we allow to main counter to run, and allow timer interrupts if they are enabled by the setting of <code>HPET_CFG_ENABLE</code> bit in the configuration register for all timers. In the end we just register new clock source by the call of the <code>hpet_clocksource_register</code> function:</p>
<pre><code class="language-C">if (hpet_clocksource_register())
	goto out_nohpet;
</code></pre>
<p>which just calls already familiar</p>
<pre><code class="language-C">clocksource_register_hz(&amp;clocksource_hpet, (u32)hpet_freq);
</code></pre>
<p>function. Where the <code>clocksource_hpet</code> is the <code>clocksource</code> structure with the rating <code>250</code> (remember rating of the previous <code>refined_jiffies</code> clock source was <code>2</code>), name - <code>hpet</code> and <code>read_hpet</code> callback for the reading of atomic counter provided by the <code>High Precision Event Timer</code>:</p>
<pre><code class="language-C">static struct clocksource clocksource_hpet = {
	.name		= &quot;hpet&quot;,
	.rating		= 250,
	.read		= read_hpet,
	.mask		= HPET_MASK,
	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
	.resume		= hpet_resume_counter,
	.archdata	= { .vclock_mode = VCLOCK_HPET },
};
</code></pre>
<p>After the <code>clocksource_hpet</code> is registered, we can return to the <code>hpet_time_init()</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/time.c">arch/x86/kernel/time.c</a> source code file. We can remember that the last step is the call of the:</p>
<pre><code class="language-C">setup_default_timer_irq();
</code></pre>
<p>function in the <code>hpet_time_init()</code>. The <code>setup_default_timer_irq</code> function checks existence of <code>legacy</code> IRQs or in other words support for the <a href="https://en.wikipedia.org/wiki/Intel_8259">i8259</a> and setups <a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29#Master_PIC">IRQ0</a> depends on this.</p>
<p>That's all. From this moment the <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a> clock source registered in the Linux kernel <code>clock source</code> framework and may be used from generic kernel code via the <code>read_hpet</code>:</p>
<pre><code class="language-C">static cycle_t read_hpet(struct clocksource *cs)
{
	return (cycle_t)hpet_readl(HPET_COUNTER);
}
</code></pre>
<p>function which just reads and returns atomic counter from the <code>Main Counter Register</code>.</p>
<h2 id="acpi-pm-timer"><a class="header" href="#acpi-pm-timer">ACPI PM timer</a></h2>
<p>The seconds clock source is <a href="http://uefi.org/sites/default/files/resources/ACPI_5.pdf">ACPI Power Management Timer</a>. Implementation of this clock source is located in the <a href="https://github.com/torvalds/linux/blob/master/drivers/clocksource/acpi_pm.c">drivers/clocksource/acpi_pm.c</a> source code file and starts from the call of the <code>init_acpi_pm_clocksource</code> function during <code>fs</code> <a href="https://kernelnewbies.org/Documents/InitcallMechanism">initcall</a>.</p>
<p>If we will look at implementation of the <code>init_acpi_pm_clocksource</code> function, we will see that it starts from the check of the value of <code>pmtmr_ioport</code> variable:</p>
<pre><code class="language-C">static int __init init_acpi_pm_clocksource(void)
{
    ...
    ...
    ...
	if (!pmtmr_ioport)
		return -ENODEV;
    ...
    ...
    ...
</code></pre>
<p>This <code>pmtmr_ioport</code> variable contains extended address of the <code>Power Management Timer Control Register Block</code>. It gets its value in the <code>acpi_parse_fadt</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/acpi/boot.c">arch/x86/kernel/acpi/boot.c</a> source code file. This function parses <code>FADT</code> or <code>Fixed ACPI Description Table</code> <a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI</a> table and tries to get the values of the <code>X_PM_TMR_BLK</code> field which contains extended address of the <code>Power Management Timer Control Register Block</code>, represented in <code>Generic Address Structure</code> format:</p>
<pre><code class="language-C">static int __init acpi_parse_fadt(struct acpi_table_header *table)
{
#ifdef CONFIG_X86_PM_TIMER
        ...
        ...
        ...
		pmtmr_ioport = acpi_gbl_FADT.xpm_timer_block.address;
        ...
        ...
        ...
#endif
	return 0;
}
</code></pre>
<p>So, if the <code>CONFIG_X86_PM_TIMER</code> Linux kernel configuration option is disabled or something going wrong in the <code>acpi_parse_fadt</code> function, we can't access the <code>Power Management Timer</code> register and return from the <code>init_acpi_pm_clocksource</code>. In other way, if the value of the <code>pmtmr_ioport</code> variable is not zero, we check rate of this timer and register this clock source by the call of the:</p>
<pre><code class="language-C">clocksource_register_hz(&amp;clocksource_acpi_pm, PMTMR_TICKS_PER_SEC);
</code></pre>
<p>function. After the call of the <code>clocksource_register_hs</code>, the <code>acpi_pm</code> clock source will be registered in the <code>clocksource</code> framework of the Linux kernel:</p>
<pre><code class="language-C">static struct clocksource clocksource_acpi_pm = {
	.name		= &quot;acpi_pm&quot;,
	.rating		= 200,
	.read		= acpi_pm_read,
	.mask		= (cycle_t)ACPI_PM_MASK,
	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
};
</code></pre>
<p>with the rating - <code>200</code> and the <code>acpi_pm_read</code> callback to read atomic counter provided by the <code>acpi_pm</code> clock source. The <code>acpi_pm_read</code> function just executes <code>read_pmtmr</code> function:</p>
<pre><code class="language-C">static cycle_t acpi_pm_read(struct clocksource *cs)
{
	return (cycle_t)read_pmtmr();
}
</code></pre>
<p>which reads value of the <code>Power Management Timer</code> register. This register has following structure:</p>
<pre><code>+-------------------------------+----------------------------------+
|                               |                                  |
|  upper eight bits of a        |      running count of the        |
| 32-bit power management timer |     power management timer       |
|                               |                                  |
+-------------------------------+----------------------------------+
31          E_TMR_VAL           24               TMR_VAL           0
</code></pre>
<p>Address of this register is stored in the <code>Fixed ACPI Description Table</code> <a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">ACPI</a> table and we already have it in the <code>pmtmr_ioport</code>. So, the implementation of the <code>read_pmtmr</code> function is pretty easy:</p>
<pre><code class="language-C">static inline u32 read_pmtmr(void)
{
	return inl(pmtmr_ioport) &amp; ACPI_PM_MASK;
}
</code></pre>
<p>We just read the value of the <code>Power Management Timer</code> register and mask its <code>24</code> bits.</p>
<p>That's all. Now we move to the last clock source in this part - <code>Time Stamp Counter</code>.</p>
<h2 id="time-stamp-counter"><a class="header" href="#time-stamp-counter">Time Stamp Counter</a></h2>
<p>The third and last clock source in this part is - <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a> clock source and its implementation is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/tsc.c">arch/x86/kernel/tsc.c</a> source code file. We already saw the <code>x86_late_time_init</code> function in this part and initialization of the <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a> starts from this place. This function calls the <code>tsc_init()</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/tsc.c">arch/x86/kernel/tsc.c</a> source code file.</p>
<p>At the beginning of the <code>tsc_init</code> function we can see check, which checks that a processor has support of the <code>Time Stamp Counter</code>:</p>
<pre><code class="language-C">void __init tsc_init(void)
{
	u64 lpj;
	int cpu;

	if (!cpu_has_tsc) {
		setup_clear_cpu_cap(X86_FEATURE_TSC_DEADLINE_TIMER);
		return;
	}
    ...
    ...
    ...
</code></pre>
<p>The <code>cpu_has_tsc</code> macro expands to the call of the <code>cpu_has</code> macro:</p>
<pre><code class="language-C">#define cpu_has_tsc		boot_cpu_has(X86_FEATURE_TSC)

#define boot_cpu_has(bit)	cpu_has(&amp;boot_cpu_data, bit)

#define cpu_has(c, bit)							\
	(__builtin_constant_p(bit) &amp;&amp; REQUIRED_MASK_BIT_SET(bit) ? 1 :	\
	 test_cpu_cap(c, bit))
</code></pre>
<p>which check the given bit (the <code>X86_FEATURE_TSC_DEADLINE_TIMER</code> in our case) in the <code>boot_cpu_data</code> array which is filled during early Linux kernel initialization. If the processor has support of the <code>Time Stamp Counter</code>, we get the frequency of the <code>Time Stamp Counter</code> by the call of the <code>calibrate_tsc</code> function from the same source code file which tries to get frequency from the different source like <a href="https://en.wikipedia.org/wiki/Model-specific_register">Model Specific Register</a>, calibrate over <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a> and etc, after this we initialize frequency and scale factor for the all processors in the system:</p>
<pre><code class="language-C">tsc_khz = x86_platform.calibrate_tsc();
cpu_khz = tsc_khz;

for_each_possible_cpu(cpu) {
	cyc2ns_init(cpu);
	set_cyc2ns_scale(cpu_khz, cpu);
}
</code></pre>
<p>because only first bootstrap processor will call the <code>tsc_init</code>. After this we check hat <code>Time Stamp Counter</code> is not disabled:</p>
<pre><code>if (tsc_disabled &gt; 0)
	return;
...
...
...
check_system_tsc_reliable();
</code></pre>
<p>and call the <code>check_system_tsc_reliable</code> function which sets the <code>tsc_clocksource_reliable</code> if bootstrap processor has the <code>X86_FEATURE_TSC_RELIABLE</code> feature. Note that we went through the <code>tsc_init</code> function, but did not register our clock source. Actual registration of the <code>Time Stamp Counter</code> clock source occurs in the:</p>
<pre><code class="language-C">static int __init init_tsc_clocksource(void)
{
	if (!cpu_has_tsc || tsc_disabled &gt; 0 || !tsc_khz)
		return 0;
    ...
    ...
    ...
    if (boot_cpu_has(X86_FEATURE_TSC_RELIABLE)) {
		clocksource_register_khz(&amp;clocksource_tsc, tsc_khz);
		return 0;
	}
</code></pre>
<p>function. This function called during the <code>device</code> <a href="https://kernelnewbies.org/Documents/InitcallMechanism">initcall</a>. We do it to be sure that the <code>Time Stamp Counter</code> clock source will be registered after the  <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a> clock source.</p>
<p>After these all three clock sources will be registered in the <code>clocksource</code> framework and the <code>Time Stamp Counter</code> clock source will be selected as active, because it has the highest rating among other clock sources:</p>
<pre><code class="language-C">static struct clocksource clocksource_tsc = {
	.name                   = &quot;tsc&quot;,
	.rating                 = 300,
	.read                   = read_tsc,
	.mask                   = CLOCKSOURCE_MASK(64),
	.flags                  = CLOCK_SOURCE_IS_CONTINUOUS | CLOCK_SOURCE_MUST_VERIFY,
	.archdata               = { .vclock_mode = VCLOCK_TSC },
};
</code></pre>
<p>That's all.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This is the end of the sixth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> that describes timers and timer management related stuff in the Linux kernel. In the previous part got acquainted with the <code>clockevents</code> framework. In this part we continued to learn time management related stuff in the Linux kernel and saw a little about three different clock sources which are used in the <a href="https://en.wikipedia.org/wiki/X86">x86</a> architecture. The next part will be last part of this <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> and we will see some user space related stuff, i.e. how some time related <a href="https://en.wikipedia.org/wiki/System_call">system calls</a> implemented in the Linux kernel.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/X86">x86</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a></li>
<li><a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">Time Stamp Counter</a></li>
<li><a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a></li>
<li><a href="http://uefi.org/sites/default/files/resources/ACPI_5.pdf">ACPI Power Management Timer (PDF)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>.</li>
<li><a href="https://en.wikipedia.org/wiki/Dmesg">dmesg</a></li>
<li><a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29">IRQ</a> </li>
<li><a href="http://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/software-developers-hpet-spec-1-0a.pdf">IA-PC HPET (High Precision Event Timers) Specification</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29#Master_PIC">IRQ0</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8259">i8259</a></li>
<li><a href="https://kernelnewbies.org/Documents/InitcallMechanism">initcall</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-5">previous part</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Timers/linux-timers-5.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Timers/linux-timers-7.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Timers/linux-timers-5.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Timers/linux-timers-7.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
