<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Clockevents framework - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html" class="active">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="timers-and-time-management-in-the-linux-kernel-part-5"><a class="header" href="#timers-and-time-management-in-the-linux-kernel-part-5">Timers and time management in the Linux kernel. Part 5.</a></h1>
<h2 id="introduction-to-the-clockevents-framework"><a class="header" href="#introduction-to-the-clockevents-framework">Introduction to the <code>clockevents</code> framework</a></h2>
<p>This is fifth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> which describes timers and time management related stuff in the Linux kernel. As you might noted from the title of this part, the <code>clockevents</code> framework will be discussed. We already saw one framework in the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-2">second</a> part of this chapter. It was <code>clocksource</code> framework. Both of these frameworks represent timekeeping abstractions in the Linux kernel.</p>
<p>At first let's refresh your memory and try to remember what is it <code>clocksource</code> framework and and what its purpose. The main goal of the <code>clocksource</code> framework is to provide <code>timeline</code>. As described in the <a href="https://github.com/0xAX/linux/blob/0a07b238e5f488b459b6113a62e06b6aab017f71/Documentation/timers/timekeeping.txt">documentation</a>:</p>
<blockquote>
<p>For example issuing the command 'date' on a Linux system will eventually read the clock source to determine exactly what time it is.</p>
</blockquote>
<p>The Linux kernel supports many different clock sources. You can find some of them in the <a href="https://github.com/torvalds/linux/tree/master/drivers/clocksource">drivers/clocksource</a>. For example old good <a href="https://en.wikipedia.org/wiki/Intel_8253">Intel 8253</a> - <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a> with <code>1193182</code> Hz frequency, yet another one - <a href="http://uefi.org/sites/default/files/resources/ACPI_5.pdf">ACPI PM</a> timer with <code>3579545</code> Hz frequency. Besides the <a href="https://github.com/torvalds/linux/tree/master/drivers/clocksource">drivers/clocksource</a> directory, each architecture may provide own architecture-specific clock sources. For example <a href="https://en.wikipedia.org/wiki/X86">x86</a> architecture provides <a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a>, or for example <a href="https://en.wikipedia.org/wiki/PowerPC">powerpc</a> provides access to the processor timer through <code>timebase</code> register.</p>
<p>Each clock source provides monotonic atomic counter. As I already wrote, the Linux kernel supports a huge set of different clock source and each clock source has own parameters like <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>. The main goal of the <code>clocksource</code> framework is to provide <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> to select best available clock source in the system i.e. a clock source with the highest frequency. Additional goal of the <code>clocksource</code> framework is to represent an atomic counter provided by a clock source in human units. In this time, nanoseconds are the favorite choice for the time value units of the given clock source in the Linux kernel.</p>
<p>The <code>clocksource</code> framework represented by the <code>clocksource</code> structure which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clocksource.h">include/linux/clocksource.h</a> header code file which contains <code>name</code> of a clock source, rating of certain clock source in the system (a clock source with the higher frequency has the biggest rating in the system), <code>list</code> of all registered clock source in the system, <code>enable</code> and <code>disable</code> fields to enable and disable a clock source, pointer to the <code>read</code> function which must return an atomic counter of a clock source and etc.</p>
<p>Additionally the <code>clocksource</code> structure provides two fields: <code>mult</code> and <code>shift</code> which are needed for translation of an atomic counter which is provided by a certain clock source to the human units, i.e. <a href="https://en.wikipedia.org/wiki/Nanosecond">nanoseconds</a>. Translation occurs via following formula:</p>
<pre><code>ns ~= (clocksource * mult) &gt;&gt; shift
</code></pre>
<p>As we already know, besides the <code>clocksource</code> structure, the <code>clocksource</code> framework provides an API for registration of clock source with different frequency scale factor:</p>
<pre><code class="language-C">static inline int clocksource_register_hz(struct clocksource *cs, u32 hz)
static inline int clocksource_register_khz(struct clocksource *cs, u32 khz)
</code></pre>
<p>A clock source unregistration:</p>
<pre><code class="language-C">int clocksource_unregister(struct clocksource *cs)
</code></pre>
<p>and etc.</p>
<p>Additionally to the <code>clocksource</code> framework, the Linux kernel provides <code>clockevents</code> framework. As described in the <a href="https://github.com/0xAX/linux/blob/0a07b238e5f488b459b6113a62e06b6aab017f71/Documentation/timers/timekeeping.txt">documentation</a>:</p>
<blockquote>
<p>Clock events are the conceptual reverse of clock sources</p>
</blockquote>
<p>Main goal of the is to manage clock event devices or in other words - to manage devices that allow to register an event or in other words <a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a> that is going to happen at a defined point of time in the future.</p>
<p>Now we know a little about the <code>clockevents</code> framework in the Linux kernel, and now time is to see on it <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a>.</p>
<h2 id="api-of-clockevents-framework"><a class="header" href="#api-of-clockevents-framework">API of <code>clockevents</code> framework</a></h2>
<p>The main structure which described a clock event device is <code>clock_event_device</code> structure. This structure is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clockchips.h">include/linux/clockchips.h</a> header file and contains a huge set of fields. as well as the <code>clocksource</code> structure it has <code>name</code> fields which contains human readable name of a clock event device, for example <a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">local APIC</a> timer:</p>
<pre><code class="language-C">static struct clock_event_device lapic_clockevent = {
    .name                   = &quot;lapic&quot;,
    ...
    ...
    ...
}
</code></pre>
<p>Addresses of the <code>event_handler</code>, <code>set_next_event</code>, <code>next_event</code> functions for a certain clock event device which are an <a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt handler</a>, setter of next event and local storage for next event respectively. Yet another field of the <code>clock_event_device</code> structure is - <code>features</code> field. Its value maybe on of the following generic features:</p>
<pre><code class="language-C">#define CLOCK_EVT_FEAT_PERIODIC	0x000001
#define CLOCK_EVT_FEAT_ONESHOT		0x000002
</code></pre>
<p>Where the <code>CLOCK_EVT_FEAT_PERIODIC</code> represents device which may be programmed to generate events periodically. The <code>CLOCK_EVT_FEAT_ONESHOT</code> represents device which may generate an event only once. Besides these two features, there are also architecture-specific features. For example <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> supports two additional features:</p>
<pre><code class="language-C">#define CLOCK_EVT_FEAT_C3STOP		0x000008
</code></pre>
<p>The first <code>CLOCK_EVT_FEAT_C3STOP</code> means that a clock event device will be stopped in the <a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface#Device_states">C3</a> state. Additionally the <code>clock_event_device</code> structure has <code>mult</code> and <code>shift</code> fields as well as <code>clocksource</code> structure. The <code>clocksource</code> structure also contains other fields, but we will consider it later.</p>
<p>After we considered part of the <code>clock_event_device</code> structure, time is to look at the <code>API</code> of the <code>clockevents</code> framework. To work with a clock event device, first of all we need to initialize <code>clock_event_device</code> structure and register a clock events device. The <code>clockevents</code> framework provides following <code>API</code> for registration of clock event devices:</p>
<pre><code class="language-C">void clockevents_register_device(struct clock_event_device *dev)
{
   ...
   ...
   ...
}
</code></pre>
<p>This function defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/clockevents.c">kernel/time/clockevents.c</a> source code file and as we may see, the <code>clockevents_register_device</code> function takes only one parameter:</p>
<ul>
<li>address of a <code>clock_event_device</code> structure which represents a clock event device.</li>
</ul>
<p>So, to register a clock event device, at first we need to initialize <code>clock_event_device</code> structure with parameters of a certain clock event device. Let's take a look at one random clock event device in the Linux kernel source code. We can find one in the <a href="https://github.com/torvalds/linux/tree/master/drivers/clocksource">drivers/clocksource</a> directory or try to take a look at an architecture-specific clock event device. Let's take for example - <a href="http://www.atmel.com/Images/doc6062.pdf">Periodic Interval Timer (PIT) for at91sam926x</a>. You can find its implementation in the <a href="https://github.com/torvalds/linux/tree/master/drivers/clocksource/timer-atmel-pit.c">drivers/clocksource</a>.</p>
<p>First of all let's look at initialization of the <code>clock_event_device</code> structure. This occurs in the <code>at91sam926x_pit_common_init</code> function:</p>
<pre><code class="language-C">struct pit_data {
    ...
    ...
    struct clock_event_device       clkevt;
    ...
    ...
};

static void __init at91sam926x_pit_common_init(struct pit_data *data)
{
    ...
    ...
    ...
    data-&gt;clkevt.name = &quot;pit&quot;;
    data-&gt;clkevt.features = CLOCK_EVT_FEAT_PERIODIC;
    data-&gt;clkevt.shift = 32;
    data-&gt;clkevt.mult = div_sc(pit_rate, NSEC_PER_SEC, data-&gt;clkevt.shift);
    data-&gt;clkevt.rating = 100;
    data-&gt;clkevt.cpumask = cpumask_of(0);

    data-&gt;clkevt.set_state_shutdown = pit_clkevt_shutdown;
    data-&gt;clkevt.set_state_periodic = pit_clkevt_set_periodic;
    data-&gt;clkevt.resume = at91sam926x_pit_resume;
    data-&gt;clkevt.suspend = at91sam926x_pit_suspend;
    ...
}
</code></pre>
<p>Here we can see that <code>at91sam926x_pit_common_init</code> takes one parameter - pointer to the <code>pit_data</code> structure which contains <code>clock_event_device</code> structure which will contain clock event related information of the <code>at91sam926x</code> <a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">periodic Interval Timer</a>. At the start we fill <code>name</code> of the timer device and its <code>features</code>. In our case we deal with periodic timer which as we already know may be programmed to generate events periodically.</p>
<p>The next two fields <code>shift</code> and <code>mult</code> are familiar to us. They will be used to translate counter of our timer to nanoseconds. After this we set rating of the timer  to <code>100</code>. This means if there will not be timers with higher rating in the system, this timer will be used for timekeeping. The next field - <code>cpumask</code> indicates for which processors in the system the device will work. In our case, the device will work for the first processor. The <code>cpumask_of</code> macro defined in the <a href="https://github.com/torvalds/linux/tree/master/include/linux/cpumask.h">include/linux/cpumask.h</a> header file and just expands to the call of the:</p>
<pre><code class="language-C">#define cpumask_of(cpu) (get_cpu_mask(cpu))
</code></pre>
<p>Where the <code>get_cpu_mask</code> returns the cpumask containing just a given <code>cpu</code> number. More about <code>cpumasks</code> concept you may read in the <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">CPU masks in the Linux kernel</a> part. In the last four lines of code we set callbacks for the clock event device suspend/resume, device shutdown and update of the clock event device state.</p>
<p>After we finished with the initialization of the <code>at91sam926x</code> periodic timer, we can register it by the call of the following functions:</p>
<pre><code class="language-C">clockevents_register_device(&amp;data-&gt;clkevt);
</code></pre>
<p>Now we can consider implementation of the <code>clockevent_register_device</code> function. As I already wrote above, this function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/clockevents.c">kernel/time/clockevents.c</a> source code file and starts from the initialization of the initial event device state:</p>
<pre><code class="language-C">clockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);
</code></pre>
<p>Actually, an event device may be in one of this states:</p>
<pre><code class="language-C">enum clock_event_state {
	CLOCK_EVT_STATE_DETACHED,
	CLOCK_EVT_STATE_SHUTDOWN,
	CLOCK_EVT_STATE_PERIODIC,
	CLOCK_EVT_STATE_ONESHOT,
	CLOCK_EVT_STATE_ONESHOT_STOPPED,
};
</code></pre>
<p>Where:</p>
<ul>
<li><code>CLOCK_EVT_STATE_DETACHED</code> - a clock event device is not not used by <code>clockevents</code> framework. Actually it is initial state of all clock event devices;</li>
<li><code>CLOCK_EVT_STATE_SHUTDOWN</code> - a clock event device is powered-off;</li>
<li><code>CLOCK_EVT_STATE_PERIODIC</code> - a clock event device may be programmed to generate event periodically;</li>
<li><code>CLOCK_EVT_STATE_ONESHOT</code>  - a clock event device may be programmed to generate event only once;</li>
<li><code>CLOCK_EVT_STATE_ONESHOT_STOPPED</code> - a clock event device was programmed to generate event only once and now it is temporary stopped.</li>
</ul>
<p>The implementation of the <code>clock_event_set_state</code> function is pretty easy:</p>
<pre><code class="language-C">static inline void clockevent_set_state(struct clock_event_device *dev,
					enum clock_event_state state)
{
	dev-&gt;state_use_accessors = state;
}
</code></pre>
<p>As we can see, it just fills the <code>state_use_accessors</code> field of the given <code>clock_event_device</code> structure with the given value which is in our case is <code>CLOCK_EVT_STATE_DETACHED</code>. Actually all clock event devices has this initial state during registration. The <code>state_use_accessors</code> field of the <code>clock_event_device</code> structure provides <code>current</code> state of the clock event device.</p>
<p>After we have set initial state of the given <code>clock_event_device</code> structure we check that the <code>cpumask</code> of the given clock event device is not zero:</p>
<pre><code class="language-C">if (!dev-&gt;cpumask) {
	WARN_ON(num_possible_cpus() &gt; 1);
	dev-&gt;cpumask = cpumask_of(smp_processor_id());
}
</code></pre>
<p>Remember that we have set the <code>cpumask</code> of the <code>at91sam926x</code> periodic timer to first processor. If the <code>cpumask</code> field is zero, we check the number of possible processors in the system and print warning message if it is less than on. Additionally we set the <code>cpumask</code> of the given clock event device to the current processor. If you are interested in how the <code>smp_processor_id</code> macro is implemented, you can read more about it in the fourth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-4">part</a> of the Linux kernel initialization process chapter.</p>
<p>After this check we lock the actual code of the clock event device registration by the call following macros:</p>
<pre><code class="language-C">raw_spin_lock_irqsave(&amp;clockevents_lock, flags);
...
...
...
raw_spin_unlock_irqrestore(&amp;clockevents_lock, flags);
</code></pre>
<p>Additionally the <code>raw_spin_lock_irqsave</code> and the <code>raw_spin_unlock_irqrestore</code> macros disable local interrupts, however interrupts on other processors still may occur. We need to do it to prevent potential <a href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a> if we adding new clock event device to the list of clock event devices and an interrupt occurs from other clock event device.</p>
<p>We can see following code of clock event device registration between the <code>raw_spin_lock_irqsave</code> and <code>raw_spin_unlock_irqrestore</code> macros:</p>
<pre><code class="language-C">list_add(&amp;dev-&gt;list, &amp;clockevent_devices);
tick_check_new_device(dev);
clockevents_notify_released();
</code></pre>
<p>First of all we add the given clock event device to the list of clock event devices which is represented by the <code>clockevent_devices</code>:</p>
<pre><code class="language-C">static LIST_HEAD(clockevent_devices);
</code></pre>
<p>At the next step we call the <code>tick_check_new_device</code> function which is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/tick-common.c">kernel/time/tick-common.c</a> source code file and checks do the new registered clock event device should be used or not. The <code>tick_check_new_device</code> function checks the given <code>clock_event_device</code> gets the current registered tick device which is represented by the <code>tick_device</code> structure and compares their ratings and features. Actually <code>CLOCK_EVT_STATE_ONESHOT</code> is preferred:</p>
<pre><code class="language-C">static bool tick_check_preferred(struct clock_event_device *curdev,
				 struct clock_event_device *newdev)
{
	if (!(newdev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT)) {
		if (curdev &amp;&amp; (curdev-&gt;features &amp; CLOCK_EVT_FEAT_ONESHOT))
			return false;
		if (tick_oneshot_mode_active())
			return false;
	}

	return !curdev ||
		newdev-&gt;rating &gt; curdev-&gt;rating ||
	       !cpumask_equal(curdev-&gt;cpumask, newdev-&gt;cpumask);
}
</code></pre>
<p>If the new registered clock event device is more preferred than old tick device, we exchange old and new registered devices and install new device:</p>
<pre><code class="language-C">clockevents_exchange_device(curdev, newdev);
tick_setup_device(td, newdev, cpu, cpumask_of(cpu));
</code></pre>
<p>The <code>clockevents_exchange_device</code> function releases or in other words deleted the old clock event device from the <code>clockevent_devices</code> list. The next function - <code>tick_setup_device</code> as we may understand from its name, setups new tick device. This function check the mode of the new registered clock event device and call the <code>tick_setup_periodic</code> function or the <code>tick_setup_oneshot</code> depends on the tick device mode:</p>
<pre><code class="language-C">if (td-&gt;mode == TICKDEV_MODE_PERIODIC)
	tick_setup_periodic(newdev, 0);
else
	tick_setup_oneshot(newdev, handler, next_event);
</code></pre>
<p>Both of this functions calls the <code>clockevents_switch_state</code> to change state of the clock event device and the <code>clockevents_program_event</code> function to set next event of clock event device based on delta between the maximum and minimum difference current time and time for the next event. The <code>tick_setup_periodic</code>:</p>
<pre><code class="language-C">clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);
clockevents_program_event(dev, next, false))
</code></pre>
<p>and the <code>tick_setup_oneshot_periodic</code>:</p>
<pre><code class="language-C">clockevents_switch_state(newdev, CLOCK_EVT_STATE_ONESHOT);
clockevents_program_event(newdev, next_event, true);
</code></pre>
<p>The <code>clockevents_switch_state</code> function checks that the clock event device is not in the given state and calls the <code>__clockevents_switch_state</code> function from the same source code file:</p>
<pre><code class="language-C">if (clockevent_get_state(dev) != state) {
	if (__clockevents_switch_state(dev, state))
		return;
</code></pre>
<p>The <code>__clockevents_switch_state</code> function just makes a call of the certain callback depends on the given state:</p>
<pre><code class="language-C">static int __clockevents_switch_state(struct clock_event_device *dev,
				      enum clock_event_state state)
{
	if (dev-&gt;features &amp; CLOCK_EVT_FEAT_DUMMY)
		return 0;

	switch (state) {
	case CLOCK_EVT_STATE_DETACHED:
	case CLOCK_EVT_STATE_SHUTDOWN:
		if (dev-&gt;set_state_shutdown)
			return dev-&gt;set_state_shutdown(dev);
		return 0;

	case CLOCK_EVT_STATE_PERIODIC:
		if (!(dev-&gt;features &amp; CLOCK_EVT_FEAT_PERIODIC))
			return -ENOSYS;
		if (dev-&gt;set_state_periodic)
			return dev-&gt;set_state_periodic(dev);
		return 0;
    ...
    ...
    ...
</code></pre>
<p>In our case for <code>at91sam926x</code> periodic timer, the state is the <code>CLOCK_EVT_FEAT_PERIODIC</code>:</p>
<pre><code class="language-C">data-&gt;clkevt.features = CLOCK_EVT_FEAT_PERIODIC;
data-&gt;clkevt.set_state_periodic = pit_clkevt_set_periodic;
</code></pre>
<p>So, for the <code>pit_clkevt_set_periodic</code> callback will be called. If we will read the documentation of the <a href="http://www.atmel.com/Images/doc6062.pdf">Periodic Interval Timer (PIT) for at91sam926x</a>, we will see that there is <code>Periodic Interval Timer Mode Register</code> which allows us to control of periodic interval timer.</p>
<p>It looks like:</p>
<pre><code>31                                                   25        24
+---------------------------------------------------------------+
|                                          |  PITIEN  |  PITEN  |
+---------------------------------------------------------------+
23                            19                               16
+---------------------------------------------------------------+
|                             |               PIV               |
+---------------------------------------------------------------+
15                                                              8
+---------------------------------------------------------------+
|                            PIV                                |
+---------------------------------------------------------------+
7                                                               0
+---------------------------------------------------------------+
|                            PIV                                |
+---------------------------------------------------------------+
</code></pre>
<p>Where <code>PIV</code> or <code>Periodic Interval Value</code> - defines the value compared with the primary <code>20-bit</code> counter of the Periodic Interval Timer. The <code>PITEN</code> or <code>Period Interval Timer Enabled</code> if the bit is <code>1</code> and the <code>PITIEN</code> or <code>Periodic Interval Timer Interrupt Enable</code> if the bit is <code>1</code>. So, to set periodic mode, we need to set <code>24</code>, <code>25</code> bits in the <code>Periodic Interval Timer Mode Register</code>. And we are doing it in the <code>pit_clkevt_set_periodic</code> function:</p>
<pre><code class="language-C">static int pit_clkevt_set_periodic(struct clock_event_device *dev)
{
        struct pit_data *data = clkevt_to_pit_data(dev);
        ...
        ...
        ...
        pit_write(data-&gt;base, AT91_PIT_MR,
                  (data-&gt;cycle - 1) | AT91_PIT_PITEN | AT91_PIT_PITIEN);

        return 0;
}
</code></pre>
<p>Where the <code>AT91_PT_MR</code>, <code>AT91_PT_PITEN</code> and the <code>AT91_PIT_PITIEN</code> are declared as:</p>
<pre><code class="language-C">#define AT91_PIT_MR             0x00
#define AT91_PIT_PITIEN       BIT(25)
#define AT91_PIT_PITEN        BIT(24)
</code></pre>
<p>After the setup of the new clock event device is finished, we can return to the <code>clockevents_register_device</code> function. The last function in the <code>clockevents_register_device</code> function is:</p>
<pre><code class="language-C">clockevents_notify_released();
</code></pre>
<p>This function checks the <code>clockevents_released</code> list which contains released clock event devices (remember that they may occur after the call of the <code> clockevents_exchange_device</code> function). If this list is not empty, we go through clock event devices from the <code>clock_events_released</code> list and delete it from the <code>clockevent_devices</code>:</p>
<pre><code class="language-C">static void clockevents_notify_released(void)
{
	struct clock_event_device *dev;

	while (!list_empty(&amp;clockevents_released)) {
		dev = list_entry(clockevents_released.next,
				 struct clock_event_device, list);
		list_del(&amp;dev-&gt;list);
		list_add(&amp;dev-&gt;list, &amp;clockevent_devices);
		tick_check_new_device(dev);
	}
}
</code></pre>
<p>That's all. From this moment we have registered new clock event device. So the usage of the <code>clockevents</code> framework is simple and clear. Architectures registered their clock event devices, in the clock events core. Users of the clockevents core can get clock event devices for their use. The <code>clockevents</code> framework provides notification mechanisms for various clock related management events like a clock event device registered or unregistered, a processor is offlined in system which supports <a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">CPU hotplug</a> and etc.</p>
<p>We saw implementation only of the <code>clockevents_register_device</code> function. But generally, the clock event layer <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a> is small. Besides the <code>API</code> for clock event device registration, the <code>clockevents</code> framework provides functions to schedule the next event interrupt, clock event device notification service and support for suspend and resume for clock event devices.</p>
<p>If you want to know more about <code>clockevents</code> API you can start to research following source code and header files: <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/tick-common.c">kernel/time/tick-common.c</a>, <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/kernel/time/clockevents.c">kernel/time/clockevents.c</a> and <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/clockchips.h">include/linux/clockchips.h</a>.</p>
<p>That's all.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This is the end of the fifth part of the <a href="https://0xax.gitbook.io/linux-insides/summary/timers/">chapter</a> that describes timers and timer management related stuff in the Linux kernel. In the previous part got acquainted with the <code>timers</code> concept. In this part we continued to learn time management related stuff in the Linux kernel and saw a little about yet another framework - <code>clockevents</code>.</p>
<p>If you have questions or suggestions, feel free to ping me in twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://github.com/0xAX/linux/blob/0a07b238e5f488b459b6113a62e06b6aab017f71/Documentation/timers/timekeeping.txt">timekeeping documentation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Intel_8253">Intel 8253</a></li>
<li><a href="https://en.wikipedia.org/wiki/Programmable_interval_timer">programmable interval timer</a></li>
<li><a href="http://uefi.org/sites/default/files/resources/ACPI_5.pdf">ACPI pdf</a></li>
<li><a href="https://en.wikipedia.org/wiki/X86">x86</a></li>
<li><a href="https://en.wikipedia.org/wiki/High_Precision_Event_Timer">High Precision Event Timer</a></li>
<li><a href="https://en.wikipedia.org/wiki/PowerPC">powerpc</a></li>
<li><a href="https://en.wikipedia.org/wiki/Frequency">frequency</a></li>
<li><a href="https://en.wikipedia.org/wiki/Application_programming_interface">API</a></li>
<li><a href="https://en.wikipedia.org/wiki/Nanosecond">nanoseconds</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt">interrupt</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_handler">interrupt handler</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">local APIC</a></li>
<li><a href="https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface#Device_states">C3 state</a> </li>
<li><a href="http://www.atmel.com/Images/doc6062.pdf">Periodic Interval Timer (PIT) for at91sam926x</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-2">CPU masks in the Linux kernel</a></li>
<li><a href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">CPU hotplug</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/timers/linux-timers-3">previous part</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Timers/linux-timers-4.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Timers/linux-timers-6.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Timers/linux-timers-4.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Timers/linux-timers-6.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
