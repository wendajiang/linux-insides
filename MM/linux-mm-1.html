<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Memblock - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html" class="active">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linux-kernel-memory-management-part-1"><a class="header" href="#linux-kernel-memory-management-part-1">Linux kernel memory management Part 1.</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Memory management is one of the most complex (and I think that it is the most complex) part of the operating system kernel. In the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-3">last preparations before the kernel entry point</a> part we stopped right before call of the <code>start_kernel</code> function. This function initializes all the kernel features (including architecture-dependent features) before the kernel runs the first <code>init</code> process. You may remember as we built early page tables, identity page tables and fixmap page tables in the boot time. No complicated memory management is working yet. When the <code>start_kernel</code> function is called we will see the transition to more complex data structures and techniques for memory management. For a good understanding of the initialization process in the Linux kernel we need to have a clear understanding of these techniques. This chapter will provide an overview of the different parts of the linux kernel memory management framework and its API, starting from the <code>memblock</code>.</p>
<h2 id="memblock"><a class="header" href="#memblock">Memblock</a></h2>
<p>Memblock is one of the methods of managing memory regions during the early bootstrap period while the usual kernel memory allocators are not up and
running yet. Previously it was called <code>Logical Memory Block</code>, but with the <a href="https://lkml.org/lkml/2010/7/13/68">patch</a> by Yinghai Lu, it was renamed to the <code>memblock</code>. As Linux kernel for <code>x86_64</code> architecture uses this method. We already met <code>memblock</code> in the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-3">Last preparations before the kernel entry point</a> part. And now it's time to get acquainted with it closer. We will see how it is implemented.</p>
<p>We will start to learn <code>memblock</code> from the data structures. Definitions of all logical-memory-block-related data structures can be found in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/memblock.h">include/linux/memblock.h</a> header file.</p>
<p>The first structure has the same name as this part and it is:</p>
<pre><code class="language-C">struct memblock {
         bool bottom_up;
         phys_addr_t current_limit;
         struct memblock_type memory;   --&gt; array of memblock_region
         struct memblock_type reserved; --&gt; array of memblock_region
#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP
         struct memblock_type physmem;
#endif
};
</code></pre>
<p>This structure contains five fields. First is <code>bottom_up</code> which allows allocating memory in bottom-up mode when it is <code>true</code>. Next field is <code>current_limit</code>. This field describes the limit size of the memory block. The next three fields describe the type of the memory block. It can be: reserved, memory and physical memory (physical memory is available if the <code>CONFIG_HAVE_MEMBLOCK_PHYS_MAP</code> configuration option is enabled). Now we see yet another data structure - <code>memblock_type</code>. Let's look at its definition:</p>
<pre><code class="language-C">struct memblock_type {
	unsigned long cnt;
	unsigned long max;
	phys_addr_t total_size;
	struct memblock_region *regions;
};
</code></pre>
<p>This structure provides information about the memory type. It contains fields which describe the number of memory regions inside the current memory block, the size of all memory regions, the size of the allocated array of the memory regions, and a pointer to the array of the <code>memblock_region</code> structures. <code>memblock_region</code> is a structure which describes a memory region. Its definition is:</p>
<pre><code class="language-C">struct memblock_region {
        phys_addr_t base;
        phys_addr_t size;
        unsigned long flags;
#ifdef CONFIG_HAVE_MEMBLOCK_NODE_MAP
        int nid;
#endif
};
</code></pre>
<p><code>memblock_region</code> provides the base address and size of the memory region as well as a flags field which can have the following values:</p>
<pre><code class="language-C">enum {
    MEMBLOCK_NONE	= 0x0,	/* No special request */
    MEMBLOCK_HOTPLUG	= 0x1,	/* hotpluggable region */
    MEMBLOCK_MIRROR	= 0x2,	/* mirrored region */
    MEMBLOCK_NOMAP	= 0x4,	/* don't add to kernel direct mapping */
};
</code></pre>
<p>Also <code>memblock_region</code> provides an integer field - <a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access">numa</a> node selector, if the <code>CONFIG_HAVE_MEMBLOCK_NODE_MAP</code> configuration option is enabled.</p>
<p>Schematically we can imagine it as:</p>
<pre><code>+---------------------------+   +---------------------------+
|         memblock          |   |                           |
|  _______________________  |   |                           |
| |        memory         | |   |       Array of the        |
| |      memblock_type    |-|--&gt;|      memblock_region      |
| |_______________________| |   |                           |
|                           |   +---------------------------+
|  _______________________  |   +---------------------------+
| |       reserved        | |   |                           |
| |      memblock_type    |-|--&gt;|       Array of the        |
| |_______________________| |   |      memblock_region      |
|                           |   |                           |
+---------------------------+   +---------------------------+
</code></pre>
<p>These three structures: <code>memblock</code>, <code>memblock_type</code> and <code>memblock_region</code> are main in the <code>Memblock</code>. Now we know about it and can look at Memblock initialization process.</p>
<h2 id="memblock-initialization"><a class="header" href="#memblock-initialization">Memblock initialization</a></h2>
<p>As all API of the <code>memblock</code> are described in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/memblock.h">include/linux/memblock.h</a> header file, all implementations of these functions are in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/memblock.c">mm/memblock.c</a> source code file. Let's look at the top of the source code file and we will see the initialization of the <code>memblock</code> structure:</p>
<pre><code class="language-C">struct memblock memblock __initdata_memblock = {
	.memory.regions		= memblock_memory_init_regions,
	.memory.cnt		    = 1,
	.memory.max		    = INIT_MEMBLOCK_REGIONS,

	.reserved.regions	= memblock_reserved_init_regions,
	.reserved.cnt		= 1,
	.reserved.max		= INIT_MEMBLOCK_REGIONS,

#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP
	.physmem.regions	= memblock_physmem_init_regions,
	.physmem.cnt		= 1,
	.physmem.max		= INIT_PHYSMEM_REGIONS,
#endif
	.bottom_up		    = false,
	.current_limit		= MEMBLOCK_ALLOC_ANYWHERE,
};
</code></pre>
<p>Here we can see initialization of the <code>memblock</code> structure which has the same name as structure - <code>memblock</code>. First of all note the <code>__initdata_memblock</code>. Definition of this macro looks like:</p>
<pre><code class="language-C">#ifdef CONFIG_ARCH_DISCARD_MEMBLOCK
    #define __init_memblock __meminit
    #define __initdata_memblock __meminitdata
#else
    #define __init_memblock
    #define __initdata_memblock
#endif
</code></pre>
<p>You can see that it depends on <code>CONFIG_ARCH_DISCARD_MEMBLOCK</code>. If this configuration option is enabled, memblock code will be put into the <code>.init</code> section and will be released after the kernel is booted up.</p>
<p>Next we can see the initialization of the <code>memblock_type memory</code>, <code>memblock_type reserved</code> and <code>memblock_type physmem</code> fields of the <code>memblock</code> structure. Here we are interested only in the <code>memblock_type.regions</code> initialization process. Note that every <code>memblock_type</code> field is initialized by and array of <code>memblock_region</code>s:</p>
<pre><code class="language-C">static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP
static struct memblock_region memblock_physmem_init_regions[INIT_PHYSMEM_REGIONS] __initdata_memblock;
#endif
</code></pre>
<p>Every array contains 128 memory regions. We can see it in the <code>INIT_MEMBLOCK_REGIONS</code> macro definition:</p>
<pre><code class="language-C">#define INIT_MEMBLOCK_REGIONS   128
</code></pre>
<p>Note that all arrays are also defined with the <code>__initdata_memblock</code> macro which we already saw in the <code>memblock</code> structure initialization (read above if you've forgotten).</p>
<p>The last two fields describe that <code>bottom_up</code> allocation is disabled and the limit of the current Memblock is:</p>
<pre><code class="language-C">#define MEMBLOCK_ALLOC_ANYWHERE (~(phys_addr_t)0)
</code></pre>
<p>which is <code>0xffffffffffffffff</code>.</p>
<p>On this step the initialization of the <code>memblock</code> structure has been finished and we can have a look at the Memblock API.</p>
<h2 id="memblock-api"><a class="header" href="#memblock-api">Memblock API</a></h2>
<p>Ok we have finished with the initialization of the <code>memblock</code> structure and now we can look at the Memblock API and its implementation. As I said above, the implementation of <code>memblock</code> is taking place fully in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/memblock.c">mm/memblock.c</a>. To understand how <code>memblock</code> works and how it is implemented, let's look at its usage first. There are a couple of <a href="http://lxr.free-electrons.com/ident?i=memblock">places</a> in the Linux kernel where memblock is used. For example let's take <code>memblock_x86_fill</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/e820.c#L1061">arch/x86/kernel/e820.c</a>. This function goes through the memory map provided by the <a href="http://en.wikipedia.org/wiki/E820">e820</a> and adds memory regions reserved by the kernel to the <code>memblock</code> with the <code>memblock_add</code> function. Since we have met the <code>memblock_add</code> function first, let's start from it.</p>
<p>This function takes a physical base address and the size of the memory region as arguments and add them to the <code>memblock</code>. The <code>memblock_add</code> function does not do anything special in its body, but just calls the:</p>
<pre><code class="language-C">memblock_add_range(&amp;memblock.memory, base, size, MAX_NUMNODES, 0);
</code></pre>
<p>function. We pass the memory block type - <code>memory</code>, the physical base address and the size of the memory region, the maximum number of nodes which is 1 if <code>CONFIG_NODES_SHIFT</code> is not set in the configuration file or <code>1 &lt;&lt; CONFIG_NODES_SHIFT</code> if it is set, and the flags. The <code>memblock_add_range</code> function adds a new memory region to the memory block. It starts by checking the size of the given region and if it is zero it just returns. After this, <code>memblock_add_range</code> checks the existence of the memory regions in the <code>memblock</code> structure with the given <code>memblock_type</code>. If there are no memory regions, we just fill a new <code>memory_region</code> with the given values and return (we already saw the implementation of this in the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-3">First touch of the Linux kernel memory manager framework</a>). If <code>memblock_type</code> is not empty, we start to add a new memory region to the <code>memblock</code> with the given <code>memblock_type</code>.</p>
<p>First of all we get the end of the memory region with the:</p>
<pre><code class="language-C">phys_addr_t end = base + memblock_cap_size(base, &amp;size);
</code></pre>
<p><code>memblock_cap_size</code> adjusts <code>size</code> so that <code>base + size</code> will not overflow. Its implementation is pretty easy:</p>
<pre><code class="language-C">static inline phys_addr_t memblock_cap_size(phys_addr_t base, phys_addr_t *size)
{
	return *size = min(*size, (phys_addr_t)ULLONG_MAX - base);
}
</code></pre>
<p><code>memblock_cap_size</code> returns the new size which is the smallest value between the given size and <code>ULLONG_MAX - base</code>.</p>
<p>After that we have the end address of the new memory region, <code>memblock_add_range</code> checks for overlap and merge conditions with memory regions that have been added before. Insertion of the new memory region to the <code>memblock</code> consists of two steps:</p>
<ul>
<li>Adding of non-overlapping parts of the new memory area as separate regions;</li>
<li>Merging of all neighboring regions.</li>
</ul>
<p>We are going through all the already stored memory regions and checking for overlap with the new region:</p>
<pre><code class="language-C">	for (i = 0; i &lt; type-&gt;cnt; i++) {
		struct memblock_region *rgn = &amp;type-&gt;regions[i];
		phys_addr_t rbase = rgn-&gt;base;
		phys_addr_t rend = rbase + rgn-&gt;size;

		if (rbase &gt;= end)
			break;
		if (rend &lt;= base)
			continue;
        ...
		...
		...
	}
</code></pre>
<p>If the new memory region does not overlap with regions which are already stored in the <code>memblock</code>, insert this region into the memblock with and this is first step, we check if the new region can fit into the memory block and call <code>memblock_double_array</code> in another way:</p>
<pre><code class="language-C">while (type-&gt;cnt + nr_new &gt; type-&gt;max)
	if (memblock_double_array(type, obase, size) &lt; 0)
		return -ENOMEM;
	insert = true;
	goto repeat;
</code></pre>
<p><code>memblock_double_array</code> doubles the size of the given regions array. Then we set <code>insert</code> to <code>true</code> and go to the <code>repeat</code> label. In the second step, starting from the <code>repeat</code> label we go through the same loop and insert the current memory region into the memory block with the <code>memblock_insert_region</code> function:</p>
<pre><code class="language-C">	if (base &lt; end) {
		nr_new++;
		if (insert)
			memblock_insert_region(type, i, base, end - base,
					       nid, flags);
	}
</code></pre>
<p>Since we set <code>insert</code> to <code>true</code> in the first step, now <code>memblock_insert_region</code> will be called. <code>memblock_insert_region</code> has almost the same implementation that we saw when we inserted a new region to the empty <code>memblock_type</code> (see above). This function gets the last memory region:</p>
<pre><code class="language-C">struct memblock_region *rgn = &amp;type-&gt;regions[idx];
</code></pre>
<p>and copies the memory area with <code>memmove</code>:</p>
<pre><code class="language-C">memmove(rgn + 1, rgn, (type-&gt;cnt - idx) * sizeof(*rgn));
</code></pre>
<p>After this fills <code>memblock_region</code> fields of the new memory region base, size, etc. and increases size of the <code>memblock_type</code>. In the end of the execution, <code>memblock_add_range</code> calls <code>memblock_merge_regions</code> which merges neighboring compatible regions in the second step.</p>
<p>In the second case the new memory region can overlap already stored regions. For example we already have <code>region1</code> in the <code>memblock</code>:</p>
<pre><code>0                    0x1000
+-----------------------+
|                       |
|                       |
|        region1        |
|                       |
|                       |
+-----------------------+
</code></pre>
<p>And now we want to add <code>region2</code> to the <code>memblock</code> with the following base address and size:</p>
<pre><code>0x100                 0x2000
+-----------------------+
|                       |
|                       |
|        region2        |
|                       |
|                       |
+-----------------------+
</code></pre>
<p>In this case set the base address of the new memory region as the end address of the overlapped region with:</p>
<pre><code class="language-C">base = min(rend, end);
</code></pre>
<p>So it will be <code>0x1000</code> in our case. And insert it as we did it already in the second step with:</p>
<pre><code>if (base &lt; end) {
	nr_new++;
	if (insert)
		memblock_insert_region(type, i, base, end - base, nid, flags);
}
</code></pre>
<p>In this case we insert <code>overlapping portion</code> (we insert only the higher portion, because the lower portion is already in the overlapped memory region), then the remaining portion and merge these portions with <code>memblock_merge_regions</code>. As I said above <code>memblock_merge_regions</code> function merges neighboring compatible regions. It goes through all memory regions from the given <code>memblock_type</code>, takes two neighboring memory regions - <code>type-&gt;regions[i]</code> and <code>type-&gt;regions[i + 1]</code> and checks that these regions have the same flags, belong to the same node and that the end address of the first regions is not equal to the base address of the second region:</p>
<pre><code class="language-C">while (i &lt; type-&gt;cnt - 1) {
	struct memblock_region *this = &amp;type-&gt;regions[i];
	struct memblock_region *next = &amp;type-&gt;regions[i + 1];
	if (this-&gt;base + this-&gt;size != next-&gt;base ||
	    memblock_get_region_node(this) !=
	    memblock_get_region_node(next) ||
	    this-&gt;flags != next-&gt;flags) {
		BUG_ON(this-&gt;base + this-&gt;size &gt; next-&gt;base);
		i++;
		continue;
	}
</code></pre>
<p>If none of these conditions are true, we update the size of the first region with the size of the next region:</p>
<pre><code class="language-C">this-&gt;size += next-&gt;size;
</code></pre>
<p>As we update the size of the first memory region with the size of the next memory region, we move all memory regions which are after the (<code>next</code>) memory region one index backwards with the <code>memmove</code> function:</p>
<pre><code class="language-C">memmove(next, next + 1, (type-&gt;cnt - (i + 2)) * sizeof(*next));
</code></pre>
<p>The <code>memmove</code> here moves all regions which are located after the <code>next</code> region to the base address of the <code>next</code> region. In the end we just decrease the count of the memory regions which belong to the <code>memblock_type</code>:</p>
<pre><code class="language-C">type-&gt;cnt--;
</code></pre>
<p>After this we will get two memory regions merged into one:</p>
<pre><code>0                                             0x2000
+------------------------------------------------+
|                                                |
|                                                |
|                   region1                      |
|                                                |
|                                                |
+------------------------------------------------+
</code></pre>
<p>As we decreased counts of regions in a memblock with certain type, increased size of the <code>this</code> region and shifted all regions which are located after <code>next</code> region to its place.</p>
<p>That's all. This is the whole principle of the work of the <code>memblock_add_range</code> function.</p>
<p>There is also <code>memblock_reserve</code> function which does the same as <code>memblock_add</code>, but with one difference. It stores <code>memblock_type.reserved</code> in the memblock instead of <code>memblock_type.memory</code>.</p>
<p>Of course this is not the full API. Memblock provides APIs not only for adding <code>memory</code> and <code>reserved</code> memory regions, but also:</p>
<ul>
<li><code>memblock_remove</code> - removes memory region from memblock;</li>
<li><code>memblock_find_in_range</code> - finds free area in given range;</li>
<li><code>memblock_free</code> - releases memory region in memblock;</li>
<li><code>for_each_mem_range</code> - iterates through memblock areas.</li>
</ul>
<p>and many more....</p>
<h2 id="getting-info-about-memory-regions"><a class="header" href="#getting-info-about-memory-regions">Getting info about memory regions</a></h2>
<p>Memblock also provides an API for getting information about allocated memory regions in the <code>memblock</code>. It is split in two parts:</p>
<ul>
<li><code>get_allocated_memblock_memory_regions_info</code> - getting info about memory regions;</li>
<li><code>get_allocated_memblock_reserved_regions_info</code> - getting info about reserved regions.</li>
</ul>
<p>Implementation of these functions is easy. Let's look at <code>get_allocated_memblock_reserved_regions_info</code> for example:</p>
<pre><code class="language-C">phys_addr_t __init_memblock get_allocated_memblock_reserved_regions_info(
					phys_addr_t *addr)
{
	if (memblock.reserved.regions == memblock_reserved_init_regions)
		return 0;

	*addr = __pa(memblock.reserved.regions);

	return PAGE_ALIGN(sizeof(struct memblock_region) *
			  memblock.reserved.max);
}
</code></pre>
<p>First of all this function checks that <code>memblock</code> contains reserved memory regions. If <code>memblock</code> does not contain reserved memory regions we just return zero. Otherwise we write the physical address of the reserved memory regions array to the given address and return aligned size of the allocated array. Note that there is <code>PAGE_ALIGN</code> macro used for align. Actually it depends on size of page:</p>
<pre><code class="language-C">#define PAGE_ALIGN(addr) ALIGN(addr, PAGE_SIZE)
</code></pre>
<p>Implementation of the <code>get_allocated_memblock_memory_regions_info</code> function is the same. It has only one difference, <code>memblock_type.memory</code> used instead of <code>memblock_type.reserved</code>.</p>
<h2 id="memblock-debugging"><a class="header" href="#memblock-debugging">Memblock debugging</a></h2>
<p>There are many calls to <code>memblock_dbg</code> in the memblock implementation. If you pass the <code>memblock=debug</code> option to the kernel command line, this function will be called. Actually <code>memblock_dbg</code> is just a macro which expands to <code>printk</code>:</p>
<pre><code class="language-C">#define memblock_dbg(fmt, ...) \
         if (memblock_debug) printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)
</code></pre>
<p>For example you can see a call of this macro in the <code>memblock_reserve</code> function:</p>
<pre><code class="language-C">memblock_dbg(&quot;memblock_reserve: [%#016llx-%#016llx] flags %#02lx %pF\n&quot;,
		     (unsigned long long)base,
		     (unsigned long long)base + size - 1,
		     flags, (void *)_RET_IP_);
</code></pre>
<p>And you will see something like this:</p>
<p><img src="images/memblock.png" alt="Memblock" /></p>
<p>Memblock also has support in <a href="http://en.wikipedia.org/wiki/Debugfs">debugfs</a>. If you run the kernel on another architecture than <code>X86</code> you can access:</p>
<ul>
<li><code>/sys/kernel/debug/memblock/memory</code></li>
<li><code>/sys/kernel/debug/memblock/reserved</code></li>
<li><code>/sys/kernel/debug/memblock/physmem</code></li>
</ul>
<p>to get a dump of the <code>memblock</code> contents.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This is the end of the first part about Linux kernel memory management. If you have questions or suggestions, ping me on twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/E820">e820</a></li>
<li><a href="http://en.wikipedia.org/wiki/Non-uniform_memory_access">numa</a></li>
<li><a href="http://en.wikipedia.org/wiki/Debugfs">debugfs</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-3">First touch of the Linux kernel memory manager framework</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../MM/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../MM/linux-mm-2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../MM/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../MM/linux-mm-2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
