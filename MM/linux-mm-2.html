<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fixmaps and ioremap - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html" class="active">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linux-kernel-memory-management-part-2"><a class="header" href="#linux-kernel-memory-management-part-2">Linux kernel memory management Part 2.</a></h1>
<h2 id="fix-mapped-addresses-and-ioremap"><a class="header" href="#fix-mapped-addresses-and-ioremap">Fix-Mapped Addresses and ioremap</a></h2>
<p><code>Fix-Mapped</code> addresses are a set of special compile-time addresses whose corresponding physical addresses do not have to be a linear address minus <code>__START_KERNEL_map</code>. Each fix-mapped address maps one page frame and the kernel uses them as pointers that never change their address. That is the main point of these addresses. As the comment says: <code>to have a constant address at compile time, but to set the physical address only in the boot process</code>. You can remember that in the earliest <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">part</a>, we already set the <code>level2_fixmap_pgt</code>:</p>
<pre><code class="language-assembly">NEXT_PAGE(level2_fixmap_pgt)
	.fill	506,8,0
	.quad	level1_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE
	.fill	5,8,0

NEXT_PAGE(level1_fixmap_pgt)
	.fill	512,8,0
</code></pre>
<p>As you can see <code>level2_fixmap_pgt</code> is right after the <code>level2_kernel_pgt</code> which is kernel code+data+bss. Every fix-mapped address is represented by an integer index which is defined in the <code>fixed_addresses</code> enum from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/include/asm/fixmap.h">arch/x86/include/asm/fixmap.h</a>. For example it contains entries for <code>VSYSCALL_PAGE</code> - if emulation of legacy vsyscall page is enabled, <code>FIX_APIC_BASE</code> for local <a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">apic</a>, etc. In virtual memory fix-mapped area is placed in the modules area:</p>
<pre><code>       +-----------+-----------------+---------------+------------------+
       |           |                 |               |                  |
       |kernel text|      kernel     |               |    vsyscalls     |
       | mapping   |       text      |    Modules    |    fix-mapped    |
       |from phys 0|       data      |               |    addresses     |
       |           |                 |               |                  |
       +-----------+-----------------+---------------+------------------+
__START_KERNEL_map   __START_KERNEL    MODULES_VADDR            0xffffffffffffffff
</code></pre>
<p>Base virtual address and size of the <code>fix-mapped</code> area are presented by the two following macro:</p>
<pre><code class="language-C">#define FIXADDR_SIZE	(__end_of_permanent_fixed_addresses &lt;&lt; PAGE_SHIFT)
#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)
</code></pre>
<p>Here <code>__end_of_permanent_fixed_addresses</code> is an element of the <code>fixed_addresses</code> enum and as I wrote above, every fix-mapped address is represented by an integer index which is defined in the <code>fixed_addresses</code>. <code>PAGE_SHIFT</code> determines the size of a page. For example size of the one page we can get with the <code>1 &lt;&lt; PAGE_SHIFT</code> expression.</p>
<p>In our case we need to get the size of the fix-mapped area, but not only of one page, that's why we are using <code>__end_of_permanent_fixed_addresses</code> for getting the size of the fix-mapped area. The <code>__end_of_permanent_fixed_addresses</code> is the last index of the <code>fixed_addresses</code> enum or in other words the <code>__end_of_permanent_fixed_addresses</code> contains amount of pages in a fixed-mapped area. So if we multiply the value of the <code>__end_of_permanent_fixed_addresses</code> on a page size value we will get size of fix-mapped area. In my case it's a little more than <code>536</code> kilobytes. In your case it might be a different number, because the size depends on amount of the fix-mapped addresses which depends on your kernel configuration.</p>
<p>The second <code>FIXADDR_START</code> macro just subtracts the fix-mapped area size from the last address of the fix-mapped area to get its base virtual address. <code>FIXADDR_TOP</code> is a rounded up address from the base address of the <a href="https://lwn.net/Articles/446528/">vsyscall</a> space:</p>
<pre><code class="language-C">#define FIXADDR_TOP     (round_up(VSYSCALL_ADDR + PAGE_SIZE, 1&lt;&lt;PMD_SHIFT) - PAGE_SIZE)
</code></pre>
<p>The <code>fixed_addresses</code> enums are used as indexes to get the virtual addresses by the <code>fix_to_virt</code> function. Implementation of this function is easy:</p>
<pre><code class="language-C">static __always_inline unsigned long fix_to_virt(const unsigned int idx)
{
        BUILD_BUG_ON(idx &gt;= __end_of_fixed_addresses);
        return __fix_to_virt(idx);
}
</code></pre>
<p>first of all it checks that the index given for the <code>fixed_addresses</code> enum is not greater or equal than <code>__end_of_fixed_addresses</code> with the <code>BUILD_BUG_ON</code> macro and then returns the result of the <code>__fix_to_virt</code> macro:</p>
<pre><code class="language-C">#define __fix_to_virt(x)        (FIXADDR_TOP - ((x) &lt;&lt; PAGE_SHIFT))
</code></pre>
<p>Here we shift left the given index of a <code>fix-mapped</code> area on the <code>PAGE_SHIFT</code> which determines size of a page as I wrote above and subtract it from the <code>FIXADDR_TOP</code> which is the highest address of the <code>fix-mapped</code> area:</p>
<pre><code>+-----------------+
|    PAGE 1       | FIXADDR_TOP (virt address)
|    PAGE 2       |
|    PAGE 3       |
|    PAGE 4 (idx) | x - 4
|    PAGE 5       |
+-----------------+
</code></pre>
<p>There is an inverse function for getting an index of a fix-mapped area corresponding to the given virtual address:</p>
<pre><code class="language-C">static inline unsigned long virt_to_fix(const unsigned long vaddr)
{
        BUG_ON(vaddr &gt;= FIXADDR_TOP || vaddr &lt; FIXADDR_START);
        return __virt_to_fix(vaddr);
}
</code></pre>
<p>The <code>virt_to_fix</code> takes a virtual address, checks that this address is between <code>FIXADDR_START</code> and <code>FIXADDR_TOP</code> and calls the <code>__virt_to_fix</code> macro which implemented as:</p>
<pre><code class="language-C">#define __virt_to_fix(x)        ((FIXADDR_TOP - ((x)&amp;PAGE_MASK)) &gt;&gt; PAGE_SHIFT)
</code></pre>
<p>As we may see, the <code>__virt_to_fix</code> macro clears the first <code>12</code> bits in the given virtual address, subtracts it from the last address the of <code>fix-mapped</code> area (<code>FIXADDR_TOP</code>) and shifts the result right on <code>PAGE_SHIFT</code> which is <code>12</code>. Let me explain how it works.</p>
<p>As in previous example (in <code>__fix_to_virt</code> macro), we start from the top of the fix-mapped area. We also go back to bottom from the top to search an index of a fix-mapped area corresponding to the given virtual address. As you may see, first of all we will clear the first <code>12</code> bits in the given virtual address with <code>x &amp; PAGE_MASK</code> expression. This allows us to get base address of page. We need to do this for case when the given virtual address points somewhere in a beginning/middle or end of a page, but not to the base address of it. At the next step subtract this from the <code>FIXADDR_TOP</code> and this gives us virtual address of a corresponding page in a fix-mapped area. In the end we just divide value of this address on <code>PAGE_SHIFT</code>. This gives us index of a fix-mapped area corresponding to the given virtual address. It may looks hard, but if you will go through this step by step, you will be sure that the <code>__virt_to_fix</code> macro is pretty easy.</p>
<p>That's all. For this moment we know a little about <code>fix-mapped</code> addresses, but this is enough to go next.</p>
<p><code>Fix-mapped</code> addresses are used in different <a href="http://lxr.free-electrons.com/ident?i=fix_to_virt">places</a> in the Linux kernel. <code>IDT</code> descriptor stored there, <a href="http://en.wikipedia.org/wiki/Trusted_Execution_Technology">Intel Trusted Execution Technology</a> UUID stored in the <code>fix-mapped</code> area started from <code>FIX_TBOOT_BASE</code> index, <a href="http://en.wikipedia.org/wiki/Xen">Xen</a> bootmap and many more... We already saw a little about <code>fix-mapped</code> addresses in the fifth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">part</a> about of the linux kernel initialization. We use <code>fix-mapped</code> area in the early <code>ioremap</code> initialization. Let's look at it more closely and try to understand what <code>ioremap</code> is, how it is implemented in the kernel and how it is related to the <code>fix-mapped</code> addresses.</p>
<h2 id="ioremap"><a class="header" href="#ioremap">ioremap</a></h2>
<p>The Linux kernel provides many different primitives to manage memory. For this moment we will touch <code>I/O memory</code>. Every device is controlled by reading/writing from/to its registers. For example a driver can turn off/on a device by writing to its registers or get the state of a device by reading from its registers. Besides registers, many devices have buffers where a driver can write something or read from there. As we know for this moment there are two ways to access device's registers and data buffers:</p>
<ul>
<li>through the I/O ports;</li>
<li>mapping of all the registers to the memory address space;</li>
</ul>
<p>In the first case every control register of a device has a number of input and output port. A device driver can read from a port and write to it with two <code>in</code> and <code>out</code> instructions which we already saw. If you want to know about currently registered port regions, you can learn about them by accessing <code>/proc/ioports</code>:</p>
<pre><code>$ cat /proc/ioports
0000-0cf7 : PCI Bus 0000:00
  0000-001f : dma1
  0020-0021 : pic1
  0040-0043 : timer0
  0050-0053 : timer1
  0060-0060 : keyboard
  0064-0064 : keyboard
  0070-0077 : rtc0
  0080-008f : dma page reg
  00a0-00a1 : pic2
  00c0-00df : dma2
  00f0-00ff : fpu
    00f0-00f0 : PNP0C04:00
  03c0-03df : vesafb
  03f8-03ff : serial
  04d0-04d1 : pnp 00:06
  0800-087f : pnp 00:01
  0a00-0a0f : pnp 00:04
  0a20-0a2f : pnp 00:04
  0a30-0a3f : pnp 00:04
0cf8-0cff : PCI conf1
0d00-ffff : PCI Bus 0000:00
...
...
...
</code></pre>
<p><code>/proc/ioports</code> provides information about which driver uses which address of a <code>I/O</code> port region. All of these memory regions, for example <code>0000-0cf7</code>, were claimed with the <code>request_region</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/include/linux/ioport.h">include/linux/ioport.h</a>. Actually <code>request_region</code> is a macro which is defined as:</p>
<pre><code class="language-C">#define request_region(start,n,name)   __request_region(&amp;ioport_resource, (start), (n), (name), 0)
</code></pre>
<p>As we can see it takes three parameters:</p>
<ul>
<li><code>start</code> -  begin of region;</li>
<li><code>n</code>     -  length of region;</li>
<li><code>name</code>  -  name of requester.</li>
</ul>
<p><code>request_region</code> allocates an <code>I/O</code> port region. Very often the <code>check_region</code> function is called before the <code>request_region</code> to check that the given address range is available and the <code>release_region</code> function to release the memory region. <code>request_region</code> returns a pointer to the <code>resource</code> structure. The <code>resource</code> structure represents an abstraction for a tree-like subset of system resources. We already saw the <code>resource</code> structure in the fifth part of the kernel <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">initialization</a> process and it looks as follows:</p>
<pre><code class="language-C">struct resource {
        resource_size_t start;
        resource_size_t end;
        const char *name;
        unsigned long flags;
        struct resource *parent, *sibling, *child;
};
</code></pre>
<p>and contains start and end addresses of the resource, the name, etc. Every <code>resource</code> structure contains pointers to the <code>parent</code>, <code>sibling</code> and <code>child</code> resources. As it has a parent and a child, it means that every subset of resources has root <code>resource</code> structure. For example, for <code>I/O</code> ports it is the <code>ioport_resource</code> structure:</p>
<pre><code class="language-C">struct resource ioport_resource = {
         .name   = &quot;PCI IO&quot;,
         .start  = 0,
         .end    = IO_SPACE_LIMIT,
        .flags  = IORESOURCE_IO,
};
EXPORT_SYMBOL(ioport_resource);
</code></pre>
<p>Or for <code>iomem</code>, it is the <code>iomem_resource</code> structure:</p>
<pre><code class="language-C">struct resource iomem_resource = {
        .name   = &quot;PCI mem&quot;,
        .start  = 0,
        .end    = -1,
        .flags  = IORESOURCE_MEM,
};
</code></pre>
<p>As I have mentioned before, <code>request_regions</code> is used to register I/O port regions and this macro is used in many <a href="http://lxr.free-electrons.com/ident?i=request_region">places</a> in the kernel. For example let's look at <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/drivers/char/rtc.c">drivers/char/rtc.c</a>. This source code file provides the <a href="http://en.wikipedia.org/wiki/Real-time_clock">Real Time Clock</a> interface in the Linux kernel. As every kernel module, <code>rtc</code> module contains <code>module_init</code> definition:</p>
<pre><code class="language-C">module_init(rtc_init);
</code></pre>
<p>where <code>rtc_init</code> is the <code>rtc</code> initialization function. This function is defined in the same <code>rtc.c</code> source code file. In the <code>rtc_init</code> function we can see a couple of calls to the <code>rtc_request_region</code> functions, which wrap <code>request_region</code> for example:</p>
<pre><code class="language-C">r = rtc_request_region(RTC_IO_EXTENT);
</code></pre>
<p>where <code>rtc_request_region</code> calls:</p>
<pre><code class="language-C">r = request_region(RTC_PORT(0), size, &quot;rtc&quot;);
</code></pre>
<p>Here <code>RTC_IO_EXTENT</code> is the size of the memory region and it is <code>0x8</code>, <code>&quot;rtc&quot;</code> is the name of the region and <code>RTC_PORT</code> is:</p>
<pre><code class="language-C">#define RTC_PORT(x)     (0x70 + (x))
</code></pre>
<p>So with the <code>request_region(RTC_PORT(0), size, &quot;rtc&quot;)</code> we register a memory region that starts at <code>0x70</code> and has a size of <code>0x8</code>. Let's look at <code>/proc/ioports</code>:</p>
<pre><code>~$ sudo cat /proc/ioports | grep rtc
0070-0077 : rtc0
</code></pre>
<p>So, we got it! Ok, that was it for the I/O ports. The second way to communicate with drivers is through the use of <code>I/O</code> memory. As I have mentioned above this works by mapping the control registers and the memory of a device to the memory address space. <code>I/O</code> memory is a set of contiguous addresses which are provided by a device to the CPU through a bus. None of the memory-mapped I/O addresses are used by the kernel directly. There is a special <code>ioremap</code> function which allows us to convert the physical address on a bus to a kernel virtual address. In other words, <code>ioremap</code> maps I/O physical memory regions to make them accessible from the kernel. The <code>ioremap</code> function takes two parameters:</p>
<ul>
<li>start of the memory region;</li>
<li>size of the memory region;</li>
</ul>
<p>The I/O memory mapping API provides functions to check, request and release memory regions as I/O memory. There are three functions for that:</p>
<ul>
<li><code>request_mem_region</code></li>
<li><code>release_mem_region</code></li>
<li><code>check_mem_region</code></li>
</ul>
<pre><code>~$ sudo cat /proc/iomem
...
...
...
be826000-be82cfff : ACPI Non-volatile Storage
be82d000-bf744fff : System RAM
bf745000-bfff4fff : reserved
bfff5000-dc041fff : System RAM
dc042000-dc0d2fff : reserved
dc0d3000-dc138fff : System RAM
dc139000-dc27dfff : ACPI Non-volatile Storage
dc27e000-deffefff : reserved
defff000-deffffff : System RAM
df000000-dfffffff : RAM buffer
e0000000-feafffff : PCI Bus 0000:00
  e0000000-efffffff : PCI Bus 0000:01
    e0000000-efffffff : 0000:01:00.0
  f7c00000-f7cfffff : PCI Bus 0000:06
    f7c00000-f7c0ffff : 0000:06:00.0
    f7c10000-f7c101ff : 0000:06:00.0
      f7c10000-f7c101ff : ahci
  f7d00000-f7dfffff : PCI Bus 0000:03
    f7d00000-f7d3ffff : 0000:03:00.0
      f7d00000-f7d3ffff : alx
...
...
...
</code></pre>
<p>Part of these addresses are from the call of the <code>e820_reserve_resources</code> function. We can find a call to this function in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/kernel/setup.c">arch/x86/kernel/setup.c</a> and the function itself is defined in <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/kernel/e820.c">arch/x86/kernel/e820.c</a>. <code>e820_reserve_resources</code> goes through the <a href="http://en.wikipedia.org/wiki/E820">e820</a> map and inserts memory regions into the root <code>iomem</code> resource structure. All <code>e820</code> memory regions which are inserted into the <code>iomem</code> resource have the following types:</p>
<pre><code class="language-C">static inline const char *e820_type_to_string(int e820_type)
{
	switch (e820_type) {
	case E820_RESERVED_KERN:
	case E820_RAM:	return &quot;System RAM&quot;;
	case E820_ACPI:	return &quot;ACPI Tables&quot;;
	case E820_NVS:	return &quot;ACPI Non-volatile Storage&quot;;
	case E820_UNUSABLE:	return &quot;Unusable memory&quot;;
	default:	return &quot;reserved&quot;;
	}
}
</code></pre>
<p>and we can see them in the <code>/proc/iomem</code> (read above).</p>
<p>Now let's try to understand how <code>ioremap</code> works. We already know a little about <code>ioremap</code>, we saw it in the fifth <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">part</a> about Linux kernel initialization. If you have read this part, you can remember the call of the <code>early_ioremap_init</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/ioremap.c">arch/x86/mm/ioremap.c</a>. Initialization of the <code>ioremap</code> is split into two parts: there is the early part which we can use before the normal <code>ioremap</code> is available and the normal <code>ioremap</code> which is available after <code>vmalloc</code> initialization and the call of <code>paging_init</code>. We do not know anything about <code>vmalloc</code> for now, so let's consider early initialization of the <code>ioremap</code>. First of all <code>early_ioremap_init</code> checks that <code>fixmap</code> is aligned on page middle directory boundary:</p>
<pre><code class="language-C">BUILD_BUG_ON((fix_to_virt(0) + PAGE_SIZE) &amp; ((1 &lt;&lt; PMD_SHIFT) - 1));
</code></pre>
<p>more about <code>BUILD_BUG_ON</code> you can read in the first part about <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-1">Linux Kernel initialization</a>. So <code>BUILD_BUG_ON</code> macro raises a compilation error if the given expression is true. In the next step after this check, we can see call of the <code>early_ioremap_setup</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/early_ioremap.c">mm/early_ioremap.c</a>. This function presents generic initialization of the <code>ioremap</code>. <code>early_ioremap_setup</code> function fills the <code>slot_virt</code> array with the virtual addresses of the early fixmaps. All early fixmaps are after <code>__end_of_permanent_fixed_addresses</code> in memory. They start at <code>FIX_BITMAP_BEGIN</code> (top) and end with <code>FIX_BITMAP_END</code> (down). Actually there are <code>512</code> temporary boot-time mappings, used by early <code>ioremap</code>:</p>
<pre><code>#define NR_FIX_BTMAPS		64
#define FIX_BTMAPS_SLOTS	8
#define TOTAL_FIX_BTMAPS	(NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)
</code></pre>
<p>and <code>early_ioremap_setup</code>:</p>
<pre><code class="language-C">void __init early_ioremap_setup(void)
{
        int i;

        for (i = 0; i &lt; FIX_BTMAPS_SLOTS; i++)
                if (WARN_ON(prev_map[i]))
                        break;

        for (i = 0; i &lt; FIX_BTMAPS_SLOTS; i++)
                slot_virt[i] = __fix_to_virt(FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*i);
}
</code></pre>
<p>the <code>slot_virt</code> and other arrays are defined in the same source code file:</p>
<pre><code class="language-C">static void __iomem *prev_map[FIX_BTMAPS_SLOTS] __initdata;
static unsigned long prev_size[FIX_BTMAPS_SLOTS] __initdata;
static unsigned long slot_virt[FIX_BTMAPS_SLOTS] __initdata;
</code></pre>
<p><code>slot_virt</code> contains the virtual addresses of the <code>fix-mapped</code> areas, <code>prev_map</code> array contains addresses of the early ioremap areas. Note that I wrote above: <code>Actually there are 512 temporary boot-time mappings, used by early ioremap</code> and you can see that all arrays are defined with the <code>__initdata</code> attribute which means that this memory will be released after the kernel initialization process. After <code>early_ioremap_setup</code> has finished its work, we're getting page middle directory where early ioremap begins with the <code>early_ioremap_pmd</code> function which just gets the base address of the page global directory and calculates the page middle directory for the given address:</p>
<pre><code class="language-C">static inline pmd_t * __init early_ioremap_pmd(unsigned long addr)
{
	pgd_t *base = __va(read_cr3_pa());
	pgd_t *pgd = &amp;base[pgd_index(addr)];
	pud_t *pud = pud_offset(pgd, addr);
	pmd_t *pmd = pmd_offset(pud, addr);
	return pmd;
}
</code></pre>
<p>After this we fill <code>bm_pte</code> (early ioremap page table entries) with zeros and call the <code>pmd_populate_kernel</code> function:</p>
<pre><code class="language-C">pmd = early_ioremap_pmd(fix_to_virt(FIX_BTMAP_BEGIN));
memset(bm_pte, 0, sizeof(bm_pte));
pmd_populate_kernel(&amp;init_mm, pmd, bm_pte);
</code></pre>
<p><code>pmd_populate_kernel</code> takes three parameters:</p>
<ul>
<li><code>init_mm</code> - memory descriptor of the <code>init</code> process (you can read about it in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-5">part</a>);</li>
<li><code>pmd</code>     - page middle directory of the beginning of the <code>ioremap</code> fixmaps;</li>
<li><code>bm_pte</code>  - early <code>ioremap</code> page table entries array which defined as:</li>
</ul>
<pre><code class="language-C">static pte_t bm_pte[PAGE_SIZE/sizeof(pte_t)] __page_aligned_bss;
</code></pre>
<p>The <code>pmd_populate_kernel</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/master/arch/x86/include/asm/pgalloc.h">arch/x86/include/asm/pgalloc.h</a> and populates the page middle directory (<code>pmd</code>) provided as an argument with the given page table entries (<code>bm_pte</code>):</p>
<pre><code class="language-C">static inline void pmd_populate_kernel(struct mm_struct *mm,
                                       pmd_t *pmd, pte_t *pte)
{
        paravirt_alloc_pte(mm, __pa(pte) &gt;&gt; PAGE_SHIFT);
        set_pmd(pmd, __pmd(__pa(pte) | _PAGE_TABLE));
}
</code></pre>
<p>where <code>set_pmd</code> is:</p>
<pre><code class="language-C">#define set_pmd(pmdp, pmd)              native_set_pmd(pmdp, pmd)
</code></pre>
<p>and <code>native_set_pmd</code> is:</p>
<pre><code class="language-C">static inline void native_set_pmd(pmd_t *pmdp, pmd_t pmd)
{
        *pmdp = pmd;
}
</code></pre>
<p>That's all. Early <code>ioremap</code> is ready to use. There are a couple of checks in the <code>early_ioremap_init</code> function, but they are not so important, anyway initialization of the <code>ioremap</code> is finished.</p>
<h2 id="use-of-early-ioremap"><a class="header" href="#use-of-early-ioremap">Use of early ioremap</a></h2>
<p>As soon as early <code>ioremap</code> has been setup successfully, we can use it. It provides two functions:</p>
<ul>
<li>early_ioremap</li>
<li>early_iounmap</li>
</ul>
<p>for mapping/unmapping of I/O physical address to virtual address. Both functions depend on the <code>CONFIG_MMU</code> configuration option. <a href="http://en.wikipedia.org/wiki/Memory_management_unit">Memory management unit</a> is a special block of memory management. The main purpose of this block is the translation of physical addresses to virtual addresses. The memory management unit knows about the high-level page table addresses (<code>pgd</code>) from the <code>cr3</code> control register. If <code>CONFIG_MMU</code> options is set to <code>n</code>, <code>early_ioremap</code> just returns the given physical address and <code>early_iounmap</code> does nothing. If <code>CONFIG_MMU</code> option is set to <code>y</code>, <code>early_ioremap</code> calls <code>__early_ioremap</code> which takes three parameters:</p>
<ul>
<li><code>phys_addr</code> - base physical address of the <code>I/O</code> memory region to map on virtual addresses;</li>
<li><code>size</code>      - size of the <code>I/O</code> memory region;</li>
<li><code>prot</code>      - page table entry bits.</li>
</ul>
<p>First of all in the <code>__early_ioremap</code>, we go through all early ioremap fixmap slots and search for the first free one in the <code>prev_map</code> array. When we found it we remember its number in the <code>slot</code> variable and set up size:</p>
<pre><code class="language-C">slot = -1;
for (i = 0; i &lt; FIX_BTMAPS_SLOTS; i++) {
	if (!prev_map[i]) {
		slot = i;
		break;
	}
}
...
...
...
prev_size[slot] = size;
last_addr = phys_addr + size - 1;
</code></pre>
<p>In the next spte we can see the following code:</p>
<pre><code class="language-C">offset = phys_addr &amp; ~PAGE_MASK;
phys_addr &amp;= PAGE_MASK;
size = PAGE_ALIGN(last_addr + 1) - phys_addr;
</code></pre>
<p>Here we are using <code>PAGE_MASK</code> for clearing all bits in the <code>phys_addr</code> except the first 12 bits. <code>PAGE_MASK</code> macro is defined as:</p>
<pre><code class="language-C">#define PAGE_MASK       (~(PAGE_SIZE-1))
</code></pre>
<p>We know that size of a page is 4096 bytes or <code>1000000000000</code> in binary. <code>PAGE_SIZE - 1</code> will be <code>111111111111</code>, but with <code>~</code>, we will get <code>000000000000</code>, but as we use <code>~PAGE_MASK</code> we will get <code>111111111111</code> again. On the second line we do the same but clear the first 12 bits and getting page-aligned size of the area on the third line. We getting aligned area and now we need to get the number of pages which are occupied by the new <code>ioremap</code> area and calculate the fix-mapped index from <code>fixed_addresses</code> in the next steps:</p>
<pre><code class="language-C">nrpages = size &gt;&gt; PAGE_SHIFT;
idx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS*slot;
</code></pre>
<p>Now we can fill <code>fix-mapped</code> area with the given physical addresses. On every iteration in the loop, we call the <code>__early_set_fixmap</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/ioremap.c">arch/x86/mm/ioremap.c</a>, increase the given physical address by the page size which is <code>4096</code> bytes and update the <code>addresses</code> index and the number of pages:</p>
<pre><code class="language-C">while (nrpages &gt; 0) {
	__early_set_fixmap(idx, phys_addr, prot);
	phys_addr += PAGE_SIZE;
	--idx;
    --nrpages;
}
</code></pre>
<p>The <code>__early_set_fixmap</code> function gets the page table entry (stored in the <code>bm_pte</code>, see above) for the given physical address with:</p>
<pre><code class="language-C">pte = early_ioremap_pte(addr);
</code></pre>
<p>In the next step of <code>early_ioremap_pte</code> we check the given page flags with the <code>pgprot_val</code> macro and call <code>set_pte</code> or <code>pte_clear</code> depending on the flags given:</p>
<pre><code class="language-C">if (pgprot_val(flags))
		set_pte(pte, pfn_pte(phys &gt;&gt; PAGE_SHIFT, flags));
	else
		pte_clear(&amp;init_mm, addr, pte);
</code></pre>
<p>As you can see above, we passed <code>FIXMAP_PAGE_IO</code> as flags to the <code>__early_ioremap</code>. <code>FIXMPA_PAGE_IO</code> expands to the:</p>
<pre><code class="language-C">(__PAGE_KERNEL_EXEC | _PAGE_NX)
</code></pre>
<p>flags, so we call <code>set_pte</code> function to set the page table entry which works in the same manner as <code>set_pmd</code> but for PTEs (read above about it). As we have set all <code>PTEs</code> in the loop, we can now take a look at the call of the <code>__flush_tlb_one</code> function:</p>
<pre><code class="language-C">__flush_tlb_one(addr);
</code></pre>
<p>This function is defined in <a href="https://github.com/torvalds/linux">arch/x86/include/asm/tlbflush.h</a> and calls <code>__flush_tlb_single</code> or <code>__flush_tlb</code> depending on the value of <code>cpu_has_invlpg</code>:</p>
<pre><code class="language-C">static inline void __flush_tlb_one(unsigned long addr)
{
        if (cpu_has_invlpg)
                __flush_tlb_single(addr);
        else
                __flush_tlb();
}
</code></pre>
<p>The <code>__flush_tlb_one</code> function invalidates the given address in the <a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a>. As you just saw we updated the paging structure, but <code>TLB</code> is not informed of the changes, that's why we need to do it manually. There are two ways to do it. The first is to update the <code>cr3</code> control register and the <code>__flush_tlb</code> function does this:</p>
<pre><code class="language-C">native_write_cr3(__native_read_cr3());
</code></pre>
<p>The second method is to use the <code>invlpg</code> instruction to invalidate the <code>TLB</code> entry. Let's look at the <code>__flush_tlb_one</code> implementation. As you can see, first of all the function checks <code>cpu_has_invlpg</code> which is defined as:</p>
<pre><code class="language-C">#if defined(CONFIG_X86_INVLPG) || defined(CONFIG_X86_64)
# define cpu_has_invlpg         1
#else
# define cpu_has_invlpg         (boot_cpu_data.x86 &gt; 3)
#endif
</code></pre>
<p>If a CPU supports the <code>invlpg</code> instruction, we call the <code>__flush_tlb_single</code> macro which expands to the call of <code>__native_flush_tlb_single</code>:</p>
<pre><code class="language-C">static inline void __native_flush_tlb_single(unsigned long addr)
{
        asm volatile(&quot;invlpg (%0)&quot; ::&quot;r&quot; (addr) : &quot;memory&quot;);
}
</code></pre>
<p>or call <code>__flush_tlb</code> which just updates the <code>cr3</code> register as we have seen. After this step execution of the <code>__early_set_fixmap</code> function is finished and we can go back to the <code>__early_ioremap</code> implementation. When we have set up the fixmap area for the given address, we need to save the base virtual address of the I/O remapped area in the <code>prev_map</code> using the <code>slot</code> index:</p>
<pre><code class="language-C">prev_map[slot] = (void __iomem *)(offset + slot_virt[slot]);
</code></pre>
<p>and return it.</p>
<p>The second function, <code>early_iounmap</code>, unmaps an <code>I/O</code> memory region. This function takes two parameters: base address and size of a <code>I/O</code> region and generally looks very similar to <code>early_ioremap</code>. It also goes through fixmap slots and looks for a slot with the given address. After that, it gets the index of the fixmap slot and calls <code>__late_clear_fixmap</code> or <code>__early_set_fixmap</code> depending on the <code>after_paging_init</code> value. It calls <code>__early_set_fixmap</code> with one difference to how <code>early_ioremap</code> does it: <code>early_iounmap</code> passes <code>zero</code> as physical address. And in the end it sets the address of the I/O memory region to <code>NULL</code>:</p>
<pre><code class="language-C">prev_map[slot] = NULL;
</code></pre>
<p>That's all about <code>fixmaps</code> and <code>ioremap</code>. Of course this part does not cover all features of <code>ioremap</code>, only early ioremap but there is also normal ioremap. But we need to know more things before we study that in more detail.</p>
<p>So, this is the end!</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This is the end of the second part about Linux kernel memory management. If you have questions or suggestions, ping me on twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">apic</a></li>
<li><a href="https://lwn.net/Articles/446528/">vsyscall</a></li>
<li><a href="http://en.wikipedia.org/wiki/Trusted_Execution_Technology">Intel Trusted Execution Technology</a></li>
<li><a href="http://en.wikipedia.org/wiki/Xen">Xen</a></li>
<li><a href="http://en.wikipedia.org/wiki/Real-time_clock">Real Time Clock</a></li>
<li><a href="http://en.wikipedia.org/wiki/E820">e820</a></li>
<li><a href="http://en.wikipedia.org/wiki/Memory_management_unit">Memory management unit</a></li>
<li><a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer">TLB</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-1">Paging</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-1">Linux kernel memory management Part 1.</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../MM/linux-mm-1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../MM/linux-mm-3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../MM/linux-mm-1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../MM/linux-mm-3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
