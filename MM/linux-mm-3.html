<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>kmemcheck - Linux Insides</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../Booting/index.html">Booting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-1.html">From bootloader to kernel</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-2.html">First steps in the kernel setup code</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-3.html">Video mode initialization and transition to protected mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-4.html">Transition to 64-bit mode</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-5.html">Kernel decompression</a></li><li class="chapter-item expanded "><a href="../Booting/linux-bootstrap-6.html">Kernel load address randomization</a></li></ol></li><li class="chapter-item expanded "><a href="../Initialization/index.html">Initialization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-1.html">First steps in the kernel</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-2.html">Early interrupts handler</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-3.html">Last preparations before the kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-4.html">Kernel entry point</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-5.html">Continue architecture-specific boot-time initializations</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-6.html">Architecture-specific initializations, again...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-7.html">End of the architecture-specific initializations, almost...</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-8.html">Scheduler initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-9.html">RCU initialization</a></li><li class="chapter-item expanded "><a href="../Initialization/linux-initialization-10.html">End of initialization</a></li></ol></li><li class="chapter-item expanded "><a href="../Interrupts/index.html">Interrupts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-2.html">Start to dive into interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-3.html">Interrupt handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-4.html">Initialization of non-early interrupt gates</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-5.html">Implementation of some exception handlers</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-6.html">Handling Non-Maskable interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-7.html">Dive into external hardware interrupts</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-8.html">Initialization of external hardware interrupts structures</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-9.html">Softirq, Tasklets and Workqueues</a></li><li class="chapter-item expanded "><a href="../Interrupts/linux-interrupts-10.html">Last part</a></li></ol></li><li class="chapter-item expanded "><a href="../SysCall/index.html">System calls</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-1.html">Introduction to system calls</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-2.html">How the Linux kernel handles a system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-3.html">vsyscall and vDSO</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-4.html">How the Linux kernel runs a program</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-5.html">Implementation of the open system call</a></li><li class="chapter-item expanded "><a href="../SysCall/linux-syscall-6.html">Limits on resources in Linux</a></li></ol></li><li class="chapter-item expanded "><a href="../Timers/index.html">Timers and time management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Timers/linux-timers-1.html">Introduction</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-2.html">Clocksource framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-3.html">The tick broadcast framework and dyntick</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-4.html">Introduction to timers</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-5.html">Clockevents framework</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-6.html">x86 related clock sources</a></li><li class="chapter-item expanded "><a href="../Timers/linux-timers-7.html">Time related system calls</a></li></ol></li><li class="chapter-item expanded "><a href="../SyncPrim/index.html">Synchronization primitives</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-1.html">Introduction to spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-2.html">Queued spinlocks</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-3.html">Semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-4.html">Mutex</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-5.html">Reader/Writer semaphores</a></li><li class="chapter-item expanded "><a href="../SyncPrim/linux-sync-6.html">SeqLock</a></li><li class="chapter-item expanded "><div>RCU</div></li><li class="chapter-item expanded "><div>Lockdep</div></li></ol></li><li class="chapter-item expanded "><a href="../MM/index.html">Memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../MM/linux-mm-1.html">Memblock</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-2.html">Fixmaps and ioremap</a></li><li class="chapter-item expanded "><a href="../MM/linux-mm-3.html" class="active">kmemcheck</a></li></ol></li><li class="chapter-item expanded "><a href="../Cgroups/index.html">Cgroups</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Cgroups/linux-cgroups-1.html">Introduction to Control Groups</a></li></ol></li><li class="chapter-item expanded "><div>SMP</div></li><li class="chapter-item expanded "><a href="../Concepts/index.html">Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-1.html">Per-CPU variables</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-2.html">Cpumasks</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-3.html">The initcall mechanism</a></li><li class="chapter-item expanded "><a href="../Concepts/linux-cpu-4.html">Notification Chains</a></li></ol></li><li class="chapter-item expanded "><a href="../DataStructures/index.html">Data Structures in the Linux Kernel</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-1.html">Doubly linked list</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-2.html">Radix tree</a></li><li class="chapter-item expanded "><a href="../DataStructures/linux-datastructures-3.html">Bit arrays</a></li></ol></li><li class="chapter-item expanded "><a href="../Theory/index.html">Theory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Theory/linux-theory-1.html">Paging</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-2.html">Elf64</a></li><li class="chapter-item expanded "><a href="../Theory/linux-theory-3.html">Inline assembly</a></li><li class="chapter-item expanded "><div>CPUID</div></li><li class="chapter-item expanded "><div>MSR</div></li></ol></li><li class="chapter-item expanded "><div>Initial ram disk</div></li><li><ol class="section"><li class="chapter-item expanded "><div>initrd</div></li></ol></li><li class="chapter-item expanded "><a href="../Misc/index.html">Misc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Misc/linux-misc-1.html">Linux kernel development</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-2.html">How the kernel is compiled</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-3.html">Linkers</a></li><li class="chapter-item expanded "><a href="../Misc/linux-misc-4.html">Program startup process in userspace</a></li><li class="chapter-item expanded "><div>Write and Submit your first Linux kernel Patch</div></li><li class="chapter-item expanded "><div>Data types in the kernel</div></li></ol></li><li class="chapter-item expanded "><a href="../KernelStructures/index.html">KernelStructures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../KernelStructures/linux-kernelstructure-1.html">IDT</a></li></ol></li><li class="chapter-item expanded "><a href="../LINKS.html">Useful links</a></li><li class="chapter-item expanded "><a href="../contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Linux Insides</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xAX/linux-insides/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="linux-kernel-memory-management-part-3"><a class="header" href="#linux-kernel-memory-management-part-3">Linux kernel memory management Part 3.</a></h1>
<h2 id="introduction-to-the-kmemcheck-in-the-linux-kernel"><a class="header" href="#introduction-to-the-kmemcheck-in-the-linux-kernel">Introduction to the kmemcheck in the Linux kernel</a></h2>
<p>This is the third part of the <a href="https://0xax.gitbook.io/linux-insides/summary/mm">chapter</a> which describes <a href="https://en.wikipedia.org/wiki/Memory_management">memory management</a> in the Linux kernel and in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-2">part</a> of this chapter we met two memory management related concepts:</p>
<ul>
<li><code>Fix-Mapped Addresses</code>;</li>
<li><code>ioremap</code>.</li>
</ul>
<p>The first concept represents special area in <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual memory</a>, whose corresponding physical mapping is calculated in <a href="https://en.wikipedia.org/wiki/Compile_time">compile-time</a>. The second concept provides ability to map input/output related memory to virtual memory.</p>
<p>For example if you will look at the output of the <code>/proc/iomem</code>:</p>
<pre><code>$ sudo cat /proc/iomem

00000000-00000fff : reserved
00001000-0009d7ff : System RAM
0009d800-0009ffff : reserved
000a0000-000bffff : PCI Bus 0000:00
000c0000-000cffff : Video ROM
000d0000-000d3fff : PCI Bus 0000:00
000d4000-000d7fff : PCI Bus 0000:00
000d8000-000dbfff : PCI Bus 0000:00
000dc000-000dffff : PCI Bus 0000:00
000e0000-000fffff : reserved
...
...
...
</code></pre>
<p>you will see map of the system's memory for each physical device. Here the first column displays the memory registers used by each of the different types of memory. The second column lists the kind of memory located within those registers. Or for example:</p>
<pre><code>$ sudo cat /proc/ioports

0000-0cf7 : PCI Bus 0000:00
  0000-001f : dma1
  0020-0021 : pic1
  0040-0043 : timer0
  0050-0053 : timer1
  0060-0060 : keyboard
  0064-0064 : keyboard
  0070-0077 : rtc0
  0080-008f : dma page reg
  00a0-00a1 : pic2
  00c0-00df : dma2
  00f0-00ff : fpu
    00f0-00f0 : PNP0C04:00
  03c0-03df : vga+
  03f8-03ff : serial
  04d0-04d1 : pnp 00:06
  0800-087f : pnp 00:01
  0a00-0a0f : pnp 00:04
  0a20-0a2f : pnp 00:04
  0a30-0a3f : pnp 00:04
...
...
...
</code></pre>
<p>can show us lists of currently registered port regions used for input or output communication with a device. All memory-mapped I/O addresses are not used by the kernel directly. So, before the Linux kernel can use such memory, it must map it to the virtual memory space which is the main purpose of the <code>ioremap</code> mechanism. Note that we saw only early <code>ioremap</code> in the previous <a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-2">part</a>. Soon we will look at the implementation of the non-early <code>ioremap</code> function. But before this we must learn other things, like different types of memory allocators and etc., because otherwise it will be very difficult to understand it.</p>
<p>So, before we will move on to the non-early <a href="https://en.wikipedia.org/wiki/Memory_management">memory management</a> of the Linux kernel, we will see some mechanisms which provide special abilities for <a href="https://en.wikipedia.org/wiki/Debugging">debugging</a>, check of <a href="https://en.wikipedia.org/wiki/Memory_leak">memory leaks</a>, memory control and etc. It will be easier to understand how memory management arranged in the Linux kernel after learning of all of these things.</p>
<p>As you already may guess from the title of this part, we will start to consider memory mechanisms from the <a href="https://www.kernel.org/doc/Documentation/kmemcheck.txt">kmemcheck</a>. As we always did in other <a href="https://github.com/0xAX/linux-insides/blob/master/SUMMARY.md">chapters</a>, we will start to consider from theoretical side and will learn what is <code>kmemcheck</code> mechanism in general and only after this, we will see how it is implemented in the Linux kernel.</p>
<p>So let's start. What is it <code>kmemcheck</code> in the Linux kernel? As you may guess from the name of this mechanism, the <code>kmemcheck</code> checks memory. That's true. Main point of the <code>kmemcheck</code> mechanism is to check that some kernel code accesses <code>uninitialized memory</code>. Let's take following simple <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> program:</p>
<pre><code class="language-C">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

struct A {
        int a;
};

int main(int argc, char **argv) {
        struct A *a = malloc(sizeof(struct A));
        printf(&quot;a-&gt;a = %d\n&quot;, a-&gt;a);
        return 0;
}
</code></pre>
<p>Here we allocate memory for the <code>A</code> structure and tries to print value of the <code>a</code> field. If we will compile this program without additional options:</p>
<pre><code>gcc test.c -o test
</code></pre>
<p>The <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">compiler</a> will not show us warning that <code>a</code> field is not uninitialized. But if we will run this program with <a href="https://en.wikipedia.org/wiki/Valgrind">valgrind</a> tool, we will see the following output:</p>
<pre><code>~$   valgrind --leak-check=yes ./test
==28469== Memcheck, a memory error detector
==28469== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==28469== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==28469== Command: ./test
==28469==
==28469== Conditional jump or move depends on uninitialised value(s)
==28469==    at 0x4E820EA: vfprintf (in /usr/lib64/libc-2.22.so)
==28469==    by 0x4E88D48: printf (in /usr/lib64/libc-2.22.so)
==28469==    by 0x4005B9: main (in /home/alex/test)
==28469==
==28469== Use of uninitialised value of size 8
==28469==    at 0x4E7E0BB: _itoa_word (in /usr/lib64/libc-2.22.so)
==28469==    by 0x4E8262F: vfprintf (in /usr/lib64/libc-2.22.so)
==28469==    by 0x4E88D48: printf (in /usr/lib64/libc-2.22.so)
==28469==    by 0x4005B9: main (in /home/alex/test)
...
...
...
</code></pre>
<p>Actually the <code>kmemcheck</code> mechanism does the same for the kernel, what the <code>valgrind</code> does for userspace programs. It check uninitialized memory.</p>
<p>To enable this mechanism in the Linux kernel, you need to enable the <code>CONFIG_KMEMCHECK</code> kernel configuration option in the:</p>
<pre><code>Kernel hacking
  -&gt; Memory Debugging
</code></pre>
<p>menu of the Linux kernel configuration:</p>
<p><img src="images/kernel_configuration_menu1.png" alt="kernel configuration menu" /></p>
<p>We may not only enable support of the <code>kmemcheck</code> mechanism in the Linux kernel, but it also provides some configuration options for us. We will see all of these options in the next paragraph of this part. Last note before we will consider how does the <code>kmemcheck</code> check memory. Now this mechanism is implemented only for the <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture. You can be sure if you will look in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/Kconfig">arch/x86/Kconfig</a> <code>x86</code> related kernel configuration file, you will see following lines:</p>
<pre><code>config X86
  ...
  ...
  ...
  select HAVE_ARCH_KMEMCHECK
  ...
  ...
  ...
</code></pre>
<p>So, there isn't anything which is specific for other architectures.</p>
<p>Ok, so we know that <code>kmemcheck</code> provides mechanism to check usage of <code>uninitialized memory</code> in the Linux kernel and how to enable it. How it does these checks? When the Linux kernel tries to allocate some memory i.e. something is called like this:</p>
<pre><code class="language-C">struct my_struct *my_struct = kmalloc(sizeof(struct my_struct), GFP_KERNEL);
</code></pre>
<p>or in other words somebody wants to access a <a href="https://en.wikipedia.org/wiki/Page_%28computer_memory%29">page</a>, a <a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a> exception is generated. This is achieved by the fact that the <code>kmemcheck</code> marks memory pages as <code>non-present</code> (more about this you can read in the special part which is devoted to <a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-1">Paging</a>). If a <code>page fault</code> exception occurred, the exception handler knows about it and in a case when the <code>kmemcheck</code> is enabled it transfers control to it. After the <code>kmemcheck</code> will finish its checks, the page will be marked as <code>present</code> and the interrupted code will be able to continue execution. There is little subtlety in this chain. When the first instruction of interrupted code will be executed, the <code>kmemcheck</code> will mark the page as <code>non-present</code> again. In this way next access to memory will be caught again.</p>
<p>We just considered the <code>kmemcheck</code> mechanism from theoretical side. Now let's consider how it is implemented in the Linux kernel.</p>
<h2 id="implementation-of-the-kmemcheck-mechanism-in-the-linux-kernel"><a class="header" href="#implementation-of-the-kmemcheck-mechanism-in-the-linux-kernel">Implementation of the <code>kmemcheck</code> mechanism in the Linux kernel</a></h2>
<p>So, now we know what is it <code>kmemcheck</code> and what it does in the Linux kernel. Time to see at its implementation in the Linux kernel. Implementation of the <code>kmemcheck</code> is split in two parts. The first is generic part is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/kmemcheck.c">mm/kmemcheck.c</a> source code file and the second <a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> architecture-specific part is located in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/mm/kmemcheck">arch/x86/mm/kmemcheck</a> directory.</p>
<p>Let's start from the initialization of this mechanism. We already know that to enable the <code>kmemcheck</code> mechanism in the Linux kernel, we must enable the <code>CONFIG_KMEMCHECK</code> kernel configuration option. But besides this, we need to pass one of following parameters:</p>
<ul>
<li>kmemcheck=0 (disabled)</li>
<li>kmemcheck=1 (enabled)</li>
<li>kmemcheck=2 (one-shot mode)</li>
</ul>
<p>to the Linux kernel command line. The first two are clear, but the last needs a little explanation. This option switches the <code>kmemcheck</code> in a special mode when it will be turned off after detecting the first use of uninitialized memory. Actually this mode is enabled by default in the Linux kernel:</p>
<p><img src="images/kernel_configuration_menu2.png" alt="kernel configuration menu" /></p>
<p>We know from the seventh <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-7">part</a> of the chapter which describes initialization of the Linux kernel that the kernel command line is parsed during initialization of the Linux kernel in <code>do_initcall_level</code>, <code>do_early_param</code> functions. Actually the <code>kmemcheck</code> subsystem consists from two stages. The first stage is early. If we will look at the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/kmemcheck.c">mm/kmemcheck.c</a> source code file, we will see the <code>param_kmemcheck</code> function which is will be called during early command line parsing:</p>
<pre><code class="language-C">static int __init param_kmemcheck(char *str)
{
	int val;
	int ret;

	if (!str)
		return -EINVAL;

	ret = kstrtoint(str, 0, &amp;val);
	if (ret)
		return ret;
	kmemcheck_enabled = val;
	return 0;
}

early_param(&quot;kmemcheck&quot;, param_kmemcheck);
</code></pre>
<p>As we already saw, the <code>param_kmemcheck</code> may have one of the following values: <code>0</code> (enabled), <code>1</code> (disabled) or <code>2</code> (one-shot). The implementation of the <code>param_kmemcheck</code> is pretty simple. We just convert string value of the <code>kmemcheck</code> command line option to integer representation and set it to the <code>kmemcheck_enabled</code> variable.</p>
<p>The second stage will be executed during initialization of the Linux kernel, rather during initialization of early <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-3">initcalls</a>. The second stage is represented by the <code>kmemcheck_init</code>:</p>
<pre><code class="language-C">int __init kmemcheck_init(void)
{
    ...
    ...
    ...
}

early_initcall(kmemcheck_init);
</code></pre>
<p>Main goal of the <code>kmemcheck_init</code> function is to call the <code>kmemcheck_selftest</code> function and check its result:</p>
<pre><code class="language-C">if (!kmemcheck_selftest()) {
	printk(KERN_INFO &quot;kmemcheck: self-tests failed; disabling\n&quot;);
	kmemcheck_enabled = 0;
	return -EINVAL;
}

printk(KERN_INFO &quot;kmemcheck: Initialized\n&quot;);
</code></pre>
<p>and return with the <code>EINVAL</code> if this check is failed. The <code>kmemcheck_selftest</code> function checks sizes of different memory access related <a href="https://en.wikipedia.org/wiki/Opcode">opcodes</a> like <code>rep movsb</code>, <code>movzwq</code> and etc. If sizes of opcodes are equal to expected sizes, the <code>kmemcheck_selftest</code> will return <code>true</code> and <code>false</code> otherwise.</p>
<p>So when somebody calls:</p>
<pre><code class="language-C">struct my_struct *my_struct = kmalloc(sizeof(struct my_struct), GFP_KERNEL);
</code></pre>
<p>through a series of different function calls the <code>kmem_getpages</code> function will be called. This function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/slab.c">mm/slab.c</a> source code file and main goal of this function tries to allocate <a href="https://en.wikipedia.org/wiki/Paging">pages</a> with the given flags. In the end of this function we can see following code:</p>
<pre><code class="language-C">if (kmemcheck_enabled &amp;&amp; !(cachep-&gt;flags &amp; SLAB_NOTRACK)) {
	kmemcheck_alloc_shadow(page, cachep-&gt;gfporder, flags, nodeid);

    if (cachep-&gt;ctor)
		kmemcheck_mark_uninitialized_pages(page, nr_pages);
	else
		kmemcheck_mark_unallocated_pages(page, nr_pages);
}
</code></pre>
<p>So, here we check that the if <code>kmemcheck</code> is enabled and the <code>SLAB_NOTRACK</code> bit is not set in flags we set <code>non-present</code> bit for the just allocated page. The <code>SLAB_NOTRACK</code> bit tell us to not track uninitialized memory. Additionally we check if a cache object has constructor (details will be considered in next parts) we mark allocated page as uninitialized or unallocated otherwise. The <code>kmemcheck_alloc_shadow</code> function is defined in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/mm/kmemcheck.c">mm/kmemcheck.c</a> source code file and does following things:</p>
<pre><code class="language-C">void kmemcheck_alloc_shadow(struct page *page, int order, gfp_t flags, int node)
{
    struct page *shadow;

   	shadow = alloc_pages_node(node, flags | __GFP_NOTRACK, order);

   	for(i = 0; i &lt; pages; ++i)
		page[i].shadow = page_address(&amp;shadow[i]);

   	kmemcheck_hide_pages(page, pages);
}
</code></pre>
<p>First of all it allocates memory space for the shadow bits. If this bit is set in a page, this means that this page is tracked by the <code>kmemcheck</code>. After we allocated space for the shadow bit, we fill all allocated pages with this bit. In the end we just call the <code>kmemcheck_hide_pages</code> function with the pointer to the allocated page and number of these pages. The <code>kmemcheck_hide_pages</code> is architecture-specific function, so its implementation is located in the <a href="https://github.com/torvalds/linux/tree/master/arch/x86/mm/kmemcheck/kmemcheck.c">arch/x86/mm/kmemcheck/kmemcheck.c</a> source code file. The main goal of this function is to set <code>non-present</code> bit in given pages. Let's look at the implementation of this function:</p>
<pre><code class="language-C">void kmemcheck_hide_pages(struct page *p, unsigned int n)
{
	unsigned int i;

	for (i = 0; i &lt; n; ++i) {
		unsigned long address;
		pte_t *pte;
		unsigned int level;

		address = (unsigned long) page_address(&amp;p[i]);
		pte = lookup_address(address, &amp;level);
		BUG_ON(!pte);
		BUG_ON(level != PG_LEVEL_4K);

		set_pte(pte, __pte(pte_val(*pte) &amp; ~_PAGE_PRESENT));
		set_pte(pte, __pte(pte_val(*pte) | _PAGE_HIDDEN));
		__flush_tlb_one(address);
	}
}
</code></pre>
<p>Here we go through all pages and try to get <code>page table entry</code> for each page. If this operation was successful, we unset present bit and set hidden bit in each page. In the end we flush <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">translation lookaside buffer</a>, because some pages was changed. From this point allocated pages are tracked by the <code>kmemcheck</code>. Now, as <code>present</code> bit is unset, the <a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a> execution will be occurred right after the <code>kmalloc</code> will return pointer to allocated space and a code will try to access this memory.</p>
<p>As you may remember from the <a href="https://0xax.gitbook.io/linux-insides/summary/initialization/linux-initialization-2">second part</a> of the Linux kernel initialization chapter, the <code>page fault</code> handler is located in the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/fault.c">arch/x86/mm/fault.c</a> source code file and represented by the <code>do_page_fault</code> function. We can see following check from the beginning of the <code>do_page_fault</code> function:</p>
<pre><code class="language-C">static noinline void
__do_page_fault(struct pt_regs *regs, unsigned long error_code,
		unsigned long address)
{
    ...
    ...
    ...
	if (kmemcheck_active(regs))
		kmemcheck_hide(regs);
    ...
    ...
    ...
}
</code></pre>
<p>The <code>kmemcheck_active</code> gets <code>kmemcheck_context</code> <a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu</a> structure and returns the result of comparison of the <code>balance</code> field of this structure with zero:</p>
<pre><code>bool kmemcheck_active(struct pt_regs *regs)
{
	struct kmemcheck_context *data = this_cpu_ptr(&amp;kmemcheck_context);

	return data-&gt;balance &gt; 0;
}
</code></pre>
<p>The <code>kmemcheck_context</code> is structure which describes current state of the <code>kmemcheck</code> mechanism. It stored uninitialized addresses, number of such addresses and etc. The <code>balance</code> field of this structure represents current state of the <code>kmemcheck</code> or in other words it can tell us did <code>kmemcheck</code> already hid pages or not yet. If the <code>data-&gt;balance</code> is greater than zero, the <code>kmemcheck_hide</code> function will be called. This means than <code>kmemecheck</code> already set <code>present</code> bit for given pages and now we need to hide pages again to cause next step to page fault. This function will hide addresses of pages again by unsetting of <code>present</code> bit. This means that one session of <code>kmemcheck</code> already finished and new page fault occurred. At the first step the <code>kmemcheck_active</code> will return false as the <code>data-&gt;balance</code> is zero for the start and the <code>kmemcheck_hide</code> will not be called. Next, we may see following line of code in the <code>do_page_fault</code>:</p>
<pre><code class="language-C">if (kmemcheck_fault(regs, address, error_code))
		return;
</code></pre>
<p>First of all the <code>kmemcheck_fault</code> function checks that the fault occurred by the correct reason. At first we check the <a href="https://en.wikipedia.org/wiki/FLAGS_register">flags register</a> and check that we are in normal kernel mode:</p>
<pre><code class="language-C">if (regs-&gt;flags &amp; X86_VM_MASK)
		return false;
if (regs-&gt;cs != __KERNEL_CS)
		return false;
</code></pre>
<p>If these checks weren't successful we return from the <code>kmemcheck_fault</code> function as it was not <code>kmemcheck</code> related page fault. After this we try to lookup a <code>page table entry</code> related to the faulted address and if we can't find it we return:</p>
<pre><code class="language-C">pte = kmemcheck_pte_lookup(address);
if (!pte)
	return false;
</code></pre>
<p>Last two steps of the <code>kmemcheck_fault</code> function is to call the <code>kmemcheck_access</code> function which check access to the given page and show addresses again by setting present bit in the given page. The <code>kmemcheck_access</code> function does all main job. It checks current instruction which caused a page fault. If it finds an error, the context of this error will be saved by <code>kmemcheck</code> to the ring queue:</p>
<pre><code class="language-C">static struct kmemcheck_error error_fifo[CONFIG_KMEMCHECK_QUEUE_SIZE];
</code></pre>
<p>The <code>kmemcheck</code> mechanism declares special <a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-9">tasklet</a>:</p>
<pre><code class="language-C">static DECLARE_TASKLET(kmemcheck_tasklet, &amp;do_wakeup, 0);
</code></pre>
<p>which runs the <code>do_wakeup</code> function from the <a href="https://github.com/torvalds/linux/blob/16f73eb02d7e1765ccab3d2018e0bd98eb93d973/arch/x86/mm/kmemcheck/error.c">arch/x86/mm/kmemcheck/error.c</a> source code file when it is scheduled to run.</p>
<p>The <code>do_wakeup</code> function will call the <code>kmemcheck_error_recall</code> function which will print errors collected by <code>kmemcheck</code>. As we already saw the:</p>
<pre><code class="language-C">kmemcheck_show(regs);
</code></pre>
<p>function will be called in the end of the <code>kmemcheck_fault</code> function. This function will set present bit for the given pages again:</p>
<pre><code class="language-C">if (unlikely(data-&gt;balance != 0)) {
	kmemcheck_show_all();
	kmemcheck_error_save_bug(regs);
	data-&gt;balance = 0;
	return;
}
</code></pre>
<p>Where the <code>kmemcheck_show_all</code> function calls the <code>kmemcheck_show_addr</code> for each address:</p>
<pre><code class="language-C">static unsigned int kmemcheck_show_all(void)
{
	struct kmemcheck_context *data = this_cpu_ptr(&amp;kmemcheck_context);
	unsigned int i;
	unsigned int n;

	n = 0;
	for (i = 0; i &lt; data-&gt;n_addrs; ++i)
		n += kmemcheck_show_addr(data-&gt;addr[i]);

	return n;
}
</code></pre>
<p>by the call of the <code>kmemcheck_show_addr</code>:</p>
<pre><code class="language-C">int kmemcheck_show_addr(unsigned long address)
{
	pte_t *pte;

	pte = kmemcheck_pte_lookup(address);
	if (!pte)
		return 0;

	set_pte(pte, __pte(pte_val(*pte) | _PAGE_PRESENT));
	__flush_tlb_one(address);
	return 1;
}
</code></pre>
<p>In the end of the <code>kmemcheck_show</code> function we set the <a href="https://en.wikipedia.org/wiki/Trap_flag">TF</a> flag if it wasn't set:</p>
<pre><code class="language-C">if (!(regs-&gt;flags &amp; X86_EFLAGS_TF))
	data-&gt;flags = regs-&gt;flags;
</code></pre>
<p>We need to do it because we need to hide pages again after first executed instruction after a page fault will be handled. In a case when the <code>TF</code> flag, so the processor will switch into single-step mode after the first instruction will be executed. In this case <code>debug</code> exception will occurred. From this moment pages will be hidden again and execution will be continued. As pages hidden from this moment, page fault exception will occur again and <code>kmemcheck</code> continue to check/collect errors again and print them from time to time.</p>
<p>That's all.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This is the end of the third part about Linux kernel <a href="https://en.wikipedia.org/wiki/Memory_management">memory management</a>. If you have questions or suggestions, ping me on twitter <a href="https://twitter.com/0xAX">0xAX</a>, drop me an <a href="mailto:anotherworldofworld@gmail.com">email</a> or just create an <a href="https://github.com/0xAX/linux-insides/issues/new">issue</a>. In the next part we will see yet another memory debugging related tool - <code>kmemleak</code>.</p>
<p><strong>Please note that English is not my first language and I am really sorry for any inconvenience. If you found any mistakes please send me a PR to <a href="https://github.com/0xAX/linux-insides">linux-insides</a>.</strong></p>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Memory_management">memory management</a></li>
<li><a href="https://en.wikipedia.org/wiki/Debugging">debugging</a></li>
<li><a href="https://en.wikipedia.org/wiki/Memory_leak">memory leaks</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/kmemcheck.txt">kmemcheck documentation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Valgrind">valgrind</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/theory/linux-theory-1">Paging</a></li>
<li><a href="https://en.wikipedia.org/wiki/Page_fault">page fault</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-3">initcalls</a></li>
<li><a href="https://en.wikipedia.org/wiki/Opcode">opcode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">translation lookaside buffer</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/concepts/linux-cpu-1">per-cpu variables</a></li>
<li><a href="https://en.wikipedia.org/wiki/FLAGS_register">flags register</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/interrupts/linux-interrupts-9">tasklet</a></li>
<li><a href="https://0xax.gitbook.io/linux-insides/summary/mm/linux-mm-2">Previous part</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../MM/linux-mm-2.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../Cgroups/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../MM/linux-mm-2.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../Cgroups/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
